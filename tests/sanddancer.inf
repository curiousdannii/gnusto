!% $MAX_ARRAYS=1500
!% $MAX_CLASSES=200
!% $MAX_VERBS=255
!% $MAX_LABELS=10000
!% $MAX_ZCODE_SIZE=100000
!% $MAX_STATIC_DATA=180000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000
!% $MAX_EXPRESSION_NODES=256


Constant Grammar__Version 2;

! This file was compiled by Inform 7: the build number and version of the
! I6 template layer used are as follows.
Constant NI_BUILD_COUNT "6E72";

Constant LibSerial = "080126";
Constant LibRelease = "6/12N";
Constant LIBRARY_VERSION = 612;

Constant PLUGIN_FILES;


Array UUID_ARRAY string "UUID://5703486A-3324-43F9-AC32-0580B026FAC0//";

Constant Story "Sand-dancer";
Constant Headline SC_2;
Constant Story_Author SC_3;
Release 4;
Serial "101102";

Default Story 0;
Default Headline 0;

[ ShowExtensionVersions;
    print "Standard Rules version 2/090402 by Graham Nelson^";
    print "Conversation Framework for Sand-dancer by Aaron Reed (based on Conversation Framework and Conversation Suggestions by Eric Eve)^";
    print "Extended Grammar version 3 by Aaron Reed^";
    print "Small Kindnesses version 5 by Aaron Reed^";
    print "Default Messages version 11/090530 by David Fisher^";
    print "Conditional Undo version 3/080626 by Jesse McGrew^";
    print "Epistemology version 6 by Eric Eve^";
];
[ ShowFullExtensionVersions;
    print "Standard Rules version 2/090402 by Graham Nelson^";
    print "Conversation Framework for Sand-dancer by Aaron Reed (based on Conversation Framework and Conversation Suggestions by Eric Eve)^";
    print "Extended Grammar version 3 by Aaron Reed^";
    print "Modified Exit version 5 by Emily Short^";
    print "Small Kindnesses version 5 by Aaron Reed^";
    print "Default Messages version 11/090530 by David Fisher^";
    print "Conditional Undo version 3/080626 by Jesse McGrew^";
    print "Epistemology version 6 by Eric Eve^";
    print "Plurality version 8 by Emily Short^";
];


! Use option:
 Constant DynamicMemoryAllocation = 8192; 
! Use option:
 Constant IT_MemoryBufferSize = 1024+3; 
! Use option:
 Constant MATCH_LIST_WORDS = 100; 
! Use option:
 Constant DIALECT_US; 
! Use option:
 Constant MEMORY_ECONOMY; 
! Use option:
 Constant NO_SCORING; 


#Ifndef WORDSIZE; ! compiling with Z-code only compiler
Constant TARGET_ZCODE;
Constant WORDSIZE 2;
#Endif;

#Iftrue (WORDSIZE == 2);
Constant NULL = $ffff;
Constant WORD_HIGHBIT = $8000;
Constant WORD_NEXTTOHIGHBIT = $4000;
Constant IMPROBABLE_VALUE = $7fe3;
Constant MAX_POSITIVE_NUMBER 32767;
Constant MIN_NEGATIVE_NUMBER -32768;
Constant REPARSE_CODE = 10000;
#Endif;

#Iftrue (WORDSIZE == 4);
Constant NULL = $ffffffff;
Constant WORD_HIGHBIT = $80000000;
Constant WORD_NEXTTOHIGHBIT = $40000000;
Constant IMPROBABLE_VALUE = $deadce11;
Constant MAX_POSITIVE_NUMBER 2147483647;
Constant MIN_NEGATIVE_NUMBER -2147483648;
Constant REPARSE_CODE = $40000000;
#Endif;

#Ifdef TARGET_ZCODE;

Global max_z_object;

Constant INDIV_PROP_START 64;

! Offsets into Z-machine header:

Constant HDR_ZCODEVERSION     = $00;     ! byte
Constant HDR_TERPFLAGS        = $01;     ! byte
Constant HDR_GAMERELEASE      = $02;     ! word
Constant HDR_HIGHMEMORY       = $04;     ! word
Constant HDR_INITIALPC        = $06;     ! word
Constant HDR_DICTIONARY       = $08;     ! word
Constant HDR_OBJECTS          = $0A;     ! word
Constant HDR_GLOBALS          = $0C;     ! word
Constant HDR_STATICMEMORY     = $0E;     ! word
Constant HDR_GAMEFLAGS        = $10;     ! word
Constant HDR_GAMESERIAL       = $12;     ! six ASCII characters
Constant HDR_ABBREVIATIONS    = $18;     ! word
Constant HDR_FILELENGTH       = $1A;     ! word
Constant HDR_CHECKSUM         = $1C;     ! word
Constant HDR_TERPNUMBER       = $1E;     ! byte
Constant HDR_TERPVERSION      = $1F;     ! byte
Constant HDR_SCREENHLINES     = $20;     ! byte
Constant HDR_SCREENWCHARS     = $21;     ! byte
Constant HDR_SCREENWUNITS     = $22;     ! word
Constant HDR_SCREENHUNITS     = $24;     ! word
Constant HDR_FONTWUNITS       = $26;     ! byte
Constant HDR_FONTHUNITS       = $27;     ! byte
Constant HDR_ROUTINEOFFSET    = $28;     ! word
Constant HDR_STRINGOFFSET     = $2A;     ! word
Constant HDR_BGCOLOUR         = $2C;     ! byte
Constant HDR_FGCOLOUR         = $2D;     ! byte
Constant HDR_TERMCHARS        = $2E;     ! word
Constant HDR_PIXELSTO3        = $30;     ! word
Constant HDR_TERPSTANDARD     = $32;     ! two bytes
Constant HDR_ALPHABET         = $34;     ! word
Constant HDR_EXTENSION        = $36;     ! word
Constant HDR_UNUSED           = $38;     ! two words
Constant HDR_INFORMVERSION    = $3C;     ! four ASCII characters

#Endif;

#IFDEF TARGET_GLULX;

Global unicode_gestalt_ok; ! Set if interpreter supports Unicode

! Offsets into Glulx header and start of ROM:

Constant HDR_MAGICNUMBER      = $00;     ! long word
Constant HDR_GLULXVERSION     = $04;     ! long word
Constant HDR_RAMSTART         = $08;     ! long word
Constant HDR_EXTSTART         = $0C;     ! long word
Constant HDR_ENDMEM           = $10;     ! long word
Constant HDR_STACKSIZE        = $14;     ! long word
Constant HDR_STARTFUNC        = $18;     ! long word
Constant HDR_DECODINGTBL      = $1C;     ! long word
Constant HDR_CHECKSUM         = $20;     ! long word
Constant ROM_INFO             = $24;     ! four ASCII characters
Constant ROM_MEMORYLAYOUT     = $28;     ! long word
Constant ROM_INFORMVERSION    = $2C;     ! four ASCII characters
Constant ROM_COMPVERSION      = $30;     ! four ASCII characters
Constant ROM_GAMERELEASE      = $34;     ! short word
Constant ROM_GAMESERIAL       = $36;     ! six ASCII characters

#Endif;

Array PowersOfTwo_TB
  --> $$100000000000
      $$010000000000
      $$001000000000
      $$000100000000
      $$000010000000
      $$000001000000
      $$000000100000
      $$000000010000
      $$000000001000
      $$000000000100
      $$000000000010
      $$000000000001;

Array IncreasingPowersOfTwo_TB
  --> $$0000000000000001
      $$0000000000000010
      $$0000000000000100
      $$0000000000001000
      $$0000000000010000
      $$0000000000100000
      $$0000000001000000
      $$0000000010000000
      $$0000000100000000
      $$0000001000000000
      $$0000010000000000
	  $$0000100000000000
	  $$0001000000000000
	  $$0010000000000000
	  $$0100000000000000
	  $$1000000000000000;

Constant NORMAL_VMSTY     = 0;
Constant HEADER_VMSTY     = 3;
Constant SUBHEADER_VMSTY  = 4;
Constant ALERT_VMSTY      = 5;
Constant NOTE_VMSTY       = 6;
Constant BLOCKQUOTE_VMSTY = 7;
Constant INPUT_VMSTY      = 8;

Constant CLR_DEFAULT = 1;
Constant CLR_BLACK   = 2;
Constant CLR_RED     = 3;
Constant CLR_GREEN   = 4;
Constant CLR_YELLOW  = 5;
Constant CLR_BLUE    = 6;
Constant CLR_MAGENTA = 7; Constant CLR_PURPLE  = 7;
Constant CLR_CYAN    = 8; Constant CLR_AZURE   = 8;
Constant CLR_WHITE   = 9;

Constant WIN_ALL     = 0; ! Both windows at once
Constant WIN_STATUS  = 1;
Constant WIN_MAIN    = 2;

Constant PARA_COMPLETED          = 1;
Constant PARA_PROMPTSKIP         = 2;
Constant PARA_SUPPRESSPROMPTSKIP = 4;
Constant PARA_NORULEBOOKBREAKS   = 8;
Constant PARA_CONTENTEXPECTED    = 16;

Constant POSSESS_PK  = $100;
Constant DEFART_PK   = $101;
Constant INDEFART_PK = $102;

Constant RTP_BACKDROP                = 1;
Constant RTP_EXITDOOR                = 2;
Constant RTP_NOEXIT                  = 3;
Constant RTP_CANTCHANGE              = 4;
Constant RTP_IMPREL                  = 5;
Constant RTP_RULESTACK               = 6;
Constant RTP_TOOMANYRULEBOOKS        = 7;
Constant RTP_TOOMANYEVENTS           = 8;
Constant RTP_BADPROPERTY             = 9;
Constant RTP_UNPROVIDED              = 10;
Constant RTP_UNSET                   = 11;
Constant RTP_TOOMANYACTS             = 12;
Constant RTP_CANTABANDON             = 13;
Constant RTP_CANTEND                 = 14;
Constant RTP_CANTMOVENOTHING         = 15;
Constant RTP_CANTREMOVENOTHING       = 16;
Constant RTP_DIVZERO                 = 17;
Constant RTP_BADVALUEPROPERTY        = 18;
Constant RTP_NOTBACKDROP             = 19;
Constant RTP_TABLE_NOCOL             = 20;
Constant RTP_TABLE_NOCORR            = 21;
Constant RTP_TABLE_NOROW             = 22;
Constant RTP_TABLE_NOENTRY           = 23;
Constant RTP_TABLE_NOTABLE           = 24;
Constant RTP_TABLE_NOMOREBLANKS      = 25;
Constant RTP_TABLE_NOROWS            = 26;
Constant RTP_TABLE_CANTSORT          = 27;
Constant RTP_NOTINAROOM              = 28;
Constant RTP_BADTOPIC                = 29;
Constant RTP_ROUTELESS               = 30;
Constant RTP_PROPOFNOTHING           = 31;
Constant RTP_DECIDEONWRONGKIND       = 32;
Constant RTP_DECIDEONNOTHING         = 33;
Constant RTP_TABLE_CANTSAVE          = 34;
Constant RTP_TABLE_WONTFIT           = 35;
Constant RTP_TABLE_BADFILE           = 36;
Constant RTP_LOWLEVELERROR           = 37;
Constant RTP_DONTIGNORETURNSEQUENCE  = 38;
Constant RTP_SAYINVALIDSNIPPET       = 39;
Constant RTP_SPLICEINVALIDSNIPPET    = 40;
Constant RTP_INCLUDEINVALIDSNIPPET   = 41;
Constant RTP_LISTWRITERMEMORY        = 42;
Constant RTP_CANTREMOVEPLAYER        = 43;
Constant RTP_CANTREMOVEDOORS         = 44;
Constant RTP_CANTCHANGEOFFSTAGE      = 45;
Constant RTP_MSTACKMEMORY            = 46;
Constant RTP_TYPECHECK               = 47;
Constant RTP_FILEIOERROR             = 48;
Constant RTP_HEAPERROR               = 49;
Constant RTP_LISTRANGEERROR          = 50;
Constant RTP_REGEXPSYNTAXERROR       = 51;
Constant RTP_NOGLULXUNICODE          = 52;
Constant RTP_BACKDROPONLY            = 53;
Constant RTP_NOTTHING                = 54;
Constant RTP_SCENEHASNTSTARTED       = 55;
Constant RTP_SCENEHASNTENDED         = 56;
Constant RTP_NEGATIVEROOT            = 57;
Constant RTP_TABLE_CANTRUNTHROUGH    = 58;
Constant RTP_CANTITERATE             = 59;

Constant PRINTING_THE_NAME_ACT           = 0;
Constant PRINTING_THE_PLURAL_NAME_ACT    = 1;
Constant PRINTING_A_NUMBER_OF_ACT        = 2;
Constant PRINTING_ROOM_DESC_DETAILS_ACT  = 3;
Constant LISTING_CONTENTS_ACT            = 4;
Constant GROUPING_TOGETHER_ACT           = 5;
Constant WRITING_A_PARAGRAPH_ABOUT_ACT   = 6;
Constant LISTING_NONDESCRIPT_ITEMS_ACT   = 7;

Constant PRINTING_NAME_OF_DARK_ROOM_ACT  = 8;
Constant PRINTING_DESC_OF_DARK_ROOM_ACT  = 9;
Constant PRINTING_NEWS_OF_DARKNESS_ACT   = 10;
Constant PRINTING_NEWS_OF_LIGHT_ACT      = 11;
Constant REFUSAL_TO_ACT_IN_DARK_ACT      = 12;

Constant CONSTRUCTING_STATUS_LINE_ACT    = 13;
Constant PRINTING_BANNER_TEXT_ACT        = 14;

Constant READING_A_COMMAND_ACT           = 15;
Constant DECIDING_SCOPE_ACT              = 16;
Constant DECIDING_CONCEALED_POSSESS_ACT  = 17;
Constant DECIDING_WHETHER_ALL_INC_ACT    = 18;
Constant CLARIFYING_PARSERS_CHOICE_ACT   = 19;
Constant ASKING_WHICH_DO_YOU_MEAN_ACT    = 20;
Constant PRINTING_A_PARSER_ERROR_ACT     = 21;
Constant SUPPLYING_A_MISSING_NOUN_ACT    = 22;
Constant SUPPLYING_A_MISSING_SECOND_ACT  = 23;
Constant IMPLICITLY_TAKING_ACT           = 24;
Constant STARTING_VIRTUAL_MACHINE_ACT    = 25;

Constant AMUSING_A_VICTORIOUS_PLAYER_ACT = 26;
Constant PRINTING_PLAYERS_OBITUARY_ACT   = 27;
Constant DEALING_WITH_FINAL_QUESTION_ACT = 28;

Constant PRINTING_LOCALE_DESCRIPTION_ACT = 29;
Constant CHOOSING_NOTABLE_LOCALE_OBJ_ACT = 30;
Constant PRINTING_LOCALE_PARAGRAPH_ACT   = 31;

Constant PROCEDURAL_RB                   = 0;

Constant STARTUP_RB                      = 1;
Constant TURN_SEQUENCE_RB                = 2;
Constant SHUTDOWN_RB                     = 3;

Constant WHEN_PLAY_BEGINS_RB             = 5;
Constant WHEN_PLAY_ENDS_RB               = 6;
Constant WHEN_SCENE_BEGINS_RB            = 7;
Constant WHEN_SCENE_ENDS_RB              = 8;

Constant ACTION_PROCESSING_RB            = 10;
Constant SETTING_ACTION_VARIABLES_RB     = 11;
Constant SPECIFIC_ACTION_PROCESSING_RB   = 12;

Constant ACCESSIBILITY_RB                = 14;
Constant REACHING_INSIDE_RB              = 15;
Constant REACHING_OUTSIDE_RB             = 16;
Constant VISIBLE_RB                      = 17;

Constant PERSUADE_RB                     = 18;
Constant UNSUCCESSFUL_ATTEMPT_RB         = 19;

Constant AFTER_RB                        = 24;
Constant REPORT_RB                       = 25;

Constant UNKNOWN_TY = 1;
Constant MATCHING_FMY = 5;
Constant NEW_LOCAL_VARIABLE_NAME_SPC = 6;
Constant VALUE_FMY = 10;
Constant CONSTANT_SPC = 11;
Constant PHRASE_TO_DECIDE_VALUE_SPC = 12;
Constant STORAGE_FMY = 20;
Constant LOCAL_VARIABLE_SPC = 21;
Constant NONLOCAL_VARIABLE_SPC = 22;
Constant PROPERTY_VALUE_SPC = 23;
Constant TABLE_ENTRY_SPC = 24;
Constant LIST_ENTRY_SPC = 25;
Constant CONDITION_FMY = 30;
Constant LOGICAL_AND_SPC = 31;
Constant LOGICAL_OR_SPC = 32;
Constant TEST_PROPOSITION_SPC = 33;
Constant TEST_PHRASE_OPTION_SPC = 34;
Constant TEST_ACTION_SPC = 35;
Constant TEST_PAST_ACTION_SPC = 36;
Constant NOW_PROPOSITION_SPC = 37;
Constant PHRASE_TO_DECIDE_IF_SPC = 38;
Constant DESCRIPTION_SPC = 39;
Constant COMMAND_FMY = 40;
Constant TO_PHRASE_SPC = 41;
Constant END_BLOCK_SPC = 42;
Constant OTHERWISE_SPC = 43;
Constant CASE_SPC = 44;
Constant RULEBOOK_OUTCOME_PHRASE_SPC = 45;
Constant TRY_ACTION_SPC = 46;
Constant VALUE_TY = 50;
Constant WORD_VALUE_TY = 51;
Constant POINTER_VALUE_TY = 52;
Constant ARITHMETIC_VALUE_TY = 53;
Constant ENUMERATED_VALUE_TY = 54;
Constant NIL_TY = 60;
Constant TUPLE_ENTRY_TY = 61;
Constant KIND_VARIABLE_TY = 62;
Constant OBJECT_TY = 65;
Constant NUMBER_TY = 66;
Constant TRUTH_STATE_TY = 67;
Constant TEXT_TY = 68;
Constant INDEXED_TEXT_TY = 69;
Constant SNIPPET_TY = 70;
Constant UNICODE_CHARACTER_TY = 71;
Constant TABLE_TY = 72;
Constant EQUATION_TY = 73;
Constant USE_OPTION_TY = 74;
Constant INTERMEDIATE_TY = 75;
Constant RULEBOOK_OUTCOME_TY = 76;
Constant UNDERSTANDING_TY = 77;
Constant LIST_OF_TY = 78;
Constant DESCRIPTION_OF_TY = 79;
Constant RELATION_TY = 80;
Constant RULE_TY = 81;
Constant RULEBOOK_TY = 82;
Constant ACTIVITY_TY = 83;
Constant MAP_TY = 84;
Constant PROPERTY_TY = 85;
Constant TABLE_COLUMN_TY = 86;
Constant COMBINATION_TY = 87;
Constant SAYABLE_VALUE_TY = 88;
Constant COMBINED_VALUE_TY = 89;
Constant DESCRIPTION_OF_ACTION_TY = 90;
Constant STORED_ACTION_TY = 91;
Constant ACTION_NAME_TY = 92;
Constant TIME_TY = 93;
Constant SCENE_TY = 94;
Constant FIGURE_NAME_TY = 95;
Constant SOUND_NAME_TY = 96;
Constant EXTERNAL_FILE_TY = 97;
Constant BASE_KIND_HWM = 104;


Constant STUCK_PE     = 1;
Constant UPTO_PE      = 2;
Constant NUMBER_PE    = 3;
Constant ANIMA_PE     = 4;
Constant CANTSEE_PE   = 5;
Constant TOOLIT_PE    = 6;
Constant NOTHELD_PE   = 7;
Constant MULTI_PE     = 8;
Constant MMULTI_PE    = 9;
Constant VAGUE_PE     = 10;
Constant EXCEPT_PE    = 11;
Constant VERB_PE      = 12;
Constant SCENERY_PE   = 13;
Constant ITGONE_PE    = 14;
Constant JUNKAFTER_PE = 15;
Constant TOOFEW_PE    = 16;
Constant NOTHING_PE   = 17;
Constant ASKSCOPE_PE  = 18;
Constant NOTINCONTEXT_PE = 19;
Constant BLANKLINE_PE = 20; ! Not formally a parser error, but used by I7 as if

Constant PARSING_REASON       = 0;
Constant TALKING_REASON       = 1;
Constant EACH_TURN_REASON     = 2;
Constant LOOPOVERSCOPE_REASON = 5;
Constant TESTSCOPE_REASON     = 6;

Constant ILLEGAL_TT         = 0;    ! Types of grammar token: illegal
Constant ELEMENTARY_TT      = 1;    !     (one of those below)
Constant PREPOSITION_TT     = 2;    !     e.g. 'into'
Constant ROUTINE_FILTER_TT  = 3;    !     e.g. noun=CagedCreature
Constant ATTR_FILTER_TT     = 4;    !     e.g. edible
Constant SCOPE_TT           = 5;    !     e.g. scope=Spells
Constant GPR_TT             = 6;    !     a general parsing routine

Constant NOUN_TOKEN         = 0;    ! The elementary grammar tokens, and
Constant HELD_TOKEN         = 1;    ! the numbers compiled by I6 to
Constant MULTI_TOKEN        = 2;    ! encode them
Constant MULTIHELD_TOKEN    = 3;
Constant MULTIEXCEPT_TOKEN  = 4;
Constant MULTIINSIDE_TOKEN  = 5;
Constant CREATURE_TOKEN     = 6;
Constant SPECIAL_TOKEN      = 7;
Constant NUMBER_TOKEN       = 8;
Constant TOPIC_TOKEN        = 9;
Constant ENDIT_TOKEN        = 15;   ! Value used to mean "end of grammar line"

Constant GPR_FAIL           = -1;   ! Return values from General Parsing
Constant GPR_PREPOSITION    = 0;    ! Routines
Constant GPR_NUMBER         = 1;
Constant GPR_MULTIPLE       = 2;
Constant GPR_REPARSE        = REPARSE_CODE;
Constant GPR_NOUN           = -256; ! Reparse, but as |NOUN_TOKEN| this time
Constant GPR_HELD           = GPR_NOUN + 1; ! And so on
Constant GPR_MULTI          = GPR_NOUN + 2;
Constant GPR_MULTIHELD      = GPR_NOUN + 3;
Constant GPR_MULTIEXCEPT    = GPR_NOUN + 4;
Constant GPR_MULTIINSIDE    = GPR_NOUN + 5;
Constant GPR_CREATURE       = GPR_NOUN + 6;

Constant NEWLINE_BIT        = $$0000000000000001; ! New-line after each entry
Constant INDENT_BIT         = $$0000000000000010; ! Indent each entry by depth
Constant FULLINV_BIT        = $$0000000000000100; ! Full inventory information after entry
Constant ENGLISH_BIT        = $$0000000000001000; ! English sentence style, with commas and and
Constant RECURSE_BIT        = $$0000000000010000; ! Recurse downwards with usual rules
Constant ALWAYS_BIT         = $$0000000000100000; ! Always recurse downwards
Constant TERSE_BIT          = $$0000000001000000; ! More terse English style
Constant PARTINV_BIT        = $$0000000010000000; ! Only brief inventory information after entry
Constant DEFART_BIT         = $$0000000100000000; ! Use the definite article in list
Constant WORKFLAG_BIT       = $$0000001000000000; ! At top level (only), only list objects
                                                  ! which have the "workflag" attribute
Constant ISARE_BIT          = $$0000010000000000; ! Print " is" or " are" before list
Constant CONCEAL_BIT        = $$0000100000000000; ! Omit objects with "concealed" or "scenery":
                                                  ! if WORKFLAG_BIT also set, then does not
                                                  ! apply at top level, but does lower down
Constant NOARTICLE_BIT      = $$0001000000000000; ! Print no articles, definite or not
Constant EXTRAINDENT_BIT    = $$0010000000000000; ! New in I7: extra indentation of 1 level
Constant CFIRSTART_BIT      = $$0100000000000000; ! Capitalise first article in list

Constant QUARTER_HOUR = 15;
Constant HALF_HOUR = 30;
Constant ONE_HOUR = 60;
Constant TWELVE_HOURS = 720;
Constant TWENTY_FOUR_HOURS = 1440;

Constant EMPTY_TEXT_VALUE "";

Array TheEmptyTable --> 0 0;

Array EMPTY_RULEBOOK -> $ff $ff $ff $ff;

[ Prop_Falsity reason obj; return 0; ];


#Ifndef MAX_SCORE;
Global MAX_SCORE = 0;
#Endif;

Attribute absent; ! Used to mark objects removed from play
Attribute animate; ! I6-level marker for I7 kind "person"
Attribute clothing; ! = I7 "wearable"
Attribute concealed; ! = I7 "undescribed"
Attribute container; ! I6-level marker for I7 kind "container"
Attribute door; ! I6-level marker for I7 kind "door"
Attribute edible; ! = I7 "edible" vs "inedible"
Attribute enterable; ! = I7 "enterable"
Attribute light; ! = I7 "lighted" vs "dark"
Attribute lockable; ! = I7 "lockable"
Attribute locked; ! = I7 "locked"
Attribute moved; ! = I7 "handled"
Attribute on; ! = I7 "switched on" vs "switched off"
Attribute open; ! = I7 "open" vs "closed"
Attribute openable; ! = I7 "openable"
Attribute scenery; ! = I7 "scenery"
Attribute static; ! = I7 "fixed in place" vs "portable"
Attribute supporter; ! I6-level marker for I7 kind "supporter"
Attribute switchable; ! I6-level marker for I7 kind "device"
Attribute talkable; ! Not currently used by I7, but retained for possible future use
Attribute transparent; ! = I7 "transparent" vs "opaque"
Attribute visited; ! = I7 "visited"
Attribute worn; ! marks that an object tree edge represents wearing

Attribute male; ! not directly used by I7, but available for languages with genders
Attribute female; ! = I7 "female" vs "male"
Attribute neuter; ! = I7 "neuter"
Attribute pluralname; ! = I7 "plural-named"
Attribute proper; ! = I7 "proper-named"
Attribute remove_proper; ! remember to remove proper again when using ChangePlayer next

Attribute privately_named; ! New in I7
Attribute mentioned; ! New in I7
Attribute pushable; ! New in I7

Attribute mark_as_room; ! Used in I7 to speed up testing "ofclass K1_room"
Attribute mark_as_thing; ! Used in I7 to speed up testing "ofclass K2_thing"

Attribute workflag; ! = I7 "marked for listing", but basically temporary workspace 
Attribute workflag2; ! new in I7 and also temporary workspace
Constant list_filter_permits = privately_named; ! another I7 listwriter convenience

Property add_to_scope; ! used as in I6 to place component parts in scope
Property article "a"; ! used as in I6 to implement articles
Property capacity 100; ! = I7 "carrying capacity"
Property component_child; ! new in I7: forest structure holding "part of" relation
Property component_parent; ! new in I7
Property component_sibling; ! new in I7
Property description; ! = I7 "description"
Property door_dir; ! used to implement two-sided doors, but holds direction object, not a property
Property door_to; ! used as in I6 to implement two-sided doors
Property found_in; ! used as in I6 to implement two-sided doors and backdrops
Property initial; ! = I7 "initial description"
Property list_together; ! used as in I6 to implement "grouping together" activity
Property map_region; ! new in I7
Property parse_name 0; ! used as in I6 to implement "Understand... as..." grammars
Property plural; ! used as in I6 to implement plural names for duplicate objects
Property regional_found_in; ! new in I7
Property room_index; ! new in I7: storage for route-finding
Property short_name 0; ! = I7 "printed name"
Property vector; ! new in I7: storage for route-finding
Property with_key; ! = I7 "matching key"

Property IK_0; ! Instance count of the kind of the current object
Property IK_1; ! These are instance counts within kinds K1, K2, ...
Property IK_2; ! and it is efficient to declare the common ones with Property
Property IK_4; ! since this results in a slightly smaller story file
Property IK_5;
Property IK_6;
Property IK_8;

Property IK1_link; ! These are for linked lists used to make searches faster
Property IK2_link; ! and again it's memory-efficient to declare the common ones
Property IK5_link; ! 
Property IK6_link; ! 
Property IK8_link; ! 

Property articles; ! not used by I7, but an interesting hook in the parser
Property grammar; ! not used by I7, but an interesting hook in the parser
Property inside_description; ! not used by I7, but an interesting hook in the locale code
Property short_name_indef 0; ! not used by I7, but an interesting hook in the listmaker

Constant life = NULL;

Constant ActionCount = 102;

Fake_Action ListMiscellany;
Fake_Action Miscellany;
Fake_Action PluralFound;
Fake_Action TheSame;

	Constant RUCKSACK_CLASS = K28_player_s_holdall;

  Constant LibraryMessages = O36_i7_librarymessages;

[ InitLibraryMessages n;

#Ifndef TARGET_GLULX;
  if (O36_i7_librarymessages.&before)
  {
      ! get rid of any other "before" routines
      for (n = 0 : n < O36_i7_librarymessages.#before / WORDSIZE : n++)
      {
          if (O36_i7_librarymessages.&before --> n ~= LibraryMessagesBefore)
              O36_i7_librarymessages.&before --> n = nothing;
      }
  }
#Endif; ! TARGET_GLULX
];


! [1]
Global location = InformLibrary; ! does not = I7 "location": see below
Global sline1; Global sline2;

! [2]
Global say__p = 1; Global say__pc = 0; Global say__n;
Global ct_0 = 0; Global ct_1 = 0;
Global los_rv = false;
Global subst__v; ! = I7 "substitution-variable"
Global parameter_object; ! = I7 "parameter-object" = I7 "container in question"
Array deferred_calling_list --> 16;
Global property_to_be_totalled; ! used to implement "total P of..."
Global property_loop_sign; ! $+1$ for increasing order, $-1$ for decreasing
Global suppress_scope_loops;
Global temporary_value; ! can be used anywhere side-effects can't occur
Global enable_rte = true; ! reporting of run-time problems is enabled

Constant BLOCKV_STACK_SIZE = 224;
Global blockv_sp = 0;
Array blockv_stack --> BLOCKV_STACK_SIZE;
Global IT_RE_Err = 0;

Array LocalParking --> 16;

! [3]
Global standard_interpreter = 0;
Global undo_flag;

! [4]
Global deadflag = 0;
Global story_complete = 0;
Global resurrect_please = false;

! [5]
Global not_yet_in_play = true; ! set false when first command received
Global turns = 1; ! = I7 "turn count"
Global the_time = NULL; ! = I7 "time of day"
Global time_rate = 1;

Constant NUMBER_SCENES_CREATED = 11;
Constant SCENE_ARRAY_SIZE = (NUMBER_SCENES_CREATED+2);
Array scene_started --> SCENE_ARRAY_SIZE;
Array scene_ended --> SCENE_ARRAY_SIZE;
Array scene_status --> SCENE_ARRAY_SIZE;
Array scene_endings --> SCENE_ARRAY_SIZE;
Array scene_latest_ending --> SCENE_ARRAY_SIZE;
Array scene_recurs -> 0 0 0 0 0 0 0 0 0 0 0 0 0;


! [6]
Global score; ! = I7 "score"
Global last_score; ! = I7 "last notified score"
Global notify_mode = 1; ! score notification on or off
Global left_hand_status_line = SL_Location; ! = I7 "left hand status line"
Global right_hand_status_line = SL_Score_Moves; ! = I7 "right hand status line"

! [7]
Global player; ! = I7 "player"
Global real_location; ! = I7 "location"
Global visibility_ceiling; ! highest object in tree visible to player
Global visibility_levels; ! distance in tree to that

Global SACK_OBJECT; ! current player's holdall item in use

! [8]
Global act_requester;
Global actor; ! = I7 "person asked" = I7 "person reaching"
Global actors_location; ! like real_location, but for the actor
Global actor_location; ! = I7 "actor-location"
Global action;
Global meta; ! action is out of world
Global inp1;
Global inp2;
Array  multiple_object --> MATCH_LIST_WORDS; ! multiple-object list (I6 table array)
Global toomany_flag; ! multiple-object list overflowed
Global multiflag; ! multiple-object being processed
Global multiple_object_item; ! item currently being processed in multiple-object list
Global noun; ! = I7 "noun"
Global second; ! = I7 "second noun"
Global keep_silent; ! true if current action is being tried silently
Global etype; ! parser error number if command not recognised
Global trace_actions = 0;

Global untouchable_object;
Global untouchable_silence;
Global touch_persona;

Global special_word; ! dictionary address of first word in "[text]" token
Global consult_from; ! word number of start of "[text]" token
Global consult_words; ! number of words in "[text]" token
Global parsed_number; ! value from any token not an object
Global special_number1; ! first value, if token not an object
Global special_number2; ! second value, if token not an object

Array  parser_results --> 16; ! for parser to write its results in
Global parser_trace = 0; ! normally 0, but 1 to 5 traces parser workings
Global pronoun_word; ! records which pronoun ("it", "them", ...) caused an error
Global pronoun_obj; ! and what object it was thought to refer to

Global players_command = 100; ! = I7 "player's command"
Global matched_text; ! = I7 "matched text"
Global reason_the_action_failed; ! = I7 "reason the action failed"
Global understand_as_mistake_number; ! which form of "Understand... as a mistake"
Global particular_possession; ! = I7 "particular possession"

! [9]
Global parser_action; ! written by the parser for the benefit of GPRs
Global parser_one;
Global parser_two;
Global parameters; ! number of I7 tokens parsed on the current line
Global action_to_be; ! (if the current line were accepted)
Global action_reversed; ! (parameters would be reversed in order)
Global wn; ! word number within "parse" buffer (from 1)
Global num_words; ! number of words in buffer
Global verb_word; ! dictionary address of command verb
Global verb_wordnum; ! word number of command verb

! [10]
Global scope_reason = PARSING_REASON; ! current reason for searching scope
Global scope_token; ! for "scope=Routine" grammar tokens
Global scope_error;
Global scope_stage; ! 1, 2 then 3
Global advance_warning; ! what a later-named thing will be
Global reason_code = NULL; ! for the I6 veneer

Global ats_flag = 0; ! for AddToScope routines
Global ats_hls;

! [11]
Global move_pushing;
Global move_from;
Global move_to;
Global move_by;
Global move_through;

! [12]
#Ifdef DEFAULT_BRIEF_DESCRIPTIONS;
Global lookmode = 1; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_VERBOSE_DESCRIPTIONS; 
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_SUPERBRIEF_DESCRIPTIONS; 
Global lookmode = 3; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifndef lookmode;
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
Global c_style; ! current list-writer style
Global c_depth; ! current recursion depth
Global c_iterator; ! current iteration function
Global lt_value; ! common value of list_together
Global listing_together; ! object number of one member of a group being listed together
Global listing_size; ! size of such a group
Global c_margin; ! current level of indentation printed by WriteListFrom()
Global inventory_stage = 1; ! 1 or 2 according to the context in which list_together uses

! [13]
Global clr_fg = 1; ! foreground colour
Global clr_bg = 1; ! background colour
Global clr_fgstatus = 1; ! foreground colour of statusline
Global clr_bgstatus = 1; ! background colour of statusline
Global clr_on; ! has colour been enabled by the player?
Global statuswin_current; ! if writing to top window

! [14]
Global statuswin_cursize = 0;
Global statuswin_size = 1;

! [15]
Global lm_act; Global lm_n; Global lm_o; Global lm_o2;

! [16]
Global debug_flag = 0;
Global debug_rules = 0;
Global debug_scenes = 0;
Global debug_rule_nesting;

#Ifdef TARGET_GLULX;
Array gg_event --> 4;
Array gg_arguments buffer 28;
Global gg_mainwin = 0;
Global gg_statuswin = 0;
Global gg_quotewin = 0;
Global gg_scriptfref = 0;
Global gg_scriptstr = 0;
Global gg_savestr = 0;
Global gg_commandstr = 0;
Global gg_command_reading = 0;      ! true if gg_commandstr is being replayed
Global gg_foregroundchan = 0;
Global gg_backgroundchan = 0;

Constant INPUT_BUFFER_LEN = 260;    ! No extra byte necessary
Constant MAX_BUFFER_WORDS = 20;
Constant PARSE_BUFFER_LEN = 61;

Array  buffer    buffer INPUT_BUFFER_LEN;
Array  buffer2   buffer INPUT_BUFFER_LEN;
Array  buffer3   buffer INPUT_BUFFER_LEN;
Array  parse     --> PARSE_BUFFER_LEN;
Array  parse2    --> PARSE_BUFFER_LEN;

#IFNDEF infglk_h; ! Standard Glulx definitions contributed by John Cater
Constant infglk_h;
!-------------------------------------------------------------------------------
!  infglk.h - an Inform library to allow easy access to glk functions
!    under glulx
!  Dynamically created by glk2inf.pl on 08/31/2006 at 19:20:21.
!  Send comments or suggestions to: katre@ruf.rice.edu
!-------------------------------------------------------------------------------
#Ifdef infglk_h;  ! remove "Constant declared but not used" warnings
#Endif;

Constant GLK_NULL 0;

! Constant definitions from glk.h
Constant gestalt_Version 0;
Constant gestalt_CharInput 1;
Constant gestalt_LineInput 2;
Constant gestalt_CharOutput 3;
Constant gestalt_CharOutput_CannotPrint 0;
Constant gestalt_CharOutput_ApproxPrint 1;
Constant gestalt_CharOutput_ExactPrint 2;
Constant gestalt_MouseInput 4;
Constant gestalt_Timer 5;
Constant gestalt_Graphics 6;
Constant gestalt_DrawImage 7;
Constant gestalt_Sound 8;
Constant gestalt_SoundVolume 9;
Constant gestalt_SoundNotify 10;
Constant gestalt_Hyperlinks 11;
Constant gestalt_HyperlinkInput 12;
Constant gestalt_SoundMusic 13;
Constant gestalt_GraphicsTransparency 14;
Constant gestalt_Unicode 15;
Constant evtype_None 0;
Constant evtype_Timer 1;
Constant evtype_CharInput 2;
Constant evtype_LineInput 3;
Constant evtype_MouseInput 4;
Constant evtype_Arrange 5;
Constant evtype_Redraw 6;
Constant evtype_SoundNotify 7;
Constant evtype_Hyperlink 8;
Constant keycode_Unknown $ffffffff;
Constant keycode_Left $fffffffe;
Constant keycode_Right $fffffffd;
Constant keycode_Up $fffffffc;
Constant keycode_Down $fffffffb;
Constant keycode_Return $fffffffa;
Constant keycode_Delete $fffffff9;
Constant keycode_Escape $fffffff8;
Constant keycode_Tab $fffffff7;
Constant keycode_PageUp $fffffff6;
Constant keycode_PageDown $fffffff5;
Constant keycode_Home $fffffff4;
Constant keycode_End $fffffff3;
Constant keycode_Func1 $ffffffef;
Constant keycode_Func2 $ffffffee;
Constant keycode_Func3 $ffffffed;
Constant keycode_Func4 $ffffffec;
Constant keycode_Func5 $ffffffeb;
Constant keycode_Func6 $ffffffea;
Constant keycode_Func7 $ffffffe9;
Constant keycode_Func8 $ffffffe8;
Constant keycode_Func9 $ffffffe7;
Constant keycode_Func10 $ffffffe6;
Constant keycode_Func11 $ffffffe5;
Constant keycode_Func12 $ffffffe4;
Constant keycode_MAXVAL 28;
Constant style_Normal 0;
Constant style_Emphasized 1;
Constant style_Preformatted 2;
Constant style_Header 3;
Constant style_Subheader 4;
Constant style_Alert 5;
Constant style_Note 6;
Constant style_BlockQuote 7;
Constant style_Input 8;
Constant style_User1 9;
Constant style_User2 10;
Constant style_NUMSTYLES 11;
Constant wintype_AllTypes 0;
Constant wintype_Pair 1;
Constant wintype_Blank 2;
Constant wintype_TextBuffer 3;
Constant wintype_TextGrid 4;
Constant wintype_Graphics 5;
Constant winmethod_Left $00;
Constant winmethod_Right $01;
Constant winmethod_Above $02;
Constant winmethod_Below $03;
Constant winmethod_DirMask $0f;
Constant winmethod_Fixed $10;
Constant winmethod_Proportional $20;
Constant winmethod_DivisionMask $f0;
Constant fileusage_Data $00;
Constant fileusage_SavedGame $01;
Constant fileusage_Transcript $02;
Constant fileusage_InputRecord $03;
Constant fileusage_TypeMask $0f;
Constant fileusage_TextMode $100;
Constant fileusage_BinaryMode $000;
Constant filemode_Write $01;
Constant filemode_Read $02;
Constant filemode_ReadWrite $03;
Constant filemode_WriteAppend $05;
Constant seekmode_Start 0;
Constant seekmode_Current 1;
Constant seekmode_End 2;
Constant stylehint_Indentation 0;
Constant stylehint_ParaIndentation 1;
Constant stylehint_Justification 2;
Constant stylehint_Size 3;
Constant stylehint_Weight 4;
Constant stylehint_Oblique 5;
Constant stylehint_Proportional 6;
Constant stylehint_TextColor 7;
Constant stylehint_BackColor 8;
Constant stylehint_ReverseColor 9;
Constant stylehint_NUMHINTS 10;
Constant stylehint_just_LeftFlush 0;
Constant stylehint_just_LeftRight 1;
Constant stylehint_just_Centered 2;
Constant stylehint_just_RightFlush 3;
Constant imagealign_InlineUp $01;
Constant imagealign_InlineDown $02;
Constant imagealign_InlineCenter $03;
Constant imagealign_MarginLeft $04;
Constant imagealign_MarginRight $05;

! The actual glk functions.
[ glk_exit _vararg_count ret;
! glk_exit ()
  ! And now the @glk call
  @glk 1 _vararg_count ret;
  return ret;
];

[ glk_set_interrupt_handler _vararg_count ret;
! glk_set_interrupt_handler (func)
  ! And now the @glk call
  @glk 2 _vararg_count ret;
  return ret;
];

[ glk_tick _vararg_count ret;
! glk_tick ()
  ! And now the @glk call
  @glk 3 _vararg_count ret;
  return ret;
];

[ glk_gestalt _vararg_count ret;
! glk_gestalt (sel val)
  ! And now the @glk call
  @glk 4 _vararg_count ret;
  return ret;
];

[ glk_gestalt_ext _vararg_count ret;
! glk_gestalt_ext (sel val arr arrlen)
  ! And now the @glk call
  @glk 5 _vararg_count ret;
  return ret;
];

[ glk_char_to_lower _vararg_count ret;
! glk_char_to_lower (ch)
  ! And now the @glk call
  @glk 160 _vararg_count ret;
  return ret;
];

[ glk_char_to_upper _vararg_count ret;
! glk_char_to_upper (ch)
  ! And now the @glk call
  @glk 161 _vararg_count ret;
  return ret;
];

[ glk_window_get_root _vararg_count ret;
! glk_window_get_root ()
  ! And now the @glk call
  @glk 34 _vararg_count ret;
  return ret;
];

[ glk_window_open _vararg_count ret;
! glk_window_open (split method size wintype rock)
  ! And now the @glk call
  @glk 35 _vararg_count ret;
  return ret;
];

[ glk_window_close _vararg_count ret;
! glk_window_close (win result)
  ! And now the @glk call
  @glk 36 _vararg_count ret;
  return ret;
];

[ glk_window_get_size _vararg_count ret;
! glk_window_get_size (win widthptr heightptr)
  ! And now the @glk call
  @glk 37 _vararg_count ret;
  return ret;
];

[ glk_window_set_arrangement _vararg_count ret;
! glk_window_set_arrangement (win method size keywin)
  ! And now the @glk call
  @glk 38 _vararg_count ret;
  return ret;
];

[ glk_window_get_arrangement _vararg_count ret;
! glk_window_get_arrangement (win methodptr sizeptr keywinptr)
  ! And now the @glk call
  @glk 39 _vararg_count ret;
  return ret;
];

[ glk_window_iterate _vararg_count ret;
! glk_window_iterate (win rockptr)
  ! And now the @glk call
  @glk 32 _vararg_count ret;
  return ret;
];

[ glk_window_get_rock _vararg_count ret;
! glk_window_get_rock (win)
  ! And now the @glk call
  @glk 33 _vararg_count ret;
  return ret;
];

[ glk_window_get_type _vararg_count ret;
! glk_window_get_type (win)
  ! And now the @glk call
  @glk 40 _vararg_count ret;
  return ret;
];

[ glk_window_get_parent _vararg_count ret;
! glk_window_get_parent (win)
  ! And now the @glk call
  @glk 41 _vararg_count ret;
  return ret;
];

[ glk_window_get_sibling _vararg_count ret;
! glk_window_get_sibling (win)
  ! And now the @glk call
  @glk 48 _vararg_count ret;
  return ret;
];

[ glk_window_clear _vararg_count ret;
! glk_window_clear (win)
  ! And now the @glk call
  @glk 42 _vararg_count ret;
  return ret;
];

[ glk_window_move_cursor _vararg_count ret;
! glk_window_move_cursor (win xpos ypos)
  ! And now the @glk call
  @glk 43 _vararg_count ret;
  return ret;
];

[ glk_window_get_stream _vararg_count ret;
! glk_window_get_stream (win)
  ! And now the @glk call
  @glk 44 _vararg_count ret;
  return ret;
];

[ glk_window_set_echo_stream _vararg_count ret;
! glk_window_set_echo_stream (win str)
  ! And now the @glk call
  @glk 45 _vararg_count ret;
  return ret;
];

[ glk_window_get_echo_stream _vararg_count ret;
! glk_window_get_echo_stream (win)
  ! And now the @glk call
  @glk 46 _vararg_count ret;
  return ret;
];

[ glk_set_window _vararg_count ret;
! glk_set_window (win)
  ! And now the @glk call
  @glk 47 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file _vararg_count ret;
! glk_stream_open_file (fileref fmode rock)
  ! And now the @glk call
  @glk 66 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory _vararg_count ret;
! glk_stream_open_memory (buf buflen fmode rock)
  ! And now the @glk call
  @glk 67 _vararg_count ret;
  return ret;
];

[ glk_stream_close _vararg_count ret;
! glk_stream_close (str result)
  ! And now the @glk call
  @glk 68 _vararg_count ret;
  return ret;
];

[ glk_stream_iterate _vararg_count ret;
! glk_stream_iterate (str rockptr)
  ! And now the @glk call
  @glk 64 _vararg_count ret;
  return ret;
];

[ glk_stream_get_rock _vararg_count ret;
! glk_stream_get_rock (str)
  ! And now the @glk call
  @glk 65 _vararg_count ret;
  return ret;
];

[ glk_stream_set_position _vararg_count ret;
! glk_stream_set_position (str pos seekmode)
  ! And now the @glk call
  @glk 69 _vararg_count ret;
  return ret;
];

[ glk_stream_get_position _vararg_count ret;
! glk_stream_get_position (str)
  ! And now the @glk call
  @glk 70 _vararg_count ret;
  return ret;
];

[ glk_stream_set_current _vararg_count ret;
! glk_stream_set_current (str)
  ! And now the @glk call
  @glk 71 _vararg_count ret;
  return ret;
];

[ glk_stream_get_current _vararg_count ret;
! glk_stream_get_current ()
  ! And now the @glk call
  @glk 72 _vararg_count ret;
  return ret;
];

[ glk_put_char _vararg_count ret;
! glk_put_char (ch)
  ! And now the @glk call
  @glk 128 _vararg_count ret;
  return ret;
];

[ glk_put_char_stream _vararg_count ret;
! glk_put_char_stream (str ch)
  ! And now the @glk call
  @glk 129 _vararg_count ret;
  return ret;
];

[ glk_put_string _vararg_count ret;
! glk_put_string (s)
  ! And now the @glk call
  @glk 130 _vararg_count ret;
  return ret;
];

[ glk_put_string_stream _vararg_count ret;
! glk_put_string_stream (str s)
  ! And now the @glk call
  @glk 131 _vararg_count ret;
  return ret;
];

[ glk_put_buffer _vararg_count ret;
! glk_put_buffer (buf len)
  ! And now the @glk call
  @glk 132 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_stream _vararg_count ret;
! glk_put_buffer_stream (str buf len)
  ! And now the @glk call
  @glk 133 _vararg_count ret;
  return ret;
];

[ glk_set_style _vararg_count ret;
! glk_set_style (styl)
  ! And now the @glk call
  @glk 134 _vararg_count ret;
  return ret;
];

[ glk_set_style_stream _vararg_count ret;
! glk_set_style_stream (str styl)
  ! And now the @glk call
  @glk 135 _vararg_count ret;
  return ret;
];

[ glk_get_char_stream _vararg_count ret;
! glk_get_char_stream (str)
  ! And now the @glk call
  @glk 144 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream _vararg_count ret;
! glk_get_line_stream (str buf len)
  ! And now the @glk call
  @glk 145 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream _vararg_count ret;
! glk_get_buffer_stream (str buf len)
  ! And now the @glk call
  @glk 146 _vararg_count ret;
  return ret;
];

[ glk_stylehint_set _vararg_count ret;
! glk_stylehint_set (wintype styl hint val)
  ! And now the @glk call
  @glk 176 _vararg_count ret;
  return ret;
];

[ glk_stylehint_clear _vararg_count ret;
! glk_stylehint_clear (wintype styl hint)
  ! And now the @glk call
  @glk 177 _vararg_count ret;
  return ret;
];

[ glk_style_distinguish _vararg_count ret;
! glk_style_distinguish (win styl1 styl2)
  ! And now the @glk call
  @glk 178 _vararg_count ret;
  return ret;
];

[ glk_style_measure _vararg_count ret;
! glk_style_measure (win styl hint result)
  ! And now the @glk call
  @glk 179 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_temp _vararg_count ret;
! glk_fileref_create_temp (usage rock)
  ! And now the @glk call
  @glk 96 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_name _vararg_count ret;
! glk_fileref_create_by_name (usage name rock)
  ! And now the @glk call
  @glk 97 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_prompt _vararg_count ret;
! glk_fileref_create_by_prompt (usage fmode rock)
  ! And now the @glk call
  @glk 98 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_from_fileref _vararg_count ret;
! glk_fileref_create_from_fileref (usage fref rock)
  ! And now the @glk call
  @glk 104 _vararg_count ret;
  return ret;
];

[ glk_fileref_destroy _vararg_count ret;
! glk_fileref_destroy (fref)
  ! And now the @glk call
  @glk 99 _vararg_count ret;
  return ret;
];

[ glk_fileref_iterate _vararg_count ret;
! glk_fileref_iterate (fref rockptr)
  ! And now the @glk call
  @glk 100 _vararg_count ret;
  return ret;
];

[ glk_fileref_get_rock _vararg_count ret;
! glk_fileref_get_rock (fref)
  ! And now the @glk call
  @glk 101 _vararg_count ret;
  return ret;
];

[ glk_fileref_delete_file _vararg_count ret;
! glk_fileref_delete_file (fref)
  ! And now the @glk call
  @glk 102 _vararg_count ret;
  return ret;
];

[ glk_fileref_does_file_exist _vararg_count ret;
! glk_fileref_does_file_exist (fref)
  ! And now the @glk call
  @glk 103 _vararg_count ret;
  return ret;
];

[ glk_select _vararg_count ret;
! glk_select (event)
  ! And now the @glk call
  @glk 192 _vararg_count ret;
  return ret;
];

[ glk_select_poll _vararg_count ret;
! glk_select_poll (event)
  ! And now the @glk call
  @glk 193 _vararg_count ret;
  return ret;
];

[ glk_request_timer_events _vararg_count ret;
! glk_request_timer_events (millisecs)
  ! And now the @glk call
  @glk 214 _vararg_count ret;
  return ret;
];

[ glk_request_line_event _vararg_count ret;
! glk_request_line_event (win buf maxlen initlen)
  ! And now the @glk call
  @glk 208 _vararg_count ret;
  return ret;
];

[ glk_request_char_event _vararg_count ret;
! glk_request_char_event (win)
  ! And now the @glk call
  @glk 210 _vararg_count ret;
  return ret;
];

[ glk_request_mouse_event _vararg_count ret;
! glk_request_mouse_event (win)
  ! And now the @glk call
  @glk 212 _vararg_count ret;
  return ret;
];

[ glk_cancel_line_event _vararg_count ret;
! glk_cancel_line_event (win event)
  ! And now the @glk call
  @glk 209 _vararg_count ret;
  return ret;
];

[ glk_cancel_char_event _vararg_count ret;
! glk_cancel_char_event (win)
  ! And now the @glk call
  @glk 211 _vararg_count ret;
  return ret;
];

[ glk_cancel_mouse_event _vararg_count ret;
! glk_cancel_mouse_event (win)
  ! And now the @glk call
  @glk 213 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_lower_case_uni _vararg_count ret;
! glk_buffer_to_lower_case_uni (buf len numchars)
  ! And now the @glk call
  @glk 288 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_upper_case_uni _vararg_count ret;
! glk_buffer_to_upper_case_uni (buf len numchars)
  ! And now the @glk call
  @glk 289 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_title_case_uni _vararg_count ret;
! glk_buffer_to_title_case_uni (buf len numchars lowerrest)
  ! And now the @glk call
  @glk 290 _vararg_count ret;
  return ret;
];

[ glk_put_char_uni _vararg_count ret;
! glk_put_char_uni (ch)
  ! And now the @glk call
  @glk 296 _vararg_count ret;
  return ret;
];

[ glk_put_string_uni _vararg_count ret;
! glk_put_string_uni (s)
  ! And now the @glk call
  @glk 297 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_uni _vararg_count ret;
! glk_put_buffer_uni (buf len)
  ! And now the @glk call
  @glk 298 _vararg_count ret;
  return ret;
];

[ glk_put_char_stream_uni _vararg_count ret;
! glk_put_char_stream_uni (str ch)
  ! And now the @glk call
  @glk 299 _vararg_count ret;
  return ret;
];

[ glk_put_string_stream_uni _vararg_count ret;
! glk_put_string_stream_uni (str s)
  ! And now the @glk call
  @glk 300 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_stream_uni _vararg_count ret;
! glk_put_buffer_stream_uni (str buf len)
  ! And now the @glk call
  @glk 301 _vararg_count ret;
  return ret;
];

[ glk_get_char_stream_uni _vararg_count ret;
! glk_get_char_stream_uni (str)
  ! And now the @glk call
  @glk 304 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream_uni _vararg_count ret;
! glk_get_buffer_stream_uni (str buf len)
  ! And now the @glk call
  @glk 305 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream_uni _vararg_count ret;
! glk_get_line_stream_uni (str buf len)
  ! And now the @glk call
  @glk 306 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file_uni _vararg_count ret;
! glk_stream_open_file_uni (fileref fmode rock)
  ! And now the @glk call
  @glk 312 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory_uni _vararg_count ret;
! glk_stream_open_memory_uni (buf buflen fmode rock)
  ! And now the @glk call
  @glk 313 _vararg_count ret;
  return ret;
];

[ glk_request_char_event_uni _vararg_count ret;
! glk_request_char_event_uni (win)
  ! And now the @glk call
  @glk 320 _vararg_count ret;
  return ret;
];

[ glk_request_line_event_uni _vararg_count ret;
! glk_request_line_event_uni (win buf maxlen initlen)
  ! And now the @glk call
  @glk 321 _vararg_count ret;
  return ret;
];

[ glk_image_draw _vararg_count ret;
! glk_image_draw (win image val1 val2)
  ! And now the @glk call
  @glk 225 _vararg_count ret;
  return ret;
];

[ glk_image_draw_scaled _vararg_count ret;
! glk_image_draw_scaled (win image val1 val2 width height)
  ! And now the @glk call
  @glk 226 _vararg_count ret;
  return ret;
];

[ glk_image_get_info _vararg_count ret;
! glk_image_get_info (image width height)
  ! And now the @glk call
  @glk 224 _vararg_count ret;
  return ret;
];

[ glk_window_flow_break _vararg_count ret;
! glk_window_flow_break (win)
  ! And now the @glk call
  @glk 232 _vararg_count ret;
  return ret;
];

[ glk_window_erase_rect _vararg_count ret;
! glk_window_erase_rect (win left top width height)
  ! And now the @glk call
  @glk 233 _vararg_count ret;
  return ret;
];

[ glk_window_fill_rect _vararg_count ret;
! glk_window_fill_rect (win color left top width height)
  ! And now the @glk call
  @glk 234 _vararg_count ret;
  return ret;
];

[ glk_window_set_background_color _vararg_count ret;
! glk_window_set_background_color (win color)
  ! And now the @glk call
  @glk 235 _vararg_count ret;
  return ret;
];

[ glk_schannel_create _vararg_count ret;
! glk_schannel_create (rock)
  ! And now the @glk call
  @glk 242 _vararg_count ret;
  return ret;
];

[ glk_schannel_destroy _vararg_count ret;
! glk_schannel_destroy (chan)
  ! And now the @glk call
  @glk 243 _vararg_count ret;
  return ret;
];

[ glk_schannel_iterate _vararg_count ret;
! glk_schannel_iterate (chan rockptr)
  ! And now the @glk call
  @glk 240 _vararg_count ret;
  return ret;
];

[ glk_schannel_get_rock _vararg_count ret;
! glk_schannel_get_rock (chan)
  ! And now the @glk call
  @glk 241 _vararg_count ret;
  return ret;
];

[ glk_schannel_play _vararg_count ret;
! glk_schannel_play (chan snd)
  ! And now the @glk call
  @glk 248 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_ext _vararg_count ret;
! glk_schannel_play_ext (chan snd repeats notify)
  ! And now the @glk call
  @glk 249 _vararg_count ret;
  return ret;
];

[ glk_schannel_stop _vararg_count ret;
! glk_schannel_stop (chan)
  ! And now the @glk call
  @glk 250 _vararg_count ret;
  return ret;
];

[ glk_schannel_set_volume _vararg_count ret;
! glk_schannel_set_volume (chan vol)
  ! And now the @glk call
  @glk 251 _vararg_count ret;
  return ret;
];

[ glk_sound_load_hint _vararg_count ret;
! glk_sound_load_hint (snd flag)
  ! And now the @glk call
  @glk 252 _vararg_count ret;
  return ret;
];

[ glk_set_hyperlink _vararg_count ret;
! glk_set_hyperlink (linkval)
  ! And now the @glk call
  @glk 256 _vararg_count ret;
  return ret;
];

[ glk_set_hyperlink_stream _vararg_count ret;
! glk_set_hyperlink_stream (str linkval)
  ! And now the @glk call
  @glk 257 _vararg_count ret;
  return ret;
];

[ glk_request_hyperlink_event _vararg_count ret;
! glk_request_hyperlink_event (win)
  ! And now the @glk call
  @glk 258 _vararg_count ret;
  return ret;
];

[ glk_cancel_hyperlink_event _vararg_count ret;
! glk_cancel_hyperlink_event (win)
  ! And now the @glk call
  @glk 259 _vararg_count ret;
  return ret;
];
#ENDIF;

Constant GG_MAINWIN_ROCK        201;
Constant GG_STATUSWIN_ROCK      202;
Constant GG_QUOTEWIN_ROCK       203;
Constant GG_SAVESTR_ROCK        301;
Constant GG_SCRIPTSTR_ROCK      302;
Constant GG_COMMANDWSTR_ROCK    303;
Constant GG_COMMANDRSTR_ROCK    304;
Constant GG_SCRIPTFREF_ROCK     401;
Constant GG_FOREGROUNDCHAN_ROCK 410;
Constant GG_BACKGROUNDCHAN_ROCK 411;

#Stub HandleGlkEvent    2;
#Stub IdentifyGlkObject 4;
#Stub InitGlkWindow     1;

[ VM_PreInitialise res;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

	unicode_gestalt_ok = false;
	if (glk_gestalt(gestalt_Unicode, 0))
		unicode_gestalt_ok = true;

    ! Set the VM's I/O system to be Glk.
    @setiosys 2 0;
];

[ VM_Initialise res sty i;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

    ! First, we must go through all the Glk objects that exist, and see
    ! if we created any of them. One might think this strange, since the
    ! program has just started running, but remember that the player might
    ! have just typed "restart".

    GGRecoverObjects();

	! Sound channel initialisation, and RNG fixing, must be done now rather
	! than later in case InitGlkWindow() returns a non-zero value.

	if (glk_gestalt(gestalt_Sound, 0)) {
		if (gg_foregroundchan == 0)
			gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK);
		if (gg_backgroundchan == 0)
			gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK);
	}

	#ifdef FIX_RNG;
	@random 10000 i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@setrandom i;
	#endif; ! FIX_RNG

    res = InitGlkWindow(0);
    if (res ~= 0) return;

    ! Now, gg_mainwin and gg_storywin might already be set. If not, set them.

    if (gg_mainwin == 0) {
        ! Open the story window.
        res = InitGlkWindow(GG_MAINWIN_ROCK);
        if (res == 0) {
        	! Left-justify the header style
			glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
			! Try to make emphasized type in italics and not boldface
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
		}
        if (gg_mainwin == 0) quit; ! If we can't even open one window, give in
    } else {
        ! There was already a story window. We should erase it.
        glk_window_clear(gg_mainwin);
    }

    if (gg_statuswin == 0) {
        res = InitGlkWindow(GG_STATUSWIN_ROCK);
        if (res == 0) {
            statuswin_cursize = statuswin_size;
			for (sty=0: sty<style_NUMSTYLES: sty++)
				glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
            gg_statuswin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        }
    }
    ! It's possible that the status window couldn't be opened, in which case
    ! gg_statuswin is now zero. We must allow for that later on.

    glk_set_window(gg_mainwin);

    InitGlkWindow(1);
];

[ GGRecoverObjects id;
    ! If GGRecoverObjects() has been called, all these stored IDs are
    ! invalid, so we start by clearing them all out.
    ! (In fact, after a restoreundo, some of them may still be good.
    ! For simplicity, though, we assume the general case.)
    gg_mainwin = 0;
    gg_statuswin = 0;
    gg_quotewin = 0;
    gg_scriptfref = 0;
    gg_scriptstr = 0;
    gg_savestr = 0;
    statuswin_cursize = 0;
    gg_foregroundchan = 0;
    gg_backgroundchan = 0;
    #Ifdef DEBUG;
    gg_commandstr = 0;
    gg_command_reading = false;
    #Endif; ! DEBUG
    ! Also tell the game to clear its object references.
    IdentifyGlkObject(0);

    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SAVESTR_ROCK: gg_savestr = id;
            GG_SCRIPTSTR_ROCK: gg_scriptstr = id;
            #Ifdef DEBUG;
            GG_COMMANDWSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = false;
            GG_COMMANDRSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = true;
            #Endif; ! DEBUG
            default: IdentifyGlkObject(1, 1, id, gg_arguments-->0);
        }
        id = glk_stream_iterate(id, gg_arguments);
    }

    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_MAINWIN_ROCK: gg_mainwin = id;
            GG_STATUSWIN_ROCK: gg_statuswin = id;
            GG_QUOTEWIN_ROCK: gg_quotewin = id;
            default: IdentifyGlkObject(1, 0, id, gg_arguments-->0);
        }
        id = glk_window_iterate(id, gg_arguments);
    }

    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SCRIPTFREF_ROCK: gg_scriptfref = id;
            default: IdentifyGlkObject(1, 2, id, gg_arguments-->0);
        }
        id = glk_fileref_iterate(id, gg_arguments);
    }

	if (glk_gestalt(gestalt_Sound, 0)) {
		id = glk_schannel_iterate(0, gg_arguments);
		while (id) {
			switch (gg_arguments-->0) {
				GG_FOREGROUNDCHAN_ROCK: gg_foregroundchan = id;
				GG_BACKGROUNDCHAN_ROCK: gg_backgroundchan = id;
			}
			id = glk_schannel_iterate(id, gg_arguments);
		}
		if (gg_foregroundchan ~= 0) { glk_schannel_stop(gg_foregroundchan); }
		if (gg_backgroundchan ~= 0) { glk_schannel_stop(gg_backgroundchan); }
	}

    ! Tell the game to tie up any loose ends.
    IdentifyGlkObject(2);
];

[ ENABLE_GLULX_ACCEL_R addr res;
	@gestalt 9 0 res;
	if (res == 0) return;
	addr = #classes_table;
	@accelparam 0 addr;
	@accelparam 1 INDIV_PROP_START;
	@accelparam 2 Class;
	@accelparam 3 Object;
	@accelparam 4 Routine;
	@accelparam 5 String;
	addr = #globals_array + WORDSIZE * #g$self;
	@accelparam 6 addr;
	@accelparam 7 NUM_ATTR_BYTES;
	addr = #cpv__start;
	@accelparam 8 addr;
	@accelfunc 1 Z__Region;
	@accelfunc 2 CP__Tab;
	@accelfunc 3 RA__Pr;
	@accelfunc 4 RL__Pr;
	@accelfunc 5 OC__Cl;
	@accelfunc 6 RV__Pr;
	@accelfunc 7 OP__Pr;
	rfalse;
];

[ VM_Describe_Release i;
	print "Release ";
	@aloads ROM_GAMERELEASE 0 i;
	print i;
	print " / Serial number ";
	for (i=0 : i<6 : i++) print (char) ROM_GAMESERIAL->i;
];

[ VM_KeyChar win nostat done res ix jx ch;
    jx = ch; ! squash compiler warnings
    if (win == 0) win = gg_mainwin;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, gg_arguments, 31);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
            ! fall through to normal user input.
        } else {
            ! Trim the trailing newline
            if (gg_arguments->(done-1) == 10) done = done-1;
            res = gg_arguments->0;
            if (res == '\') {
                res = 0;
                for (ix=1 : ix<done : ix++) {
                    ch = gg_arguments->ix;
                    if (ch >= '0' && ch <= '9') {
                        @shiftl res 4 res;
                        res = res + (ch-'0');
                    } else if (ch >= 'a' && ch <= 'f') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'a');
                    } else if (ch >= 'A' && ch <= 'F') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'A');
                    }
                }
            }
       		jump KCPContinue;
        }
    }
    done = false;
    glk_request_char_event(win);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            if (nostat) {
                glk_cancel_char_event(win);
                res = $80000000;
                done = true;
                break;
            }
            DrawStatusLine();
          2: ! evtype_CharInput
            if (gg_event-->1 == win) {
                res = gg_event-->2;
                done = true;
                }
        }
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            res = gg_arguments-->0;
            done = true;
        } else if (ix == -1)  done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        if (res < 32 || res >= 256 || (res == '\' or ' ')) {
            glk_put_char_stream(gg_commandstr, '\');
            done = 0;
            jx = res;
            for (ix=0 : ix<8 : ix++) {
                @ushiftr jx 28 ch;
                @shiftl jx 4 jx;
                ch = ch & $0F;
                if (ch ~= 0 || ix == 7) done = 1;
                if (done) {
                    if (ch >= 0 && ch <= 9) ch = ch + '0';
                    else                    ch = (ch - 10) + 'A';
                    glk_put_char_stream(gg_commandstr, ch);
                }
            }
        } else {
            glk_put_char_stream(gg_commandstr, res);
        }
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KCPContinue;
    return res;
];

[ VM_KeyDelay tenths  key done ix;
    glk_request_char_event(gg_mainwin);
    glk_request_timer_events(tenths*100);
    while (~~done) {
        glk_select(gg_event);
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            key = gg_arguments-->0;
            done = true;
        }
        else if (ix >= 0 && gg_event-->0 == 1 or 2) {
            key = gg_event-->2;
            done = true;
        }
    }
    glk_cancel_char_event(gg_mainwin);
    glk_request_timer_events(0);
    return key;
];

[ VM_ReadKeyboard  a_buffer a_table done ix;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, a_buffer+WORDSIZE,
        	(INPUT_BUFFER_LEN-WORDSIZE)-1);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
            ! L__M(##CommandsRead, 5); would come after prompt
            ! fall through to normal user input.
        }
        else {
            ! Trim the trailing newline
            if ((a_buffer+WORDSIZE)->(done-1) == 10) done = done-1;
            a_buffer-->0 = done;
            VM_Style(INPUT_VMSTY);
            glk_put_buffer(a_buffer+WORDSIZE, done);
            VM_Style(NORMAL_VMSTY);
            print "^";
            jump KPContinue;
        }
    }
    done = false;
    glk_request_line_event(gg_mainwin, a_buffer+WORDSIZE, INPUT_BUFFER_LEN-WORDSIZE, 0);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            DrawStatusLine();
          3: ! evtype_LineInput
            if (gg_event-->1 == gg_mainwin) {
                a_buffer-->0 = gg_event-->2;
                done = true;
            }
        }
        ix = HandleGlkEvent(gg_event, 0, a_buffer);
        if (ix == 2) done = true;
        else if (ix == -1) done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        glk_put_buffer_stream(gg_commandstr, a_buffer+WORDSIZE, a_buffer-->0);
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KPContinue;
    VM_Tokenise(a_buffer,a_table);
    ! It's time to close any quote window we've got going.
    if (gg_quotewin) {
        glk_window_close(gg_quotewin, 0);
        gg_quotewin = 0;
    }
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (ix=WORDSIZE: ix<(a_buffer-->0)+WORDSIZE: ix++) print (char) a_buffer->ix;
    print "^";
    #endif; ! ECHO_COMMANDS
];

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    if (b) {
        if (metaclass(a) == Object && a.#b == WORDSIZE
            && metaclass(a.b) == String)
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a.b);
		else if (metaclass(a) == Routine)
			buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
        else
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b);
    }
    else if (metaclass(a) == Routine)
        buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
    else
		buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a);
    if (buf-->0 > len) buf-->0 = len;
    return buf-->0;
];

[ VM_Tokenise buf tab
    cx numwords len bx ix wx wpos wlen val res dictlen entrylen;
    len = buf-->0;
    buf = buf+WORDSIZE;

    ! First, split the buffer up into words. We use the standard Infocom
    ! list of word separators (comma, period, double-quote).

    cx = 0;
    numwords = 0;
    while (cx < len) {
        while (cx < len && buf->cx == ' ') cx++;
        if (cx >= len) break;
        bx = cx;
        if (buf->cx == '.' or ',' or '"') cx++;
        else {
            while (cx < len && buf->cx ~= ' ' or '.' or ',' or '"') cx++;
        }
        tab-->(numwords*3+2) = (cx-bx);
        tab-->(numwords*3+3) = WORDSIZE+bx;
        numwords++;
        if (numwords >= MAX_BUFFER_WORDS) break;
    }
    tab-->0 = numwords;

    ! Now we look each word up in the dictionary.

    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;

    for (wx=0 : wx<numwords : wx++) {
        wlen = tab-->(wx*3+2);
        wpos = tab-->(wx*3+3);

        ! Copy the word into the gg_tokenbuf array, clipping to DICT_WORD_SIZE
        ! characters and lower case.
        if (wlen > DICT_WORD_SIZE) wlen = DICT_WORD_SIZE;
        cx = wpos - WORDSIZE;
        for (ix=0 : ix<wlen : ix++) gg_tokenbuf->ix = VM_UpperToLowerCase(buf->(cx+ix));
        for (: ix<DICT_WORD_SIZE : ix++) gg_tokenbuf->ix = 0;

        val = #dictionary_table + WORDSIZE;
        @binarysearch gg_tokenbuf DICT_WORD_SIZE val entrylen dictlen 1 1 res;
        tab-->(wx*3+1) = res;
    }
];

[ LTI_Insert i ch  b y;

    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b-->0;
    if (y > INPUT_BUFFER_LEN) y = INPUT_BUFFER_LEN;

    ! Move the subsequent text along one character:
    for (y=y+WORDSIZE : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b-->0 < INPUT_BUFFER_LEN) (b-->0)++;
];

[ VM_InvalidDictionaryAddress addr;
	if (addr < 0) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return w; ];
[ VM_NumberToDictionaryAddress n; return n; ];

Array gg_tokenbuf -> DICT_WORD_SIZE;

[ GGWordCompare str1 str2 ix jx;
    for (ix=0 : ix<DICT_WORD_SIZE : ix++) {
        jx = (str1->ix) - (str2->ix);
        if (jx ~= 0) return jx;
    }
    return 0;
];

#Ifdef DEBUG;
[ DebugAction a str;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    if (a < 0 || a >= #identifiers_table-->7) print "<invalid action ", a, ">";
    else {
        str = #identifiers_table-->6;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed action ", a, ">";
    }
];

[ DebugAttribute a str;
    if (a < 0 || a >= NUM_ATTR_BYTES*8) print "<invalid attribute ", a, ">";
    else {
        str = #identifiers_table-->4;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed attribute ", a, ">";
    }
];
#Endif;

[ VM_CommandTableAddress i;
	return (#grammar_table)-->(i+1);
];

[ VM_PrintCommandWords i wd j dictlen entrylen;
    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;
    for (j=0 : j<dictlen : j++) {
        wd = #dictionary_table + WORDSIZE + entrylen*j;
        if (DictionaryWordToVerbNum(wd) == i)
            print "'", (address) wd, "' ";
    }
];

[ VM_Seed_RNG n;
	@setrandom n;
];

[ VM_AllocateMemory amount i;
	@gestalt 7 0 i;
	if (i == 0) return i;
	@malloc amount i;
	return i;
];

[ VM_FreeMemory address i;
	@gestalt 7 0 i;
	if (i == 0) return;
	@mfree address;
];

[ VM_Picture resource_ID;
	if (glk_gestalt(gestalt_Graphics, 0)) {
		glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
	} else {
		print "[Picture number ", resource_ID, " here.]^";
	}
];

[ VM_SoundEffect resource_ID;
	if (glk_gestalt(gestalt_Sound, 0)) {
		glk_schannel_play(gg_foregroundchan, resource_ID);
	} else {
		print "[Sound effect number ", resource_ID, " here.]^";
	}
];

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY:     glk_set_style(style_Normal);
		HEADER_VMSTY:     glk_set_style(style_Header);
		SUBHEADER_VMSTY:  glk_set_style(style_Subheader);
		NOTE_VMSTY:       glk_set_style(style_Note);
		ALERT_VMSTY:      glk_set_style(style_Alert);
		BLOCKQUOTE_VMSTY: glk_set_style(style_BlockQuote);
		INPUT_VMSTY:      glk_set_style(style_Input);
	}
];

[ VM_UpperToLowerCase c; return glk_char_to_lower(c); ];
[ VM_LowerToUpperCase c; return glk_char_to_upper(c); ];

! Glulx_PrintAnything()                    <nothing printed>
! Glulx_PrintAnything(0)                   <nothing printed>
! Glulx_PrintAnything("string");           print (string) "string";
! Glulx_PrintAnything('word')              print (address) 'word';
! Glulx_PrintAnything(obj)                 print (name) obj;
! Glulx_PrintAnything(obj, prop)           obj.prop();
! Glulx_PrintAnything(obj, prop, args...)  obj.prop(args...);
! Glulx_PrintAnything(func)                func();
! Glulx_PrintAnything(func, args...)       func(args...);

[ Glulx_PrintAnything _vararg_count obj mclass;
    if (_vararg_count == 0) return;
    @copy sp obj;
    _vararg_count--;
    if (obj == 0) return;

    if (obj->0 == $60) {
        ! Dictionary word. Metaclass() can't catch this case, so we do it manually
        print (address) obj;
        return;
    }

    mclass = metaclass(obj);
    switch (mclass) {
      nothing:
        return;
      String:
        print (string) obj;
        return;
      Routine:
        ! Call the function with all the arguments which are already
        ! on the stack.
        @call obj _vararg_count 0;
        return;
      Object:
        if (_vararg_count == 0) {
            print (name) obj;
        }
        else {
            ! Push the object back onto the stack, and call the
            ! veneer routine that handles obj.prop() calls.
            @copy obj sp;
            _vararg_count++;
            @call CA__Pr _vararg_count 0;
        }
        return;
    }
];

[ Glulx_PrintAnyToArray _vararg_count arr arrlen str oldstr len;
    @copy sp arr;
    @copy sp arrlen;
    _vararg_count = _vararg_count - 2;

    oldstr = glk_stream_get_current();
    str = glk_stream_open_memory(arr, arrlen, 1, 0);
    if (str == 0) return 0;

    glk_stream_set_current(str);

    @call Glulx_PrintAnything _vararg_count 0;

    glk_stream_set_current(oldstr);
    @copy $ffffffff sp;
    @copy str sp;
    @glk $0044 2 0; ! stream_close
    @copy sp len;
    @copy sp 0;
    return len;
];

Constant GG_ANYTOSTRING_LEN 66;
Array AnyToStrArr -> GG_ANYTOSTRING_LEN+1;

[ Glulx_ChangeAnyToCString _vararg_count ix len;
    ix = GG_ANYTOSTRING_LEN-2;
    @copy ix sp;
    ix = AnyToStrArr+1;
    @copy ix sp;
    ix = _vararg_count+2;
    @call Glulx_PrintAnyToArray ix len;
    AnyToStrArr->0 = $E0;
    if (len >= GG_ANYTOSTRING_LEN)
        len = GG_ANYTOSTRING_LEN-1;
    AnyToStrArr->(len+1) = 0;
    return AnyToStrArr;
];

[ VM_ClearScreen window;
    if (window == WIN_ALL or WIN_MAIN) {
        glk_window_clear(gg_mainwin);
        if (gg_quotewin) {
            glk_window_close(gg_quotewin, 0);
            gg_quotewin = 0;
        }
    }
    if (gg_statuswin && window == WIN_ALL or WIN_STATUS) glk_window_clear(gg_statuswin);
];

[ VM_ScreenWidth  id;
    id=gg_mainwin;
    if (gg_statuswin && statuswin_current) id = gg_statuswin;
    glk_window_get_size(id, gg_arguments, 0);
    return gg_arguments-->0;
];

[ VM_ScreenHeight;
    glk_window_get_size(gg_mainwin, 0, gg_arguments);
    return gg_arguments-->0;
];

[ VM_SetWindowColours f b window doclear  i fwd bwd swin;
    if (clr_on && f && b) {
        if (window) swin = 5-window; ! 4 for TextGrid, 3 for TextBuffer

        fwd = MakeColourWord(f);
        bwd = MakeColourWord(b);
        for (i=0 : i<style_NUMSTYLES: i++) {
            if (f == CLR_DEFAULT || b == CLR_DEFAULT) {  ! remove style hints
                glk_stylehint_clear(swin, i, stylehint_TextColor);
                glk_stylehint_clear(swin, i, stylehint_BackColor);
            } else {
                glk_stylehint_set(swin, i, stylehint_TextColor, fwd);
                glk_stylehint_set(swin, i, stylehint_BackColor, bwd);
            }
        }

        ! Now re-open the windows to apply the hints
        if (gg_statuswin) glk_window_close(gg_statuswin, 0);
        gg_statuswin = 0;

        if (doclear || ( window ~= 1 && (clr_fg ~= f || clr_bg ~= b) ) ) {
            glk_window_close(gg_mainwin, 0);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
            if (gg_scriptstr ~= 0)
                glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
        }

        gg_statuswin =
        	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
        		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        if (statuswin_current && gg_statuswin) VM_MoveCursorInStatusLine(); else VM_MainWindow();

        if (window ~= 2) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window ~= 1) {
            clr_fg = f;
            clr_bg = b;
        }
    }
];

[ VM_RestoreWindowColours; ! used after UNDO: compare I6 patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
];

[ MakeColourWord c;
    if (c > 9) return c;
    c = c-2;
    return $ff0000*(c&1) + $ff00*(c&2 ~= 0) + $ff*(c&4 ~= 0);
];

[ VM_MainWindow;
    glk_set_window(gg_mainwin); ! set_window
    statuswin_current=0;
];

[ VM_StatusLineHeight hgt;
    if (gg_statuswin == 0) return;
    if (hgt == statuswin_cursize) return;
    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin), $12, hgt, 0);
    statuswin_cursize = hgt;
];

[ VM_MoveCursorInStatusLine line column;
    if (gg_statuswin == 0) return;
    glk_set_window(gg_statuswin);
    if (line == 0) { line = 1; column = 1; }
    glk_window_move_cursor(gg_statuswin, column-1, line-1);
    statuswin_current=1;
];

[ Box__Routine maxwid arr ix lines lastnl parwin;
    maxwid = 0; ! squash compiler warning
    lines = arr-->0;

    if (gg_quotewin == 0) {
        gg_arguments-->0 = lines;
        ix = InitGlkWindow(GG_QUOTEWIN_ROCK);
        if (ix == 0)
            gg_quotewin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		lines, wintype_TextBuffer, GG_QUOTEWIN_ROCK);
    } else {
        parwin = glk_window_get_parent(gg_quotewin);
        glk_window_set_arrangement(parwin, $12, lines, 0);
    }

    lastnl = true;
    if (gg_quotewin) {
        glk_window_clear(gg_quotewin);
        glk_set_window(gg_quotewin);
        lastnl = false;
    }

	VM_Style(BLOCKQUOTE_VMSTY);
    for (ix=0 : ix<lines : ix++) {
        print (string) arr-->(ix+1);
        if (ix < lines-1 || lastnl) new_line;
    }
	VM_Style(NORMAL_VMSTY);

    if (gg_quotewin) glk_set_window(gg_mainwin);
];

#Ifdef DEBUG;
[ GlkListSub id val;
    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        print "Window ", id, " (", gg_arguments-->0, "): ";
        val = glk_window_get_type(id);
        switch (val) {
          1: print "pair";
          2: print "blank";
          3: print "textbuffer";
          4: print "textgrid";
          5: print "graphics";
          default: print "unknown";
        }
        val = glk_window_get_parent(id);
        if (val) print ", parent is window ", val;
        else     print ", no parent (root)";
        val = glk_window_get_stream(id);
        print ", stream ", val;
        val = glk_window_get_echo_stream(id);
        if (val) print ", echo stream ", val;
        print "^";
        id = glk_window_iterate(id, gg_arguments);
    }
    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        print "Stream ", id, " (", gg_arguments-->0, ")^";
        id = glk_stream_iterate(id, gg_arguments);
    }
    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        print "Fileref ", id, " (", gg_arguments-->0, ")^";
        id = glk_fileref_iterate(id, gg_arguments);
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        id = glk_schannel_iterate(0, gg_arguments);
        while (id) {
            print "Soundchannel ", id, " (", gg_arguments-->0, ")^";
            id = glk_schannel_iterate(id, gg_arguments);
        }
    }
];

Verb meta 'glklist'

    *                                           -> Glklist;
#Endif;

[ VM_Undo result_code;
	@restoreundo result_code;
	return (~~result_code);
];

[ VM_Save_Undo result_code;
    @saveundo result_code;
    if (result_code == -1) { GGRecoverObjects(); return 2; }
    return (~~result_code);
];

[ QUIT_THE_GAME_R;
	if (actor ~= player) rfalse;
	GL__M(##Quit, 2); if (YesOrNo()~=0) quit;
];

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	GL__M(##Restart, 1);
	if (YesOrNo() ~= 0) {
		@restart;
		GL__M(##Restart, 2);
	}
];

[ RESTORE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $02, 0);
	if (fref == 0) jump RFailed;
	gg_savestr = glk_stream_open_file(fref, $02, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump RFailed;
	@restore gg_savestr res;
	glk_stream_close(gg_savestr, 0);
	gg_savestr = 0;
	.RFailed;
	GL__M(##Restore, 1);
];

[ SAVE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $01, 0);
	if (fref == 0) jump SFailed;
	gg_savestr = glk_stream_open_file(fref, $01, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump SFailed;
	@save gg_savestr res;
	if (res == -1) {
		! The player actually just typed "restore". We're going to print
		!  GL__M(##Restore,2); the Z-Code Inform library does this correctly
		! now. But first, we have to recover all the Glk objects; the values
		! in our global variables are all wrong.
		GGRecoverObjects();
		glk_stream_close(gg_savestr, 0); ! stream_close
		gg_savestr = 0;
		return GL__M(##Restore, 2);
	}
	glk_stream_close(gg_savestr, 0); ! stream_close
	gg_savestr = 0;
	if (res == 0) return GL__M(##Save, 2);
	.SFailed;
	GL__M(##Save, 1);
];

[ VERIFY_THE_STORY_FILE_R res;
	if (actor ~= player) rfalse;
	@verify res;
	if (res == 0) return GL__M(##Verify, 1);
	GL__M(##Verify, 2);
];

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr ~= 0) return GL__M(##ScriptOn, 1);
	if (gg_scriptfref == 0) {
		gg_scriptfref = glk_fileref_create_by_prompt($102, $05, GG_SCRIPTFREF_ROCK);
		if (gg_scriptfref == 0) jump S1Failed;
	}
	! stream_open_file
	gg_scriptstr = glk_stream_open_file(gg_scriptfref, $05, GG_SCRIPTSTR_ROCK);
	if (gg_scriptstr == 0) jump S1Failed;
	glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
	GL__M(##ScriptOn, 2);
	VersionSub();
	return;
	.S1Failed;
	GL__M(##ScriptOn, 3);
];

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr == 0) return GL__M(##ScriptOff,1);
	GL__M(##ScriptOff, 2);
	glk_stream_close(gg_scriptstr, 0); ! stream_close
	gg_scriptstr = 0;
];

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	@gestalt 1 0 ix;
	print "Interpreter version ", ix / $10000, ".", (ix & $FF00) / $100,
	".", ix & $FF, " / ";
	@gestalt 0 0 ix;
	print "VM ", ix / $10000, ".", (ix & $FF00) / $100, ".", ix & $FF, " / ";
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	ShowExtensionVersions();
	say__p = 1;
];

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->(action+1));
	rtrue;
];

#Endif;

#Ifdef TARGET_ZCODE;
Global top_object; ! largest valid number of any tree object
Global xcommsdir; ! true if command recording is on
Global transcript_mode; ! true if game scripting is on

Constant INPUT_BUFFER_LEN = 120; ! Length of buffer array

Array  buffer    -> 123;            ! Buffer for parsing main line of input
Array  buffer2   -> 123;            ! Buffers for supplementary questions
Array  buffer3   -> 123;            ! Buffer retaining input for "again"
Array  parse     buffer 63;         ! Parse table mirroring it
Array  parse2    buffer 63;         !

Global dict_start;
Global dict_entry_size;
Global dict_end;

[ VM_Initialise i;
	standard_interpreter = HDR_TERPSTANDARD-->0;
	transcript_mode = ((HDR_GAMEFLAGS-->0) & 1);

	dict_start = HDR_DICTIONARY-->0;
	dict_entry_size = dict_start->(dict_start->0 + 1);
	dict_start = dict_start + dict_start->0 + 4;
	dict_end = dict_start + ((dict_start - 2)-->0) * dict_entry_size;

	buffer->0  = INPUT_BUFFER_LEN;
	buffer2->0 = INPUT_BUFFER_LEN;
	buffer3->0 = INPUT_BUFFER_LEN;
	parse->0   = 15;
	parse2->0  = 15;

	top_object = #largest_object-255;

	#ifdef FIX_RNG;
	@random 10000 -> i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@random i -> i;
	#endif; ! FIX_RNG	
	
	! Make @random predictable
	@random -2000 -> i;
];

[ ENABLE_GLULX_ACCEL_R;
	rfalse;
];

[ VM_Describe_Release i;
	print "Release ", (HDR_GAMERELEASE-->0) & $03ff, " / Serial number ";
	for (i=0 : i<6 : i++) print (char) HDR_GAMESERIAL->i;
];

[ VM_KeyChar win  key;
    if (win) @set_window win;
    @read_char 1 -> key;
    return key;
];

[ VM_KeyDelay tenths  key;
    @read_char 1 tenths VM_KeyDelay_Interrupt -> key;
    return key;
];
[ VM_KeyDelay_Interrupt; rtrue; ];

[ VM_ReadKeyboard  a_buffer a_table i;
    read a_buffer a_table;
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (i=2: i<=(a_buffer->1)+1: i++) print (char) a_buffer->i;
    print "^";
    #ifnot;
    i=0;  ! suppress compiler warning
    #endif;

    #Iftrue (#version_number == 6);
    @output_stream -1;
    @loadb a_buffer 1 -> sp;
    @add a_buffer 2 -> sp;
    @print_table sp sp;
    new_line;
    @output_stream 1;
    #Endif;
];

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    @output_stream 3 buf;
    switch (metaclass(a)) {
		String: print (string) a;
		Routine: a(b, c);
		Object, Class: if (b) PrintOrRun(a, b, true); else print (name) a;
    }
    @output_stream -3;
    if (buf-->0 > len) print "Error: Overflow in VM_PrintToBuffer.^";
    return buf-->0;
];

[ VM_Tokenise b p; b->(2 + b->1) = 0; @tokenise b p; ];

[ LTI_Insert i ch  b y;
    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b->1;
    if (y > b->0) y = b->0;

    ! Move the subsequent text along one character:
    for (y=y+2 : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b->1 < b->0) (b->1)++;
];

[ VM_InvalidDictionaryAddress addr;
    if ((UnsignedCompare(addr, dict_start) < 0) ||
		(UnsignedCompare(addr, dict_end) >= 0) ||
		((addr - dict_start) % dict_entry_size ~= 0)) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return (w-(HDR_DICTIONARY-->0 + 7))/9; ];
[ VM_NumberToDictionaryAddress n; return HDR_DICTIONARY-->0 + 7 + 9*n; ];

[ VM_CommandTableAddress i;
	return (HDR_STATICMEMORY-->0)-->i;
];

[ VM_PrintCommandWords i da j;
    da = HDR_DICTIONARY-->0;
    for (j=0 : j<(da+5)-->0 : j++)
        if (da->(j*9 + 14) == $ff-i)
        	print "'", (address) VM_NumberToDictionaryAddress(j), "' ";
];

#Ifdef DEBUG;
[ DebugAction a anames;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    anames = #identifiers_table;
    anames = anames + 2*(anames-->0) + 2*48;
    print (string) anames-->a;
];

[ DebugAttribute a anames;
    if (a < 0 || a >= 48) print "<invalid attribute ", a, ">";
    else {
        anames = #identifiers_table; anames = anames + 2*(anames-->0);
        print (string) anames-->a;
    }
];
#Endif;

[ VM_Seed_RNG n;
	if (n > 0) n = -n;
	@random n -> n;
];

[ VM_AllocateMemory amount;
	return 0;
];

[ VM_FreeMemory address;
];

[ VM_Picture resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@draw_picture resource_ID;
	#ENDIF;
];

[ VM_SoundEffect resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@sound_effect resource_ID;
	#ENDIF;
];

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY, NOTE_VMSTY: style roman;
		HEADER_VMSTY, SUBHEADER_VMSTY, ALERT_VMSTY: style bold;
	}
];

[ VM_UpperToLowerCase c;
   switch (c) {
     'A' to 'Z': c = c + 32;
     202, 204, 212, 214, 221: c--;
     217, 218: c = c - 2;
     158 to 160, 167 to 169, 208 to 210: c = c - 3;
     186 to 190, 196 to 200: c = c - 5 ;
     175 to 180: c = c - 6;
   }
   return c;
];

[ VM_LowerToUpperCase c;
   switch (c) {
     'a' to 'z': c = c - 32;
     201, 203, 211, 213, 220: c++;
     215, 216: c = c + 2;
     155 to 157, 164 to 166, 205 to 207: c = c + 3;
     181 to 185, 191 to 195: c = c + 5 ;
     169 to 174: c = c + 6;
   }
   return c;
];

[ VM_ClearScreen window;
    switch (window) {
		WIN_ALL:    @erase_window -1; statuswin_cursize = 0;
		WIN_STATUS: @erase_window 1;
		WIN_MAIN:   @erase_window 0;
    }
];

#Iftrue (#version_number == 6);
[ VM_ScreenWidth  width charw;
    @get_wind_prop 1 3 -> width;
    @get_wind_prop 1 13 -> charw;
    charw = charw & $FF;
    return (width+charw-1) / charw;
];
#Ifnot;
[ VM_ScreenWidth; return (HDR_SCREENWCHARS->0); ];
#Endif;

[ VM_ScreenHeight; return (HDR_SCREENHLINES->0); ];

[ VM_SetWindowColours f b window;
    if (clr_on && f && b) {
        if (window == 0) {  ! if setting both together, set reverse
            clr_fgstatus = b;
            clr_bgstatus = f;
            }
        if (window == 1) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window == 0 or 2) {
            clr_fg = f;
            clr_bg = b;
        }
        if (statuswin_current)
            @set_colour clr_fgstatus clr_bgstatus;
        else
            @set_colour clr_fg clr_bg;
    }
];

[ VM_RestoreWindowColours; ! compare I6 library patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
    #Iftrue (#version_number == 6); ! request screen update
    (0-->8) = (0-->8) | $$00000100;
    #Endif;
];

[ VM_MainWindow;
    if (statuswin_current) {
        if (clr_on && clr_bgstatus > 1) @set_colour clr_fg clr_bg;
        else style roman;
        @set_window 0;
    }
    statuswin_current = false;
];

[ VM_MoveCursorInStatusLine line column; ! 1-based position on text grid
    if (~~statuswin_current) {
         @set_window 1;
         if (clr_on && clr_bgstatus > 1) @set_colour clr_fgstatus clr_bgstatus;
         else                            style reverse;
    }
    if (line == 0) {
        line = 1;
        column = 1;
    }
    #Iftrue (#version_number == 6);
    Z6_MoveCursor(line, column);
    #Ifnot;
    @set_cursor line column;
    #Endif;
	statuswin_current = true;
];

#Iftrue (#version_number == 6);
[ Z6_MoveCursor line column  charw charh; ! 1-based position on text grid
	@get_wind_prop 1 13 -> charw; ! font size
	@log_shift charw $FFF8 -> charh;
	charw = charw / $100;
	line = 1 + charh*(line-1);
	column = 1 + charw*(column-1);
	@set_cursor line column;
];
#Endif;

#Iftrue (#version_number == 6);
[ VM_StatusLineHeight height  wx wy x y charh;
    ! Split the window. Standard 1.0 interpreters should keep the window 0
    ! cursor in the same absolute position, but older interpreters,
    ! including Infocom's don't - they keep the window 0 cursor in the
    ! same position relative to its origin. We therefore compensate
    ! manually.
    @get_wind_prop 0 0 -> wy; @get_wind_prop 0 1 -> wx;
    @get_wind_prop 0 13 -> charh; @log_shift charh $FFF8 -> charh;
    @get_wind_prop 0 4 -> y; @get_wind_prop 0 5 -> x;
    height = height * charh;
    @split_window height;
    y = y - height + wy - 1;
    if (y < 1) y = 1;
    x = x + wx - 1;
    @set_cursor y x 0;
    statuswin_cursize = height;
];
#Ifnot;
[ VM_StatusLineHeight height;
    if (statuswin_cursize ~= height)
        @split_window height;
    statuswin_cursize = height;
];
#Endif;

#Iftrue (#version_number == 6);
[ Z6_DrawStatusLine width x charw scw;
	(0-->8) = (0-->8) &~ $$00000100;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(statuswin_size);
	! Now clear the window. This isn't totally trivial. Our approach is to select the
	! fixed space font, measure its width, and print an appropriate
	! number of spaces. We round up if the screen isn't a whole number
	! of characters wide, and rely on window 1 being set to clip by default.
	VM_MoveCursorInStatusLine(1, 1);
	@set_font 4 -> x;
	width = VM_ScreenWidth();
	spaces width;
	ClearParagraphing();
	if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
		! Back to standard font for the display. We use output_stream 3 to
		! measure the space required, the aim being to get 50 characters
		! worth of space for the location name.
		VM_MoveCursorInStatusLine(1, 2);
		@set_font 1 -> x;
		switch (metaclass(left_hand_status_line)) {
			String: print (string) left_hand_status_line;
			Routine: left_hand_status_line();
		}
		@get_wind_prop 1 3 -> width;
		@get_wind_prop 1 13 -> charw;
		charw = charw & $FF;
		@output_stream 3 StorageForShortName;
		print (PrintText) right_hand_status_line;
		@output_stream -3; scw = HDR_PIXELSTO3-->0 + charw;
		x = 1+width-scw;
		@set_cursor 1 x; print (PrintText) right_hand_status_line;
	}
	! Reselect roman, as Infocom's interpreters go funny if reverse is selected twice.
	VM_MainWindow();
	ClearParagraphing();
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;

[ VM_Undo result_code;
	@restore_undo result_code;
	return result_code;
];

[ VM_Save_Undo result_code;
    @save_undo result_code;
	return result_code;
];

[ QUIT_THE_GAME_R; if (actor ~= player) rfalse;
	GL__M(##Quit,2); if (YesOrNo()~=0) quit; ];

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	GL__M(##Restart,1);
	if (YesOrNo()~=0) { @restart; GL__M(##Restart,2); }
];

[ RESTORE_THE_GAME_R;
	if (actor ~= player) rfalse;
	restore Rmaybe;
	return GL__M(##Restore,1);
	.RMaybe; GL__M(##Restore,2);
];

[ SAVE_THE_GAME_R flag;
	if (actor ~= player) rfalse;
	#IFV5;
	@save -> flag;
	switch (flag) {
		0: GL__M(##Save,1);
		1: GL__M(##Save,2);
		2: GL__M(##Restore,2);
	}
	#IFNOT;
	save Smaybe;
	return GL__M(##Save,1);
	.SMaybe; GL__M(##Save,2);
	#ENDIF;
];

[ VERIFY_THE_STORY_FILE_R;
	if (actor ~= player) rfalse;
	@verify ?Vmaybe;
	jump Vwrong;
	.Vmaybe; return GL__M(##Verify,1);
	.Vwrong;
	GL__M(##Verify,2);
];

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode) return GL__M(##ScriptOn,1);
	@output_stream 2;
	if (((0-->8) & 1) == 0) return GL__M(##ScriptOn,3);
	GL__M(##ScriptOn,2); VersionSub();
	transcript_mode = true;
];

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode == false) return GL__M(##ScriptOff,1);
	GL__M(##ScriptOff,2);
	@output_stream -2;
	if ((0-->8) & 1) return GL__M(##ScriptOff,3);
	transcript_mode = false;
];

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	ix = 0; ! shut up compiler warning
	if (standard_interpreter > 0) {
		print "Standard interpreter ",
			standard_interpreter/256, ".", standard_interpreter%256,
			" (", HDR_TERPNUMBER->0;
		#Iftrue (#version_number == 6);
		print (char) '.', HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print ") / ";
	} else {
		print "Interpreter ", HDR_TERPNUMBER->0, " Version ";
		#Iftrue (#version_number == 6);
		print HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print " / ";
	}
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	#ifdef ShowExtensionVersions;
	ShowExtensionVersions();
	#endif;
	say__p = 1;
];

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->action);
	rtrue;
];

[ OhLookItsReal; ];
[ OhLookItsRoom; ];
[ OhLookItsThing; ];

[ OC__Cl obj cla j a n objflag;

!	if (cla > 4) OhLookItsReal();
!	if (cla == K1_room) OhLookItsRoom();
!	if (cla == K2_thing) OhLookItsThing();

	@jl obj 1 ?NotObj;
	@jg obj max_z_object ?NotObj;
	@inc objflag;
	@je cla K1_room ?~NotRoom;
	@test_attr obj mark_as_room ?rtrue;
	@rfalse;
	.NotRoom;
	@je cla K2_thing ?~NotObj;
	@test_attr obj mark_as_thing ?rtrue;
	@rfalse;
	.NotObj;

	@je cla Object Class ?ObjOrClass;
	@je cla Routine String ?RoutOrStr;

	@jin cla 1 ?~Mistake;

	@jz objflag ?rfalse;
	@get_prop_addr obj 2 -> a;
	@jz a ?rfalse;
	@get_prop_len a -> n;

	@div n 2 -> n;
	.Loop;
	@loadw a j -> sp;
	@je sp cla ?rtrue;
	@inc j;
	@jl j n ?Loop;
	@rfalse;

	.ObjOrClass;
	@jz objflag ?rfalse;
	@je cla Object ?JustObj;

	! So now cla is Class
	@jg obj String ?~rtrue;
	@jin obj Class ?rtrue;
	@rfalse;

	.JustObj;
	! So now cla is Object
	@jg obj String ?~rfalse;
	@jin obj Class ?rfalse;
	@rtrue;

	.RoutOrStr;
	@jz objflag ?~rfalse;
	@call_2s Z__Region obj -> sp;
	@inc sp;
	@je sp cla ?rtrue;
	@rfalse;

	.Mistake;
	RT__Err("apply 'ofclass' for", cla, -1);
	rfalse;
];

[ Unsigned__Compare x y u v;
	@je x y ?rfalse; ! i.e., return 0
	@jl x 0 ?XNegative;
	! So here x >= 0 and x ~= y
	@jl y 0 ?XPosYNeg;

	! Here x >=0, y >= 0, x ~= y

	@jg x y ?rtrue; ! i.e., return 1
	@ret -1;

	.XPosYNeg;
	! Here x >= 0, y < 0, x ~= y
	@ret -1;

	.XNegative;
	@jl y 0 ?~rtrue; ! if x < 0, y >= 0, return 1
	
	! Here x < 0, y < 0, x ~= y
	@jg x y ?rtrue;
	@ret -1;
];

[ RT__ChLDW base offset;
    @loadw base offset -> sp;
    @ret sp;
];

#Endif;

Object Compass "compass" has concealed;

Constant AGAIN1__WD     = 'again';
Constant AGAIN2__WD     = 'g//';
Constant AGAIN3__WD     = 'again';
Constant OOPS1__WD      = 'oops';
Constant OOPS2__WD      = 'o//';
Constant OOPS3__WD      = 'oops';
Constant UNDO1__WD      = 'undo';
Constant UNDO2__WD      = 'undo';
Constant UNDO3__WD      = 'undo';

Constant ALL1__WD       = 'all';
Constant ALL2__WD       = 'each';
Constant ALL3__WD       = 'every';
Constant ALL4__WD       = 'everything';
Constant ALL5__WD       = 'both';
Constant AND1__WD       = 'and';
Constant AND2__WD       = 'and';
Constant AND3__WD       = 'and';
Constant BUT1__WD       = 'but';
Constant BUT2__WD       = 'except';
Constant BUT3__WD       = 'but';
Constant ME1__WD        = 'me';
Constant ME2__WD        = 'myself';
Constant ME3__WD        = 'self';
Constant OF1__WD        = 'of';
Constant OF2__WD        = 'of';
Constant OF3__WD        = 'of';
Constant OF4__WD        = 'of';
Constant OTHER1__WD     = 'another';
Constant OTHER2__WD     = 'other';
Constant OTHER3__WD     = 'other';
Constant THEN1__WD      = 'then';
Constant THEN2__WD      = 'then';
Constant THEN3__WD      = 'then';

Constant NO1__WD        = 'n//';
Constant NO2__WD        = 'no';
Constant NO3__WD        = 'no';
Constant YES1__WD       = 'y//';
Constant YES2__WD       = 'yes';
Constant YES3__WD       = 'yes';

Constant AMUSING__WD    = 'amusing';
Constant FULLSCORE1__WD = 'fullscore';
Constant FULLSCORE2__WD = 'full';
Constant QUIT1__WD      = 'q//';
Constant QUIT2__WD      = 'quit';
Constant RESTART__WD    = 'restart';
Constant RESTORE__WD    = 'restore';

Array LanguagePronouns table

  ! word        possible GNAs                   connected
  !             to follow:                      to:
  !             a     i
  !             s  p  s  p
  !             mfnmfnmfnmfn

    'it'      $$001000111000                    NULL
    'him'     $$100000000000                    NULL
    'her'     $$010000000000                    NULL
    'them'    $$000111000111                    NULL;

Array LanguageDescriptors table

  ! word        possible GNAs   descriptor      connected
  !             to follow:      type:           to:
  !             a     i
  !             s  p  s  p
  !             mfnmfnmfnmfn

    'my'      $$111111111111    POSSESS_PK      0
    'this'    $$111111111111    POSSESS_PK      0
    'these'   $$000111000111    POSSESS_PK      0
    'that'    $$111111111111    POSSESS_PK      1
    'those'   $$000111000111    POSSESS_PK      1
    'his'     $$111111111111    POSSESS_PK      'him'
    'her'     $$111111111111    POSSESS_PK      'her'
    'their'   $$111111111111    POSSESS_PK      'them'
    'its'     $$111111111111    POSSESS_PK      'it'
    'the'     $$111111111111    DEFART_PK       NULL
    'a//'     $$111000111000    INDEFART_PK     NULL
    'an'      $$111000111000    INDEFART_PK     NULL
    'some'    $$000111000111    INDEFART_PK     NULL
    'lit'     $$111111111111    light           NULL
    'lighted' $$111111111111    light           NULL
    'unlit'   $$111111111111    (-light)        NULL;

Array LanguageNumbers table
    'one' 1 'two' 2 'three' 3 'four' 4 'five' 5
    'six' 6 'seven' 7 'eight' 8 'nine' 9 'ten' 10
    'eleven' 11 'twelve' 12 'thirteen' 13 'fourteen' 14 'fifteen' 15
    'sixteen' 16 'seventeen' 17 'eighteen' 18 'nineteen' 19 'twenty' 20
    'twenty-one' 21 'twenty-two' 22 'twenty-three' 23 'twenty-four' 24
	'twenty-five' 25 'twenty-six' 26 'twenty-seven' 27 'twenty-eight' 28
	'twenty-nine' 29 'thirty' 30
;

[ LanguageNumber n f;
    if (n == 0)    { print "zero"; rfalse; }
    if (n < 0)     { print "minus "; n = -n; }
#Iftrue (WORDSIZE == 4);
    if (n >= 1000000000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000000000, " million"; n = n%1000000000; f = 1;
    }
    if (n >= 1000000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000000, " million"; n = n%1000000; f = 1;
    }
#Endif;
    if (n >= 1000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000, " thousand"; n = n%1000; f = 1;
    }
    if (n >= 100)  {
        if (f == 1) print ", ";
        print (LanguageNumber) n/100, " hundred"; n = n%100; f = 1;
    }
    if (n == 0) rfalse;
    #Ifdef DIALECT_US;
    if (f == 1) print " ";
    #Ifnot;
    if (f == 1) print " and ";
    #Endif;
    switch (n) {
      1:    print "one";
      2:    print "two";
      3:    print "three";
      4:    print "four";
      5:    print "five";
      6:    print "six";
      7:    print "seven";
      8:    print "eight";
      9:    print "nine";
      10:   print "ten";
      11:   print "eleven";
      12:   print "twelve";
      13:   print "thirteen";
      14:   print "fourteen";
      15:   print "fifteen";
      16:   print "sixteen";
      17:   print "seventeen";
      18:   print "eighteen";
      19:   print "nineteen";
      20 to 99: switch (n/10) {
        2:  print "twenty";
        3:  print "thirty";
        4:  print "forty";
        5:  print "fifty";
        6:  print "sixty";
        7:  print "seventy";
        8:  print "eighty";
        9:  print "ninety";
        }
        if (n%10 ~= 0) print "-", (LanguageNumber) n%10;
    }
];

[ LanguageTimeOfDay hours mins i;
    i = hours%12;
    if (i == 0) i = 12;
    if (i < 10) print " ";
    print i, ":", mins/10, mins%10;
    if ((hours/12) > 0) print " pm"; else print " am";
];

[ LanguageDirection d;
	print (name) d;
];

[ LanguageToInformese; ];

Constant LanguageAnimateGender   = male;
Constant LanguageInanimateGender = neuter;

Constant LanguageContractionForms = 2;     ! English has two:
                                           ! 0 = starting with a consonant
                                           ! 1 = starting with a vowel

[ LanguageContraction text;
    if (text->0 == 'a' or 'e' or 'i' or 'o' or 'u'
                or 'A' or 'E' or 'I' or 'O' or 'U') return 1;
    return 0;
];

Array LanguageArticles -->

 !   Contraction form 0:     Contraction form 1:
 !   Cdef   Def    Indef     Cdef   Def    Indef

     "The " "the " "a "      "The " "the " "an "          ! Articles 0
     "The " "the " "some "   "The " "the " "some ";       ! Articles 1

                   !             a           i
                   !             s     p     s     p
                   !             m f n m f n m f n m f n

Array LanguageGNAsToArticles --> 0 0 0 1 1 1 0 0 0 1 1 1;

[ LanguageVerb i;
    switch (i) {
      'i//','inv','inventory':
               print "take inventory";
      'l//':   print "look";
      'x//':   print "examine";
      'z//':   print "wait";
      default: rfalse;
    }
    rtrue;
];

[ LanguageVerbLikesAdverb w;
    if (w == 'look' or 'go' or 'push' or 'walk')
        rtrue;
    rfalse;
];

[ LanguageVerbMayBeName w;
    if (w == 'long' or 'short' or 'normal'
                    or 'brief' or 'full' or 'verbose')
        rtrue;
    rfalse;
];

Constant NKEY__TX       = "N = next subject";
Constant PKEY__TX       = "P = previous";
Constant QKEY1__TX      = "  Q = resume game";
Constant QKEY2__TX      = "Q = previous menu";
Constant RKEY__TX       = "RETURN = read subject";

Constant NKEY1__KY      = 'N';
Constant NKEY2__KY      = 'n';
Constant PKEY1__KY      = 'P';
Constant PKEY2__KY      = 'p';
Constant QKEY1__KY      = 'Q';
Constant QKEY2__KY      = 'q';

Constant SCORE__TX      = "Score: ";
Constant MOVES__TX      = "Moves: ";
Constant TIME__TX       = "Time: ";
Global CANTGO__TX     = "You can't go that way.";
Global FORMER__TX     = "your former self";
Global YOURSELF__TX   = "yourself";
Constant YOU__TX        = "You";
Constant DARKNESS__TX   = "Darkness";

Constant THOSET__TX     = "those things";
Constant THAT__TX       = "that";
Constant OR__TX         = " or ";
Constant NOTHING__TX    = "nothing";
Global IS__TX         = " is";
Global ARE__TX        = " are";
Global IS2__TX        = "is ";
Global ARE2__TX       = "are ";
Global IS3__TX        = "is";
Global ARE3__TX       = "are";
Constant AND__TX        = " and ";
#ifdef SERIAL_COMMA;
Constant LISTAND__TX   = ", and ";
Constant LISTAND2__TX  = " and ";
#ifnot;
Constant LISTAND__TX   = " and ";
Constant LISTAND2__TX  = " and ";
#endif; ! SERIAL_COMMA
Constant WHOM__TX       = "whom ";
Constant WHICH__TX      = "which ";
Constant COMMA__TX      = ", ";

[ ThatorThose obj;      ! Used in the accusative
    if (obj == player)            { print "you"; return; }
    if (obj has pluralname)       { print "those"; return; }
    if (obj has animate) {
        if (obj has female)       { print "her"; return; }
        else
            if (obj hasnt neuter) { print "him"; return; }
    }
    print "that";
];

[ ItorThem obj;
    if (obj == player)            { print "yourself"; return; }
    if (obj has pluralname)       { print "them"; return; }
    if (obj has animate) {
        if (obj has female)       { print "her"; return; }
        else
            if (obj hasnt neuter) { print "him"; return; }
    }
    print "it";
];

[ IsorAre obj;
    if (obj has pluralname || obj == player) print "are"; else print "is";
];

[ HasorHave obj;
    if (obj has pluralname || obj == player) print "have"; else print "has";
];

[ CThatorThose obj;     ! Used in the nominative
    if (obj == player)            { print "You"; return; }
    if (obj has pluralname)       { print "Those"; return; }
    if (obj has animate) {
        if (obj has female)       { print "She"; return; }
        else
            if (obj hasnt neuter) { print "He"; return; }
    }
    print "That";
];

[ CTheyreorThats obj;
    if (obj == player)             { print "You're"; return; }
    if (obj has pluralname)        { print "They're"; return; }
    if (obj has animate) {
        if (obj has female)        { print "She's"; return; }
        else if (obj hasnt neuter) { print "He's"; return; }
    }
    print "That's";
];

[ HisHerTheir o; if (o has pluralname) { print "their"; return; }
	if (o has female) { print "her"; return; }
	if (o has neuter) { print "its"; return; }
	print "his";
];

[ HimHerItself o; if (o has pluralname) { print "theirselves"; return; }
	if (o has female) { print "herself"; return; }
	if (o has neuter) { print "itself"; return; }
	print "himself";
];

[ LanguageLM n x1 x2;
  say__p = 1;
  Answer,Ask:
            "There is no reply.";
! Ask:      see Answer
  Attack:   "Violence isn't the answer to this one.";
  Burn:     "This dangerous act would achieve little.";
  Buy:      "Nothing is on sale.";
  Climb:    "I don't think much is to be achieved by that.";
  Close: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can close.";
        2:  print_ret (ctheyreorthats) x1, " already closed.";
        3:  "You close ", (the) x1, ".";
		4:	print (The) actor, " closes ", (the) x1, ".^";
		5:	print (The) x1, " close"; if (x1 hasnt pluralname) print "s";
			print ".^";
    }
  Consult: switch (n) {
  		1:	"You discover nothing of interest in ", (the) x1, ".";
  		2:	print (The) actor, " looks at ", (the) x1, ".^";
    }
  Cut:      "Cutting ", (thatorthose) x1, " up would achieve little.";
  Disrobe: switch (n) {
        1:  "You're not wearing ", (thatorthose) x1, ".";
        2:  "You take off ", (the) x1, ".";
		3:	print (The) actor, " takes off ", (the) x1, ".^";
    }
  Drink:    "There's nothing suitable to drink here.";
  Drop: switch (n) {
        1:  if (x1 has pluralname) print (The) x1, " are "; else print (The) x1, " is ";
            "already here.";
        2:  "You haven't got ", (thatorthose) x1, ".";
        3:  print "(first taking ", (the) x1, " off)^"; say__p = 0; return;
        4:  "Dropped.";
        5:	"There is no more room on ", (the) x1, ".";
        6:	"There is no more room in ", (the) x1, ".";
        7:	print (The) actor, " puts down ", (the) x1, ".^";
    }
  Eat: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " plainly inedible.";
        2:  "You eat ", (the) x1, ". Not bad.";
        3:	print (The) actor, " eats ", (the) x1, ".^";
    }
  Enter: switch (n) {
        1:  print "But you're already ";
            if (x1 has supporter) print "on "; else print "in ";
            print_ret (the) x1, ".";
        2:  if (x1 has pluralname) print "They're"; else print "That's";
            print " not something you can ";
            switch (verb_word) {
              'stand':  "stand on.";
              'sit':    "sit down on.";
              'lie':    "lie down on.";
              default:  "enter.";
            }
        3:  "You can't get into the closed ", (name) x1, ".";
        4:  "You can only get into something free-standing.";
        5:  print "You get ";
            if (x1 has supporter) print "onto "; else print "into ";
            print_ret (the) x1, ".";
        6:  print "(getting ";
            if (x1 has supporter) print "off "; else print "out of ";
            print (the) x1; print ")^"; say__p = 0; return;
        7:  ! say__p = 0;
            if (x1 has supporter) "(getting onto ", (the) x1, ")";
            if (x1 has container) "(getting into ", (the) x1, ")";
            "(entering ", (the) x1, ")";
		8:	print (The) actor, " gets into ", (the) x1, ".^";
        9:  print (The) actor, " gets onto ", (the) x1, ".^";
    }
  Examine: switch (n) {
        1:  "Darkness, noun.  An absence of light to see by.";
        2:  "You see nothing special about ", (the) x1, ".";
        3:  print (The) x1, " ", (isorare) x1, " currently switched ";
            if (x1 has on) "on."; else "off.";
		4:	print (The) actor, " looks closely at ", (the) x1, ".^";
		5:	"You see nothing unexpected in that direction.";
	}
  Exit: switch (n) {
        1:  "But you aren't in anything at the moment.";
        2:  "You can't get out of the closed ", (name) x1, ".";
        3:  print "You get ";
            if (x1 has supporter) print "off "; else print "out of ";
            print_ret (the) x1, ".";
        4:  print "But you aren't ";
            if (x1 has supporter) print "on "; else print "in ";
            print_ret (the) x1, ".";
		5:	print (The) actor, " gets off ", (the) x1, ".^";
		6:	print (The) actor, " gets out of ", (the) x1, ".^";
    }
  GetOff:   "But you aren't on ", (the) x1, " at the moment.";
  Give: switch (n) {
        1:  "You aren't holding ", (the) x1, ".";
        2:  "You juggle ", (the) x1, " for a while, but don't achieve much.";
        3:  print (The) x1;
            if (x1 has pluralname) print " don't"; else print " doesn't";
            " seem interested.";
        4:  print (The) x1;
            if (x1 has pluralname) print " aren't";
            else print " isn't";
            " able to receive things.";
		5:	"You give ", (the) x1, " to ", (the) second, ".";
		6: print (The) actor, " gives ", (the) x1, " to you.^";
		7: print (The) actor, " gives ", (the) x1, " to ", (the) second, ".^";
    }
  Go: switch (n) {
        1:  print "You'll have to get ";
            if (x1 has supporter) print "off "; else print "out of ";
            print_ret (the) x1, " first.";
        2:  print_ret (string) CANTGO__TX;   ! "You can't go that way."
        6:  print "You can't, since ", (the) x1;
            if (x1 has pluralname) " lead nowhere."; else " leads nowhere.";
		7:	"You'll have to say which compass direction to go in.";
		8:	print (The) actor, " goes up";
		9:	print (The) actor, " goes down";
		10:	print (The) actor, " goes ", (name) x1;
		11:	print (The) actor, " arrives from above";
		12:	print (The) actor, " arrives from below";
		13:	print (The) actor, " arrives from the ", (name) x1;
		14:	print (The) actor, " arrives";
		15:	print (The) actor, " arrives at ", (the) x1, " from above";
		16:	print (The) actor, " arrives at ", (the) x1, " from below";
		17:	print (The) actor, " arrives at ", (the) x1, " from the ", (name) x2;
		18:	print (The) actor, " goes through ", (the) x1;
		19:	print (The) actor, " arrives from ", (the) x1;
		20:	print "on ", (the) x1;
		21:	print "in ", (the) x1;
		22:	print ", pushing ", (the) x1, " in front, and you along too";
		23:	print ", pushing ", (the) x1, " in front";
		24:	print ", pushing ", (the) x1, " away";
		25:	print ", pushing ", (the) x1, " in";
		26:	print ", taking you along";
		27: print "(first getting off ", (the) x1, ")^"; say__p = 0; return;
		28: print "(first opening ", (the) x1, ")^"; say__p = 0; return;
    }
  Insert: switch (n) {
        1:  "You need to be holding ", (the) x1, " before you can put ", (itorthem) x1,
            " into something else.";
        2:  print_ret (Cthatorthose) x1, " can't contain things.";
        3:  print_ret (The) x1, " ", (isorare) x1, " closed.";
        4:  "You'll need to take ", (itorthem) x1, " off first.";
        5:  "You can't put something inside itself.";
        6:  print "(first taking ", (itorthem) x1, " off)^"; say__p = 0; return;
        7:  "There is no more room in ", (the) x1, ".";
        8:  "Done.";
        9:  "You put ", (the) x1, " into ", (the) second, ".";
       10:  print (The) actor, " puts ", (the) x1, " into ", (the) second, ".^";
    }
  Inv: switch (n) {
        1:  "You are carrying nothing.";
        2:  print "You are carrying";
        3:  print ":^";
        4:  print ".^";
        5:	print (The) x1, " looks through ", (HisHerTheir) x1, " possessions.^";
    }
  Jump:     "You jump on the spot, fruitlessly.";
  Kiss:     "Keep your mind on the game.";
  Listen:   "You hear nothing unexpected.";
  ListMiscellany: switch (n) {
        1:  print " (providing light)";
        2:  print " (closed)";
        4:  print " (empty)";
        6:  print " (closed and empty)";
        3:  print " (closed and providing light)";
        5:  print " (empty and providing light)";
        7:  print " (closed, empty and providing light)";
        8:  print " (providing light and being worn";
        9:  print " (providing light";
        10: print " (being worn";
        11: print " (";
        12: print "open";
        13: print "open but empty";
        14: print "closed";
        15: print "closed and locked";
        16: print " and empty";
        17: print " (empty)";
        18: print " containing ";
        19: print " (on ";
        20: print ", on top of ";
        21: print " (in ";
        22: print ", inside ";
    }
  LMode1:   " is now in its normal ~brief~ printing mode, which gives long descriptions
             of places never before visited and short descriptions otherwise.";
  LMode2:   " is now in its ~verbose~ mode, which always gives long descriptions
             of locations (even if you've been there before).";
  LMode3:   " is now in its ~superbrief~ mode, which always gives short descriptions
             of locations (even if you haven't been there before).";
  Lock: switch (n) {
        1:  if (x1 has pluralname) print "They don't "; else print "That doesn't ";
            "seem to be something you can lock.";
        2:  print_ret (ctheyreorthats) x1, " locked at the moment.";
        3:  "First you'll have to close ", (the) x1, ".";
        4:  if (x1 has pluralname) print "Those don't "; else print "That doesn't ";
            "seem to fit the lock.";
        5:  "You lock ", (the) x1, ".";
        6:	print (The) actor, " locks ", (the) x1, ".^";
    }
  Look: switch (n) {
        1:  print " (on ", (the) x1, ")";
        2:  print " (in ", (the) x1, ")";
        3:  print " (as ", (object) x1, ")";
        4:  print "On ", (the) x1, " ";
            WriteListFrom(child(x1),
              ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+TERSE_BIT+CONCEAL_BIT+ISARE_BIT);
            ".";
        5,6:
            if (x1 ~= location) {
                if (x1 has supporter) print "On "; else print "In ";
                print (the) x1, " you";
            }
            else print "You";
            print " can ";
            if (n == 5) print "also ";
            print "see ";
            WriteListFrom(child(x1),
              ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+TERSE_BIT+CONCEAL_BIT+WORKFLAG_BIT);
            if (x1 ~= location) "."; else " here.";
        7:  "You see nothing unexpected in that direction.";
        8:  if (x1 has supporter) print " (on "; else print " (in ";
        	print (the) x1, ")";
		9:	print (The) actor, " looks around.^";
    }
  LookUnder: switch (n) {
        1:  "But it's dark.";
        2:  "You find nothing of interest.";
		3:	print (The) actor, " looks under ", (the) x1, ".^";
    }
  Mild:     "Quite.";
  Miscellany: switch (n) {
        1:  "(considering the first sixteen objects only)^";
        2:  "Nothing to do!";
        3:  print " You have died ";
        4:  print " You have won ";
        5:  print "^Would you like to RESTART, RESTORE a saved game";
            #Ifdef DEATH_MENTION_UNDO;
            print ", UNDO your last move";
            #Endif;
            #ifdef SERIAL_COMMA;
            print ",";
            #endif;
            " or QUIT?";
        6:  "[Your interpreter does not provide ~undo~.  Sorry!]";
            #Ifdef TARGET_ZCODE;
        7:  "~Undo~ failed.  [Not all interpreters provide it.]";
            #Ifnot; ! TARGET_GLULX
        7:  "[You cannot ~undo~ any further.]";
            #Endif; ! TARGET_
        8:  "Please give one of the answers above.";
        9:  "It is now pitch dark in here!";
        10: "I beg your pardon?";
        11: "[You can't ~undo~ what hasn't been done!]";
        12: "[Can't ~undo~ twice in succession. Sorry!]";
        13: "[Previous turn undone.]";
        14: "Sorry, that can't be corrected.";
        15: "Think nothing of it.";
        16: "~Oops~ can only correct a single word.";
        17: "It is pitch dark, and you can't see a thing.";
        18: print "yourself";
        19: "As good-looking as ever.";
        20: "To repeat a command like ~frog, jump~, just say ~again~, not ~frog, again~.";
        21: "You can hardly repeat that.";
        22: "You can't begin with a comma.";
        23: "You seem to want to talk to someone, but I can't see whom.";
        24: "You can't talk to ", (the) x1, ".";
        25: "To talk to someone, try ~someone, hello~ or some such.";
        26: "(first taking ", (the) x1, ")";
        27: "I didn't understand that sentence.";
        28: print "I only understood you as far as wanting to ";
        29: "I didn't understand that number.";
        30: "You can't see any such thing.";
        31: "You seem to have said too little!";
        32: "You aren't holding that!";
        33: "You can't use multiple objects with that verb.";
        34: "You can only use multiple objects once on a line.";
        35: "I'm not sure what ~", (address) pronoun_word, "~ refers to.";
        36: "You excepted something not included anyway!";
        37: "You can only do that to something animate.";
            #Ifdef DIALECT_US;
        38: "That's not a verb I recognize.";
            #Ifnot;
        38: "That's not a verb I recognise.";
            #Endif;
        39: "That's not something you need to refer to in the course of this game.";
        40: "You can't see ~", (address) pronoun_word, "~ (", (the) pronoun_obj,
            ") at the moment.";
        41: "I didn't understand the way that finished.";
        42: if (x1 == 0) print "None"; else print "Only ", (number) x1;
            print " of those ";
            if (x1 == 1) print "is"; else print "are";
            " available.";
        43: "Nothing to do!";
        44: "There are none at all available!";
        45: print "Who do you mean, ";
        46: print "Which do you mean, ";
        47: "Sorry, you can only have one item here. Which exactly?";
        48: print "Whom do you want";
            if (actor ~= player) print " ", (the) actor;
            print " to "; PrintCommand(); print "?^";
        49: print "What do you want";
            if (actor ~= player) print " ", (the) actor;
            print " to "; PrintCommand(); print "?^";
        50: print "Your score has just gone ";
            if (x1 > 0) print "up"; else { x1 = -x1; print "down"; }
            print " by ", (number) x1, " point";
            if (x1 > 1) print "s";
        51: "(Since something dramatic has happened, your list of commands has been cut short.)";
        52: "^Type a number from 1 to ", x1, ", 0 to redisplay or press ENTER.";
        53: "^[Please press SPACE.]";
        54: "[Comment recorded.]";
        55: "[Comment NOT recorded.]";
        56: print ".^";
        57: print "?^";
        58: print (The) actor, " ", (IsOrAre) actor, " unable to do that.^";
		59:	"You must supply a noun.";
		60:	"You may not supply a noun.";
		61:	"You must name an object.";
		62:	"You may not name an object.";
		63:	"You must name a second object.";
		64:	"You may not name a second object.";
		65:	"You must supply a second noun.";
		66:	"You may not supply a second noun.";
		67:	"You must name something more substantial.";
		68:	print "(", (The) actor, " first taking ", (the) x1, ")^";
        69: "(first taking ", (the) x1, ")";
        70: "The use of UNDO is forbidden in this game.";
        71: print (string) DARKNESS__TX;
  		72: print (The) x1;
            if (x1 has pluralname) print " have"; else print " has";
            " better things to do.";
        73: "That noun did not make sense in this context.";
        74: print "[That command asks to do something outside of play, so it can
        	only make sense from you to me. ", (The) x1, " cannot be asked to do this.]^";
        75:  print " The End ";
    }
  No,Yes:   "That was a rhetorical question.";
  NotifyOff:
            "Score notification off.";
  NotifyOn: "Score notification on.";
  Open: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can open.";
        2:  if (x1 has pluralname) print "They seem "; else print "It seems ";
            "to be locked.";
        3:  print_ret (ctheyreorthats) x1, " already open.";
        4:  print "You open ", (the) x1, ", revealing ";
            if (WriteListFrom(child(x1), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT) == 0) "nothing.";
            ".";
        5:  "You open ", (the) x1, ".";
		6:	print (The) actor, " opens ", (the) x1, ".^";
		7:	print (The) x1, " open";
			if (x1 hasnt pluralname) print "s";
			print ".^";
    }
  Pronouns: switch (n) {
        1:  print "At the moment, ";
        2:  print "means ";
        3:  print "is unset";
        4:  "no pronouns are known to the game.";
        5:  ".";
    }
  Pull,Push,Turn: switch (n) {
        1:  if (x1 has pluralname) print "Those are "; else print "It is ";
            "fixed in place.";
        2:  "You are unable to.";
        3:  "Nothing obvious happens.";
        4:  "That would be less than courteous.";
		5:	print (The) actor, " pulls ", (the) x1, ".^";
		6:	print (The) actor, " pushes ", (the) x1, ".^";
		7:	print (The) actor, " turns ", (the) x1, ".^";
    }
! Push: see Pull
  PushDir: switch (n) {
        1:  print (The) x1, " cannot be pushed from place to place.^";
        2:  "That's not a direction.";
        3:  "Not that way you can't.";
    }
  PutOn: switch (n) {
        1:  "You need to be holding ", (the) x1, " before you can put ",
                (itorthem) x1, " on top of something else.";
        2:  "You can't put something on top of itself.";
        3:  "Putting things on ", (the) x1, " would achieve nothing.";
        4:  "You lack the dexterity.";
        5:  print "(first taking ", (itorthem) x1, " off)^"; say__p = 0; return;
        6:  "There is no more room on ", (the) x1, ".";
        7:  "Done.";
        8:  "You put ", (the) x1, " on ", (the) second, ".";
        9:  print (The) actor, " puts ", (the) x1, " on ", (the) second, ".^";
    }
  Quit: switch (n) {
        1:  print "Please answer yes or no.";
        2:  print "Are you sure you want to quit? ";
    }
  Remove: switch (n) {
        1:  if (x1 has pluralname) print "They are"; else print "It is";
            " unfortunately closed.";
        2:  if (x1 has pluralname) print "But they aren't"; else print "But it isn't";
            " there now.";
        3:  "Removed.";
    }
  Restart: switch (n) {
        1:  print "Are you sure you want to restart? ";
        2:  "Failed.";
    }
  Restore: switch (n) {
        1:  "Restore failed.";
        2:  "Ok.";
    }
  Rub:      "You achieve nothing by this.";
  Save: switch (n) {
        1:  "Save failed.";
        2:  "Ok.";
    }
  Score: switch (n) {
        1:  if (deadflag) print "In that game you scored "; else print "You have so far scored ";
            print score, " out of a possible ", MAX_SCORE, ", in ", turns, " turn";
            if (turns ~= 1) print "s";
            return;
        2:  "There is no score in this story.";
        3:	print ", earning you the rank of ";
    }
  ScriptOff: switch (n) {
        1:  "Transcripting is already off.";
        2:  "^End of transcript.";
        3:  "Attempt to end transcript failed.";
    }
  ScriptOn: switch (n) {
        1:  "Transcripting is already on.";
        2:  "Start of a transcript of";
        3:  "Attempt to begin transcript failed.";
    }
  Search: switch (n) {
        1:  "But it's dark.";
        2:  "There is nothing on ", (the) x1, ".";
        3:  print "On ", (the) x1, " ";
            WriteListFrom(child(x1), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT+ISARE_BIT);
            ".";
        4:  "You find nothing of interest.";
        5:  "You can't see inside, since ", (the) x1, " ", (isorare) x1, " closed.";
        6:  print_ret (The) x1, " ", (isorare) x1, " empty.";
        7:  print "In ", (the) x1, " ";
            WriteListFrom(child(x1), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT+ISARE_BIT);
            ".";
		8:	print (The) actor, " searches ", (the) x1, ".^";
    }
  SetTo:    "No, you can't set ", (thatorthose) x1, " to anything.";
  Show: switch (n) {
        1:  "You aren't holding ", (the) x1, ".";
        2:  print_ret (The) x1, " ", (isorare) x1, " unimpressed.";
    }
  Sing:     "Your singing is abominable.";
  Sleep:    "You aren't feeling especially drowsy.";
  Smell:    "You smell nothing unexpected.";
            #Ifdef DIALECT_US;
  Sorry:    "Oh, don't apologize.";
            #Ifnot;
  Sorry:    "Oh, don't apologise.";
            #Endif;
  Squeeze: switch (n) {
        1:  "Keep your hands to yourself.";
        2:  "You achieve nothing by this.";
		3:	print (The) actor, " squeezes ", (the) x1, ".^";
    }
  Strong:   "Real adventurers do not use such language.";
  Swing:    "There's nothing sensible to swing here.";
  SwitchOff: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can switch.";
        2:  print_ret (ctheyreorthats) x1, " already off.";
        3:  "You switch ", (the) x1, " off.";
		4:	print (The) actor, " switches ", (the) x1, " off.^";
    }
  SwitchOn: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can switch.";
        2:  print_ret (ctheyreorthats) x1, " already on.";
        3:  "You switch ", (the) x1, " on.";
		4:	print (The) actor, " switches ", (the) x1, " on.^";
    }
  Take: switch (n) {
        1:  "Taken.";
        2:  "You are always self-possessed.";
        3:  "I don't suppose ", (the) x1, " would care for that.";
        4:  print "You'd have to get ";
            if (x1 has supporter) print "off "; else print "out of ";
            print_ret (the) x1, " first.";
        5:  "You already have ", (thatorthose) x1, ".";
        6:  if (noun has pluralname) print "Those seem "; else print "That seems ";
            "to belong to ", (the) x1, ".";
        7:  if (noun has pluralname) print "Those seem "; else print "That seems ";
            "to be a part of ", (the) x1, ".";
        8:  print_ret (Cthatorthose) x1, " ", (isorare) x1,
            "n't available.";
        9:  print_ret (The) x1, " ", (isorare) x1, "n't open.";
        10: if (x1 has pluralname) print "They're "; else print "That's ";
            "hardly portable.";
        11: if (x1 has pluralname) print "They're "; else print "That's ";
            "fixed in place.";
        12: "You're carrying too many things already.";
        13: print "(putting ", (the) x1, " into ", (the) SACK_OBJECT,
            " to make room)^"; say__p = 0; return;
        14: "You can't reach into ", (the) x1, ".";
        15: "You cannot carry ", (the) x1, ".";
        16: print (The) actor, " picks up ", (the) x1, ".^";
    }
  Taste:    "You taste nothing unexpected.";
  Tell: switch (n) {
        1:  "You talk to yourself a while.";
        2:  "This provokes no reaction.";
    }
  Think:    "What a good idea.";
  ThrowAt: switch (n) {
        1:  "Futile.";
        2:  "You lack the nerve when it comes to the crucial moment.";
    }
  Tie:		"You would achieve nothing by this.";
  Touch: switch (n) {
        1:  "Keep your hands to yourself!";
        2:  "You feel nothing unexpected.";
        3:  "If you think that'll help.";
		4:	print (The) actor, " touches ", (himheritself) x1, ".^";
		5:	print (The) actor, " touches you.^";
		6:	print (The) actor, " touches ", (the) x1, ".^";
    }
! Turn: see Pull.
  Unlock:  switch (n) {
        1:  if (x1 has pluralname) print "They don't "; else print "That doesn't ";
            "seem to be something you can unlock.";
        2:  print_ret (ctheyreorthats) x1, " unlocked at the moment.";
        3:  if (x1 has pluralname) print "Those don't "; else print "That doesn't ";
            "seem to fit the lock.";
        4:  "You unlock ", (the) x1, ".";
        5:	print (The) actor, " unlocks ", (the) x1, ".^";
    }
  Verify: switch (n) {
        1:  "The game file has verified as intact.";
        2:  "The game file did not verify as intact, and may be corrupt.";
    }
  Wait: switch (n) {
        1:  "Time passes.";
        2:	print (The) actor, " waits.^";
    }
  Wake:     "The dreadful truth is, this is not a dream.";
  WakeOther:"That seems unnecessary.";
  Wave: switch (n) {
        1:  "But you aren't holding ", (thatorthose) x1, ".";
        2:  "You look ridiculous waving ", (the) x1, ".";
		3:	print (The) actor, " waves ", (the) x1, ".^";
    }
  WaveHands:"You wave, feeling foolish.";
  Wear: switch (n) {
        1:  "You can't wear ", (thatorthose) x1, "!";
        2:  "You're not holding ", (thatorthose) x1, "!";
        3:  "You're already wearing ", (thatorthose) x1, "!";
        4:  "You put on ", (the) x1, ".";
		5:	print (The) actor, " puts on ", (the) x1, ".^";
    }
! Yes:  see No.
];

[ L__M act n x1 x2 rv flag;
    @push sw__var;
    sw__var = act;
    if (n == 0) n = 1;
    @push action;
    lm_act = act;
    lm_n = n;
    lm_o = x1;
    lm_o2 = x2;
    switch (act) {
    	##Miscellany: rv =  ((((PHR_716_r0 ())))) ;
    	##ListMiscellany: rv =  ((((PHR_717_r1 ())))) ;
    	default: rv =  ((((PHR_718_r2 ())))) ;
    }
    action = sw__var;
    if (rv == false) rv = RunRoutines(LibraryMessages, before);
    @pull action;
    if (rv == false) LanguageLM(n, x1, x2);
    @pull sw__var;
];


Default LanguageCases 1;
#Ifndef LibraryMessages; Object LibraryMessages; #Endif;

Object thedark "(darkness object)";

[ OffersLight obj j;
    while (obj) {
		if (obj has light) rtrue;
		objectloop (j in obj) if (HasLightSource(j)) rtrue;
		if ((obj has container) && (obj hasnt open) && (obj hasnt transparent)) rfalse;
		if ((obj provides component_parent) && (obj.component_parent))
			obj = obj.component_parent;
		else
			obj = parent(obj);
	}
    rfalse;
];

[ HasLightSource i j ad sr po;
	if (i == 0) rfalse;
    if (i has light) rtrue;
    if ((IsSeeThrough(i)) && (~~(HidesLightSource(i))))
        objectloop (j in i)
            if (HasLightSource(j)) rtrue;
    ad = i.&add_to_scope;
    if (parent(i) ~= 0 && ad ~= 0) {
        if (metaclass(ad-->0) == Routine) {
            ats_hls = 0; ats_flag = 1;
            sr = scope_reason; po = parser_one;
            scope_reason = LOOPOVERSCOPE_REASON; parser_one = 0;
            RunRoutines(i, add_to_scope);
            scope_reason = sr; parser_one = po;
            ats_flag = 0; if (ats_hls == 1) rtrue;
        }
        else {
            for (j=0 : (WORDSIZE*j)<i.#add_to_scope : j++)
                if ((ad-->j) && (HasLightSource(ad-->j) == 1)) rtrue;
        }
    }
    if (ComponentHasLight(i)) rtrue;
    rfalse;
];

[ ComponentHasLight o obj next_obj;
	if (o provides component_child) {
		obj = o.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if (obj has light) rtrue;
			if (HasLightSource(obj)) rtrue;
			if ((obj provides component_child) && (ComponentHasLight(obj))) rtrue;
			obj = next_obj;
		}
	}
	rfalse;
];

[ HidesLightSource obj;
    if (obj == player) rfalse;
    if (obj has transparent or supporter) rfalse;
    if (obj has animate) rfalse;
    if (obj has container) return (obj hasnt open);
    return (obj hasnt enterable);
];

Global lightflag = false;

[ ADJUST_LIGHT_R previous_light_condition;
    previous_light_condition = lightflag;
    lightflag = OffersLight(parent(player));

    if ((previous_light_condition == false) && (lightflag == false)) {
    	location = thedark;
    	rfalse;
    }

    if ((previous_light_condition == false) && (lightflag == true)) {
        location = real_location;
        CarryOutActivity(PRINTING_NEWS_OF_LIGHT_ACT);
        rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == false)) {
        location = thedark;
		DivideParagraphPoint();
		BeginActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		if (ForActivity(PRINTING_NEWS_OF_DARKNESS_ACT) == false) L__M(##Miscellany, 9);
		EndActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == true)) {
    	location = real_location;
    	rfalse;
    }

    rfalse;
];

[ SilentlyConsiderLight;
    lightflag = OffersLight(parent(player));
	if (lightflag) location = real_location; else location = thedark;
	rfalse;
];

[ IsSeeThrough obj;
    if ((obj has supporter)
    	|| (obj has transparent)
    	|| (obj has animate)
    	|| ((obj has container) && (obj has open)))
        rtrue;
   rfalse;
];

[ VisibilityParent o;
    if (o && (o has container) && (o hasnt open) && (o hasnt transparent)) return nothing;
	if (o) o = CoreOfParentOfCoreOf(o);
    return o;
];

[ FindVisibilityLevels lc up;
	if (location == thedark) {
		visibility_ceiling = thedark;
		visibility_levels = 0;	
	} else {
		visibility_ceiling = player;
		while (true) {
			up = VisibilityParent(visibility_ceiling);
			if (up == 0) break;
			visibility_ceiling = up;
			lc++;
		}
		visibility_levels = lc;
	}
];

[ ScopeCeiling pos c;
	if (pos == player && location == thedark) return thedark;
	c = parent(pos);
	if (c == 0) return pos;
	while (VisibilityParent(c)) c = VisibilityParent(c);
	return c;
];

[ ObjectIsUntouchable item silent_flag flag2 p save_sp decision;
	if ((p ~= player) && (LocationOf(p) ~= LocationOf(player)) &&
		((item ofclass K4_door) || (item ofclass K7_backdrop))) {
		decision = false;
	} else {
		untouchable_object = item; untouchable_silence = silent_flag;
		touch_persona = p; if (p == actor) touch_persona = 0;
		save_sp = say__p; say__p = 0;
		if (ProcessRulebook(ACCESSIBILITY_RB, 0, true)) {
			if (RulebookSucceeded()) decision = false;
			else decision = true;
		} else decision = false;
		if (say__p == false) say__p = save_sp;
	}
	untouchable_silence = 0;
	return decision;
];

[ ACCESS_THROUGH_BARRIERS_R ancestor i j external p;
	p = touch_persona; if (p == 0) p = actor;

	ancestor = CommonAncestor(p, untouchable_object);
	if ((ancestor == 0) && (LocationOf(untouchable_object) == nothing)
		&& ((untouchable_object ofclass K4_door or K7_backdrop) == false)) {
		if (touch_persona == 0) GL__M(##Take,8,untouchable_object);
		RulebookFails();
		rtrue;
	}

	! First, a barrier between the player and the ancestor.

	if (CoreOf(p) ~= ancestor) {
		i = parent(CoreOf(p)); j = CoreOf(i); external = false;
		if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false)
				&& (ProcessRulebook(REACHING_OUTSIDE_RB, i))
				&& (RulebookFailed())) rtrue; ! Barrier
			i = parent(CoreOf(i)); j = CoreOf(i); external = false;
			if (j ~= i) { i = j; external = true; }
		}
	}

	! Second, a barrier between the item and the ancestor.

	if (CoreOf(untouchable_object) ~= ancestor) {
		! We can always get to the core of the item.
		i = CoreOf(untouchable_object);
		! This will be on the inside of its parent, if its parent is a
		! container, so there should be no exemption.
		i = parent(i); external = false;
		! j = CoreOf(i); if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false) &&
				(ProcessRulebook(REACHING_INSIDE_RB, i)) &&
				(RulebookFailed())) rtrue; ! Barrier
			i = CoreOf(i);
			if (i == ancestor) break;
			i = parent(i); j = CoreOf(i); external = false;
			if (j ~= i) { i = j; external = true; }
		}
	}

	RulebookSucceeds(); ! No barrier
	rtrue;
];

[ CANT_REACH_INSIDE_CLOSED_R;
	if (parameter_object has container && parameter_object hasnt open) {
		if (touch_persona == 0) GL__M(##Take,9,parameter_object);
		RulebookFails(); rtrue;
	}
	rfalse;
];

[ CANT_REACH_OUTSIDE_CLOSED_R;
	if (parameter_object has container && parameter_object hasnt open) {
		if (touch_persona == 0) GL__M(##Take,9,parameter_object);
		RulebookFails(); rtrue;
	}
	rfalse;
];

[ CANT_REACH_INSIDE_ROOMS_R;
	if (parameter_object && parameter_object ofclass K1_room) {
		if (touch_persona == 0) GL__M(##Take,14,parameter_object);
		RulebookFails(); rtrue;
	}
	rfalse;
];


Constant REQUISITION_STACK_SIZE = 3*216;
Array requisition_stack --> REQUISITION_STACK_SIZE;
Global requisition_stack_pointer = 0;

[ RequisitionStack len top addr;
	top = requisition_stack_pointer + len;
	if (top > REQUISITION_STACK_SIZE) return false;
	addr = requisition_stack + requisition_stack_pointer*WORDSIZE;
	! print "Allocating ", addr, " at pointer ", requisition_stack_pointer, "^";
	requisition_stack_pointer = top;
	return addr;
];

[ FreeStack addr;
	if (addr == 0) return;
	requisition_stack_pointer = (addr - requisition_stack)/WORDSIZE;
];

Global MarkedObjectArray = 0;
Global MarkedObjectLength = 0;

[ WriteListOfMarkedObjects style
	obj common_parent first mixed_parentage length;

	objectloop (obj ofclass Object && obj has workflag2) {
		length++;
		if (first == nothing) { first = obj; common_parent = parent(obj); }
		else { if (parent(obj) ~= common_parent) mixed_parentage = true; }
	}
	if (mixed_parentage) common_parent = nothing;

	if (length == 0) print (string) NOTHING__TX;
	else {
		@push MarkedObjectArray; @push MarkedObjectLength;
		MarkedObjectArray = RequisitionStack(length);
		MarkedObjectLength = length;
		if (MarkedObjectArray == 0) return RunTimeProblem(RTP_LISTWRITERMEMORY); 

		if (common_parent) {
			ObjectTreeCoalesce(child(common_parent));
			length = 0;
			objectloop (obj in common_parent) ! object tree order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		} else {
			length = 0;
			objectloop (obj ofclass Object) ! object number order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		}

		WriteListFrom(first, style, 0, false, MarkedListIterator);

		FreeStack(MarkedObjectArray);
		@pull MarkedObjectLength; @pull MarkedObjectArray;
	}
	return;
];

Constant SEEK_ITF = 0;
Constant ADVANCE_ITF = 1;
Constant COALESCE_ITF = 2;
Constant START_ITF = 3;

! Constant DBLW; ! Uncomment this to provide debugging information at run-time

[ MarkedListIterator obj depth required_lt function i;
    if (obj == nothing) return nothing;
    switch(function) {
    	START_ITF: return MarkedObjectArray-->0;
    	COALESCE_ITF: return MarkedListCoalesce();
    	SEEK_ITF, ADVANCE_ITF:
			for (i=0: i<MarkedObjectLength: i++)
				if (MarkedObjectArray-->i == obj) {
					if (function == ADVANCE_ITF) i++;
					for (:i<MarkedObjectLength: i++) {
						obj = MarkedObjectArray-->i;
						if ((required_lt) && (obj.list_together ~= required_lt)) continue;
						if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag))
							continue;
						if ((c_style & CONCEAL_BIT) &&
							((obj has concealed) || (obj has scenery))) continue;
						return obj;
					}
					return nothing;
				}
	}
	return nothing;
];

[ MarkedListCoalesce o i lt l swap m;
	for (i=0: i<MarkedObjectLength: i++) {
		lt = (MarkedObjectArray-->i).list_together;
		if (lt ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (i++: (i<MarkedObjectLength)&&((MarkedObjectArray-->i).list_together==lt): i++) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (i == MarkedObjectLength) return MarkedObjectArray-->0;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (l=i+1: l<MarkedObjectLength: l++)
				if ((MarkedObjectArray-->l).list_together == lt) {
					! Yes, they do: so we perform a rotation to insert it before element i:
					swap = MarkedObjectArray-->l;
					for (m=l: m>i: m--) MarkedObjectArray-->m = MarkedObjectArray-->(m-1);
					MarkedObjectArray-->i = swap;
					! And now the run is longer:
					i++;
					if (i == MarkedObjectLength) return MarkedObjectArray-->0;
				}
			i--;
		}
	}
	return MarkedObjectArray-->0;
];

Global list_filter_routine;

[ ObjectTreeIterator obj depth required_lt function;
    if ((obj == nothing) || (parent(obj) == nothing)) return nothing;
	if (function == START_ITF) return child(parent(obj));
	if (function == COALESCE_ITF) return ObjectTreeCoalesce(obj);
    if (function == ADVANCE_ITF) obj = sibling(obj);
    for (:: obj = sibling(obj)) {
        if (obj == nothing) return nothing;
		if ((required_lt) && (obj.list_together ~= required_lt)) continue;
		if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag)) continue;
		if (obj hasnt list_filter_permits) continue;
		if ((c_style & CONCEAL_BIT) &&
			((obj has concealed) || (obj has scenery))) continue;
		return obj;
    }
];

[ ObjectTreeCoalesce obj memb lt later;
	#Ifdef DBLW; print "^^Sorting out: "; DiagnoseSortList(obj); #Endif;
	.StartAgain;
	for (memb=obj: memb~=nothing: memb=sibling(memb)) {
		lt = memb.list_together;
		if (lt ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (memb=sibling(memb): (memb) && (memb.list_together == lt): memb = sibling(memb)) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (memb == 0) return obj;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (later=sibling(memb): later: later=sibling(later))
				if (later.list_together == lt) {
					! Yes, they do: so we perform a regrouping of the list and start again:
					obj = GroupChildren(parent(obj), list_together, lt);
					#Ifdef DBLW; print "^^Sorted to: "; DiagnoseSortList(obj); #Endif;
					jump StartAgain;
				}
		}
	}
	return obj;
];
#Ifdef DBLW;
[ DiagnoseSortList obj memb;
    for (memb=child(obj): memb~=nothing: memb=sibling(memb)) print memb, " --> "; new_line;
];
#Endif;

[ WriteListFrom first style depth noactivity iter a ol;
	@push c_iterator; @push c_style; @push c_depth; @push c_margin;
    if (iter) c_iterator = iter; else c_iterator = ObjectTreeIterator;
    c_style = style; c_depth = depth;
	c_margin = 0; if (style & EXTRAINDENT_BIT) c_margin = 1;

	objectloop (a ofclass Object) {
		give a list_filter_permits;
		if ((list_filter_routine) && (list_filter_routine(a) == false))
			give a ~list_filter_permits;
	}

    first = c_iterator(first, depth, 0, START_ITF);
	if (first == nothing) {
        print (string) NOTHING__TX;
        if (style & NEWLINE_BIT ~= 0) new_line;
    } else {
		if ((noactivity) || (iter)) {
			WriteListR(first, c_depth, true);
			say__p = 1;
		} else {
			objectloop (ol provides list_together) ol.list_together = 0;
			CarryOutActivity(LISTING_CONTENTS_ACT, parent(first));
		}
	}

    @pull c_margin; @pull c_depth; @pull c_style; @pull c_iterator;
];

[ STANDARD_CONTENTS_LISTING_R;
	WriteListFrom(child(parameter_object), c_style, c_depth, true);
];

#Ifdef DBLW;
Global DBLW_no_classes; Global DBLW_no_objs;
[ DebugPartition partition_class_sizes partition_classes first depth i k o;
	print "[Length of list is ", DBLW_no_objs, " with ", k, " plural.]^";
	print "[Partitioned into ", DBLW_no_classes, " equivalence classes.]^";
    for (i=1: i<=DBLW_no_classes : i++) {
    	print "Class ", i, " has size ", partition_class_sizes->i, "^";
	}
	for (k=0, o=first: k<DBLW_no_objs : k++, o = c_iterator(o, depth, lt_value, ADVANCE_ITF)) {
    	print "Entry ", k, " has class ", partition_classes->k,
    		" represented by ", o, " with L=", o.list_together, "^";
	}
];
#Endif;

[ PartitionList first no_objs depth partition_classes partition_class_sizes
	i k l n m;
    for (i=0: i<no_objs: i++) partition_classes->i = 0;
    n = 1;
    for (i=first, k=0: k<no_objs: i=c_iterator(i, depth, lt_value, ADVANCE_ITF), k++)
        if (partition_classes->k == 0) {
            partition_classes->k = n; partition_class_sizes->n = 1;
            for (l=c_iterator(i, depth, lt_value, ADVANCE_ITF), m=k+1:
            	(l~=0) && (m<no_objs):
            	l=c_iterator(l, depth, lt_value, ADVANCE_ITF), m++) {
                if ((partition_classes->m == 0) && (ListEqual(i, l))) {
                    if (partition_class_sizes->n < 255) (partition_class_sizes->n)++;
                    partition_classes->m = n;
                }
            }
            if (n < 255) n++;
        }
    n--;
	#Ifdef DBLW;
	DBLW_no_classes = n; DBLW_no_objs = no_objs;
	DebugPartition(partition_class_sizes, partition_classes, first, depth);
	#Endif;
    return n;
];

[ ListEqual o1 o2;
	if ((o1.plural == 0) || (o2.plural == 0)) rfalse;
 	if (child(o1) ~= 0 && WillRecurs(o1) ~= 0) rfalse;
    if (child(o2) ~= 0 && WillRecurs(o2) ~= 0) rfalse;
    if (c_style & (FULLINV_BIT + PARTINV_BIT) ~= 0) {
        if ((o1 hasnt worn && o2 has worn) || (o2 hasnt worn && o1 has worn)) rfalse;
        if ((o1 hasnt light && o2 has light) || (o2 hasnt light && o1 has light)) rfalse;
        if (o1 has container) {
            if (o2 hasnt container) rfalse;
            if ((o1 has open && o2 hasnt open) || (o2 has open && o1 hasnt open))
                rfalse;
        }
        else if (o2 has container)
            rfalse;
    }
    return Identical(o1, o2);
];

[ WillRecurs o;
    if (c_style & ALWAYS_BIT ~= 0) rtrue;
    if (c_style & RECURSE_BIT == 0) rfalse;
    if ((o has supporter) || ((o has container) && (o has open or transparent))) rtrue;
    rfalse;
];

[ NumberOfGroupsInList o no_classes depth partition_classes partition_class_sizes
	no_groups cl memb k current_lt lt;
	no_groups = no_classes;
    for (cl=1, memb=o, k=0: cl<=no_classes: cl++) {
    	! Advance to first member of class number cl
        while (partition_classes->k ~= cl) {
            k++; memb = c_iterator(memb, depth, lt_value, ADVANCE_ITF);
        }
        if (memb) { ! In case of accidents, but should always happen
        	lt = memb.list_together;
            if ((lt ~= lt_value) && (lt ofclass Routine or String) && (lt == current_lt))
            	no_groups--;
            current_lt = lt;
        }
    }
 	#Ifdef DBLW; print "[There are ", no_groups, " groups.]^"; #Endif;
	return no_groups;
];

[ WriteListR o depth from_start
	partition_classes partition_class_sizes
	cl memb index k2 l m no_classes q groups_to_do current_lt;
    if (o == nothing) return; ! An empty list: no output

    if (from_start) {
    	o = c_iterator(o, depth, 0, COALESCE_ITF); ! Coalesce list and choose new start
	}
    o = c_iterator(o, depth, 0, SEEK_ITF); ! Find first entry in list from o
    if (o == nothing) return;

	! Count index = length of list
    for (memb=o, index=0: memb: memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF)) index++;

    if (c_style & ISARE_BIT ~= 0) {
        if (index == 1 && o hasnt pluralname) print (string) IS3__TX;
        else                              print (string) ARE3__TX;
        if (c_style & NEWLINE_BIT ~= 0)   print ":^";
        else                              print (char) ' ';
        c_style = c_style - ISARE_BIT;
    }

    partition_classes = RequisitionStack(index/WORDSIZE + 2);
    partition_class_sizes = RequisitionStack(index/WORDSIZE + 2);
    if ((partition_classes == 0) || (partition_class_sizes == 0))
    	return RunTimeProblem(RTP_LISTWRITERMEMORY);

	no_classes =
		PartitionList(o, index, depth, partition_classes, partition_class_sizes);

	groups_to_do =
		NumberOfGroupsInList(o, no_classes, depth, partition_classes, partition_class_sizes);

    for (cl=1, memb=o, index=0, current_lt=0: groups_to_do>0: cl++) {
		! Set memb to first object of partition class cl
        while (partition_classes->index ~= cl) {
        	index++; memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF);
            if (memb==0) { print "*** Error in list-writer ***^"; break; }
        }

    	#Ifdef DBLW;
		! DebugPartition(partition_class_sizes, partition_classes, o, depth);
		print "^[Class ", cl, " of ", no_classes, ": first object ", memb,
			" (", memb.list_together, "); groups_to_do ", groups_to_do, ",
			current_lt=", current_lt, " listing_size=", listing_size,
			" lt_value=", lt_value, " memb.list_together=", memb.list_together, "]^";
    	#Endif;

		if ((memb.list_together == lt_value) ||
        	(~~(memb.list_together ofclass Routine or String))) current_lt = 0;
		else {
            if (memb.list_together == current_lt) continue;
            
            ! Otherwise this class begins a new group
            @push listing_size;
            q = memb; listing_size = 1; l = index; m = cl;
			while (m < no_classes && q.list_together == memb.list_together) {
				m++;
				while (partition_classes->l ~= m) {
					l++; q = c_iterator(q, depth, lt_value, ADVANCE_ITF);
				}
				if (q.list_together == memb.list_together) listing_size++;
			}

			if (listing_size > 1) {
				! The new group contains more than one partition class
				WriteMultiClassGroup(cl, memb, depth, partition_class_sizes);
				current_lt = memb.list_together;
				jump GroupComplete;
			}
			current_lt = 0;
			@pull listing_size;
		}

		WriteSingleClassGroup(cl, memb, depth, partition_class_sizes->cl);

		.GroupComplete;
		groups_to_do--;
        if (c_style & ENGLISH_BIT ~= 0) {
            if (groups_to_do == 1) {
                if (cl <= 1) print (string) LISTAND2__TX;
                else print (string) LISTAND__TX;
            }
            if (groups_to_do > 1) print (string) COMMA__TX;
        }
    }

    FreeStack(partition_class_sizes);
    FreeStack(partition_classes);
]; ! end of WriteListR

[ WriteMultiClassGroup cl memb depth partition_class_sizes q k2 l;
	! Save the style, because the activity below is allowed to change it
	q = c_style;
	if (c_style & INDENT_BIT ~= 0) PrintSpaces(2*(depth+c_margin));

	BeginActivity(GROUPING_TOGETHER_ACT, memb);

	if (ForActivity(GROUPING_TOGETHER_ACT, memb)) {
		c_style = c_style &~ NEWLINE_BIT;
	} else {

		if (memb.list_together ofclass String) {
			! Set k2 to the number of objects covered by the group
			k2 = 0;
			for (l=0 : l<listing_size : l++) k2 = k2 + partition_class_sizes->(l+cl);
			EnglishNumber(k2); print " ";
			print (string) memb.list_together;
			if (c_style & ENGLISH_BIT ~= 0) print " (";
			if (c_style & INDENT_BIT ~= 0)  print ":^";
		} else {
			inventory_stage = 1;
			parser_one = memb; parser_two = depth + c_margin;
			if (RunRoutines(memb, list_together) == 1) jump Omit__Sublist2;
		}

		c_margin++;
		@push lt_value; @push listing_together; @push listing_size;
		
		lt_value = memb.list_together; listing_together = memb;
		#Ifdef DBLW; print "^^DOWN lt_value = ", lt_value, " listing_together = ", memb, "^^";
		@push DBLW_no_classes; @push DBLW_no_objs; #Endif;
		WriteListR(memb, depth, false); 
		#Ifdef DBLW; print "^^UP^^"; @pull DBLW_no_objs; @pull DBLW_no_classes; #Endif;

		@pull listing_size; @pull listing_together; @pull lt_value;
		c_margin--;
		
		if (memb.list_together ofclass String) {
			if (q & ENGLISH_BIT ~= 0) print ")";
		} else {
			inventory_stage = 2;
			parser_one = memb; parser_two = depth+c_margin;
			RunRoutines(memb, list_together);
		}
		.Omit__Sublist2;
	}
  
	EndActivity(GROUPING_TOGETHER_ACT, memb);

	! If the NEWLINE_BIT has been forced by the activity, act now
	! before it vanishes...
	if (q & NEWLINE_BIT ~= 0 && c_style & NEWLINE_BIT == 0) new_line;

	! ...when the original style is restored again:
	c_style = q;
];

[ WriteSingleClassGroup cl memb depth size q;
	q = c_style;
    if (c_style & INDENT_BIT) PrintSpaces(2*(depth+c_margin));
	if (size == 1) {
		if (c_style & NOARTICLE_BIT ~= 0) print (name) memb;
		else {
			if (c_style & DEFART_BIT) {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (The) memb;
				else print (the) memb;
			} else {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (CIndefArt) memb;
				else print (a) memb;
			}
		}
	} else {
		if (c_style & DEFART_BIT) {
			if ((cl == 1) && (c_style & CFIRSTART_BIT)) PrefaceByArticle(memb, 0, size);
			else PrefaceByArticle(memb, 1, size);
		}
		@push listing_size; listing_size = size;
		CarryOutActivity(PRINTING_A_NUMBER_OF_ACT, memb);
		@pull listing_size;
	}
	if ((size > 1) && (memb hasnt pluralname)) {
		give memb pluralname;
		WriteAfterEntry(memb, depth);
		give memb ~pluralname;
	} else WriteAfterEntry(memb, depth);
	c_style = q;
];

[ WriteAfterEntry o depth
    p recurse_flag parenth_flag eldest_child child_count combo;

    inventory_stage = 2;
    if (c_style & PARTINV_BIT) {
        BeginActivity(PRINTING_ROOM_DESC_DETAILS_ACT);
        if (ForActivity(PRINTING_ROOM_DESC_DETAILS_ACT) == false) {

        combo = 0;
        if (o has light && location hasnt light) combo=combo+1;
        if (o has container && o hasnt open)     combo=combo+2;
        if ((o has container && (o has open || o has transparent))
            && (child(o)==0))                    combo=combo+4;
        if (combo) L__M(##ListMiscellany, combo, o);
        }
        EndActivity(PRINTING_ROOM_DESC_DETAILS_ACT);
    }   ! end of PARTINV_BIT processing

    if (c_style & FULLINV_BIT) {
        if (o has light && o has worn) { L__M(##ListMiscellany, 8);     parenth_flag = true; }
        else {
            if (o has light)           { L__M(##ListMiscellany, 9, o);  parenth_flag = true; }
            if (o has worn)            { L__M(##ListMiscellany, 10, o); parenth_flag = true; }
        }

        if (o has container)
            if (o has openable) {
                if (parenth_flag) {
                	#Ifdef SERIAL_COMMA; print ","; #Endif;
                	print (string) AND__TX;
                } else            L__M(##ListMiscellany, 11, o);
                if (o has open)
                    if (child(o)) L__M(##ListMiscellany, 12, o);
                    else          L__M(##ListMiscellany, 13, o);
                else
                    if (o has lockable && o has locked) L__M(##ListMiscellany, 15, o);
                    else                                L__M(##ListMiscellany, 14, o);
                parenth_flag = true;
            }
            else
                if (child(o)==0 && o has transparent)
                    if (parenth_flag) L__M(##ListMiscellany, 16, o);
                    else              L__M(##ListMiscellany, 17, o);

        if (parenth_flag) print ")";
    }   ! end of FULLINV_BIT processing

	child_count = 0;
	eldest_child = nothing;
	objectloop (p in o)
		if ((c_style & CONCEAL_BIT == 0) || (p hasnt concealed && p hasnt scenery))
			if (p has list_filter_permits) {
				child_count++;
				if (eldest_child == nothing) eldest_child = p;
			}

    if (child_count && (c_style & ALWAYS_BIT)) {
        if (c_style & ENGLISH_BIT) L__M(##ListMiscellany, 18, o);
        recurse_flag = true;
    }
    
    if (child_count && (c_style & RECURSE_BIT)) {
        if (o has supporter) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) L__M(##ListMiscellany, 19, o);
                else                     L__M(##ListMiscellany, 20, o);
                if (o has animate)       print (string) WHOM__TX;
                else                     print (string) WHICH__TX;
            }
            recurse_flag = true;
        }
        if (o has container && (o has open || o has transparent)) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) L__M(##ListMiscellany, 21, o);
                else                     L__M(##ListMiscellany, 22, o);
                if (o has animate)       print (string) WHOM__TX;
                else                     print (string) WHICH__TX;
            }
            recurse_flag = true;
        }
    }

    if (recurse_flag && (c_style & ENGLISH_BIT))
        if (child_count > 1 || eldest_child has pluralname) print (string) ARE2__TX;
        else                                                print (string) IS2__TX;

    if (c_style & NEWLINE_BIT) new_line;

    if (recurse_flag) {
        o = child(o);
        @push lt_value; @push listing_together; @push listing_size;
        @push c_iterator;
        c_iterator = ObjectTreeIterator;
        lt_value = 0;   listing_together = 0;   listing_size = 0;
        WriteListR(o, depth+1, true);
        @pull c_iterator;
        @pull listing_size; @pull listing_together; @pull lt_value;
        if (c_style & TERSE_BIT) print ")";
    }
];

[ SayPhraseName closure;
	if (closure == 0) print "nothing";
	else print (string) closure-->2;
];

[ KindAtomic kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return kind;
	return kind-->0;
];

[ KindBaseArity kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return 0;
	return kind-->1;
];

[ KindBaseTerm kind n;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return UNKNOWN_TY;
	return kind-->(2+n);
];

[ DigitToValue c n;
	n = c-'0';
	if ((n<0) || (n>9)) return -1;
	return n;
];

[ GenerateRandomNumber n m s;
	if (n==m) return n;
	if (n>m) { s = n; n = m; m = s; }
	n--;
	return random(m-n) + n;
];
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;

[ GroupChildren par prop value;
    while (child(par) ~= 0) {
        if (child(par).prop ~= value) move child(par) to out_obj;
        else move child(par) to in_obj;
    }
    while (child(in_obj) ~= 0)  move child(in_obj) to par;
    while (child(out_obj) ~= 0) move child(out_obj) to par;
    return child(par);
];

[ PrintSpaces n;
    while (n > 0) {
        print " ";
        n = n - 1;
    }
];

[ RunRoutines obj prop;
    if (obj == thedark) obj = real_location;
    if ((obj.&prop == 0) && (prop >= INDIV_PROP_START)) rfalse;
    return obj.prop();
];

[ SwapWorkflags obj lst;
	objectloop (obj ofclass Object) {
		lst = false;
		if (obj has workflag2) lst = true;
		give obj ~workflag2;
		if (obj has workflag) give obj workflag2;
		give obj ~workflag;
		if (lst) give obj workflag;
	}
];

Constant NO_USE_OPTIONS = 24;
[ TestUseOption UO;
    if (UO == 1) rtrue;
    if (UO == 2) rtrue;
    if (UO == 3) rtrue;
    if (UO == 4) rtrue;
    if (UO == 8) rtrue;
    if (UO == 10) rtrue;
    rfalse;
];
[ PrintUseOption UO;
    switch(UO) {
        0: print "ineffectual option";
        1: print "dynamic memory allocation option [8192]";
        2: print "maximum indexed text length option [1024]";
        3: print "maximum things understood at once option [100]";
        4: print "American dialect option";
        5: print "serial comma option";
        6: print "full-length room descriptions option";
        7: print "abbreviated room descriptions option";
        8: print "memory economy option";
        9: print "authorial modesty option";
        10: print "no scoring option";
        11: print "command line echoing option";
        12: print "undo prevention option";
        13: print "predictable randomisation option";
        14: print "fast route-finding option";
        15: print "slow route-finding option";
        16: print "numbered rules option";
        17: print "telemetry recordings option";
        18: print "no deprecated features option";
        19: print "VERBOSE room descriptions option";
        20: print "BRIEF room descriptions option";
        21: print "SUPERBRIEF room descriptions option";
        22: print "Manual Pronouns option";
        23: print "sequential action option";
    }
];


[ IntegerDivide A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A/B;
];

[ IntegerRemainder A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A%B;
];

[ UnsignedCompare x y u v;
    if (x == y) return 0;
    if (x < 0 && y >= 0) return 1;
    if (x >= 0 && y < 0) return -1;
    u = x&~WORD_HIGHBIT; v= y&~WORD_HIGHBIT;
    if (u > v) return 1;
    return -1;
];

[ ZRegion addr;
    switch (metaclass(addr)) {
		nothing: return 0;
		Object, Class: return 1;
		Routine: return 2;
		String: return 3;
    }
];

[ GL__M a b c d;
	if ((actor ~= player) || (untouchable_silence)) rtrue;
	return L__M(a,b,c,d); ];
[ AGL__M a b c d;
	if (untouchable_silence) rtrue;
	return L__M(a,b,c,d); ];


Object InformParser "(Inform Parser)" has proper;

Global best_etype;                  ! Preferred error number so far
Global nextbest_etype;              ! Preferred one, if ASKSCOPE_PE disallowed

Global parser_inflection;           ! A property (usually "name") to find object names in

Array pattern --> 32;               ! For the current pattern match
Global pcount;                      ! and a marker within it
Array pattern2 --> 32;              ! And another, which stores the best match
Global pcount2;                     ! so far

Array  line_ttype-->32;             ! For storing an analysed grammar line
Array  line_tdata-->32;
Array  line_token-->32;

Global nsns;                        ! Number of special_numbers entered so far

Global params_wanted;               ! Number of parameters needed (which may change in parsing)

Global inferfrom;                   ! The point from which the rest of the command must be inferred
Global inferword;                   ! And the preposition inferred
Global dont_infer;                  ! Another dull flag

Global cobj_flag = 0;

Global oops_from;                   ! The "first mistake" word number
Global saved_oops;                  ! Used in working this out
Array  oops_workspace -> 64;        ! Used temporarily by "oops" routine

Global held_back_mode;              ! Flag: is there some input from last time
Global hb_wn;                       ! left over?  (And a save value for wn.)
                                    ! (Used for full stops and "then".)

Global usual_grammar_after;         ! Point from which usual grammar is parsed (it may vary from
                                    ! the above if user's routines match multi-word verbs)

Constant PATTERN_NULL = $ffff;      ! Entry for a token producing no text

Global found_ttype;                 ! Used to break up tokens into type
Global found_tdata;                 ! and data (by AnalyseToken)
Global token_filter;                ! For noun filtering by user routines

Global length_of_noun;              ! Set by NounDomain to no of words in noun

Global lookahead;                   ! The token after the one now being matched

Global multi_mode;                  ! Multiple mode
Global multi_wanted;                ! Number of things needed in multitude
Global multi_had;                   ! Number of things actually found
Global multi_context;               ! What token the multi-obj was accepted for

Global indef_mode;                  ! "Indefinite" mode - ie, "take a brick"
                                    ! is in this mode
Global indef_type;                  ! Bit-map holding types of specification
Global indef_wanted;                ! Number of items wanted (INDEF_ALL_WANTED for all)
Constant INDEF_ALL_WANTED = 32767;
Global indef_guess_p;               ! Plural-guessing flag
Global indef_owner;                 ! Object which must hold these items
Global indef_cases;                 ! Possible gender and numbers of them
Global indef_possambig;             ! Has a possibly dangerous assumption
                                    ! been made about meaning of a descriptor?
Global indef_nspec_at;              ! Word at which a number like "two" was parsed
                                    ! (for backtracking)
Global allow_plurals;               ! Whether plurals presently allowed or not

Global take_all_rule;               ! Slightly different rules apply to "take all" than other uses
                                    ! of multiple objects, to make adjudication produce more
                                    ! pragmatically useful results
                                    ! (Not a flag: possible values 0, 1, 2)

Global dict_flags_of_noun;          ! Of the noun currently being parsed
                                    ! (a bitmap in #dict_par1 format)
Global pronoun__word;               ! Saved value
Global pronoun__obj;                ! Saved value

Constant comma_word = 'comma,';     ! An "untypeable word" used to substitute
                                    ! for commas in parse buffers

Array  match_list --> MATCH_LIST_WORDS;    ! An array of matched objects so far
Array  match_classes --> MATCH_LIST_WORDS; ! An array of equivalence classes for them
Array  match_scores --> MATCH_LIST_WORDS;  ! An array of match scores for them
Global number_matched;              ! How many items in it?  (0 means none)
Global number_of_classes;           ! How many equivalence classes?
Global match_length;                ! How many words long are these matches?
Global match_from;                  ! At what word of the input do they begin?

#Ifdef TARGET_ZCODE;
[ WordCount; return parse->1; ];
[ WordAddress wordnum; return buffer + parse->(wordnum*4+1); ];
[ WordLength wordnum; return parse->(wordnum*4); ];
[ MoveWord at1 b2 at2 x y;
    x = at1*2-1; y = at2*2-1;
    parse-->x++ = b2-->y++;
    parse-->x = b2-->y;
];
#Ifnot;
[ WordCount; return parse-->0; ];
[ WordAddress wordnum; return buffer + parse-->(wordnum*3); ];
[ WordLength wordnum; return parse-->(wordnum*3-1); ];
[ MoveWord at1 b2 at2 x y;
    x = at1*3-2; y = at2*3-2;
    parse-->x++ = b2-->y++;
    parse-->x++ = b2-->y++;
    parse-->x = b2-->y;
];
#Endif;

[ NextWord i j wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; i = wn*2-1;
	#Ifnot; wc = parse-->0; i = wn*3-2; #Endif;
    wn++;
    if ((wn < 2) || (wn > wc+1)) return 0;
    j = parse-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWordStopped wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; #Ifnot; wc = parse-->0; #Endif;
	if ((wn < 1) || (wn > wc)) { wn++; return -1; }
    return NextWord();
];

[ PrintSnippet snip from to i w1 w2;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1) || (w2>WordCount())) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_SAYINVALIDSNIPPET, w1, w2);
	}
	from = WordAddress(w1); to = WordAddress(w2) + WordLength(w2) - 1;
	for (i=from: i<=to: i++) print (char) i->0;
];

[ SpliceSnippet snip t i w1 w2 nextw at endsnippet newlen;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) return;
		return RunTimeProblem(RTP_SPLICEINVALIDSNIPPET, w1, w2);
	}
	@push say__p; @push say__pc;
	nextw = w2 + 1;
	at = WordAddress(w1) - buffer;
	if (nextw <= WordCount()) endsnippet = 100*nextw + (WordCount() - nextw + 1);
	buffer2-->0 = 120;
	newlen = VM_PrintToBuffer(buffer2, 120, SpliceSnippet__TextPrinter, t, endsnippet);
	for (i=0: (i<newlen) && (at+i<120): i++) buffer->(at+i) = buffer2->(WORDSIZE+i);
	#Ifdef TARGET_ZCODE; buffer->1 = at+i; #ifnot; buffer-->0 = at+i; #endif;
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount();
	@pull say__pc; @pull say__p;
];

[ SpliceSnippet__TextPrinter t endsnippet;
	PrintText(t);
	if (endsnippet) { print " "; PrintSnippet(endsnippet); }
];

[ SnippetIncludes test snippet w1 w2 wlen i j;
	w1 = snippet/100; w2 = w1 + (snippet%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_INCLUDEINVALIDSNIPPET, w1, w2);
	}
	if (metaclass(test) == Routine) {
		wlen = snippet%100;
		for (i=w1, j=wlen: j>0: i++, j--) {
			if (((test)(i, 0)) ~= GPR_FAIL) return i*100+wn-i;
		}
	}
	rfalse;
];

[ SnippetMatches snippet topic_gpr rv;
	wn=1;
	if (topic_gpr == 0) rfalse;
	if (metaclass(topic_gpr) == Routine) {
		rv = (topic_gpr)(snippet/100, snippet%100);
		if (rv ~= GPR_FAIL) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_BADTOPIC);
	rfalse;
];

[ UnpackGrammarLine line_address i size;
    for (i=0 : i<32 : i++) {
        line_token-->i = ENDIT_TOKEN;
        line_ttype-->i = ELEMENTARY_TT;
        line_tdata-->i = ENDIT_TOKEN;
    }
#Ifdef TARGET_ZCODE;
    action_to_be = 256*(line_address->0) + line_address->1;
    action_reversed = ((action_to_be & $400) ~= 0);
    action_to_be = action_to_be & $3ff;
    line_address--;
    size = 3;
#Ifnot; ! GLULX
    @aloads line_address 0 action_to_be;
    action_reversed = (((line_address->2) & 1) ~= 0);
    line_address = line_address - 2;
    size = 5;
#Endif;
    params_wanted = 0;
    for (i=0 : : i++) {
        line_address = line_address + size;
        if (line_address->0 == ENDIT_TOKEN) break;
        line_token-->i = line_address;
        AnalyseToken(line_address);
        if (found_ttype ~= PREPOSITION_TT) params_wanted++;
        line_ttype-->i = found_ttype;
        line_tdata-->i = found_tdata;
    }
    return line_address + 1;
];

[ AnalyseToken token;
    if (token == ENDIT_TOKEN) {
        found_ttype = ELEMENTARY_TT;
        found_tdata = ENDIT_TOKEN;
        return;
    }
    found_ttype = (token->0) & $$1111;
    found_tdata = (token+1)-->0;
];

[ DictionaryWordToVerbNum dword verbnum;
#Ifdef TARGET_ZCODE;
	verbnum = $ff-(dword->#dict_par2);
#Ifnot; ! GLULX
	dword = dword + #dict_par2 - 1;
    @aloads dword 0 verbnum;
    verbnum = $ffff-verbnum;
#Endif;
	return verbnum;
];

[ KeyboardPrimitive a_buffer a_table;
#Ifdef DEBUG; #Iftrue (0 > 0);
	return TestKeyboardPrimitive(a_buffer, a_table);
#Endif; #Endif;
	return VM_ReadKeyboard(a_buffer, a_table);
];

[ Keyboard  a_buffer a_table  nw i w w2 x1 x2;
	sline1 = score; sline2 = turns;

	while (true) {
		! Save the start of the buffer, in case "oops" needs to restore it
		for (i=0 : i<64 : i++) oops_workspace->i = a_buffer->i;
	
		! In case of an array entry corruption that shouldn't happen, but would be
		! disastrous if it did:
		#Ifdef TARGET_ZCODE;
		a_buffer->0 = INPUT_BUFFER_LEN;
		a_table->0 = 15;  ! Allow to split input into this many words
		#Endif; ! TARGET_
	
		! Print the prompt, and read in the words and dictionary addresses
		PrintPrompt();
		DrawStatusLine();
		KeyboardPrimitive(a_buffer, a_table);
	
		! Set nw to the number of words
		#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
	
		! If the line was blank, get a fresh line
		if (nw == 0) {
			@push etype; etype = BLANKLINE_PE;
			players_command = 100;
			BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
			if (ForActivity(PRINTING_A_PARSER_ERROR_ACT) == false) L__M(##Miscellany,10);
			EndActivity(PRINTING_A_PARSER_ERROR_ACT);
			@pull etype;
			continue;
		}
	
		! Unless the opening word was OOPS, return
		! Conveniently, a_table-->1 is the first word on both the Z-machine and Glulx
	
		w = a_table-->1;
		if (w == OOPS1__WD or OOPS2__WD or OOPS3__WD) {
			if (oops_from == 0) { L__M(##Miscellany, 14); continue; }
			if (nw == 1) { L__M(##Miscellany, 15); continue; }
			if (nw > 2) { L__M(##Miscellany, 16); continue; }
		
			! So now we know: there was a previous mistake, and the player has
			! attempted to correct a single word of it.
		
			for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer2->i = a_buffer->i;
			#Ifdef TARGET_ZCODE;
			x1 = a_table->9;  ! Start of word following "oops"
			x2 = a_table->8;  ! Length of word following "oops"
			#Ifnot; ! TARGET_GLULX
			x1 = a_table-->6; ! Start of word following "oops"
			x2 = a_table-->5; ! Length of word following "oops"
			#Endif; ! TARGET_
		
			! Repair the buffer to the text that was in it before the "oops"
			! was typed:
			for (i=0 : i<64 : i++) a_buffer->i = oops_workspace->i;
			VM_Tokenise(a_buffer,a_table);
		
			! Work out the position in the buffer of the word to be corrected:
			#Ifdef TARGET_ZCODE;
			w = a_table->(4*oops_from + 1); ! Start of word to go
			w2 = a_table->(4*oops_from);    ! Length of word to go
			#Ifnot; ! TARGET_GLULX
			w = a_table-->(3*oops_from);      ! Start of word to go
			w2 = a_table-->(3*oops_from - 1); ! Length of word to go
			#Endif; ! TARGET_
		
			! Write spaces over the word to be corrected:
			for (i=0 : i<w2 : i++) a_buffer->(i+w) = ' ';
		
			if (w2 < x2) {
				! If the replacement is longer than the original, move up...
				for (i=INPUT_BUFFER_LEN-1 : i>=w+x2 : i--)
					a_buffer->i = a_buffer->(i-x2+w2);
		
				! ...increasing buffer size accordingly.
				#Ifdef TARGET_ZCODE;
				a_buffer->1 = (a_buffer->1) + (x2-w2);
				#Ifnot; ! TARGET_GLULX
				a_buffer-->0 = (a_buffer-->0) + (x2-w2);
				#Endif; ! TARGET_
			}
		
			! Write the correction in:
			for (i=0 : i<x2 : i++) a_buffer->(i+w) = buffer2->(i+x1);
		
			VM_Tokenise(a_buffer, a_table);
			#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
		
			return nw;
		}

		! Undo handling
	
		if ((w == UNDO1__WD or UNDO2__WD or UNDO3__WD) && (nw==1)) {
			Perform_Undo();
			continue;
		}
		i = VM_Save_Undo();
		#ifdef PREVENT_UNDO; undo_flag = 0; #endif;
		#ifndef PREVENT_UNDO; undo_flag = 2; #endif;
		if (i == -1) undo_flag = 0;
		if (i == 0) undo_flag = 1;
		if (i == 2) {
			VM_RestoreWindowColours();
			VM_Style(SUBHEADER_VMSTY);
			SL_Location(); print "^";
			! print (name) location, "^";
			VM_Style(NORMAL_VMSTY);
			L__M(##Miscellany, 13);
			continue;
		}
		return nw;
	}
];

[ Parser__parse
	syntax line num_lines line_address i j k token l m;

	cobj_flag = 0;
	parser_results-->ACTION_PRES = 0;
	parser_results-->NO_INPS_PRES = 0;
	parser_results-->INP1_PRES = 0;
	parser_results-->INP2_PRES = 0;
	meta = false;

    if (held_back_mode == 1) {
        held_back_mode = 0;
        VM_Tokenise(buffer, parse);
        jump ReParse;
    }

  .ReType;

	cobj_flag = 0;
    BeginActivity(READING_A_COMMAND_ACT); if (ForActivity(READING_A_COMMAND_ACT)==false) {
		Keyboard(buffer,parse);
		players_command = 100 + WordCount();
		num_words = WordCount();
    } if (EndActivity(READING_A_COMMAND_ACT)) jump ReType;

  .ReParse;

    parser_inflection = name;

    ! Initially assume the command is aimed at the player, and the verb
    ! is the first word

    num_words = WordCount();
    wn = 1;

    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese

    num_words = WordCount();

    k=0;
    #Ifdef DEBUG;
    if (parser_trace >= 2) {
        print "[ ";
        for (i=0 : i<num_words : i++) {

            #Ifdef TARGET_ZCODE;
            j = parse-->(i*2 + 1);
            #Ifnot; ! TARGET_GLULX
            j = parse-->(i*3 + 1);
            #Endif; ! TARGET_
            k = WordAddress(i+1);
            l = WordLength(i+1);
            print "~"; for (m=0 : m<l : m++) print (char) k->m; print "~ ";

            if (j == 0) print "?";
            else {
                #Ifdef TARGET_ZCODE;
                if (UnsignedCompare(j, HDR_DICTIONARY-->0) >= 0 &&
                    UnsignedCompare(j, HDR_HIGHMEMORY-->0) < 0)
                     print (address) j;
                else print j;
                #Ifnot; ! TARGET_GLULX
                if (j->0 == $60) print (address) j;
                else print j;
                #Endif; ! TARGET_
            }
            if (i ~= num_words-1) print " / ";
        }
        print " ]^";
    }
    #Endif; ! DEBUG
    verb_wordnum = 1;
    actor = player;
    actors_location = ScopeCeiling(player);
    usual_grammar_after = 0;

  .AlmostReParse;

    scope_token = 0;
    action_to_be = NULL;

    ! Begin from what we currently think is the verb word

  .BeginCommand;

    wn = verb_wordnum;
    verb_word = NextWordStopped();

    ! If there's no input here, we must have something like "person,".

    if (verb_word == -1) {
        best_etype = STUCK_PE;
        jump GiveError;
    }

    ! Now try for "again" or "g", which are special cases: don't allow "again" if nothing
    ! has previously been typed; simply copy the previous text across

    if (verb_word == AGAIN2__WD or AGAIN3__WD) verb_word = AGAIN1__WD;
    if (verb_word == AGAIN1__WD) {
        if (actor ~= player) {
            L__M(##Miscellany, 20);
            jump ReType;
        }
        #Ifdef TARGET_ZCODE;
        if (buffer3->1 == 0) {
            L__M(##Miscellany, 21);
            jump ReType;
        }
        #Ifnot; ! TARGET_GLULX
        if (buffer3-->0 == 0) {
            L__M(##Miscellany, 21);
            jump ReType;
        }
        #Endif; ! TARGET_
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer->i = buffer3->i;
        VM_Tokenise(buffer,parse);
		num_words = WordCount();
    	players_command = 100 + WordCount();
		jump ReParse;
    }

    ! Save the present input in case of an "again" next time

    if (verb_word ~= AGAIN1__WD)
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer3->i = buffer->i;

    if (usual_grammar_after == 0) {
        j = verb_wordnum;
        i = RunRoutines(actor, grammar); 
        #Ifdef DEBUG;
        if (parser_trace >= 2 && actor.grammar ~= 0 or NULL)
            print " [Grammar property returned ", i, "]^";
        #Endif; ! DEBUG

        if ((i ~= 0 or 1) && (VM_InvalidDictionaryAddress(i))) {
            usual_grammar_after = verb_wordnum; i=-i;
        }

        if (i == 1) {
            parser_results-->ACTION_PRES = action;
            parser_results-->NO_INPS_PRES = 0;
            parser_results-->INP1_PRES = noun;
            parser_results-->INP2_PRES = second;
            if (noun) parser_results-->NO_INPS_PRES = 1;
            if (second) parser_results-->NO_INPS_PRES = 2;
            rtrue;
        }
        if (i ~= 0) { verb_word = i; wn--; verb_wordnum--; }
        else { wn = verb_wordnum; verb_word = NextWord(); }
    }
    else usual_grammar_after = 0;

    #Ifdef LanguageIsVerb;
    if (verb_word == 0) {
        i = wn; verb_word = LanguageIsVerb(buffer, parse, verb_wordnum);
        wn = i;
    }
    #Endif; ! LanguageIsVerb

    ! If the first word is not listed as a verb, it must be a direction
    ! or the name of someone to talk to

    if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {

        ! So is the first word an object contained in the special object "compass"
        ! (i.e., a direction)?  This needs use of NounDomain, a routine which
        ! does the object matching, returning the object number, or 0 if none found,
        ! or REPARSE_CODE if it has restructured the parse table so the whole parse
        ! must be begun again...

        wn = verb_wordnum; indef_mode = false; token_filter = 0; parameters = 0;
        @push actor; @push action; @push action_to_be;
        actor = player; meta = false; action = ##Go; action_to_be = ##Go;
        l = NounDomain(compass, 0, 0);
        @pull action_to_be; @pull action; @pull actor;
        if (l == REPARSE_CODE) jump ReParse;

        ! If it is a direction, send back the results:
        ! action=GoSub, no of arguments=1, argument 1=the direction.

        if ((l~=0) && (l ofclass K3_direction)) {
            parser_results-->ACTION_PRES = ##Go;
            parser_results-->NO_INPS_PRES = 1;
            parser_results-->INP1_PRES = l;
            jump LookForMore;
        }

    } ! end of first-word-not-a-verb

	! Only check for a comma (a "someone, do something" command) if we are
	! not already in the middle of one.  (This simplification stops us from
	! worrying about "robot, wizard, you are an idiot", telling the robot to
	! tell the wizard that she is an idiot.)
	
	if (actor == player) {
		for (j=2 : j<=num_words : j++) {
			i=NextWord();
			if (i == comma_word) jump Conversation;
		}
	}
	jump NotConversation;
	
	! NextWord nudges the word number wn on by one each time, so we've now
	! advanced past a comma.  (A comma is a word all on its own in the table.)
	
	.Conversation;
	
	j = wn - 1;
	if (j == 1) {
		L__M(##Miscellany, 22);
		jump ReType;
	}
	
	! Use NounDomain (in the context of "animate creature") to see if the
	! words make sense as the name of someone held or nearby
	
	wn = 1; lookahead = HELD_TOKEN;
	scope_reason = TALKING_REASON;
	l = NounDomain(player,actors_location,6);
	scope_reason = PARSING_REASON;
	if (l == REPARSE_CODE) jump ReParse;
	if (l == 0) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		L__M(##Miscellany, 23);
		jump ReType;
	}
	
	.Conversation2;
	
	! The object addressed must at least be "talkable" if not actually "animate"
	! (the distinction allows, for instance, a microphone to be spoken to,
	! without the parser thinking that the microphone is human).
	
	if (l hasnt animate && l hasnt talkable) {
		L__M(##Miscellany, 24, l);
		jump ReType;
	}
	
	! Check that there aren't any mystery words between the end of the person's
	! name and the comma (eg, throw out "dwarf sdfgsdgs, go north").
	
	if (wn ~= j) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		L__M(##Miscellany, 25);
		jump ReType;
	}
	
	! The player has now successfully named someone.  Adjust "him", "her", "it":
	
	PronounNotice(l);
	
	! Set the global variable "actor", adjust the number of the first word,
	! and begin parsing again from there.
	
	verb_wordnum = j + 1;
	
	! Stop things like "me, again":
	
	if (l == player) {
		wn = verb_wordnum;
		if (NextWordStopped() == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
			L__M(##Miscellany, 20);
			jump ReType;
		}
	}
	
	actor = l;
	actors_location = ScopeCeiling(l);
	#Ifdef DEBUG;
	if (parser_trace >= 1)
		print "[Actor is ", (the) actor, " in ", (name) actors_location, "]^";
	#Endif; ! DEBUG
	jump BeginCommand;

	.NotConversation;
	if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {
		if (actor == player) {
			verb_word = UnknownVerb(verb_word);
			if (verb_word ~= 0) jump VerbAccepted;
		}
		best_etype = VERB_PE;
		jump GiveError;
	}
	.VerbAccepted;

    ! We now definitely have a verb, not a direction, whether we got here by the
    ! "take ..." or "person, take ..." method.  Get the meta flag for this verb:

    meta = ((verb_word->#dict_par1) & 2)/2;

    ! You can't order other people to "full score" for you, and so on...

    if (meta == 1 && actor ~= player) {
        best_etype = VERB_PE;
        meta = 0;
        jump GiveError;
    }

    ! Now let i be the corresponding verb number...

    i = DictionaryWordToVerbNum(verb_word);

    ! ...then look up the i-th entry in the verb table, whose address is at word
    ! 7 in the Z-machine (in the header), so as to get the address of the syntax
    ! table for the given verb...

    #Ifdef TARGET_ZCODE;
    syntax = (HDR_STATICMEMORY-->0)-->i;
    #Ifnot; ! TARGET_GLULX
    syntax = (#grammar_table)-->(i+1);
    #Endif; ! TARGET_

    ! ...and then see how many lines (ie, different patterns corresponding to the
    ! same verb) are stored in the parse table...

    num_lines = (syntax->0) - 1;

    ! ...and now go through them all, one by one.
    ! To prevent pronoun_word 0 being misunderstood,

    pronoun_word = NULL; pronoun_obj = NULL;

    #Ifdef DEBUG;
    if (parser_trace >= 1)
    	print "[Parsing for the verb '", (address) verb_word, "' (", num_lines+1, " lines)]^";
    #Endif; ! DEBUG

    best_etype = STUCK_PE; nextbest_etype = STUCK_PE;
    multiflag = false;

    ! "best_etype" is the current failure-to-match error - it is by default
    ! the least informative one, "don't understand that sentence".
    ! "nextbest_etype" remembers the best alternative to having to ask a
    ! scope token for an error message (i.e., the best not counting ASKSCOPE_PE).
    ! multiflag is used here to prevent inappropriate MULTI_PE errors
    ! in addition to its unrelated duties passing information to action routines

    line_address = syntax + 1;

    for (line=0 : line<=num_lines : line++) {

        for (i=0 : i<32 : i++) {
            line_token-->i = ENDIT_TOKEN;
            line_ttype-->i = ELEMENTARY_TT;
            line_tdata-->i = ENDIT_TOKEN;
        }

        ! Unpack the syntax line from Inform format into three arrays; ensure that
        ! the sequence of tokens ends in an ENDIT_TOKEN.

        line_address = UnpackGrammarLine(line_address);

        #Ifdef DEBUG;
        if (parser_trace >= 1) {
            if (parser_trace >= 2) new_line;
            print "[line ", line; DebugGrammarLine();
            print "]^";
        }
        #Endif; ! DEBUG

        ! We aren't in "not holding" or inferring modes, and haven't entered
        ! any parameters on the line yet, or any special numbers; the multiple
        ! object is still empty.

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        multi_context = 0;
        etype = STUCK_PE;

        ! Put the word marker back to just after the verb

        wn = verb_wordnum+1;

        advance_warning = -1; indef_mode = false;
        for (i=0,m=false,pcount=0 : line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
            scope_token = 0;

            if (line_ttype-->pcount ~= PREPOSITION_TT) i++;

            if (line_ttype-->pcount == ELEMENTARY_TT) {
                if (line_tdata-->pcount == MULTI_TOKEN) m = true;
                if (line_tdata-->pcount == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN  && i == 1) {
                    ! First non-preposition is "multiexcept" or
                    ! "multiinside", so look ahead.

                    #Ifdef DEBUG;
                    if (parser_trace >= 2) print " [Trying look-ahead]^";
                    #Endif; ! DEBUG

                    ! We need this to be followed by 1 or more prepositions.

                    pcount++;
                    if (line_ttype-->pcount == PREPOSITION_TT) {
                        ! skip ahead to a preposition word in the input
                        do {
                            l = NextWord();
                        } until ((wn > num_words) ||
                                 (l && (l->#dict_par1) & 8 ~= 0));
                        
                        if (wn > num_words) {
                            #Ifdef DEBUG;
                            if (parser_trace >= 2)
                                print " [Look-ahead aborted: prepositions missing]^";
                            #Endif;
                            jump LineFailed;
                        }
                        
                        do {
                            if (PrepositionChain(l, pcount) ~= -1) {
                                ! advance past the chain
                                if ((line_token-->pcount)->0 & $20 ~= 0) {
                                    pcount++;
                                    while ((line_token-->pcount ~= ENDIT_TOKEN) &&
                                           ((line_token-->pcount)->0 & $10 ~= 0))
                                        pcount++;
                                } else {
                                    pcount++;
                                }
                            } else {
                                ! try to find another preposition word
                                do {
                                    l = NextWord();
                                } until ((wn >= num_words) ||
                                         (l && (l->#dict_par1) & 8 ~= 0));
                                
                                if (l && (l->#dict_par1) & 8) continue;
                                
                                ! lookahead failed
                                #Ifdef DEBUG;
                                if (parser_trace >= 2)
                                    print " [Look-ahead aborted: prepositions don't match]^";
                                #endif;
                                jump LineFailed;
                            }
                            l = NextWord();
                        } until (line_ttype-->pcount ~= PREPOSITION_TT);
                        
                        ! put back the non-preposition we just read
                        wn--;

                        if ((line_ttype-->pcount == ELEMENTARY_TT) &&
                        	(line_tdata-->pcount == NOUN_TOKEN)) {
                            l = Descriptors();  ! skip past THE etc
                            if (l~=0) etype=l;  ! don't allow multiple objects
                        	k = parser_results-->INP1_PRES; @push k; @push parameters;
                        	parameters = 1; parser_results-->INP1_PRES = 0;
                            l = NounDomain(actors_location, actor, NOUN_TOKEN);
                            @pull parameters; @pull k; parser_results-->INP1_PRES = k;
                            #Ifdef DEBUG;
                            if (parser_trace >= 2) {
                                print " [Advanced to ~noun~ token: ";
                                if (l == REPARSE_CODE) print "re-parse request]^";
                                else {
                                	if (l == 1) print "but multiple found]^";
                                	if (l == 0) print "error ", etype, "]^";
                                	if (l >= 2) print (the) l, "]^";
                                }
                            }
                            #Endif; ! DEBUG
                            if (l == REPARSE_CODE) jump ReParse;
                            if (l >= 2) advance_warning = l;
                        }
                    }
                    break;
                }
            }
        }

        ! Slightly different line-parsing rules will apply to "take multi", to
        ! prevent "take all" behaving correctly but misleadingly when there's
        ! nothing to take.

        take_all_rule = 0;
        if (m && params_wanted == 1 && action_to_be == ##Take)
            take_all_rule = 1;

        ! And now start again, properly, forearmed or not as the case may be.
        ! As a precaution, we clear all the variables again (they may have been
        ! disturbed by the call to NounDomain, which may have called outside
        ! code, which may have done anything!).

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        etype = STUCK_PE;
        wn = verb_wordnum+1;

        for (pcount=1 : : pcount++) {
            pattern-->pcount = PATTERN_NULL; scope_token = 0;

            token = line_token-->(pcount-1);
            lookahead = line_token-->pcount;

            #Ifdef DEBUG;
            if (parser_trace >= 2)
                print " [line ", line, " token ", pcount, " word ", wn, " : ", (DebugToken) token,
                  "]^";
            #Endif; ! DEBUG

            if (token ~= ENDIT_TOKEN) {
                scope_reason = PARSING_REASON;
                AnalyseToken(token);

                l = ParseToken(found_ttype, found_tdata, pcount-1, token);
                while ((l >= GPR_NOUN) && (l < -1)) l = ParseToken(ELEMENTARY_TT, l + 256);
                scope_reason = PARSING_REASON;

                if (l == GPR_PREPOSITION) {
                    if (found_ttype~=PREPOSITION_TT && (found_ttype~=ELEMENTARY_TT ||
                        found_tdata~=TOPIC_TOKEN)) params_wanted--;
                    l = true;
                }
                else
                    if (l < 0) l = false;
                    else
                        if (l ~= GPR_REPARSE) {
                            if (l == GPR_NUMBER) {
                                if (nsns == 0) special_number1 = parsed_number;
                                else special_number2 = parsed_number;
                                nsns++; l = 1;
                            }
                            if (l == GPR_MULTIPLE) l = 0;
                            parser_results-->(parameters+INP1_PRES) = l;
                            parameters++;
                            pattern-->pcount = l;
                            l = true;
                        }

                #Ifdef DEBUG;
                if (parser_trace >= 3) {
                    print "  [token resulted in ";
                    if (l == REPARSE_CODE) print "re-parse request]^";
                    if (l == 0) print "failure with error type ", etype, "]^";
                    if (l == 1) print "success]^";
                }
                #Endif; ! DEBUG

                if (l == REPARSE_CODE) jump ReParse;
                if (l == false) break;
            }
            else {

                ! If the player has entered enough already but there's still
                ! text to wade through: store the pattern away so as to be able to produce
                ! a decent error message if this turns out to be the best we ever manage,
                ! and in the mean time give up on this line

                ! However, if the superfluous text begins with a comma or "then" then
                ! take that to be the start of another instruction

                if (wn <= num_words) {
                    l = NextWord();
                    if (l == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
                        held_back_mode = 1; hb_wn = wn-1;
                    }
                    else {
                        for (m=0 : m<32 : m++) pattern2-->m = pattern-->m;
                        pcount2 = pcount;
                        etype = UPTO_PE;
                        break;
                    }
                }

                ! Now, we may need to revise the multiple object because of the single one
                ! we now know (but didn't when the list was drawn up).

                if (parameters >= 1 && parser_results-->INP1_PRES == 0) {
                    l = ReviseMulti(parser_results-->INP2_PRES);
                    if (l ~= 0) { etype = l; parser_results-->ACTION_PRES = action_to_be; break; }
                }
                if (parameters >= 2 && parser_results-->INP2_PRES == 0) {
                    l = ReviseMulti(parser_results-->INP1_PRES);
                    if (l ~= 0) { etype = l; break; }
                }

                ! To trap the case of "take all" inferring only "yourself" when absolutely
                ! nothing else is in the vicinity...

                if (take_all_rule == 2 && parser_results-->INP1_PRES == actor) {
                    best_etype = NOTHING_PE;
                    jump GiveError;
                }

                #Ifdef DEBUG;
                if (parser_trace >= 1) print "[Line successfully parsed]^";
                #Endif; ! DEBUG

                ! The line has successfully matched the text.  Declare the input error-free...

                oops_from = 0;

                ! ...explain any inferences made (using the pattern)...

                if (inferfrom ~= 0) {
                	PrintInferredCommand(inferfrom);
                    ClearParagraphing();
                }

                ! ...copy the action number, and the number of parameters...

                parser_results-->ACTION_PRES = action_to_be;
                parser_results-->NO_INPS_PRES = parameters;

                ! ...reverse first and second parameters if need be...

                if (action_reversed && parameters == 2) {
                    i = parser_results-->INP1_PRES;
                    parser_results-->INP1_PRES = parser_results-->INP2_PRES;
                    parser_results-->INP2_PRES = i;
                    if (nsns == 2) {
                        i = special_number1; special_number1 = special_number2;
                        special_number2 = i;
                    }
                }

                ! ...and to reset "it"-style objects to the first of these parameters, if
                ! there is one (and it really is an object)...

                if (parameters > 0 && parser_results-->INP1_PRES >= 2)
                    PronounNotice(parser_results-->INP1_PRES);

                ! ...and return from the parser altogether, having successfully matched
                ! a line.

                if (held_back_mode == 1) {
                    wn=hb_wn;
                    jump LookForMore;
                }
                rtrue;

            } ! end of if(token ~= ENDIT_TOKEN) else
        } ! end of for(pcount++)

        .LineFailed;
        ! The line has failed to match.
        ! We continue the outer "for" loop, trying the next line in the grammar.

        if (etype > best_etype) best_etype = etype;
        if (etype ~= ASKSCOPE_PE && etype > nextbest_etype) nextbest_etype = etype;

        ! ...unless the line was something like "take all" which failed because
        ! nothing matched the "all", in which case we stop and give an error now.

        if (take_all_rule == 2 && etype==NOTHING_PE) break;

    } ! end of for(line++)

    ! The grammar is exhausted: every line has failed to match.

  .GiveError;

    etype = best_etype;
    if (actor ~= player) {
        if (usual_grammar_after ~= 0) {
            verb_wordnum = usual_grammar_after;
            jump AlmostReParse;
        }
        wn = verb_wordnum;
        special_word = NextWord();
        if (special_word == comma_word) {
            special_word = NextWord();
            verb_wordnum++;
        }
        parser_results-->ACTION_PRES = ##Answer;
        parser_results-->NO_INPS_PRES = 2;
        parser_results-->INP1_PRES = actor;
        parser_results-->INP2_PRES = 1; special_number1 = special_word;
        actor = player;
        consult_from = verb_wordnum; consult_words = num_words-consult_from+1;
        rtrue;
    }

    ! If the player was the actor (eg, in "take dfghh") the error must be printed,
    ! and fresh input called for.  In three cases the oops word must be jiggled.

    if ((etype ofclass Routine) || (etype ofclass String)) {
        if (ParserError(etype) ~= 0) jump ReType;
    } else {
		if (verb_wordnum == 0 && etype == CANTSEE_PE) etype = VERB_PE;
		players_command = 100 + WordCount(); ! The snippet variable ``player's command''
        BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
        if (ForActivity(PRINTING_A_PARSER_ERROR_ACT)) jump SkipParserError;
    }
    pronoun_word = pronoun__word; pronoun_obj = pronoun__obj;

    if (etype == STUCK_PE) {    L__M(##Miscellany, 27); oops_from = 1; }
    if (etype == UPTO_PE) {     L__M(##Miscellany, 28);
        for (m=0 : m<32 : m++) pattern-->m = pattern2-->m;
        pcount = pcount2; PrintCommand(0); L__M(##Miscellany, 56);
    }
    if (etype == NUMBER_PE)     L__M(##Miscellany, 29);
    if (etype == CANTSEE_PE) {  L__M(##Miscellany, 30); oops_from=saved_oops; }
    if (etype == TOOLIT_PE)     L__M(##Miscellany, 31);
    if (etype == NOTHELD_PE) {  L__M(##Miscellany, 32); oops_from=saved_oops; }
    if (etype == MULTI_PE)      L__M(##Miscellany, 33);
    if (etype == MMULTI_PE)     L__M(##Miscellany, 34);
    if (etype == VAGUE_PE)      L__M(##Miscellany, 35);
    if (etype == EXCEPT_PE)     L__M(##Miscellany, 36);
    if (etype == ANIMA_PE)      L__M(##Miscellany, 37);
    if (etype == VERB_PE)       L__M(##Miscellany, 38);
    if (etype == SCENERY_PE)    L__M(##Miscellany, 39);
    if (etype == ITGONE_PE) {
        if (pronoun_obj == NULL)
                                L__M(##Miscellany, 35);
        else                    L__M(##Miscellany, 40);
    }
    if (etype == JUNKAFTER_PE)  L__M(##Miscellany, 41);
    if (etype == TOOFEW_PE)     L__M(##Miscellany, 42, multi_had);
    if (etype == NOTHING_PE) {
        if (parser_results-->ACTION_PRES == ##Remove &&
        	parser_results-->INP2_PRES ofclass Object) {
            noun = parser_results-->INP2_PRES; ! ensure valid for messages
            if (noun has animate) L__M(##Take, 6, noun);
            else if (noun hasnt container or supporter) L__M(##Insert, 2, noun);
            else if (noun has container && noun hasnt open) L__M(##Take, 9, noun);
            else if (children(noun)==0) L__M(##Search, 6, noun);
            else parser_results-->ACTION_PRES = 0;
            }
        if (parser_results-->ACTION_PRES ~= ##Remove) {
            if (multi_wanted==100)  L__M(##Miscellany, 43);
            else                    L__M(##Miscellany, 44);
        }
    }
    if (etype == ASKSCOPE_PE) {
        scope_stage = 3;
        if (indirect(scope_error) == -1) {
            best_etype = nextbest_etype;
            if (~~((etype ofclass Routine) || (etype ofclass String)))
            	EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            jump GiveError;
        }
    }
    if (etype == NOTINCONTEXT_PE) L__M(##Miscellany, 73);

    .SkipParserError;
    if ((etype ofclass Routine) || (etype ofclass String)) jump ReType;
    say__p = 1;
    EndActivity(PRINTING_A_PARSER_ERROR_ACT);

    ! And go (almost) right back to square one...

    jump ReType;

    ! ...being careful not to go all the way back, to avoid infinite repetition
    ! of a deferred command causing an error.

    ! At this point, the return value is all prepared, and we are only looking
    ! to see if there is a "then" followed by subsequent instruction(s).

  .LookForMore;

    if (wn > num_words) rtrue;

    i = NextWord();
    if (i == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
        if (wn > num_words) {
           held_back_mode = false;
           return;
        }
        i = WordAddress(verb_wordnum);
        j = WordAddress(wn);
        for (: i<j : i++) i->0 = ' ';
        i = NextWord();
        if (i == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
            ! Delete the words "then again" from the again buffer,
            ! in which we have just realised that it must occur:
            ! prevents an infinite loop on "i. again"

            i = WordAddress(wn-2)-buffer;
            if (wn > num_words) j = INPUT_BUFFER_LEN-1;
            else j = WordAddress(wn)-buffer;
            for (: i<j : i++) buffer3->i = ' ';
        }
        VM_Tokenise(buffer,parse);
        held_back_mode = true;
        return;
    }
    best_etype = UPTO_PE;
    jump GiveError;

]; ! end of Parser__parse

[ ParseTokenStopped x y;
	if (wn>WordCount()) return GPR_FAIL;
	return ParseToken(x,y);
];

Global parsetoken_nesting = 0;
[ ParseToken given_ttype given_tdata token_n token  i t rv;
	if (parsetoken_nesting > 0) {
		! save match globals
		@push match_from; @push token_filter; @push match_length;
		@push number_of_classes; @push oops_from;
		for (i=0: i<number_matched: i++) {
			t = match_list-->i; @push t;
			t = match_classes-->i; @push t;
			t = match_scores-->i; @push t;
		}
		@push number_matched;
	 }

	parsetoken_nesting++;
	rv = ParseToken__(given_ttype, given_tdata, token_n, token);
	parsetoken_nesting--;

	if (parsetoken_nesting > 0) {
		! restore match globals
		@pull number_matched;
		for (i=0: i<number_matched: i++) {
 			@pull t; match_scores-->i = t;
			@pull t; match_classes-->i = t;
			@pull t; match_list-->i = t;
   		}
		@pull oops_from; @pull number_of_classes;
		@pull match_length; @pull token_filter; @pull match_from;
	}
	return rv;
];

[ ParseToken__ given_ttype given_tdata token_n token
	l o i j k and_parity single_object desc_wn many_flag
	token_allows_multiple prev_indef_wanted;

    token_filter = 0;
    parser_inflection = name;

    switch (given_ttype) {
      ELEMENTARY_TT:
        switch (given_tdata) {
          SPECIAL_TOKEN:
            l = TryNumber(wn);
            special_word = NextWord();
            #Ifdef DEBUG;
            if (l ~= -1000)
                if (parser_trace >= 3) print "  [Read special as the number ", l, "]^";
            #Endif; ! DEBUG
            if (l == -1000) {
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Read special word at word number ", wn, "]^";
                #Endif; ! DEBUG
                l = special_word;
            }
            parsed_number = l;
            return GPR_NUMBER;

          NUMBER_TOKEN:
            l=TryNumber(wn++);
            if (l == -1000) {
                etype = NUMBER_PE;
                return GPR_FAIL;
            }
            #Ifdef DEBUG;
            if (parser_trace>=3) print "  [Read number as ", l, "]^";
            #Endif; ! DEBUG
            parsed_number = l;
            return GPR_NUMBER;

          CREATURE_TOKEN:
            if (action_to_be == ##Answer or ##Ask or ##AskFor or ##Tell)
                scope_reason = TALKING_REASON;

          TOPIC_TOKEN:
            consult_from = wn;
            if ((line_ttype-->(token_n+1) ~= PREPOSITION_TT) &&
               (line_token-->(token_n+1) ~= ENDIT_TOKEN))
                RunTimeError(13);
            do o = NextWordStopped();
            until (o == -1 || PrepositionChain(o, token_n+1) ~= -1);
            wn--;
            consult_words = wn-consult_from;
            if (consult_words == 0) return GPR_FAIL;
            if (action_to_be == ##Ask or ##Answer or ##Tell) {
                o = wn; wn = consult_from; parsed_number = NextWord();
                wn = o; return 1;
            }
            if (o==-1 && (line_ttype-->(token_n+1) == PREPOSITION_TT))
                return GPR_FAIL;    ! don't infer if required preposition is absent
            return GPR_PREPOSITION;
        }

      PREPOSITION_TT:
        ! Is it an unnecessary alternative preposition, when a previous choice
        ! has already been matched?
        if ((token->0) & $10) return GPR_PREPOSITION;

        ! If we've run out of the player's input, but still have parameters to
        ! specify, we go into "infer" mode, remembering where we are and the
        ! preposition we are inferring...

        if (wn > num_words) {
            if (inferfrom==0 && parameters<params_wanted) {
                inferfrom = pcount; inferword = token;
                pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            }

            ! If we are not inferring, then the line is wrong...

            if (inferfrom == 0) return -1;

            ! If not, then the line is right but we mark in the preposition...

            pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            return GPR_PREPOSITION;
        }

        o = NextWord();

        pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(o);

        ! Whereas, if the player has typed something here, see if it is the
        ! required preposition... if it's wrong, the line must be wrong,
        ! but if it's right, the token is passed (jump to finish this token).

        if (o == given_tdata) return GPR_PREPOSITION;
        if (PrepositionChain(o, token_n) ~= -1) return GPR_PREPOSITION;
        return -1;

      GPR_TT:
        l = indirect(given_tdata);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Outside parsing routine returned ", l, "]^";
        #Endif; ! DEBUG
        return l;

      SCOPE_TT:
        scope_token = given_tdata;
        scope_stage = 1;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 1]^";
        #Endif; ! DEBUG
        l = indirect(scope_token);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine returned multiple-flag of ", l, "]^";
        #Endif; ! DEBUG
        if (l == 1) given_tdata = MULTI_TOKEN; else given_tdata = NOUN_TOKEN;

      ATTR_FILTER_TT:
        token_filter = 1 + given_tdata;
        given_tdata = NOUN_TOKEN;

      ROUTINE_FILTER_TT:
        token_filter = given_tdata;
        given_tdata = NOUN_TOKEN;

    } ! end of switch(given_ttype)

    token = given_tdata;

    ! There are now three possible ways we can be here:
    !     parsing an elementary token other than "special" or "number";
    !     parsing a scope token;
    !     parsing a noun-filter token (either by routine or attribute).
    !
    ! In each case, token holds the type of elementary parse to
    ! perform in matching one or more objects, and
    ! token_filter is 0 (default), an attribute + 1 for an attribute filter
    ! or a routine address for a routine filter.

    token_allows_multiple = false;
    if (token == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        token_allows_multiple = true;

    many_flag = false; and_parity = true; dont_infer = false;

    ! We expect to find a list of objects next in what the player's typed.

  .ObjectList;

    #Ifdef DEBUG;
    if (parser_trace >= 3) print "  [Object list from word ", wn, "]^";
    #Endif; ! DEBUG

    ! Take an advance look at the next word: if it's "it" or "them", and these
    ! are unset, set the appropriate error number and give up on the line
    ! (if not, these are still parsed in the usual way - it is not assumed
    ! that they still refer to something in scope)

    o = NextWord(); wn--;

    pronoun_word = NULL; pronoun_obj = NULL;
    l = PronounValue(o);
    if (l ~= 0) {
        pronoun_word = o; pronoun_obj = l;
        if (l == NULL) {
            ! Don't assume this is a use of an unset pronoun until the
            ! descriptors have been checked, because it might be an
            ! article (or some such) instead

            for (l=1 : l<=LanguageDescriptors-->0 : l=l+4)
                if (o == LanguageDescriptors-->l) jump AssumeDescriptor;
            pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
            etype = VAGUE_PE;
            if (parser_trace >= 3) print "  [Stop: unset pronoun]^";
            return GPR_FAIL;
        }
    }

  .AssumeDescriptor;

    if (o == ME1__WD or ME2__WD or ME3__WD) { pronoun_word = o; pronoun_obj = player; }

    allow_plurals = true; desc_wn = wn;

  .TryAgain;

    ! First, we parse any descriptive words (like "the", "five" or "every"):
    l = Descriptors(token_allows_multiple);
    if (l ~= 0) { etype = l; return 0; }

  .TryAgain2;

    ! This is an actual specified object, and is therefore where a typing error
    ! is most likely to occur, so we set:

    oops_from = wn;

    ! So, two cases.  Case 1: token not equal to "held" (so, no implicit takes)
    ! but we may well be dealing with multiple objects

    ! In either case below we use NounDomain, giving it the token number as
    ! context, and two places to look: among the actor's possessions, and in the
    ! present location.  (Note that the order depends on which is likeliest.)

    if (token ~= HELD_TOKEN) {
        i = multiple_object-->0;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Calling NounDomain on location and actor]^";
        #Endif; ! DEBUG
        l = NounDomain(actors_location, actor, token);
        if (l == REPARSE_CODE) return l;                  ! Reparse after Q&A
        if (indef_wanted == INDEF_ALL_WANTED && l == 0 && number_matched == 0)
            l = 1;  ! ReviseMulti if TAKE ALL FROM empty container

        if (token_allows_multiple && ~~multiflag) {
            if (best_etype==MULTI_PE) best_etype=STUCK_PE;
            multiflag = true;
        }
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            if (etype == MULTI_PE or TOOFEW_PE && multiflag) etype = STUCK_PE;
            etype=CantSee();
            jump FailToken;
        } ! Choose best error

        #Ifdef DEBUG;
        if (parser_trace >= 3) {
            if (l > 1) print "  [ND returned ", (the) l, "]^";
            else {
                print "  [ND appended to the multiple object list:^";
                k = multiple_object-->0;
                for (j=i+1 : j<=k : j++)
                    print "  Entry ", j, ": ", (The) multiple_object-->j,
                          " (", multiple_object-->j, ")^";
                print "  List now has size ", k, "]^";
            }
        }
        #Endif; ! DEBUG

        if (l == 1) {
            if (~~many_flag) many_flag = true;
            else {                                ! Merge with earlier ones
                k = multiple_object-->0;            ! (with either parity)
                multiple_object-->0 = i;
                for (j=i+1 : j<=k : j++) {
                    if (and_parity) MultiAdd(multiple_object-->j);
                    else            MultiSub(multiple_object-->j);
                }
                #Ifdef DEBUG;
                if (parser_trace >= 3)
                	print "  [Merging ", k-i, " new objects to the ", i, " old ones]^";
                #Endif; ! DEBUG
            }
        }
        else {
            ! A single object was indeed found

            if (match_length == 0 && indef_possambig) {
                ! So the answer had to be inferred from no textual data,
                ! and we know that there was an ambiguity in the descriptor
                ! stage (such as a word which could be a pronoun being
                ! parsed as an article or possessive).  It's worth having
                ! another go.

                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }

            if ((token == CREATURE_TOKEN) && (CreatureTest(l) == 0)) {
                etype = ANIMA_PE;
                jump FailToken;
            } !  Animation is required

            if (~~many_flag) single_object = l;
            else {
                if (and_parity) MultiAdd(l); else MultiSub(l);
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Combining ", (the) l, " with list]^";
                #Endif; ! DEBUG
            }
        }
    }

    else {

    ! Case 2: token is "held" (which fortunately can't take multiple objects)
    ! and may generate an implicit take

        l = NounDomain(actor,actors_location,token);       ! Same as above...
        if (l == REPARSE_CODE) return l;
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            etype = CantSee(); jump FailToken;            ! Choose best error
        }

        ! ...until it produces something not held by the actor.  Then an implicit
        ! take must be tried.  If this is already happening anyway, things are too
        ! confused and we have to give up (but saving the oops marker so as to get
        ! it on the right word afterwards).
        ! The point of this last rule is that a sequence like
        !
        !     > read newspaper
        !     (taking the newspaper first)
        !     The dwarf unexpectedly prevents you from taking the newspaper!
        !
        ! should not be allowed to go into an infinite repeat - read becomes
        ! take then read, but take has no effect, so read becomes take then read...
        ! Anyway for now all we do is record the number of the object to take.

        o = parent(l);
        if (o ~= actor) {
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Allowing object ", (the) l, " for now]^";
            #Endif; ! DEBUG
        }
        single_object = l;
    } ! end of if (token ~= HELD_TOKEN) else

    ! The following moves the word marker to just past the named object...

    wn = oops_from + match_length;

    ! Object(s) specified now: is that the end of the list, or have we reached
    ! "and", "but" and so on?  If so, create a multiple-object list if we
    ! haven't already (and are allowed to).

  .NextInList;

    o = NextWord();

    if (o == AND1__WD or AND2__WD or AND3__WD or BUT1__WD or BUT2__WD or BUT3__WD or comma_word) {

        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Read connective '", (address) o, "']^";
        #Endif; ! DEBUG

        if (~~token_allows_multiple) {
            if (multiflag) jump PassToken; ! give UPTO_PE error
            etype=MULTI_PE;
            jump FailToken;
        }

        if (o == BUT1__WD or BUT2__WD or BUT3__WD) and_parity = 1-and_parity;

        if (~~many_flag) {
            multiple_object-->0 = 1;
            multiple_object-->1 = single_object;
            many_flag = true;
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Making new list from ", (the) single_object, "]^";
            #Endif; ! DEBUG
        }
        dont_infer = true; inferfrom=0;           ! Don't print (inferences)
        jump ObjectList;                          ! And back around
    }

    wn--;   ! Word marker back to first not-understood word

    ! Happy or unhappy endings:

  .PassToken;

    if (many_flag) {
        single_object = GPR_MULTIPLE;
        multi_context = token;
    }
    else {
        if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
            if (indef_wanted < INDEF_ALL_WANTED && indef_wanted > 1) {
                multi_had = 1; multi_wanted = indef_wanted;
                etype = TOOFEW_PE;
                jump FailToken;
            }
        }
    }
    return single_object;

  .FailToken;

    ! If we were only guessing about it being a plural, try again but only
    ! allowing singulars (so that words like "six" are not swallowed up as
    ! Descriptors)

    if (allow_plurals && indef_guess_p == 1) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   [Retrying singulars after failure ", etype, "]^";
        #Endif;
        prev_indef_wanted = indef_wanted;
        allow_plurals = false;
        wn = desc_wn;
        jump TryAgain;
    }

    if ((indef_wanted > 0 || prev_indef_wanted > 0) && (~~multiflag)) etype = MULTI_PE;

    return GPR_FAIL;

]; ! end of ParseToken__

Constant OTHER_BIT  =   1;     !  These will be used in Adjudicate()
Constant MY_BIT     =   2;     !  to disambiguate choices
Constant THAT_BIT   =   4;
Constant PLURAL_BIT =   8;
Constant LIT_BIT    =  16;
Constant UNLIT_BIT  =  32;

[ ResetDescriptors;
    indef_mode = 0; indef_type = 0; indef_wanted = 0; indef_guess_p = 0;
    indef_possambig = false;
    indef_owner = nothing;
    indef_cases = $$111111111111;
    indef_nspec_at = 0;
];

[ ArticleDescriptors  o x flag cto type n;
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                type = LanguageDescriptors-->(x+2);
                if (type == DEFART_PK or INDEFART_PK) flag = true;
            }
    }
    wn--;
    return 0;
];

[ Descriptors  o x flag cto type n;
    ResetDescriptors();
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                flag = true;
                type = LanguageDescriptors-->(x+2);
                if (type ~= DEFART_PK) indef_mode = true;
                indef_possambig = true;
                indef_cases = indef_cases & (LanguageDescriptors-->(x+1));

                if (type == POSSESS_PK) {
                    cto = LanguageDescriptors-->(x+3);
                    switch (cto) {
                      0: indef_type = indef_type | MY_BIT;
                      1: indef_type = indef_type | THAT_BIT;
                      default:
                        indef_owner = PronounValue(cto);
                        if (indef_owner == NULL) indef_owner = InformParser;
                    }
                }

                if (type == light)  indef_type = indef_type | LIT_BIT;
                if (type == -light) indef_type = indef_type | UNLIT_BIT;
            }

        if (o == OTHER1__WD or OTHER2__WD or OTHER3__WD) {
            indef_mode = 1; flag = 1;
            indef_type = indef_type | OTHER_BIT;
        }
        if (o == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) {
            indef_mode = 1; flag = 1; indef_wanted = INDEF_ALL_WANTED;
            if (take_all_rule == 1) take_all_rule = 2;
            indef_type = indef_type | PLURAL_BIT;
        }
        if (allow_plurals) {
        	if (NextWordStopped() ~= -1) { wn--; n = TryNumber(wn-1); } else { n=0; wn--; }
            if (n == 1) { indef_mode = 1; flag = 1; }
            if (n > 1) {
                indef_guess_p = 1;
                indef_mode = 1; flag = 1; indef_wanted = n;
                indef_nspec_at = wn-1;
                indef_type = indef_type | PLURAL_BIT;
            }
        }
        if (flag == 1 && NextWordStopped() ~= OF1__WD or OF2__WD or OF3__WD or OF4__WD)
            wn--;  ! Skip 'of' after these
    }
    wn--;
    return 0;
];

[ SafeSkipDescriptors;
	@push indef_mode; @push indef_type; @push indef_wanted;
	@push indef_guess_p; @push indef_possambig; @push indef_owner;
	@push indef_cases; @push indef_nspec_at;
	
	Descriptors();
	
	@pull indef_nspec_at; @pull indef_cases;
	@pull indef_owner; @pull indef_possambig; @pull indef_guess_p;
	@pull indef_wanted; @pull indef_type; @pull indef_mode;
];

[ PrepositionChain wd index;
    if (line_tdata-->index == wd) return wd;
    if ((line_token-->index)->0 & $20 == 0) return -1;
    do {
        if (line_tdata-->index == wd) return wd;
        index++;
    } until ((line_token-->index == ENDIT_TOKEN) || (((line_token-->index)->0 & $10) == 0));
    return -1;
];

[ CreatureTest obj;
    if (obj has animate) rtrue;
    if (obj hasnt talkable) rfalse;
    if (action_to_be == ##Ask or ##Answer or ##Tell or ##AskFor) rtrue;
    rfalse;
];

[ NounDomain domain1 domain2 context
	first_word i j k l answer_words marker;
    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [NounDomain called at word ", wn, "^";
        print "   ";
        if (indef_mode) {
            print "seeking indefinite object: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == INDEF_ALL_WANTED) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "seeking definite object^";
    }
    #Endif; ! DEBUG

    match_length = 0; number_matched = 0; match_from = wn;

    SearchScope(domain1, domain2, context);

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   [ND made ", number_matched, " matches]^";
    #Endif; ! DEBUG

    wn = match_from+match_length;

    ! If nothing worked at all, leave with the word marker skipped past the
    ! first unmatched word...

    if (number_matched == 0) { wn++; rfalse; }

    ! Suppose that there really were some words being parsed (i.e., we did
    ! not just infer).  If so, and if there was only one match, it must be
    ! right and we return it...

    if (match_from <= num_words) {
        if (number_matched == 1) {
            i=match_list-->0;
            return i;
        }

        ! ...now suppose that there was more typing to come, i.e. suppose that
        ! the user entered something beyond this noun.  If nothing ought to follow,
        ! then there must be a mistake, (unless what does follow is just a full
        ! stop, and or comma)

        if (wn <= num_words) {
            i = NextWord(); wn--;
            if (i ~=  AND1__WD or AND2__WD or AND3__WD or comma_word
                   or THEN1__WD or THEN2__WD or THEN3__WD
                   or BUT1__WD or BUT2__WD or BUT3__WD) {
                if (lookahead == ENDIT_TOKEN) rfalse;
            }
        }
    }

    ! Now look for a good choice, if there's more than one choice...

    number_of_classes = 0;

    if (number_matched == 1) i = match_list-->0;
    if (number_matched > 1) {
        i = Adjudicate(context);
        if (i == -1) rfalse;
        if (i == 1) rtrue;       !  Adjudicate has made a multiple
                             !  object, and we pass it on
    }

    ! If i is non-zero here, one of two things is happening: either
    ! (a) an inference has been successfully made that object i is
    !     the intended one from the user's specification, or
    ! (b) the user finished typing some time ago, but we've decided
    !     on i because it's the only possible choice.
    ! In either case we have to keep the pattern up to date,
    ! note that an inference has been made and return.
    ! (Except, we don't note which of a pile of identical objects.)

    if (i ~= 0) {
        if (dont_infer) return i;
        if (inferfrom == 0) inferfrom=pcount;
        pattern-->pcount = i;
        return i;
    }

    ! If we get here, there was no obvious choice of object to make.  If in
    ! fact we've already gone past the end of the player's typing (which
    ! means the match list must contain every object in scope, regardless
    ! of its name), then it's foolish to give an enormous list to choose
    ! from - instead we go and ask a more suitable question...

    if (match_from > num_words) jump Incomplete;

    ! Now we print up the question, using the equivalence classes as worked
    ! out by Adjudicate() so as not to repeat ourselves on plural objects...

	BeginActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
	if (ForActivity(ASKING_WHICH_DO_YOU_MEAN_ACT)) jump SkipWhichQuestion;
	j = 1; marker = 0;
	for (i=1 : i<=number_of_classes : i++) {
		while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i))
			marker++;
		if (match_list-->marker hasnt animate) j = 0;
	}
	if (j) L__M(##Miscellany, 45); else L__M(##Miscellany, 46);

    j = number_of_classes; marker = 0;
    for (i=1 : i<=number_of_classes : i++) {
        while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i)) marker++;
        k = match_list-->marker;

        if (match_classes-->marker > 0) print (the) k; else print (a) k;

        if (i < j-1)  print (string) COMMA__TX;
        if (i == j-1) {
			#Ifdef SERIAL_COMMA;
			if (j ~= 2) print ",";
        	#Endif; ! SERIAL_COMMA
        	print (string) OR__TX;
        }
    }
    L__M(##Miscellany, 57);

	.SkipWhichQuestion; EndActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);

    ! ...and get an answer:

  .WhichOne;
    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i = ' ';
    #Endif; ! TARGET_ZCODE
    answer_words=Keyboard(buffer2, parse2);

    ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.
    first_word = (parse2-->1);

    ! Take care of "all", because that does something too clever here to do
    ! later on:

    if (first_word == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) {
        if (context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
            l = multiple_object-->0;
            for (i=0 : i<number_matched && l+i<MATCH_LIST_WORDS : i++) {
                k = match_list-->i;
                multiple_object-->(i+1+l) = k;
            }
            multiple_object-->0 = i+l;
            rtrue;
        }
        L__M(##Miscellany, 47);
        jump WhichOne;
    }

    ! If the first word of the reply can be interpreted as a verb, then
    ! assume that the player has ignored the question and given a new
    ! command altogether.
    ! (This is one time when it's convenient that the directions are
    ! not themselves verbs - thus, "north" as a reply to "Which, the north
    ! or south door" is not treated as a fresh command but as an answer.)

    #Ifdef LanguageIsVerb;
    if (first_word == 0) {
        j = wn; first_word = LanguageIsVerb(buffer2, parse2, 1); wn = j;
    }
    #Endif; ! LanguageIsVerb
    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if ((0 ~= j&1) && ~~LanguageVerbMayBeName(first_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }

    ! Now we insert the answer into the original typed command, as
    ! words additionally describing the same object
    ! (eg, > take red button
    !      Which one, ...
    !      > music
    ! becomes "take music red button".  The parser will thus have three
    ! words to work from next time, not two.)

    #Ifdef TARGET_ZCODE;
    k = WordAddress(match_from) - buffer; l=buffer2->1+1;
    for (j=buffer + buffer->0 - 1 : j>=buffer+k+l : j--) j->0 = 0->(j-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(2+i);
    buffer->(k+l-1) = ' ';
    buffer->1 = buffer->1 + l;
    if (buffer->1 >= (buffer->0 - 1)) buffer->1 = buffer->0;
    #Ifnot; ! TARGET_GLULX
    k = WordAddress(match_from) - buffer;
    l = (buffer2-->0) + 1;
    for (j=buffer+INPUT_BUFFER_LEN-1 : j>=buffer+k+l : j--) j->0 = j->(-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(WORDSIZE+i);
    buffer->(k+l-1) = ' ';
    buffer-->0 = buffer-->0 + l;
    if (buffer-->0 > (INPUT_BUFFER_LEN-WORDSIZE)) buffer-->0 = (INPUT_BUFFER_LEN-WORDSIZE);
    #Endif; ! TARGET_

    ! Having reconstructed the input, we warn the parser accordingly
    ! and get out.

	.RECONSTRUCT_INPUT;

	num_words = WordCount();
    wn = 1;
    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese
	num_words = WordCount();
    players_command = 100 + WordCount();
	FollowRulebook(Activity_after_rulebooks-->READING_A_COMMAND_ACT, true);

    return REPARSE_CODE;

    ! Now we come to the question asked when the input has run out
    ! and can't easily be guessed (eg, the player typed "take" and there
    ! were plenty of things which might have been meant).

  .Incomplete;

    if (context == CREATURE_TOKEN) L__M(##Miscellany, 48);
    else                           L__M(##Miscellany, 49);

    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i=' ';
    #Endif; ! TARGET_ZCODE
    answer_words = Keyboard(buffer2, parse2);

    first_word=(parse2-->1);
    #Ifdef LanguageIsVerb;
    if (first_word==0) {
        j = wn; first_word=LanguageIsVerb(buffer2, parse2, 1); wn = j;
    }
    #Endif; ! LanguageIsVerb

    ! Once again, if the reply looks like a command, give it to the
    ! parser to get on with and forget about the question...

    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if (0 ~= j&1) {
            VM_CopyBuffer(buffer, buffer2);
            return REPARSE_CODE;
        }
    }

    ! ...but if we have a genuine answer, then:
    !
    ! (1) we must glue in text suitable for anything that's been inferred.

    if (inferfrom ~= 0) {
        for (j=inferfrom : j<pcount : j++) {
            if (pattern-->j == PATTERN_NULL) continue;
            #Ifdef TARGET_ZCODE;
            i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
            #Ifnot; ! TARGET_GLULX
            i = WORDSIZE + buffer-->0;
            (buffer-->0)++; buffer->(i++) = ' ';
            #Endif; ! TARGET_

            #Ifdef DEBUG;
            if (parser_trace >= 5)
            	print "[Gluing in inference with pattern code ", pattern-->j, "]^";
            #Endif; ! DEBUG

            ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.

            parse2-->1 = 0;

            ! An inferred object.  Best we can do is glue in a pronoun.
            ! (This is imperfect, but it's very seldom needed anyway.)

            if (pattern-->j >= 2 && pattern-->j < REPARSE_CODE) {
                PronounNotice(pattern-->j);
                for (k=1 : k<=LanguagePronouns-->0 : k=k+3)
                    if (pattern-->j == LanguagePronouns-->(k+2)) {
                        parse2-->1 = LanguagePronouns-->k;
                        #Ifdef DEBUG;
                        if (parser_trace >= 5)
                        	print "[Using pronoun '", (address) parse2-->1, "']^";
                        #Endif; ! DEBUG
                        break;
                    }
            }
            else {
                ! An inferred preposition.
                parse2-->1 = VM_NumberToDictionaryAddress(pattern-->j - REPARSE_CODE);
                #Ifdef DEBUG;
                if (parser_trace >= 5)
                	print "[Using preposition '", (address) parse2-->1, "']^";
                #Endif; ! DEBUG
            }

            ! parse2-->1 now holds the dictionary address of the word to glue in.

            if (parse2-->1 ~= 0) {
                k = buffer + i;
                #Ifdef TARGET_ZCODE;
                @output_stream 3 k;
                 print (address) parse2-->1;
                @output_stream -3;
                k = k-->0;
                for (l=i : l<i+k : l++) buffer->l = buffer->(l+2);
                i = i + k; buffer->1 = i-2;
                #Ifnot; ! TARGET_GLULX
                k = Glulx_PrintAnyToArray(buffer+i, INPUT_BUFFER_LEN-i, parse2-->1);
                i = i + k; buffer-->0 = i - WORDSIZE;
                #Endif; ! TARGET_
            }
        }
    }

    ! (2) we must glue the newly-typed text onto the end.

    #Ifdef TARGET_ZCODE;
    i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2->1 : i++,j++) {
        buffer->i = buffer2->(j+2);
        (buffer->1)++;
        if (buffer->1 == INPUT_BUFFER_LEN) break;
    }
    #Ifnot; ! TARGET_GLULX
    i = WORDSIZE + buffer-->0;
    (buffer-->0)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2-->0 : i++,j++) {
        buffer->i = buffer2->(j+WORDSIZE);
        (buffer-->0)++;
        if (buffer-->0 == INPUT_BUFFER_LEN) break;
    }
    #Endif; ! TARGET_

    ! (3) we fill up the buffer with spaces, which is unnecessary, but may
    !     help incorrectly-written interpreters to cope.

    #Ifdef TARGET_ZCODE;
    for (: i<INPUT_BUFFER_LEN : i++) buffer->i = ' ';
    #Endif; ! TARGET_ZCODE

    return REPARSE_CODE;

]; ! end of NounDomain

[ Adjudicate context i j k good_ones last n ultimate flag offset;
    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [Adjudicating match list of size ", number_matched,
        	" in context ", context, "^";
        print "   ";
        if (indef_mode) {
            print "indefinite type: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == INDEF_ALL_WANTED) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "definite object^";
    }
    #Endif; ! DEBUG

    j = number_matched-1; good_ones = 0; last = match_list-->0;
    for (i=0 : i<=j : i++) {
        n = match_list-->i;
        match_scores-->i = good_ones;
        ultimate = ScopeCeiling(n);

        if (context==HELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }
        if (context==MULTI_TOKEN && ultimate==ScopeCeiling(actor)
            && n~=actor && n hasnt concealed && n hasnt scenery) 
        {   good_ones++; last=n; }
        if (context==MULTIHELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }

        if (context==MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        {   if (advance_warning==-1)
            {   if (context==MULTIEXCEPT_TOKEN)
                {   good_ones++; last=n;
                 }
                if (context==MULTIINSIDE_TOKEN)
                {   if (parent(n)~=actor) { good_ones++; last=n; }
                 }
            }
            else
            {   if (context==MULTIEXCEPT_TOKEN && n~=advance_warning)
                {   good_ones++; last=n; }
                if (context==MULTIINSIDE_TOKEN && n in advance_warning)
                {   good_ones++; last=n; }
            }
         }
        if (context==CREATURE_TOKEN && CreatureTest(n)==1)
        {   good_ones++; last=n; }
        
        match_scores-->i = 1000*(good_ones - match_scores-->i);
    }
    if (good_ones == 1) return last;

    ! If there is ambiguity about what was typed, but it definitely wasn't
    ! animate as required, then return anything; higher up in the parser
    ! a suitable error will be given.  (This prevents a question being asked.)

    if (context == CREATURE_TOKEN && good_ones == 0) return match_list-->0;

    if (indef_mode == 0) indef_type=0;

    ScoreMatchL(context);
    if (number_matched == 0) return -1;

    if (indef_mode == 0) {
        !  Is there now a single highest-scoring object?
        i = SingleBestGuess();
        if (i >= 0) {

            #Ifdef DEBUG;
            if (parser_trace >= 4) print "   Single best-scoring object returned.]^";
            #Endif; ! DEBUG
            return i;
        }
    }

    if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
        if (context ~= MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN
                     or MULTIINSIDE_TOKEN) {
            etype = MULTI_PE;
            return -1;
        }
        i = 0; offset = multiple_object-->0;
        for (j=BestGuess(): j~=-1 && i<indef_wanted && i+offset<MATCH_LIST_WORDS-1:
        	j=BestGuess()) {
            flag = 0;
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, j)) == 0) {

                if (j hasnt concealed && j hasnt worn) flag = 1;
            
                if (context == MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN && parent(j) ~= actor)
                    flag = 0;

                if (action_to_be == ##Take or ##Remove && parent(j) == actor)
                    flag = 0;

                k = ChooseObjects(j, flag);

                if (k == 1)
                    flag = 1;
                else {
                    if (k == 2) flag = 0;
                }
            } else {
                flag = 0; if (RulebookSucceeded()) flag = 1;
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if (flag == 1) {
                i++; multiple_object-->(i+offset) = j;
                #Ifdef DEBUG;
                if (parser_trace >= 4) print "   Accepting it^";
                #Endif; ! DEBUG
            }
            else {
                i = i;
                #Ifdef DEBUG;
                if (parser_trace >= 4) print "   Rejecting it^";
                #Endif; ! DEBUG
            }
        }
        if (i < indef_wanted && indef_wanted < INDEF_ALL_WANTED) {
            etype = TOOFEW_PE; multi_wanted = indef_wanted;
            multi_had=i;
            return -1;
        }
        multiple_object-->0 = i+offset;
        multi_context = context;
        #Ifdef DEBUG;
        if (parser_trace >= 4)
            print "   Made multiple object of size ", i, "]^";
        #Endif; ! DEBUG
        return 1;
    }

    for (i=0 : i<number_matched : i++) match_classes-->i = 0;

    n = 1;
    for (i=0 : i<number_matched : i++)
        if (match_classes-->i == 0) {
            match_classes-->i = n++; flag = 0;
            for (j=i+1 : j<number_matched : j++)
                if (match_classes-->j == 0 && Identical(match_list-->i, match_list-->j) == 1) {
                    flag=1;
                    match_classes-->j = match_classes-->i;
                }
            if (flag == 1) match_classes-->i = 1-n;
        }
     n--; number_of_classes = n;

    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   Grouped into ", n, " possibilities by name:^";
        for (i=0 : i<number_matched : i++)
            if (match_classes-->i > 0)
                print "   ", (The) match_list-->i, " (", match_list-->i, ")  ---  group ",
                  match_classes-->i, "^";
    }
    #Endif; ! DEBUG

    if (indef_mode == 0) {
        if (n > 1) {
            k = -1;
            for (i=0 : i<number_matched : i++) {
                if (match_scores-->i > k) {
                    k = match_scores-->i;
                    j = match_classes-->i; j = j*j;
                    flag = 0;
                }
                else
                    if (match_scores-->i == k) {
                        if ((match_classes-->i) * (match_classes-->i) ~= j)
                            flag = 1;
                    }
            }

        if (flag) {
            #Ifdef DEBUG;
            if (parser_trace >= 4) print "   Unable to choose best group, so ask player.]^";
            #Endif; ! DEBUG
            return 0;
        }
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Best choices are all from the same group.^";
        #Endif; ! DEBUG
        }
    }

    !  When the player is really vague, or there's a single collection of
    !  indistinguishable objects to choose from, choose the one the player
    !  most recently acquired, or if the player has none of them, then
    !  the one most recently put where it is.

    if (n == 1) dont_infer = true;
    return BestGuess();

]; ! Adjudicate

[ ReviseMulti second_p  i low;
    #Ifdef DEBUG;
    if (parser_trace >= 4)
    	print "   Revising multiple object list of size ", multiple_object-->0,
     	" with 2nd ", (name) second_p, "^";
    #Endif; ! DEBUG

    if (multi_context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
        for (i=1,low=0 : i<=multiple_object-->0 : i++) {
            if ( (multi_context==MULTIEXCEPT_TOKEN && multiple_object-->i ~= second_p) ||
                 (multi_context==MULTIINSIDE_TOKEN && multiple_object-->i in second_p)) {
                low++;
                multiple_object-->low = multiple_object-->i;
            }
        }
        multiple_object-->0 = low;
    }

    if (multi_context == MULTI_TOKEN && action_to_be == ##Take) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Token 2 plural case: number with actor ", low, "^";
        #Endif; ! DEBUG
        if (take_all_rule == 2) {
            for (i=1,low=0 : i<=multiple_object-->0 : i++) {
                if (ScopeCeiling(multiple_object-->i) == ScopeCeiling(actor)) {
                    low++;
                    multiple_object-->low = multiple_object-->i;
                }
            }
            multiple_object-->0 = low;
        }
    }

    i = multiple_object-->0;
    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Done: new size ", i, "^";
    #Endif; ! DEBUG
    if (i == 0) return NOTHING_PE;
    return 0;
];

[ MakeMatch obj quality i;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match with quality ",quality,"^";
    #Endif; ! DEBUG
    if (token_filter ~= 0 && ConsultNounFilterToken(obj) == 0) {
        #Ifdef DEBUG;
        if (parser_trace >= 6) print "    Match filtered out: token filter ", token_filter, "^";
        #Endif; ! DEBUG
        rtrue;
    }
    if (quality < match_length) rtrue;
    if (quality > match_length) { match_length = quality; number_matched = 0; }
    else {
        if (number_matched >= MATCH_LIST_WORDS) rtrue;
        for (i=0 : i<number_matched : i++)
            if (match_list-->i == obj) rtrue;
    }
    match_list-->number_matched++ = obj;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match added to list^";
    #Endif; ! DEBUG
];

[ ConsultNounFilterToken obj;
    if (token_filter ofclass Routine) {
	    noun = obj;
    	return indirect(token_filter);
    }
    if (obj has (token_filter-1)) rtrue;
    rfalse;
];

Constant SCORE__CHOOSEOBJ = 1000;
Constant SCORE__IFGOOD = 500;
Constant SCORE__UNCONCEALED = 100;
Constant SCORE__BESTLOC = 60;
Constant SCORE__NEXTBESTLOC = 40;
Constant SCORE__NOTCOMPASS = 20;
Constant SCORE__NOTSCENERY = 10;
Constant SCORE__NOTACTOR = 5;
Constant SCORE__GNA = 1;
Constant SCORE__DIVISOR = 20;

Constant PREFER_HELD;
[ ScoreMatchL context its_owner its_score obj i j threshold met a_s l_s;
!   if (indef_type & OTHER_BIT ~= 0) threshold++;
    if (indef_type & MY_BIT ~= 0)    threshold++;
    if (indef_type & THAT_BIT ~= 0)  threshold++;
    if (indef_type & LIT_BIT ~= 0)   threshold++;
    if (indef_type & UNLIT_BIT ~= 0) threshold++;
    if (indef_owner ~= nothing)      threshold++;

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Scoring match list: indef mode ", indef_mode, " type ",
      indef_type, ", satisfying ", threshold, " requirements:^";
    #Endif; ! DEBUG

    #ifdef PREFER_HELD;
    a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    if (action_to_be == ##Take or ##Remove) {
        a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    }
    context = context;  ! silence warning
    #ifnot;
    a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    if (context == HELD_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN) {
        a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    }
    #endif; ! PREFER_HELD

    for (i=0 : i<number_matched : i++) {
        obj = match_list-->i; its_owner = parent(obj); its_score=0; met=0;

        !      if (indef_type & OTHER_BIT ~= 0
        !          &&  obj ~= itobj or himobj or herobj) met++;
        if (indef_type & MY_BIT ~= 0 && its_owner == actor) met++;
        if (indef_type & THAT_BIT ~= 0 && its_owner == actors_location) met++;
        if (indef_type & LIT_BIT ~= 0 && obj has light) met++;
        if (indef_type & UNLIT_BIT ~= 0 && obj hasnt light) met++;
        if (indef_owner ~= 0 && its_owner == indef_owner) met++;

        if (met < threshold) {
            #Ifdef DEBUG;
            if (parser_trace >= 4)
            	print "   ", (The) match_list-->i, " (", match_list-->i, ") in ",
            	    (the) its_owner, " is rejected (doesn't match descriptors)^";
            #Endif; ! DEBUG
            match_list-->i = -1;
        }
        else {
            its_score = 0;
            if (obj hasnt concealed) its_score = SCORE__UNCONCEALED;

            if (its_owner == actor) its_score = its_score + a_s;
            else
                if (its_owner == actors_location) its_score = its_score + l_s;
                else
                    if (its_owner ~= compass) its_score = its_score + SCORE__NOTCOMPASS;

            its_score = its_score + SCORE__CHOOSEOBJ * ChooseObjects(obj, 2);

            if (obj hasnt scenery) its_score = its_score + SCORE__NOTSCENERY;
            if (obj ~= actor) its_score = its_score + SCORE__NOTACTOR;

            !   A small bonus for having the correct GNA,
            !   for sorting out ambiguous articles and the like.

            if (indef_cases & (PowersOfTwo_TB-->(GetGNAOfObject(obj))))
                its_score = its_score + SCORE__GNA;

            match_scores-->i = match_scores-->i + its_score;
            #Ifdef DEBUG;
            if (parser_trace >= 4) print "     ", (The) match_list-->i, " (", match_list-->i,
              ") in ", (the) its_owner, " : ", match_scores-->i, " points^";
            #Endif; ! DEBUG
        }
     }

    for (i=0 : i<number_matched : i++) {
        while (match_list-->i == -1) {
            if (i == number_matched-1) { number_matched--; break; }
            for (j=i : j<number_matched-1 : j++) {
                match_list-->j = match_list-->(j+1);
                match_scores-->j = match_scores-->(j+1);
            }
            number_matched--;
        }
    }
];

[ BestGuess  earliest its_score best i;
    earliest = 0; best = -1;
    for (i=0 : i<number_matched : i++) {
        if (match_list-->i >= 0) {
            its_score = match_scores-->i;
            if (its_score > best) { best = its_score; earliest = i; }
        }
    }
    #Ifdef DEBUG;
    if (parser_trace >= 4)
      if (best < 0) print "   Best guess ran out of choices^";
      else print "   Best guess ", (the) match_list-->earliest,
      	" (", match_list-->earliest, ")^";
    #Endif; ! DEBUG
    if (best < 0) return -1;
    i = match_list-->earliest;
    match_list-->earliest = -1;
    return i;
];

[ SingleBestGuess  earliest its_score best i;
    earliest = -1; best = -1000;
    for (i=0 : i<number_matched : i++) {
        its_score = match_scores-->i;
        if (its_score == best) earliest = -1;
        if (its_score > best) { best = its_score; earliest = match_list-->i; }
    }
    return earliest;
];

[ Identical o1 o2 p1 p2 n1 n2 i j flag;
    if (o1 == o2) rtrue;  ! This should never happen, but to be on the safe side
    if (o1 == 0 || o2 == 0) rfalse;  ! Similarly
    if (o1 ofclass K3_direction || o2 ofclass K3_direction) rfalse; ! Saves time

    !  What complicates things is that o1 or o2 might have a parsing routine,
    !  so the parser can't know from here whether they are or aren't the same.
    !  If they have different parsing routines, we simply assume they're
    !  different.  If they have the same routine (which they probably got from
    !  a class definition) then the decision process is as follows:
    !
    !     the routine is called (with self being o1, not that it matters)
    !       with noun and second being set to o1 and o2, and action being set
    !       to the fake action TheSame.  If it returns -1, they are found
    !       identical; if -2, different; and if >=0, then the usual method
    !       is used instead.

    if (o1.parse_name ~= 0 || o2.parse_name ~= 0) {
      if (o1.parse_name ~= o2.parse_name) rfalse;
      parser_action = ##TheSame; parser_one = o1; parser_two = o2;
      j = wn; i = RunRoutines(o1,parse_name); wn = j;
      if (i == -1) rtrue;
      if (i == -2) rfalse;
    }

    !  This is the default algorithm: do they have the same words in their
    !  "name" (i.e. property no. 1) properties.  (Note that the following allows
    !  for repeated words and words in different orders.)

    p1 = o1.&1; n1 = (o1.#1)/WORDSIZE;
    p2 = o2.&1; n2 = (o2.#1)/WORDSIZE;

    !  for (i=0 : i<n1 : i++) { print (address) p1-->i, " "; } new_line;
    !  for (i=0 : i<n2 : i++) { print (address) p2-->i, " "; } new_line;

    for (i=0 : i<n1 : i++) {
        flag = 0;
        for (j=0 : j<n2 : j++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    for (j=0 : j<n2 : j++) {
        flag = 0;
        for (i=0 : i<n1 : i++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    !  print "Which are identical!^";
    rtrue;
];

[ PrintInferredCommand from singleton_noun;
	singleton_noun = FALSE;
	if ((from ~= 0) && (from == pcount-1) &&
		(pattern-->from > 1) && (pattern-->from < REPARSE_CODE))
			singleton_noun = TRUE;

	if (singleton_noun) {
		BeginActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
		if (ForActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from) == 0) {
			print "("; PrintCommand(from); print ")^";
		}
		EndActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
	} else {
		print "("; PrintCommand(from); print ")^";
	}
];

[ PrintCommand from i k spacing_flag;
    if (from == 0) {
        i = verb_word;
        if (LanguageVerb(i) == 0)
            if (PrintVerb(i) == 0) print (address) i;
        from++; spacing_flag = true;
    }
    for (k=from : k<pcount : k++) {
        i = pattern-->k;
        if (i == PATTERN_NULL) continue;
        if (spacing_flag) print (char) ' ';
        if (i == 0) { print (string) THOSET__TX; jump TokenPrinted; }
        if (i == 1) { print (string) THAT__TX;   jump TokenPrinted; }
        if (i >= REPARSE_CODE)
            print (address) VM_NumberToDictionaryAddress(i-REPARSE_CODE);
        else
            if (i ofclass K3_direction)
                print (LanguageDirection) i; ! the direction name as adverb
            else
                print (the) i;
      .TokenPrinted;
        spacing_flag = true;
    }
];

[ CantSee  i w e;
    saved_oops=oops_from;

    if (scope_token ~= 0) {
        scope_error = scope_token; return ASKSCOPE_PE;
    }

    wn--; w = NextWord();
    e = CANTSEE_PE;
    if (w == pronoun_word) {
        pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
        e = ITGONE_PE;
    }
    
    if (etype > e) return etype;
    return e;
];

[ MultiAdd o i j;
    i = multiple_object-->0;
    if (i == MATCH_LIST_WORDS-1) { toomany_flag = 1; rtrue; }
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) rtrue;
    i++;
    multiple_object-->i = o;
    multiple_object-->0 = i;
];

[ MultiSub o i j k;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) {
            for (k=j : k<=i : k++) multiple_object-->k = multiple_object-->(k+1);
            multiple_object-->0 = --i;
            return 0;
        }
    return VAGUE_PE;
];

[ MultiFilter attr  i j o;
	.MFiltl;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++) {
        o = multiple_object-->j;
        if (o hasnt attr) { MultiSub(o); jump Mfiltl; }
    }
];

[ PlaceInScope O opts; ! If opts is set, do not place contents in scope
	wn = match_from;
	if (opts == false) DoScopeActionAndRecurse(O);
	else DoScopeAction(O);
	return;
];

[ AddToScope obj;
    if (ats_flag >= 2) DoScopeActionAndRecurse(obj, 0, ats_flag-2);
    if (ats_flag == 1) { if (HasLightSource(obj)==1) ats_hls = 1; }
];

[ TestScope obj act a al sr x y;
    x = parser_one; y = parser_two;
    parser_one = obj; parser_two = 0; a = actor; al = actors_location;
    sr = scope_reason; scope_reason = TESTSCOPE_REASON;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    SearchScope(actors_location, actor, 0); scope_reason = sr; actor = a;
    actors_location = al; parser_one = x; x = parser_two; parser_two = y;
    return x;
];

[ LoopOverScope routine act x y a al;
    x = parser_one; y = scope_reason; a = actor; al = actors_location;
    parser_one = routine;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    scope_reason = LOOPOVERSCOPE_REASON;
    SearchScope(actors_location, actor, 0);
    parser_one = x; scope_reason = y; actor = a; actors_location = al;
];

[ SearchScope domain1 domain2 context i;
	if (domain1 == 0) return;
	! (a)
    if (scope_token) {
        scope_stage = 2;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 2]^";
        #Endif;
        if (indirect(scope_token) ~= 0) rtrue;
    }
	! (b)
    BeginActivity(DECIDING_SCOPE_ACT, actor);
    if (ForActivity(DECIDING_SCOPE_ACT, actor) == false) {
		! (c.1)
		if ((scope_reason == PARSING_REASON) && (context == MULTIINSIDE_TOKEN) &&
			(advance_warning ~= -1)) {
			if (IsSeeThrough(advance_warning) == 1)
			    ScopeWithin(advance_warning, 0, context);
		} else {
			! (c.2)
			if ((scope_reason == PARSING_REASON) && (context ~= CREATURE_TOKEN) &&
				(indef_mode == 0) && (domain1 == actors_location))
					ScopeWithin(compass);
			! (c.3)
			if (domain1 has supporter or container) DoScopeAction(domain1);
			ScopeWithin(domain1, domain2, context);
			! (c.4)
			if (domain2) {
				if (domain2 has supporter or container) DoScopeAction(domain2);
				ScopeWithin(domain2, 0, context);
			}
		}
		! (c.5)
		if (thedark == domain1 or domain2) {
			DoScopeActionAndRecurse(actor, actor, context);
			if (parent(actor) has supporter or container)
				DoScopeActionAndRecurse(parent(actor), parent(actor), context);
		}
    }
    EndActivity(DECIDING_SCOPE_ACT, actor);
];

[ ScopeWithin domain nosearch context obj next_obj;
    if (domain == 0) rtrue;

    ! Look through the objects in the domain, avoiding "objectloop" in case
    ! movements occur.
    obj = child(domain);
    while (obj) {
        next_obj = sibling(obj);
        if ((domain == actor) || (TestConcealment(domain, obj) == false))
            DoScopeActionAndRecurse(obj, nosearch, context);
        obj = next_obj;
    }
];

[ DoScopeActionAndRecurse domain nosearch context i ad n obj next_obj;
	DoScopeAction(domain);

 	! (a)
    if ((domain ~= nosearch) &&
        ((domain ofclass K1_room or K8_person) || (IsSeeThrough(domain) == 1))) {
		obj = child(domain);
		while (obj) {
			next_obj = sibling(obj);
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, nosearch, context);
			obj = next_obj;
		}
	}

	! (b)
	if (domain provides component_child) {
		obj = domain.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, 0, context);
			obj = next_obj;
		}
	}

    ! (c)
    ad = domain.&add_to_scope;
    if (ad ~= 0) {
        ! Test if the property value is not an object.
        #Ifdef TARGET_ZCODE;
        i = (UnsignedCompare(ad-->0, top_object) > 0);
        #Ifnot; ! TARGET_GLULX
        i = (((ad-->0)->0) ~= $70);
        #Endif; ! TARGET_

        if (i) {
            ats_flag = 2+context;
            RunRoutines(domain, add_to_scope);
            ats_flag = 0;
        }
        else {
            n = domain.#add_to_scope;
            for (i=0 : (WORDSIZE*i)<n : i++)
                if (ad-->i)
                    DoScopeActionAndRecurse(ad-->i, 0, context);
        }
    }
];

[ DoScopeAction item;

    #Ifdef DEBUG;
    if (parser_trace >= 6)
        print "[DSA on ", (the) item, " with reason = ", scope_reason,
            " p1 = ", parser_one, " p2 = ", parser_two, "]^";
    #Endif; ! DEBUG

    @push parser_one; @push scope_reason;

	switch(scope_reason) {
		TESTSCOPE_REASON: if (item == parser_one) parser_two = 1;
		LOOPOVERSCOPE_REASON: if (parser_one ofclass Routine) indirect(parser_one, item);
		PARSING_REASON, TALKING_REASON: MatchTextAgainstObject(item);
    }

    @pull scope_reason; @pull parser_one;
];

[ MatchTextAgainstObject item i;
	if (match_from <= num_words) { ! If there's any text to match, that is
		wn = match_from;
		i = NounWord();
		if ((i == 1) && (player == item)) MakeMatch(item, 1); ! "me"
		if ((i >= 2) && (i < 128) && (LanguagePronouns-->i == item)) MakeMatch(item, 1);
	}

	! Construing the current word as the start of a noun, can it refer to the
	! object?

	wn = match_from;
	if (TryGivenObject(item) > 0)
		if (indef_nspec_at > 0 && match_from ~= indef_nspec_at) {
			! This case arises if the player has typed a number in
			! which is hypothetically an indefinite descriptor:
			! e.g. "take two clubs".  We have just checked the object
			! against the word "clubs", in the hope of eventually finding
			! two such objects.  But we also backtrack and check it
			! against the words "two clubs", in case it turns out to
			! be the 2 of Clubs from a pack of cards, say.  If it does
			! match against "two clubs", we tear up our original
			! assumption about the meaning of "two" and lapse back into
			! definite mode.

			wn = indef_nspec_at;
			if (TryGivenObject(item) > 0) {
				match_from = indef_nspec_at;
				ResetDescriptors();
			}
			wn = match_from;
		}
];

[ TryGivenObject obj nomatch threshold k w j;
    #Ifdef DEBUG;
    if (parser_trace >= 5) print "    Trying ", (the) obj, " (", obj, ") at word ", wn, "^";
    #Endif; ! DEBUG

	if (nomatch && obj == 0) return 0;

! if (nomatch) print "*** TryGivenObject *** on ", (the) obj, " at wn = ", wn, "^";

    dict_flags_of_noun = 0;

!  If input has run out then always match, with only quality 0 (this saves
!  time).

    if (wn > num_words) {
    	if (nomatch) return 0;
        if (indef_mode ~= 0)
            dict_flags_of_noun = $$01110000;  ! Reject "plural" bit
        MakeMatch(obj,0);
        #Ifdef DEBUG;
        if (parser_trace >= 5) print "    Matched (0)^";
        #Endif; ! DEBUG
        return 1;
    }

!  Ask the object to parse itself if necessary, sitting up and taking notice
!  if it says the plural was used:

    if (obj.parse_name~=0) {
        parser_action = NULL; j=wn;
        k = RunRoutines(obj,parse_name);
        if (k > 0) {
            wn=j+k;

          .MMbyPN;

            if (parser_action == ##PluralFound)
                dict_flags_of_noun = dict_flags_of_noun | 4;

            if (dict_flags_of_noun & 4) {
                if (~~allow_plurals) k = 0;
                else {
                    if (indef_mode == 0) {
                        indef_mode = 1; indef_type = 0; indef_wanted = 0;
                    }
                    indef_type = indef_type | PLURAL_BIT;
                    if (indef_wanted == 0) indef_wanted = INDEF_ALL_WANTED;
                }
            }

            #Ifdef DEBUG;
            if (parser_trace >= 5) print "    Matched (", k, ")^";
            #Endif; ! DEBUG
            if (nomatch == false) MakeMatch(obj,k);
            return k;
        }
        if (k == 0) jump NoWordsMatch;
    }

    ! The default algorithm is simply to count up how many words pass the
    ! Refers test:

    parser_action = NULL;

    w = NounWord();

    if (w == 1 && player == obj) { k=1; jump MMbyPN; }

    if (w >= 2 && w < 128 && (LanguagePronouns-->w == obj)) { k = 1; jump MMbyPN; }

    if (Refers(obj, wn-1) == 0) {
        .NoWordsMatch;
        if (indef_mode ~= 0) { k = 0; parser_action = NULL; jump MMbyPN; }
        rfalse;
    }

	threshold = 1;
	dict_flags_of_noun = (w->#dict_par1) & $$01110100;
	w = NextWord();
	while (Refers(obj, wn-1)) {
		threshold++;
		if (w)
		   dict_flags_of_noun = dict_flags_of_noun | ((w->#dict_par1) & $$01110100);
		w = NextWord();
	}

    k = threshold;
    jump MMbyPN;
];

[ Refers obj wnum   wd k l m;
    if (obj == 0) rfalse;

    #Ifdef LanguageRefers;
    k = LanguageRefers(obj,wnum); if (k >= 0) return k;
    #Endif; ! LanguageRefers

    k = wn; wn = wnum; wd = NextWordStopped(); wn = k;

    if (parser_inflection >= 256) {
        k = indirect(parser_inflection, obj, wd);
        if (k >= 0) return k;
        m = -k;
    }
    else
        m = parser_inflection;
    k = obj.&m; l = (obj.#m)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];

[ WordInProperty wd obj prop k l m;
    k = obj.&prop; l = (obj.#prop)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];

[ NounWord i j s;
    i = NextWord();
    if (i == 0) rfalse;
    if (i == ME1__WD or ME2__WD or ME3__WD) return 1;
    s = LanguagePronouns-->0;
    for (j=1 : j<=s : j=j+3)
        if (i == LanguagePronouns-->j)
            return j+2;
    if ((i->#dict_par1)&128 == 0) rfalse;
    return i;
];

[ TryNumber wordnum   i j c num len mul tot d digit;
    i = wn; wn = wordnum; j = NextWord(); wn = i;
    j = NumberWord(j); ! Test for verbal forms ONE to TWENTY
    if (j >= 1) return j;

    #Ifdef TARGET_ZCODE;
    i = wordnum*4+1; j = parse->i; num = j+buffer; len = parse->(i-1);
    #Ifnot; ! TARGET_GLULX
    i = wordnum*3; j = parse-->i; num = j+buffer; len = parse-->(i-1);
    #Endif; ! TARGET_

    if (len >= 4) mul=1000;
    if (len == 3) mul=100;
    if (len == 2) mul=10;
    if (len == 1) mul=1;

    tot = 0; c = 0; len = len-1;

    for (c=0 : c<=len : c++) {
        digit=num->c;
        if (digit == '0') { d = 0; jump digok; }
        if (digit == '1') { d = 1; jump digok; }
        if (digit == '2') { d = 2; jump digok; }
        if (digit == '3') { d = 3; jump digok; }
        if (digit == '4') { d = 4; jump digok; }
        if (digit == '5') { d = 5; jump digok; }
        if (digit == '6') { d = 6; jump digok; }
        if (digit == '7') { d = 7; jump digok; }
        if (digit == '8') { d = 8; jump digok; }
        if (digit == '9') { d = 9; jump digok; }
        return -1000;
     .digok;
        tot = tot+mul*d; mul = mul/10;
    }
    if (len > 3) tot=10000;
    return tot;
];

[ I7_ExtendedTryNumber wordnum i j;
	i = wn; wn = wordnum; j = NextWordStopped(); wn = i;
	switch (j) {
		'twenty-one': return 21;
		'twenty-two': return 22;
		'twenty-three': return 23;
		'twenty-four': return 24;
		'twenty-five': return 25;
		'twenty-six': return 26;
		'twenty-seven': return 27;
		'twenty-eight': return 28;
		'twenty-nine': return 29;
		'thirty': return 30;
		default: return TryNumber(wordnum);
	}
];

[ GetGender person;
    if (person hasnt female) rtrue;
    rfalse;
];

[ GetGNAOfObject obj case gender;
    if (obj hasnt animate) case = 6;
    if (obj has male) gender = male;
    if (obj has female) gender = female;
    if (obj has neuter) gender = neuter;
    if (gender == 0) {
        if (case == 0) gender = LanguageAnimateGender;
        else gender = LanguageInanimateGender;
    }
    if (gender == female)   case = case + 1;
    if (gender == neuter)   case = case + 2;
    if (obj has pluralname) case = case + 3;
    return case;
];

[ DetectPluralWord at n i w swn outcome;
	swn = wn; wn = at;
	for (i=0:i<n:i++) {
		w = NextWordStopped();
		if (w == 0 or THEN1__WD or COMMA_WORD or -1) break;
		if ((w->#dict_par1) & $$00000100) {
			parser_action = ##PluralFound;
			outcome = true;
		}
	}
	wn = swn;
	return outcome;
];

[ SetPronoun dword value x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword) {
            LanguagePronouns-->(x+2) = value; return;
        }
    RunTimeError(14);
];

[ PronounValue dword x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword)
            return LanguagePronouns-->(x+2);
    return 0;
];

[ ResetVagueWords obj; PronounNotice(obj); ];

[ PronounNotice obj x bm;
    if (obj == player) return;

    bm = PowersOfTwo_TB-->(GetGNAOfObject(obj));

    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (bm & (LanguagePronouns-->(x+1)) ~= 0)
            LanguagePronouns-->(x+2) = obj;
];

[ PronounNoticeHeldObjects x;
#IFNDEF MANUAL_PRONOUNS;
	objectloop(x in player) PronounNotice(x);
#ENDIF;
	x = 0; ! To prevent a "not used" error
	rfalse;
];

[ YesOrNo i j;
    for (::) {
        #Ifdef TARGET_ZCODE;
        if (location == nothing || parent(player) == nothing) read buffer parse;
        else read buffer parse DrawStatusLine;
        j = parse->1;
        #Ifnot; ! TARGET_GLULX;
        KeyboardPrimitive(buffer, parse);
        j = parse-->0;
        #Endif; ! TARGET_
        if (j) { ! at least one word entered
            i = parse-->1;
            if (i == YES1__WD or YES2__WD or YES3__WD) rtrue;
            if (i == NO1__WD or NO2__WD or NO3__WD) rfalse;
        }
        L__M(##Quit, 1); print "> ";
    }
];

[ NumberWord o i n;
    n = LanguageNumbers-->0;
    for (i=1 : i<=n : i=i+2)
        if (o == LanguageNumbers-->i) return LanguageNumbers-->(i+1);
    return 0;
];

!Constant COBJ_DEBUG;

! the highest value returned by CheckDPMR (see the Standard Rules)
Constant HIGHEST_DPMR_SCORE = 4;

Array alt_match_list --> (MATCH_LIST_WORDS+1);

#ifdef TARGET_GLULX;
[ COBJ__Copy words from to  i;
	for (i=0: i<words: i++)
		to-->i = from-->i;
];
#ifnot;
[ COBJ__Copy words from to  bytes;
	bytes = words * 2;
	@copy_table from to bytes;
];
#endif;

! swap alt_match_list with match_list/number_matched
[ COBJ__SwapMatches i x;
	! swap the counts
	x = number_matched;
	number_matched = alt_match_list-->0;
	alt_match_list-->0 = x;
	! swap the values
	if (x < number_matched) x = number_matched;
	for (i=x: i>0: i--) {
		x = match_list-->(i-1);
		match_list-->(i-1) = alt_match_list-->i;
		alt_match_list-->i = x;
	}
];

[ ChooseObjects obj code  l i swn spcount;
	if (code<2) rfalse;

	if (cobj_flag == 1) {
		.CodeOne;
		if (parameters > 0) {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (second)]^";
			#endif;
			return ScoreDabCombo(parser_results-->INP1_PRES, obj);
		} else {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (first) in ",
				alt_match_list-->0, " combinations]^";
			#endif;
			l = 0;
			for (i=1: i<=alt_match_list-->0: i++) {
				spcount = ScoreDabCombo(obj, alt_match_list-->i);
				if (spcount == HIGHEST_DPMR_SCORE) {
					#ifdef COBJ_DEBUG;
					print "[scored ", spcount, " - best possible]^";
					#endif;
					return spcount;
				}
				if (spcount>l) l = spcount;
			}
			return l;
		}
	}
	if (cobj_flag == 2) {
		.CodeTwo;
		#ifdef COBJ_DEBUG;
		print "[scoring ", (the) obj, " (simple); parameters = ", parameters,
			" aw = ", advance_warning, "]^";
		#endif;
		@push action_to_be;
		if (parameters==0) {
			if (advance_warning > 0)
				l = ScoreDabCombo(obj, advance_warning);
			else
				l = ScoreDabCombo(obj, 0);
		} else {
			l = ScoreDabCombo(parser_results-->INP1_PRES, obj);
		}
		@pull action_to_be;
		return l;
	}

	#ifdef COBJ_DEBUG;
	print "[choosing a cobj strategy: ";
	#endif;
	swn = wn;
	spcount = pcount;
	while (line_ttype-->pcount == PREPOSITION_TT) pcount++;
	if (line_ttype-->pcount == ELEMENTARY_TT) {
		while (wn <= num_words) {
			l = NextWordStopped(); wn--;
			if ( (l ~= -1 or 0) && (l->#dict_par1) &8 ) { wn++; continue; }	! if preposition
			if (l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) { wn++; continue; }
			SafeSkipDescriptors();
			! save the current match state
			@push match_length; @push token_filter; @push match_from;
			alt_match_list-->0 = number_matched;
			COBJ__Copy(number_matched, match_list, alt_match_list+WORDSIZE);
			! now get all the matches for the second noun
			match_length = 0; number_matched = 0; match_from = wn;
			token_filter = 0;
			SearchScope(actor, actors_location, line_tdata-->pcount);
			#ifdef COBJ_DEBUG;
			print number_matched, " possible second nouns]^";
			#endif;
			wn = swn;
			cobj_flag = 1;
			! restore match variables
			COBJ__SwapMatches();
			@pull match_from; @pull token_filter; @pull match_length;
			pcount = spcount;
			jump CodeOne;
		}
	}
	pcount = spcount;
	wn = swn;	
	
	#ifdef COBJ_DEBUG;
	print "nothing interesting]^";
	#endif;
	cobj_flag = 2;
	jump CodeTwo;
];

[ ScoreDabCombo a b  result;
	@push action; @push act_requester; @push noun; @push second;
	action = action_to_be;
	act_requester = player;
	if (action_reversed) { noun = b; second = a; }
	else { noun = a; second = b; }
	result = CheckDPMR();
	@pull second; @pull noun; @pull act_requester; @pull action;
	#ifdef COBJ_DEBUG;
	print "[", (the) a, " / ", (the) b, " => ", result, "]^";
	#endif;
	return result;
];

[ DefaultTopic; return GPR_FAIL; ];



[ ParserError error_type;
	if (error_type ofclass String or Routine) PrintSingleParagraph(error_type);
	rfalse;
];

Object InformLibrary "(Inform Library)" has proper;

Array Protect_I7_Arrays --> 16339 12345;

Global EarlyInTurnSequence;

[ Main;
	#ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
	ProcessRulebook(STARTUP_RB);
	#ifdef DEBUG; InternalTestCases(); #endif;
	while (true) {
		while (deadflag == false) {
			EarlyInTurnSequence = true;
			action = ##Wait; meta = false; noun = nothing; second = nothing;
			actor = player;
			FollowRulebook(TURN_SEQUENCE_RB);
		}
		if (FollowRulebook(SHUTDOWN_RB) == false) return;
	}
];

[ VIRTUAL_MACHINE_STARTUP_R;
	ProcessRulebook(Activity_before_rulebooks-->STARTING_VIRTUAL_MACHINE_ACT);
	ProcessRulebook(Activity_for_rulebooks-->STARTING_VIRTUAL_MACHINE_ACT);
	ProcessRulebook(Activity_after_rulebooks-->STARTING_VIRTUAL_MACHINE_ACT);

	VM_Initialise();

	print "^^^";
	rfalse;
];

Constant PLAYER_OBJECT_INIS = 0;
Constant START_OBJECT_INIS = 1;
Constant START_ROOM_INIS = 2;
Constant START_TIME_INIS = 3;
Constant DONE_INIS = 4;

Array InitialSituation --> O37_knock nothing O66_middle_of_nowhere 540 0;



[ INITIALISE_MEMORY_R;
	#ifdef TARGET_GLULX; VM_PreInitialise(); #Endif;
	#Ifdef LanguageInitialise; LanguageInitialise(); #Endif;

	not_yet_in_play = true;
	#ifdef I7_LOOKMODE; lookmode = I7_LOOKMODE; #endif;
	player = InitialSituation-->PLAYER_OBJECT_INIS;
	the_time = InitialSituation-->START_TIME_INIS;
	real_location = nothing;
	location = nothing;

	CreatePropertyOffsets();
	HeapInitialise(); ! Create a completely unused memory allocation heap
	InitialHeapAllocation(); ! Allocate empty blocks for variables, properties, and such
	CreateBlockConstants(); ! Allocate and fill in blocks for constant values
	DistributeBlockConstants(); ! Ensure these exist in multiple independent copies when needed
	CreateDynamicRelations(); ! Create relation structures on the heap

	rfalse;
];

[ SEED_RANDOM_NUMBER_GENERATOR_R i;
	if (-16339) VM_Seed_RNG(-16339);
	for (i=1: i<=100: i++) random(i);
	rfalse;
];

[ POSITION_PLAYER_IN_MODEL_R player_to_be;

	player = selfobj;
	player_to_be = InitialSituation-->PLAYER_OBJECT_INIS;
	
	location = LocationOf(player_to_be);
	if (location == 0) {
		location = InitialSituation-->START_ROOM_INIS;
		if (InitialSituation-->START_OBJECT_INIS)
			move player_to_be to InitialSituation-->START_OBJECT_INIS;
		else move player_to_be to location;
	}

	if (player_to_be ~= player) { remove selfobj; ChangePlayer(player_to_be); }

	real_location = location; SilentlyConsiderLight();

	NOTE_OBJECT_ACQUISITIONS_R(); MoveFloatingObjects();
	
	actor = player; act_requester = nothing; actors_location = real_location; action = ##Wait;

	InitialSituation-->DONE_INIS = true;
	rfalse;
];

Constant ACTION_PRES = 0;
Constant NO_INPS_PRES = 1;
Constant INP1_PRES = 2;
Constant INP2_PRES = 3; ! Parser.i6t code assumes this is INP1_PRES + 1

[ PARSE_COMMAND_R;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	not_yet_in_play = false;

	Parser__parse();
	TreatParserResults();
	rfalse;
];

[ TreatParserResults;
	if (parser_results-->ACTION_PRES == ##MistakeAction) meta = true;

	if (parser_results-->ACTION_PRES == ##Tell &&
		parser_results-->INP1_PRES == player && actor ~= player) {
		parser_results-->ACTION_PRES = ##Ask;
		parser_results-->INP1_PRES = actor; actor = player;
	}
];

[ GENERATE_ACTION_R i j k l;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	EarlyInTurnSequence = false;

	action = parser_results-->ACTION_PRES;
	act_requester = nothing; if (actor ~= player) act_requester = player;

	inp1 = 0; inp2 = 0; multiflag = false;
	if (parser_results-->NO_INPS_PRES >= 1) {
		inp1 = parser_results-->INP1_PRES; if (inp1 == 0) multiflag = true;
	}
	if (parser_results-->NO_INPS_PRES >= 2) {
		inp2 = parser_results-->INP2_PRES; if (inp2 == 0) multiflag = true;
	}

	if (inp1 == 1) {
		noun = nothing; ! noun = special_number1;
	} else noun = inp1;
	if (inp2 == 1) {
		second = nothing;
		! if (inp1 == 1) second = special_number2; else second = special_number1;
	} else second = inp2;

	if (multiflag) {
		if (multiple_object-->0 == 0) { L__M(##Miscellany, 2); return; }
		if (toomany_flag) { toomany_flag = false; L__M(##Miscellany, 1); }
		GenerateMultipleActions();
		multiflag = false;
	} else BeginAction(action, noun, second);

	if ((actor ~= player) || (act_requester)) action = ##Wait;
	actor = player; act_requester = 0;

	if (meta) { RulebookSucceeds(); rtrue; }
	rfalse;
];

[ GenerateMultipleActions initial_location k item;
	initial_location = location;
	for (k=1: k<=multiple_object-->0: k++) {
		item = multiple_object-->k;
		RunParagraphOn();
		if (inp1 == 0) { inp1 = item; BeginAction(action, item, second, item); inp1 = 0; }
		else { inp2 = item; BeginAction(action, noun, item, item); inp2 = 0; }
		if (deadflag) return;
		if (location ~= initial_location) { L__M(##Miscellany, 51); return; }
	}
];

[ TIMED_EVENTS_R i event_timer fire rule;
	for (i=1: i<=(TimedEventsTable-->0): i++)
		if ((rule=TimedEventsTable-->i) ~= 0) {
			event_timer = TimedEventTimesTable-->i; fire = false;
			if (event_timer<0) {
				(TimedEventTimesTable-->i)++;
				if (TimedEventTimesTable-->i == 0) fire = true;
			} else {
				if ((the_time >= event_timer) && (the_time < event_timer+30)) fire = true;
			}
			if (fire) {
				TimedEventsTable-->i = 0;
				ProcessRulebook(rule);
			}
		}
	rfalse;
];

[ SetTimedEvent rule event_time absolute_time i b;
	for (i=1: i<=(TimedEventsTable-->0): i++) {
		if (rule == TimedEventsTable-->i) { b=i; break; }
		if ((b==0) && (TimedEventsTable-->i == 0)) b=i;
	}
	if (b==0) return RunTimeProblem(RTP_TOOMANYEVENTS);
	TimedEventsTable-->b = rule;
	if (absolute_time) TimedEventTimesTable-->b = event_time;
	else TimedEventTimesTable-->b = -event_time;
];

Global time_step;

[ SetTime t s;
    the_time = t; time_rate = s; time_step = 0;
    if (s < 0) time_step = 0-s;
];

[ ADVANCE_TIME_R;
    turns++;
    if (the_time ~= NULL) {
        if (time_rate >= 0) the_time = the_time+time_rate;
        else {
            time_step--;
            if (time_step == 0) {
                the_time++;
                time_step = -time_rate;
            }
        }
        the_time = the_time % TWENTY_FOUR_HOURS;
    }
	rfalse;
];

[ NOTE_OBJECT_ACQUISITIONS_R obj;
    objectloop (obj in player) give obj moved ~concealed;
    #Ifdef RUCKSACK_CLASS;
	objectloop (obj in player)
		if (obj ofclass RUCKSACK_CLASS)
			SACK_OBJECT = obj;
	objectloop (obj ofclass RUCKSACK_CLASS && obj provides component_parent
		&& obj.component_parent == player)
		SACK_OBJECT = obj;
	#Endif;
	rfalse;
];

[ RESURRECT_PLAYER_IF_ASKED_R;
	if (resurrect_please) {
		RulebookSucceeds(); resurrect_please = false;
		deadflag = 0; story_complete = false; rtrue;
	}
	rfalse;
];

[ ASK_FINAL_QUESTION_R;
	print "^";
	while (true) {
		CarryOutActivity(DEALING_WITH_FINAL_QUESTION_ACT);
		DivideParagraphPoint();
    }
];

[ READ_FINAL_ANSWER_R;
	DrawStatusLine();
	KeyboardPrimitive(buffer, parse);
	players_command = 100 + WordCount();
	num_words = WordCount();
	wn = 1;
	rfalse;
];

[ IMMEDIATELY_RESTART_VM_R; @restart; ];

[ IMMEDIATELY_RESTORE_SAVED_R; actor = player; RESTORE_THE_GAME_R(); ];

[ IMMEDIATELY_QUIT_R; @quit; ];

[ IMMEDIATELY_UNDO_R;
	if (not_yet_in_play == false) turns++;
	Perform_Undo();
	if (not_yet_in_play == false) turns--;
];

[ PRINT_OBITUARY_HEADLINE_R;
    print "^^    ";
    VM_Style(ALERT_VMSTY);
    print "***";
    if (deadflag == 1) L__M(##Miscellany, 3);
    if (deadflag == 2) L__M(##Miscellany, 4);
    if (deadflag == 3) L__M(##Miscellany, 75);
    if (deadflag ~= 0 or 1 or 2 or 3)  {
        print " ";
        if (deadflag ofclass Routine) (deadflag)();
		if (deadflag ofclass String) print (string) deadflag;
        print " ";
    }
    print "***";
    VM_Style(NORMAL_VMSTY);
    print "^^"; #Ifndef NO_SCORE; print "^"; #Endif;
    rfalse;
];

[ PRINT_FINAL_SCORE_R;
	#Ifndef NO_SCORING; ANNOUNCE_SCORE_R(); #Endif;
	rfalse;
];

[ DISPLAY_FINAL_STATUS_LINE_R;
	sline1 = score; sline2 = turns;
	rfalse;
];


Constant p3_printed_name = short_name;
Constant p4_printed_plural_name = plural;
Constant p5_indefinite_article = article;
Constant p6_description = description;
Constant p7_map_region = map_region;
Constant p8_initial_appearance = initial;
Constant p10_other_side = door_to;
Constant p11_carrying_capacity = capacity;
Constant p12_matching_key = with_key;
Constant p24_plural_named = pluralname;
Constant p26_proper_named = proper;
Constant p28_privately_named = privately_named;
Constant p30_lighted = light;
Constant p32_visited = visited;
Constant p34_lit = light;
Constant p36_edible = edible;
Constant p38_fixed_in_place = static;
Constant p40_scenery = scenery;
Constant p41_wearable = clothing;
Constant p42_pushable_between_rooms = pushable;
Constant p43_handled = moved;
Constant p45_undescribed = concealed;
Constant p46_marked_for_listing = workflag;
Constant p48_mentioned = mentioned;
Constant p50_enterable = enterable;
Constant p52_transparent = transparent;
Constant p53_open = open;
Constant p55_openable = openable;
Constant p57_lockable = lockable;
Constant p58_locked = locked;
Constant p60_female = female;
Constant p62_neuter = neuter;
Constant p63_switched_on = on;
Constant p87 = worn;
Constant p88 = component_parent;
Constant p89 = component_child;
Constant p90 = component_sibling;
Constant p91 = found_in;
Constant p92 = vector;
Constant p93 = mark_as_room;
Constant p94 = mark_as_thing;
Constant p95 = room_index;
Constant p96 = door_dir;
Constant p97 = door_to;
Constant p98 = absent;
Constant p99 = cap_short_name;
Constant p100 = list_together;
Constant p101 = regional_found_in;
Constant p102 = IK_0;
Constant p103 = IK0_Link;
Constant p104 = IK_1;
Constant p105 = IK1_Link;
Constant p106 = IK_2;
Constant p107 = IK2_Link;
Constant p108 = IK_3;
Constant p109 = IK3_Link;
Constant p110 = IK_4;
Constant p111 = IK4_Link;
Constant p112 = IK_5;
Constant p113 = IK5_Link;
Constant p114 = IK_6;
Constant p115 = IK6_Link;
Constant p116 = IK_7;
Constant p117 = IK7_Link;
Constant p118 = IK_8;
Constant p119 = IK8_Link;
Constant p120 = IK_9;
Constant p121 = IK9_Link;
Constant p122 = IK_23;
Constant p123 = IK23_Link;
Constant p124 = IK_24;
Constant p125 = IK24_Link;
Constant p126 = IK_25;
Constant p127 = IK25_Link;
Constant p128 = IK_26;
Constant p129 = IK26_Link;
Constant p130 = IK_27;
Constant p131 = IK27_Link;
Constant p132 = IK_28;
Constant p133 = IK28_Link;
Constant p134 = IK_29;
Constant p135 = IK29_Link;
Constant p136 = IK_30;
Constant p137 = IK30_Link;
Constant p138 = IK_43;
Constant p139 = IK43_Link;
Constant p140 = IK_72;
Constant p141 = IK72_Link;
Constant p142 = IK_78;
Constant p143 = IK78_Link;
Constant p144 = IK_119;
Constant p145 = IK119_Link;
Constant p146 = IK_150;
Constant p147 = IK150_Link;
Constant p148 = IK_165;
Constant p149 = IK165_Link;
Constant p150 = IK_169;
Constant p151 = IK169_Link;
Constant p152 = name;
Constant p153 = parse_name;
Constant p154 = action_bitmap;

Attribute p67_seen;
Attribute p69_familiar;
Attribute p71_ambiguously_plural;
Attribute p74_on;
Attribute p76_retrieved;
Attribute p80_noted_as_useful;
Attribute p81_hefty;
Attribute p82_dim;
Attribute p84_placed_correctly;
Attribute p86_named;
Constant FBNA_PROP_NUMBER = p65_recurring;
Object property_numberspace_forcer
    with p65_recurring false
    with p85_dramatic false
;

Array property_metadata -->
    ! offset 0: property p0_specification
    "specification" NULL
    ! offset 2: property p1_indefinite_appearance_tex
    "indefinite appearance text" NULL
    ! offset 4: property p2_variable_initial_value
    "variable initial value" K1_room K2_thing K3_direction K9_region NULL
    ! offset 10: property short_name
    "printed name" K1_room K2_thing K3_direction K9_region NULL
    ! offset 16: property plural
    "printed plural name" K1_room K2_thing K3_direction K9_region NULL
    ! offset 22: property article
    "indefinite article" K1_room K2_thing K3_direction K9_region NULL
    ! offset 28: property description
    "description" K1_room K2_thing NULL
    ! offset 32: property map_region
    "map region" K1_room NULL
    ! offset 35: property initial
    "initial appearance" K2_thing NULL
    ! offset 38: property p9_opposite
    "opposite" K3_direction NULL
    ! offset 41: property door_to
    "other side" K4_door NULL
    ! offset 44: property capacity
    "carrying capacity" K5_container K6_supporter K8_person NULL
    ! offset 49: property with_key
    "matching key" K2_thing K4_door K5_container NULL
    ! offset 54: property p13_ask_suggestions
    "ask-suggestions" K8_person NULL
    ! offset 57: property p14_tell_suggestions
    "tell-suggestions" K8_person NULL
    ! offset 60: property p15_other_suggestions
    "other-suggestions" K8_person NULL
    ! offset 63: property p16_seqno
    "seqno" K30_misc_suggestion NULL
    ! offset 66: property p17_count
    "count" O39_pack_of_cigarettes NULL
    ! offset 69: property p18_frequency_tuned_to
    "frequency tuned to" O118_emergency_radio NULL
    ! offset 72: property p19_maximum_frequency
    "maximum frequency" O118_emergency_radio NULL
    ! offset 75: property p20_minimum_frequency
    "minimum frequency" O118_emergency_radio NULL
    ! offset 78: property p21_price
    "price" K165_spirit_animal NULL
    ! offset 81: property p22_path
    "path" O181_darting_shadow NULL
    ! offset 84: property p23_times_followed
    "times followed" O181_darting_shadow NULL
    ! offset 87: property pluralname
    "plural-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 93: property proper
    "proper-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 99: property privately_named
    "privately-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 105: property light
    "lighted" K1_room K2_thing NULL
    ! offset 109: property visited
    "visited" K1_room NULL
    ! offset 112: property light
    "lit" K1_room K2_thing NULL
    ! offset 116: property edible
    "edible" K2_thing NULL
    ! offset 119: property static
    "fixed in place" K2_thing NULL
    ! offset 122: property scenery
    "scenery" K2_thing NULL
    ! offset 125: property clothing
    "wearable" K2_thing NULL
    ! offset 128: property pushable
    "pushable between rooms" K2_thing NULL
    ! offset 131: property moved
    "handled" K2_thing NULL
    ! offset 134: property concealed
    "undescribed" K2_thing NULL
    ! offset 137: property workflag
    "marked for listing" K2_thing K3_direction NULL
    ! offset 141: property mentioned
    "mentioned" K2_thing NULL
    ! offset 144: property enterable
    "enterable" K5_container K6_supporter NULL
    ! offset 148: property transparent
    "transparent" K5_container NULL
    ! offset 151: property open
    "open" K4_door K5_container O86_photo K119_window NULL
    ! offset 157: property openable
    "openable" K4_door K5_container O86_photo NULL
    ! offset 162: property lockable
    "lockable" K4_door K5_container NULL
    ! offset 166: property locked
    "locked" K4_door K5_container NULL
    ! offset 170: property female
    "female" K8_person NULL
    ! offset 173: property neuter
    "neuter" K2_thing K8_person NULL
    ! offset 177: property on
    "switched on" K26_device NULL
    ! offset 180: property p65_recurring
    "recurring" NULL
    ! offset 182: property p67_seen
    "seen" K2_thing NULL
    ! offset 185: property p69_familiar
    "familiar" K2_thing NULL
    ! offset 188: property p71_ambiguously_plural
    "ambiguously plural" K2_thing NULL
    ! offset 191: property p73_message_text
    "message text" NULL
    ! offset 193: property p74_on
    "on" O35_library_message_debug NULL
    ! offset 196: property p76_retrieved
    "retrieved" K43_memory NULL
    ! offset 199: property p78_suggested_memory
    "suggested memory" K2_thing NULL
    ! offset 202: property p79_objective
    "objective" K2_thing NULL
    ! offset 205: property p80_noted_as_useful
    "noted as useful" K2_thing NULL
    ! offset 208: property p81_hefty
    "hefty" K2_thing NULL
    ! offset 211: property p82_dim
    "dim" O69_staging_area NULL
    ! offset 214: property p84_placed_correctly
    "placed correctly" O144_huge_metal_barrel NULL
    ! offset 217: property p85_dramatic
    "dramatic" NULL
    ! offset 219: property p86_named
    "named" O168_sand_dancer NULL
    ! offset 222: property worn
    "<nameless>" NULL
    ! offset 224: property component_parent
    "<nameless>" NULL
    ! offset 226: property component_child
    "<nameless>" NULL
    ! offset 228: property component_sibling
    "<nameless>" NULL
    ! offset 230: property found_in
    "<nameless>" NULL
    ! offset 232: property vector
    "<nameless>" NULL
    ! offset 234: property mark_as_room
    "<nameless>" NULL
    ! offset 236: property mark_as_thing
    "<nameless>" NULL
    ! offset 238: property room_index
    "<nameless>" NULL
    ! offset 240: property door_dir
    "<nameless>" NULL
    ! offset 242: property door_to
    "<nameless>" K4_door NULL
    ! offset 245: property absent
    "<nameless>" NULL
    ! offset 247: property cap_short_name
    "<nameless>" NULL
    ! offset 249: property list_together
    "<nameless>" NULL
    ! offset 251: property regional_found_in
    "<nameless>" NULL
    ! offset 253: property IK_0
    "<nameless>" NULL
    ! offset 255: property IK0_Link
    "<nameless>" NULL
    ! offset 257: property IK_1
    "<nameless>" NULL
    ! offset 259: property IK1_Link
    "<nameless>" NULL
    ! offset 261: property IK_2
    "<nameless>" NULL
    ! offset 263: property IK2_Link
    "<nameless>" NULL
    ! offset 265: property IK_3
    "<nameless>" NULL
    ! offset 267: property IK3_Link
    "<nameless>" NULL
    ! offset 269: property IK_4
    "<nameless>" NULL
    ! offset 271: property IK4_Link
    "<nameless>" NULL
    ! offset 273: property IK_5
    "<nameless>" NULL
    ! offset 275: property IK5_Link
    "<nameless>" NULL
    ! offset 277: property IK_6
    "<nameless>" NULL
    ! offset 279: property IK6_Link
    "<nameless>" NULL
    ! offset 281: property IK_7
    "<nameless>" NULL
    ! offset 283: property IK7_Link
    "<nameless>" NULL
    ! offset 285: property IK_8
    "<nameless>" NULL
    ! offset 287: property IK8_Link
    "<nameless>" NULL
    ! offset 289: property IK_9
    "<nameless>" NULL
    ! offset 291: property IK9_Link
    "<nameless>" NULL
    ! offset 293: property IK_23
    "<nameless>" NULL
    ! offset 295: property IK23_Link
    "<nameless>" NULL
    ! offset 297: property IK_24
    "<nameless>" NULL
    ! offset 299: property IK24_Link
    "<nameless>" NULL
    ! offset 301: property IK_25
    "<nameless>" NULL
    ! offset 303: property IK25_Link
    "<nameless>" NULL
    ! offset 305: property IK_26
    "<nameless>" NULL
    ! offset 307: property IK26_Link
    "<nameless>" NULL
    ! offset 309: property IK_27
    "<nameless>" NULL
    ! offset 311: property IK27_Link
    "<nameless>" NULL
    ! offset 313: property IK_28
    "<nameless>" NULL
    ! offset 315: property IK28_Link
    "<nameless>" NULL
    ! offset 317: property IK_29
    "<nameless>" NULL
    ! offset 319: property IK29_Link
    "<nameless>" NULL
    ! offset 321: property IK_30
    "<nameless>" NULL
    ! offset 323: property IK30_Link
    "<nameless>" NULL
    ! offset 325: property IK_43
    "<nameless>" NULL
    ! offset 327: property IK43_Link
    "<nameless>" NULL
    ! offset 329: property IK_72
    "<nameless>" NULL
    ! offset 331: property IK72_Link
    "<nameless>" NULL
    ! offset 333: property IK_78
    "<nameless>" NULL
    ! offset 335: property IK78_Link
    "<nameless>" NULL
    ! offset 337: property IK_119
    "<nameless>" NULL
    ! offset 339: property IK119_Link
    "<nameless>" NULL
    ! offset 341: property IK_150
    "<nameless>" NULL
    ! offset 343: property IK150_Link
    "<nameless>" NULL
    ! offset 345: property IK_165
    "<nameless>" NULL
    ! offset 347: property IK165_Link
    "<nameless>" NULL
    ! offset 349: property IK_169
    "<nameless>" NULL
    ! offset 351: property IK169_Link
    "<nameless>" NULL
    ! offset 353: property name
    "<nameless>" NULL
    ! offset 355: property parse_name
    "<nameless>" NULL
    ! offset 357: property action_bitmap
    "<nameless>" NULL
;

Constant attributed_property_offsets_SIZE 48;
Array attributed_property_offsets --> attributed_property_offsets_SIZE;
Constant valued_property_offsets_SIZE (100 + 155 + INDIV_PROP_START-48);
Array valued_property_offsets --> valued_property_offsets_SIZE;

[ CreatePropertyOffsets i;
    for (i=0: i<attributed_property_offsets_SIZE: i++)attributed_property_offsets-->i = -1;
    for (i=0: i<valued_property_offsets_SIZE: i++)valued_property_offsets-->i = -1;
    valued_property_offsets-->p0_specification = 0;
    valued_property_offsets-->p1_indefinite_appearance_tex = 2;
    valued_property_offsets-->p2_variable_initial_value = 4;
    valued_property_offsets-->short_name = 10;
    valued_property_offsets-->plural = 16;
    valued_property_offsets-->article = 22;
    valued_property_offsets-->description = 28;
    valued_property_offsets-->map_region = 32;
    valued_property_offsets-->initial = 35;
    valued_property_offsets-->p9_opposite = 38;
    valued_property_offsets-->door_to = 41;
    valued_property_offsets-->capacity = 44;
    valued_property_offsets-->with_key = 49;
    valued_property_offsets-->p13_ask_suggestions = 54;
    valued_property_offsets-->p14_tell_suggestions = 57;
    valued_property_offsets-->p15_other_suggestions = 60;
    valued_property_offsets-->p16_seqno = 63;
    valued_property_offsets-->p17_count = 66;
    valued_property_offsets-->p18_frequency_tuned_to = 69;
    valued_property_offsets-->p19_maximum_frequency = 72;
    valued_property_offsets-->p20_minimum_frequency = 75;
    valued_property_offsets-->p21_price = 78;
    valued_property_offsets-->p22_path = 81;
    valued_property_offsets-->p23_times_followed = 84;
    attributed_property_offsets-->pluralname = 87;
    attributed_property_offsets-->proper = 93;
    attributed_property_offsets-->privately_named = 99;
    attributed_property_offsets-->light = 105;
    attributed_property_offsets-->visited = 109;
    attributed_property_offsets-->light = 112;
    attributed_property_offsets-->edible = 116;
    attributed_property_offsets-->static = 119;
    attributed_property_offsets-->scenery = 122;
    attributed_property_offsets-->clothing = 125;
    attributed_property_offsets-->pushable = 128;
    attributed_property_offsets-->moved = 131;
    attributed_property_offsets-->concealed = 134;
    attributed_property_offsets-->workflag = 137;
    attributed_property_offsets-->mentioned = 141;
    attributed_property_offsets-->enterable = 144;
    attributed_property_offsets-->transparent = 148;
    attributed_property_offsets-->open = 151;
    attributed_property_offsets-->openable = 157;
    attributed_property_offsets-->lockable = 162;
    attributed_property_offsets-->locked = 166;
    attributed_property_offsets-->female = 170;
    attributed_property_offsets-->neuter = 173;
    attributed_property_offsets-->on = 177;
    valued_property_offsets-->p65_recurring = 180;
    attributed_property_offsets-->p67_seen = 182;
    attributed_property_offsets-->p69_familiar = 185;
    attributed_property_offsets-->p71_ambiguously_plural = 188;
    valued_property_offsets-->p73_message_text = 191;
    attributed_property_offsets-->p74_on = 193;
    attributed_property_offsets-->p76_retrieved = 196;
    valued_property_offsets-->p78_suggested_memory = 199;
    valued_property_offsets-->p79_objective = 202;
    attributed_property_offsets-->p80_noted_as_useful = 205;
    attributed_property_offsets-->p81_hefty = 208;
    attributed_property_offsets-->p82_dim = 211;
    attributed_property_offsets-->p84_placed_correctly = 214;
    valued_property_offsets-->p85_dramatic = 217;
    attributed_property_offsets-->p86_named = 219;
    attributed_property_offsets-->worn = 222;
    valued_property_offsets-->component_parent = 224;
    valued_property_offsets-->component_child = 226;
    valued_property_offsets-->component_sibling = 228;
    valued_property_offsets-->found_in = 230;
    valued_property_offsets-->vector = 232;
    attributed_property_offsets-->mark_as_room = 234;
    attributed_property_offsets-->mark_as_thing = 236;
    valued_property_offsets-->room_index = 238;
    valued_property_offsets-->door_dir = 240;
    valued_property_offsets-->door_to = 242;
    attributed_property_offsets-->absent = 245;
    valued_property_offsets-->cap_short_name = 247;
    valued_property_offsets-->list_together = 249;
    valued_property_offsets-->regional_found_in = 251;
    valued_property_offsets-->IK_0 = 253;
    valued_property_offsets-->IK0_Link = 255;
    valued_property_offsets-->IK_1 = 257;
    valued_property_offsets-->IK1_Link = 259;
    valued_property_offsets-->IK_2 = 261;
    valued_property_offsets-->IK2_Link = 263;
    valued_property_offsets-->IK_3 = 265;
    valued_property_offsets-->IK3_Link = 267;
    valued_property_offsets-->IK_4 = 269;
    valued_property_offsets-->IK4_Link = 271;
    valued_property_offsets-->IK_5 = 273;
    valued_property_offsets-->IK5_Link = 275;
    valued_property_offsets-->IK_6 = 277;
    valued_property_offsets-->IK6_Link = 279;
    valued_property_offsets-->IK_7 = 281;
    valued_property_offsets-->IK7_Link = 283;
    valued_property_offsets-->IK_8 = 285;
    valued_property_offsets-->IK8_Link = 287;
    valued_property_offsets-->IK_9 = 289;
    valued_property_offsets-->IK9_Link = 291;
    valued_property_offsets-->IK_23 = 293;
    valued_property_offsets-->IK23_Link = 295;
    valued_property_offsets-->IK_24 = 297;
    valued_property_offsets-->IK24_Link = 299;
    valued_property_offsets-->IK_25 = 301;
    valued_property_offsets-->IK25_Link = 303;
    valued_property_offsets-->IK_26 = 305;
    valued_property_offsets-->IK26_Link = 307;
    valued_property_offsets-->IK_27 = 309;
    valued_property_offsets-->IK27_Link = 311;
    valued_property_offsets-->IK_28 = 313;
    valued_property_offsets-->IK28_Link = 315;
    valued_property_offsets-->IK_29 = 317;
    valued_property_offsets-->IK29_Link = 319;
    valued_property_offsets-->IK_30 = 321;
    valued_property_offsets-->IK30_Link = 323;
    valued_property_offsets-->IK_43 = 325;
    valued_property_offsets-->IK43_Link = 327;
    valued_property_offsets-->IK_72 = 329;
    valued_property_offsets-->IK72_Link = 331;
    valued_property_offsets-->IK_78 = 333;
    valued_property_offsets-->IK78_Link = 335;
    valued_property_offsets-->IK_119 = 337;
    valued_property_offsets-->IK119_Link = 339;
    valued_property_offsets-->IK_150 = 341;
    valued_property_offsets-->IK150_Link = 343;
    valued_property_offsets-->IK_165 = 345;
    valued_property_offsets-->IK165_Link = 347;
    valued_property_offsets-->IK_169 = 349;
    valued_property_offsets-->IK169_Link = 351;
    valued_property_offsets-->name = 353;
    valued_property_offsets-->parse_name = 355;
    valued_property_offsets-->action_bitmap = 357;
];


Constant NUMBER_RULEBOOKS_CREATED = 460;
Constant V0_printing_the_name_of_some = 0;
Constant V1_printing_the_plural_name_ = 1;
Constant V2_printing_a_number_of_some = 2;
Constant V3_printing_room_description = 3;
Constant V4_listing_contents_of_somet = 4;
Constant V5_grouping_together_somethi = 5;
Constant V6_writing_a_paragraph_about = 6;
Constant V7_listing_nondescript_items = 7;
Constant V8_printing_the_name_of_a_da = 8;
Constant V9_printing_the_description_ = 9;
Constant V10_printing_the_announcemen = 10;
Constant V11_printing_the_announcemen = 11;
Constant V12_printing_a_refusal_to_ac = 12;
Constant V13_constructing_the_status_ = 13;
Constant V14_printing_the_banner_text = 14;
Constant V15_reading_a_command = 15;
Constant V16_deciding_the_scope_of_so = 16;
Constant V17_deciding_the_concealed_p = 17;
Constant V18_deciding_whether_all_inc = 18;
Constant V19_clarifying_the_parser_s_ = 19;
Constant V20_asking_which_do_you_mean = 20;
Constant V21_printing_a_parser_error = 21;
Constant V22_supplying_a_missing_noun = 22;
Constant V23_supplying_a_missing_seco = 23;
Constant V24_implicitly_taking_someth = 24;
Constant V25_starting_the_virtual_mac = 25;
Constant V26_amusing_a_victorious_pla = 26;
Constant V27_printing_the_player_s_ob = 27;
Constant V28_handling_the_final_quest = 28;
Constant V29_printing_the_locale_desc = 29;
Constant V30_choosing_notable_locale_ = 30;
Constant V31_printing_a_locale_paragr = 31;
Constant V32_deciding_whether_to_allo = 32;
Constant V33_deciding_whether_the_act = 33;

Array Activity_before_rulebooks --> 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77 80 83 86 89 92 95 98 101 104 107 110 113 116 119 122 417 420 NULL;

Array Activity_for_rulebooks --> 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117 120 123 418 421 NULL;

Array Activity_after_rulebooks --> 31 34 37 40 43 46 49 52 55 58 61 64 67 70 73 76 79 82 85 88 91 94 97 100 103 106 109 112 115 118 121 124 419 422 NULL;

Array Activity_atb_rulebooks -> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 $ff;


Constant RELS_SYMMETRIC $8000;
Constant RELS_EQUIVALENCE $4000;
Constant RELS_X_UNIQUE $2000;
Constant RELS_Y_UNIQUE $1000;
Constant RELS_TEST $0800;
Constant RELS_ASSERT_TRUE $0400;
Constant RELS_ASSERT_FALSE $0200;
Constant RELS_SHOW $0100;
Constant RELS_ROUTE_FIND $0080;
Constant RELS_ROUTE_FIND_COUNT $0040;
#Iftrue (WORDSIZE == 2);
Constant REL_BLOCK_HEADER ($100*5 + $$1101);
#Ifnot;
Constant REL_BLOCK_HEADER ($100*6 + $$1101)*$10000;
#Endif;


[ PrintSceneName value;
    switch(value) {
        Q1_entire_game: print "Entire Game";
        Q339_sinister_voices: print "Sinister Voices";
        Q340_rainstorm: print "Rainstorm";
        Q341_pursuit: print "Pursuit";
        Q342_rabbit_s_offer: print "Rabbit's Offer";
        Q343_temptation: print "Temptation";
        Q344_chase: print "Chase";
        Q345_fight: print "Fight";
        Q346_coyote_s_offer: print "Coyote's Offer";
        Q347_sand_dancer_s_arrival: print "Sand-dancer's Arrival";
        Q348_sand_dancer_s_offer: print "Sand-dancer's Offer";
        default: print "<illegal scene>";
    }
];

[ A_PrintSceneName value;
    return (value % 11)+1;
];
[ B_PrintSceneName value;
    return ((value+9) % 11)+1;
];
[ R_PrintSceneName a b;
    if (a == 0 && b == 0) return (random(11));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintFigureName value;
    switch(value) {
        Q0_figure_of_cover: print "Figure of cover";
        default: print "<illegal figure name>";
    }
];

[ A_PrintFigureName value;
    return (value % 1)+1;
];
[ B_PrintFigureName value;
    return ((value+-1) % 1)+1;
];
[ R_PrintFigureName a b;
    if (a == 0 && b == 0) return (random(1));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintSoundName value;
    switch(value) {
        default: print "<illegal sound name>";
    }
];

[ A_PrintSoundName value;
    return (value % 0)+1;
];
[ B_PrintSoundName value;
    return ((value+-2) % 0)+1;
];
[ R_PrintSoundName a b;
    if (a == 0 && b == 0) return (random(0));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintExternalFileName value;
    switch(value) {
        default: print "<illegal external file>";
    }
];

[ A_PrintExternalFileName value;
    return (value % 0)+1;
];
[ B_PrintExternalFileName value;
    return ((value+-2) % 0)+1;
];
[ R_PrintExternalFileName a b;
    if (a == 0 && b == 0) return (random(0));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T42_command_parser_error value;
    switch(value) {
        Q2_didn_t_understand_error: print "didn't understand error";
        Q3_only_understood_as_far_as: print "only understood as far as error";
        Q4_didn_t_understand_that_nu: print "didn't understand that number error";
        Q5_can_only_do_that_to_somet: print "can only do that to something animate error";
        Q6_can_t_see_any_such_thing_: print "can't see any such thing error";
        Q7_said_too_little_error: print "said too little error";
        Q8_aren_t_holding_that_error: print "aren't holding that error";
        Q9_can_t_use_multiple_object: print "can't use multiple objects error";
        Q10_can_only_use_multiple_ob: print "can only use multiple objects error";
        Q11_not_sure_what_it_refers_: print "not sure what it refers to error";
        Q12_excepted_something_not_i: print "excepted something not included error";
        Q13_not_a_verb_i_recognise_e: print "not a verb I recognise error";
        Q14_not_something_you_need_t: print "not something you need to refer to error";
        Q15_can_t_see_it_at_the_mome: print "can't see it at the moment error";
        Q16_didn_t_understand_the_wa: print "didn't understand the way that finished error";
        Q17_not_enough_of_those_avai: print "not enough of those available error";
        Q18_nothing_to_do_error: print "nothing to do error";
        Q19_noun_did_not_make_sense_: print "noun did not make sense in that context error";
        Q20_referred_to_a_determinat: print "referred to a determination of scope error";
        Q21_i_beg_your_pardon_error: print "I beg your pardon error";
        default: print "<illegal command parser error>";
    }
];

[ A_T42_command_parser_error value;
    return (value % 20)+1;
];
[ B_T42_command_parser_error value;
    return ((value+18) % 20)+1;
];
[ R_T42_command_parser_error a b;
    if (a == 0 && b == 0) return (random(20));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T43_protocol_type value;
    switch(value) {
        Q22_implicit: print "implicit";
        Q23_explicit: print "explicit";
        default: print "<illegal protocol type>";
    }
];

[ A_T43_protocol_type value;
    return (value % 2)+1;
];
[ B_T43_protocol_type value;
    return ((value+0) % 2)+1;
];
[ R_T43_protocol_type a b;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T44_library_message_id value;
    switch(value) {
        Q24_libmsg__you_have_died_: print "LibMsg <you have died>";
        Q25_libmsg__you_have_won_: print "LibMsg <you have won>";
        Q26_libmsg__player_self_desc: print "LibMsg <player self description>";
        Q27_libmsg__unimportant_obje: print "LibMsg <unimportant object>";
        Q28_libmsg__empty_line_: print "LibMsg <empty line>";
        Q29_libmsg__confirm_quit_: print "LibMsg <confirm Quit>";
        Q30_libmsg__yes_or_no_prompt: print "LibMsg <yes or no prompt>";
        Q31_libmsg__restrict_answer_: print "LibMsg <restrict answer>";
        Q32_libmsg__page_prompt_: print "LibMsg <page prompt>";
        Q33_libmsg__menu_prompt_: print "LibMsg <menu prompt>";
        Q34_libmsg__comment_recorded: print "LibMsg <comment recorded>";
        Q35_libmsg__comment_not_reco: print "LibMsg <comment not recorded>";
        Q36_libmsg__undo_succeeded_: print "LibMsg <undo succeeded>";
        Q37_libmsg__undo_failed_: print "LibMsg <undo failed>";
        Q38_libmsg__undo_not_provide: print "LibMsg <undo not provided>";
        Q39_libmsg__cannot_undo_noth: print "LibMsg <cannot undo nothing>";
        Q40_libmsg__cannot_undo_twic: print "LibMsg <cannot undo twice in a row>";
        Q41_libmsg__undo_forbidden_: print "LibMsg <undo forbidden>";
        Q42_libmsg__oops_failed_: print "LibMsg <oops failed>";
        Q43_libmsg__oops_too_many_ar: print "LibMsg <oops too many arguments>";
        Q44_libmsg__oops_no_argument: print "LibMsg <oops no arguments>";
        Q45_libmsg__cannot_do_again_: print "LibMsg <cannot do again>";
        Q46_libmsg__again_usage_: print "LibMsg <again usage>";
        Q47_libmsg__command_not_unde: print "LibMsg <command not understood>";
        Q48_libmsg__command_partly_u: print "LibMsg <command partly understood>";
        Q49_libmsg__command_badly_en: print "LibMsg <command badly ended>";
        Q50_libmsg__command_incomple: print "LibMsg <command incomplete>";
        Q51_libmsg__command_cut_shor: print "LibMsg <command cut short>";
        Q52_libmsg__number_not_under: print "LibMsg <number not understood>";
        Q53_libmsg__cannot_begin_at_: print "LibMsg <cannot begin at comma>";
        Q54_libmsg__extra_words_befo: print "LibMsg <extra words before comma>";
        Q55_libmsg__unknown_object_: print "LibMsg <unknown object>";
        Q56_libmsg__object_not_held_: print "LibMsg <object not held>";
        Q57_libmsg__unknown_verb_: print "LibMsg <unknown verb>";
        Q58_libmsg__verb_cannot_have: print "LibMsg <verb cannot have inanimate object>";
        Q59_libmsg__noun_needed_: print "LibMsg <noun needed>";
        Q60_libmsg__noun_not_needed_: print "LibMsg <noun not needed>";
        Q61_libmsg__object_needed_: print "LibMsg <object needed>";
        Q62_libmsg__object_not_neede: print "LibMsg <object not needed>";
        Q63_libmsg__second_object_ne: print "LibMsg <second object needed>";
        Q64_libmsg__second_object_no: print "LibMsg <second object not needed>";
        Q65_libmsg__second_noun_need: print "LibMsg <second noun needed>";
        Q66_libmsg__second_noun_not_: print "LibMsg <second noun not needed>";
        Q67_libmsg__something_more_s: print "LibMsg <something more substantial needed>";
        Q68_libmsg__verb_cannot_have: print "LibMsg <verb cannot have multiple objects>";
        Q69_libmsg__too_many_multipl: print "LibMsg <too many multiple objects>";
        Q70_libmsg__not_that_many_av: print "LibMsg <not that many available>";
        Q71_libmsg__no_objects_avail: print "LibMsg <no objects available>";
        Q72_libmsg__zero_multiple_ob: print "LibMsg <zero multiple objects>";
        Q73_libmsg__first_n_objects_: print "LibMsg <first N objects>";
        Q74_libmsg__excepted_object_: print "LibMsg <excepted object not included anyway>";
        Q75_libmsg__report_implicit_: print "LibMsg <report implicit take>";
        Q76_libmsg__report_npc_impli: print "LibMsg <report npc implicit take>";
        Q77_libmsg__use_holdall_to_a: print "LibMsg <use holdall to avoid exceeding carrying capacity>";
        Q78_libmsg__cannot_put_if_th: print "LibMsg <cannot put if this exceeds carrying capacity>";
        Q79_libmsg__who_disambiguati: print "LibMsg <who disambiguation>";
        Q80_libmsg__which_disambigua: print "LibMsg <which disambiguation>";
        Q81_libmsg__whom_disambiguat: print "LibMsg <whom disambiguation>";
        Q82_libmsg__what_disambiguat: print "LibMsg <what disambiguation>";
        Q83_libmsg__single_object_di: print "LibMsg <single object disambiguation>";
        Q84_libmsg__pronoun_not_set_: print "LibMsg <pronoun not set>";
        Q85_libmsg__pronoun_absent_: print "LibMsg <pronoun absent>";
        Q86_libmsg__pronouns_initial: print "LibMsg <Pronouns initial text>";
        Q87_libmsg__pronouns__means_: print "LibMsg <Pronouns -means- text>";
        Q88_libmsg__pronouns__unset_: print "LibMsg <Pronouns -unset- text>";
        Q89_libmsg__no_pronouns_know: print "LibMsg <no pronouns known>";
        Q90_libmsg__person_ignores_c: print "LibMsg <person ignores command>";
        Q91_libmsg__cannot_talk_to_a: print "LibMsg <cannot talk to absent person>";
        Q92_libmsg__cannot_talk_to_i: print "LibMsg <cannot talk to inanimate object>";
        Q93_libmsg__npc_unable_to_do: print "LibMsg <npc unable to do that>";
        Q94_libmsg__confirm_restart_: print "LibMsg <confirm Restart>";
        Q95_libmsg__restart_failed_: print "LibMsg <Restart failed>";
        Q96_libmsg__restore_failed_: print "LibMsg <Restore failed>";
        Q97_libmsg__restore_succeede: print "LibMsg <Restore succeeded>";
        Q98_libmsg__save_failed_: print "LibMsg <Save failed>";
        Q99_libmsg__save_succeeded_: print "LibMsg <Save succeeded>";
        Q100_libmsg__verify_succeede: print "LibMsg <Verify succeeded>";
        Q101_libmsg__verify_failed_: print "LibMsg <Verify failed>";
        Q102_libmsg__transcript_alre: print "LibMsg <transcript already on>";
        Q103_libmsg__transcript_alre: print "LibMsg <transcript already off>";
        Q104_libmsg__start_of_transc: print "LibMsg <start of transcript>";
        Q105_libmsg__end_of_transcri: print "LibMsg <end of transcript>";
        Q106_libmsg__transcript_fail: print "LibMsg <transcript failed>";
        Q107_libmsg__end_transcript_: print "LibMsg <end transcript failed>";
        Q108_libmsg__score_command_: print "LibMsg <Score command>";
        Q109_libmsg__score_changed_: print "LibMsg <score changed>";
        Q110_libmsg__score_notificat: print "LibMsg <score notification turned on>";
        Q111_libmsg__score_notificat: print "LibMsg <score notification turned off>";
        Q112_libmsg__no_scoring_: print "LibMsg <no scoring>";
        Q113_libmsg__score_rank_: print "LibMsg <score rank>";
        Q114_libmsg__report_npc_taki: print "LibMsg <report npc taking inventory>";
        Q115_libmsg__inventory_initi: print "LibMsg <Inventory initial text>";
        Q116_libmsg__inventory_no_po: print "LibMsg <Inventory no possessions>";
        Q117_libmsg__entering_darkne: print "LibMsg <entering darkness>";
        Q118_libmsg__dark_descriptio: print "LibMsg <dark description>";
        Q119_libmsg__examine_while_d: print "LibMsg <examine while dark>";
        Q120_libmsg__search_while_da: print "LibMsg <search while dark>";
        Q121_libmsg__look_under_whil: print "LibMsg <look under while dark>";
        Q122_libmsg__dark_room_name_: print "LibMsg <dark room name>";
        Q123_libmsg__report_player_t: print "LibMsg <report player taking>";
        Q124_libmsg__report_npc_taki: print "LibMsg <report npc taking>";
        Q125_libmsg__cannot_take_you: print "LibMsg <cannot take yourself>";
        Q126_libmsg__cannot_take_oth: print "LibMsg <cannot take other people>";
        Q127_libmsg__cannot_take_som: print "LibMsg <cannot take something you are within>";
        Q128_libmsg__cannot_take_som: print "LibMsg <cannot take something already taken>";
        Q129_libmsg__cannot_take_pos: print "LibMsg <cannot take possessions of others>";
        Q130_libmsg__cannot_take_com: print "LibMsg <cannot take component parts>";
        Q131_libmsg__cannot_take_hid: print "LibMsg <cannot take hidden parts>";
        Q132_libmsg__cannot_reach_wi: print "LibMsg <cannot reach within closed containers>";
        Q133_libmsg__cannot_take_sce: print "LibMsg <cannot take scenery>";
        Q134_libmsg__cannot_take_som: print "LibMsg <cannot take something fixed>";
        Q135_libmsg__cannot_reach_wi: print "LibMsg <cannot reach within other places>";
        Q136_libmsg__cannot_exceed_c: print "LibMsg <cannot exceed carrying capacity>";
        Q137_libmsg__report_player_r: print "LibMsg <report player removing>";
        Q138_libmsg__report_npc_remo: print "LibMsg <report npc removing>";
        Q139_libmsg__cannot_remove_f: print "LibMsg <cannot remove from closed containers>";
        Q140_libmsg__cannot_remove_s: print "LibMsg <cannot remove something not within>";
        Q141_libmsg__report_player_d: print "LibMsg <report player dropping>";
        Q142_libmsg__report_npc_drop: print "LibMsg <report npc dropping>";
        Q143_libmsg__cannot_drop_som: print "LibMsg <cannot drop something already dropped>";
        Q144_libmsg__cannot_drop_not: print "LibMsg <cannot drop not holding>";
        Q145_libmsg__cannot_drop_if_: print "LibMsg <cannot drop if this exceeds carrying capacity>";
        Q146_libmsg__cannot_drop_clo: print "LibMsg <cannot drop clothes being worn>";
        Q147_libmsg__report_player_i: print "LibMsg <report player inserting>";
        Q148_libmsg__report_npc_inse: print "LibMsg <report npc inserting>";
        Q149_libmsg__cannot_insert_s: print "LibMsg <cannot insert something not held>";
        Q150_libmsg__cannot_insert_i: print "LibMsg <cannot insert into something not a container>";
        Q151_libmsg__cannot_insert_i: print "LibMsg <cannot insert into closed containers>";
        Q152_libmsg__need_to_take_of: print "LibMsg <need to take off before inserting>";
        Q153_libmsg__cannot_insert_s: print "LibMsg <cannot insert something into itself>";
        Q154_libmsg__cannot_insert_i: print "LibMsg <cannot insert if this exceeds carrying capacity>";
        Q155_libmsg__cannot_insert_c: print "LibMsg <cannot insert clothes being worn>";
        Q156_libmsg__report_player_p: print "LibMsg <report player putting on>";
        Q157_libmsg__report_npc_putt: print "LibMsg <report npc putting on>";
        Q158_libmsg__cannot_put_some: print "LibMsg <cannot put something not held>";
        Q159_libmsg__cannot_put_some: print "LibMsg <cannot put something on it-self>";
        Q160_libmsg__cannot_put_onto: print "LibMsg <cannot put onto something not a supporter>";
        Q161_libmsg__cannot_put_onto: print "LibMsg <cannot put onto something being carried>";
        Q162_libmsg__cannot_put_clot: print "LibMsg <cannot put clothes being worn>";
        Q163_libmsg__report_player_g: print "LibMsg <report player giving>";
        Q164_libmsg__report_npc_givi: print "LibMsg <report npc giving to player>";
        Q165_libmsg__report_npc_givi: print "LibMsg <report npc giving to npc>";
        Q166_libmsg__cannot_give_wha: print "LibMsg <cannot give what you have not got>";
        Q167_libmsg__cannot_give_to_: print "LibMsg <cannot give to yourself>";
        Q168_libmsg__block_giving_: print "LibMsg <block giving>";
        Q169_libmsg__unable_to_recei: print "LibMsg <unable to receive things>";
        Q170_libmsg__cannot_show_wha: print "LibMsg <cannot show what you have not got>";
        Q171_libmsg__block_showing_: print "LibMsg <block showing>";
        Q172_libmsg__report_player_e: print "LibMsg <report player entering>";
        Q173_libmsg__report_npc_ente: print "LibMsg <report npc entering>";
        Q174_libmsg__cannot_enter_so: print "LibMsg <cannot enter something already entered>";
        Q175_libmsg__cannot_enter_so: print "LibMsg <cannot enter something not enterable>";
        Q176_libmsg__cannot_enter_cl: print "LibMsg <cannot enter closed containers>";
        Q177_libmsg__cannot_enter_so: print "LibMsg <cannot enter something carried>";
        Q178_libmsg__implicitly_pass: print "LibMsg <implicitly pass outwards through other barriers>";
        Q179_libmsg__implicitly_pass: print "LibMsg <implicitly pass inwards through other barriers>";
        Q180_libmsg__report_player_e: print "LibMsg <report player exiting>";
        Q181_libmsg__report_npc_exit: print "LibMsg <report npc exiting>";
        Q182_libmsg__cannot_exit_whe: print "LibMsg <cannot exit when not within anything>";
        Q183_libmsg__cannot_exit_clo: print "LibMsg <cannot exit closed containers>";
        Q184_libmsg__cannot_get_off_: print "LibMsg <cannot get off things>";
        Q185_libmsg__cannot_exit_thi: print "LibMsg <cannot exit thing not within>";
        Q186_libmsg__cannot_go_that_: print "LibMsg <cannot go that way>";
        Q187_libmsg__cannot_travel_i: print "LibMsg <cannot travel in something not a vehicle>";
        Q188_libmsg__cannot_go_throu: print "LibMsg <cannot go through concealed doors>";
        Q189_libmsg__cannot_go_up_th: print "LibMsg <cannot go up through closed doors>";
        Q190_libmsg__cannot_go_down_: print "LibMsg <cannot go down through closed doors>";
        Q191_libmsg__cannot_go_throu: print "LibMsg <cannot go through closed doors>";
        Q192_libmsg__nothing_through: print "LibMsg <nothing through door>";
        Q193_libmsg__block_vaguely_g: print "LibMsg <block vaguely going>";
        Q194_libmsg__say_npc_goes_: print "LibMsg <say npc goes>";
        Q195_libmsg__say_npc_arrives: print "LibMsg <say npc arrives>";
        Q196_libmsg__say_npc_arrives: print "LibMsg <say npc arrives from unknown direction>";
        Q197_libmsg__say_npc_arrives: print "LibMsg <say npc arrives at>";
        Q198_libmsg__say_npc_goes_th: print "LibMsg <say npc goes through>";
        Q199_libmsg__say_npc_arrives: print "LibMsg <say npc arrives from>";
        Q200_libmsg__say_npc_vehicle: print "LibMsg <say npc vehicle>";
        Q201_libmsg__say_npc_pushing: print "LibMsg <say npc pushing in front with player>";
        Q202_libmsg__say_npc_pushing: print "LibMsg <say npc pushing in front>";
        Q203_libmsg__say_npc_pushing: print "LibMsg <say npc pushing away>";
        Q204_libmsg__say_npc_pushing: print "LibMsg <say npc pushing in>";
        Q205_libmsg__say_npc_taking_: print "LibMsg <say npc taking player along>";
        Q206_libmsg__brief_look_mode: print "LibMsg <brief look mode>";
        Q207_libmsg__superbrief_look: print "LibMsg <superbrief look mode>";
        Q208_libmsg__verbose_look_mo: print "LibMsg <verbose look mode>";
        Q209_libmsg__report_npc_look: print "LibMsg <report npc looking>";
        Q210_libmsg__top_line_what_o: print "LibMsg <top line what on>";
        Q211_libmsg__top_line_what_i: print "LibMsg <top line what in>";
        Q212_libmsg__top_line_what_a: print "LibMsg <top line what as>";
        Q213_libmsg__say_things_with: print "LibMsg <say things within>";
        Q214_libmsg__say_things_also: print "LibMsg <say things also within>";
        Q215_libmsg__say_things_on_: print "LibMsg <say things on>";
        Q216_libmsg__report_npc_exam: print "LibMsg <report npc examining>";
        Q217_libmsg__examine_undescr: print "LibMsg <examine undescribed things>";
        Q218_libmsg__examine_directi: print "LibMsg <examine direction>";
        Q219_libmsg__examine_devices: print "LibMsg <examine devices>";
        Q220_libmsg__examine_in_dark: print "LibMsg <examine in darkness>";
        Q221_libmsg__report_npc_sear: print "LibMsg <report npc searching>";
        Q222_libmsg__cannot_search_u: print "LibMsg <cannot search unless container or supporter>";
        Q223_libmsg__cannot_search_c: print "LibMsg <cannot search closed opaque containers>";
        Q224_libmsg__nothing_found_w: print "LibMsg <nothing found within container>";
        Q225_libmsg__nothing_found_o: print "LibMsg <nothing found on top of>";
        Q226_libmsg__search_in_darkn: print "LibMsg <search in darkness>";
        Q227_libmsg__report_npc_look: print "LibMsg <report npc looking under>";
        Q228_libmsg__look_under_: print "LibMsg <look under>";
        Q229_libmsg__look_under_in_d: print "LibMsg <look under in darkness>";
        Q230_libmsg__report_player_o: print "LibMsg <report player opening>";
        Q231_libmsg__report_npc_open: print "LibMsg <report npc opening>";
        Q232_libmsg__report_unseen_n: print "LibMsg <report unseen npc opening>";
        Q233_libmsg__cannot_open_unl: print "LibMsg <cannot open unless openable>";
        Q234_libmsg__cannot_open_som: print "LibMsg <cannot open something locked>";
        Q235_libmsg__cannot_open_som: print "LibMsg <cannot open something already open>";
        Q236_libmsg__reveal_any_newl: print "LibMsg <reveal any newly visible exterior initial text>";
        Q237_libmsg__no_newly_visibl: print "LibMsg <no newly visible exterior>";
        Q238_libmsg__report_player_c: print "LibMsg <report player closing>";
        Q239_libmsg__report_npc_clos: print "LibMsg <report npc closing>";
        Q240_libmsg__report_unseen_n: print "LibMsg <report unseen npc closing>";
        Q241_libmsg__cannot_close_un: print "LibMsg <cannot close unless openable>";
        Q242_libmsg__cannot_close_so: print "LibMsg <cannot close something already closed>";
        Q243_libmsg__report_player_l: print "LibMsg <report player locking>";
        Q244_libmsg__report_npc_lock: print "LibMsg <report npc locking>";
        Q245_libmsg__cannot_lock_wit: print "LibMsg <cannot lock without a lock>";
        Q246_libmsg__cannot_lock_som: print "LibMsg <cannot lock something already locked>";
        Q247_libmsg__cannot_lock_som: print "LibMsg <cannot lock something open>";
        Q248_libmsg__cannot_lock_wit: print "LibMsg <cannot lock without the correct key>";
        Q249_libmsg__report_player_u: print "LibMsg <report player unlocking>";
        Q250_libmsg__report_npc_unlo: print "LibMsg <report npc unlocking>";
        Q251_libmsg__cannot_unlock_w: print "LibMsg <cannot unlock without a lock>";
        Q252_libmsg__cannot_unlock_s: print "LibMsg <cannot unlock something already unlocked>";
        Q253_libmsg__cannot_unlock_w: print "LibMsg <cannot unlock without the correct key>";
        Q254_libmsg__report_player_s: print "LibMsg <report player switching on>";
        Q255_libmsg__report_npc_swit: print "LibMsg <report npc switching on>";
        Q256_libmsg__cannot_switch_o: print "LibMsg <cannot switch on unless switchable>";
        Q257_libmsg__cannot_switch_o: print "LibMsg <cannot switch on something already on>";
        Q258_libmsg__report_player_s: print "LibMsg <report player switching off>";
        Q259_libmsg__report_npc_swit: print "LibMsg <report npc switching off>";
        Q260_libmsg__cannot_switch_o: print "LibMsg <cannot switch off unless switchable>";
        Q261_libmsg__cannot_switch_o: print "LibMsg <cannot switch off something already off>";
        Q262_libmsg__report_player_w: print "LibMsg <report player wearing>";
        Q263_libmsg__report_npc_wear: print "LibMsg <report npc wearing>";
        Q264_libmsg__cannot_wear_som: print "LibMsg <cannot wear something not clothing>";
        Q265_libmsg__cannot_wear_not: print "LibMsg <cannot wear not holding>";
        Q266_libmsg__cannot_wear_som: print "LibMsg <cannot wear something already worn>";
        Q267_libmsg__report_player_t: print "LibMsg <report player taking off>";
        Q268_libmsg__report_npc_taki: print "LibMsg <report npc taking off>";
        Q269_libmsg__cannot_take_off: print "LibMsg <cannot take off something not worn>";
        Q270_libmsg__report_player_e: print "LibMsg <report player eating>";
        Q271_libmsg__report_npc_eati: print "LibMsg <report npc eating>";
        Q272_libmsg__cannot_eat_unle: print "LibMsg <cannot eat unless edible>";
        Q273_libmsg__block_drinking_: print "LibMsg <block drinking>";
        Q274_libmsg__block_tasting_: print "LibMsg <block tasting>";
        Q275_libmsg__block_smelling_: print "LibMsg <block smelling>";
        Q276_libmsg__block_listening: print "LibMsg <block listening>";
        Q277_libmsg__report_player_t: print "LibMsg <report player touching things>";
        Q278_libmsg__report_npc_touc: print "LibMsg <report npc touching things>";
        Q279_libmsg__report_player_t: print "LibMsg <report player touching self>";
        Q280_libmsg__report_npc_touc: print "LibMsg <report npc touching self>";
        Q281_libmsg__report_player_t: print "LibMsg <report player touching other people>";
        Q282_libmsg__report_npc_touc: print "LibMsg <report npc touching other people>";
        Q283_libmsg__block_saying_ye: print "LibMsg <block saying yes>";
        Q284_libmsg__block_saying_no: print "LibMsg <block saying no>";
        Q285_libmsg__block_saying_so: print "LibMsg <block saying sorry>";
        Q286_libmsg__block_swearing_: print "LibMsg <block swearing obscenely>";
        Q287_libmsg__block_swearing_: print "LibMsg <block swearing mildly>";
        Q288_libmsg__block_climbing_: print "LibMsg <block climbing>";
        Q289_libmsg__block_jumping_: print "LibMsg <block jumping>";
        Q290_libmsg__block_swinging_: print "LibMsg <block swinging>";
        Q291_libmsg__block_waving_ha: print "LibMsg <block waving hands>";
        Q292_libmsg__block_attacking: print "LibMsg <block attacking>";
        Q293_libmsg__block_burning_: print "LibMsg <block burning>";
        Q294_libmsg__block_cutting_: print "LibMsg <block cutting>";
        Q295_libmsg__block_rubbing_: print "LibMsg <block rubbing>";
        Q296_libmsg__block_setting_t: print "LibMsg <block setting to>";
        Q297_libmsg__block_tying_: print "LibMsg <block tying>";
        Q298_libmsg__report_player_w: print "LibMsg <report player waving things>";
        Q299_libmsg__report_npc_wavi: print "LibMsg <report npc waving things>";
        Q300_libmsg__cannot_wave_som: print "LibMsg <cannot wave something not held>";
        Q301_libmsg__squeezing_peopl: print "LibMsg <squeezing people>";
        Q302_libmsg__report_player_s: print "LibMsg <report player squeezing>";
        Q303_libmsg__report_npc_sque: print "LibMsg <report npc squeezing>";
        Q304_libmsg__block_throwing_: print "LibMsg <block throwing at>";
        Q305_libmsg__throw_at_inanim: print "LibMsg <throw at inanimate object>";
        Q306_libmsg__report_player_p: print "LibMsg <report player pushing>";
        Q307_libmsg__report_npc_push: print "LibMsg <report npc pushing>";
        Q308_libmsg__report_player_p: print "LibMsg <report player pulling>";
        Q309_libmsg__report_npc_pull: print "LibMsg <report npc pulling>";
        Q310_libmsg__report_player_t: print "LibMsg <report player turning>";
        Q311_libmsg__report_npc_turn: print "LibMsg <report npc turning>";
        Q312_libmsg__block_pushing_i: print "LibMsg <block pushing in directions>";
        Q313_libmsg__not_pushed_in_a: print "LibMsg <not pushed in a direction>";
        Q314_libmsg__pushed_in_illeg: print "LibMsg <pushed in illegal direction>";
        Q315_libmsg__cannot_push_som: print "LibMsg <cannot push something fixed in place>";
        Q316_libmsg__cannot_pull_som: print "LibMsg <cannot pull something fixed in place>";
        Q317_libmsg__cannot_turn_som: print "LibMsg <cannot turn something fixed in place>";
        Q318_libmsg__cannot_push_sce: print "LibMsg <cannot push scenery>";
        Q319_libmsg__cannot_pull_sce: print "LibMsg <cannot pull scenery>";
        Q320_libmsg__cannot_turn_sce: print "LibMsg <cannot turn scenery>";
        Q321_libmsg__cannot_push_peo: print "LibMsg <cannot push people>";
        Q322_libmsg__cannot_pull_peo: print "LibMsg <cannot pull people>";
        Q323_libmsg__cannot_turn_peo: print "LibMsg <cannot turn people>";
        Q324_libmsg__block_answering: print "LibMsg <block answering>";
        Q325_libmsg__block_asking_: print "LibMsg <block asking>";
        Q326_libmsg__block_buying_: print "LibMsg <block buying>";
        Q327_libmsg__block_kissing_: print "LibMsg <block kissing>";
        Q328_libmsg__block_singing_: print "LibMsg <block singing>";
        Q329_libmsg__block_telling_: print "LibMsg <block telling>";
        Q330_libmsg__telling_yoursel: print "LibMsg <telling yourself>";
        Q331_libmsg__block_thinking_: print "LibMsg <block thinking>";
        Q332_libmsg__block_player_co: print "LibMsg <block player consulting>";
        Q333_libmsg__block_npc_consu: print "LibMsg <block npc consulting>";
        Q334_libmsg__block_sleeping_: print "LibMsg <block sleeping>";
        Q335_libmsg__block_waking_up: print "LibMsg <block waking up>";
        Q336_libmsg__block_waking_ot: print "LibMsg <block waking other>";
        Q337_libmsg__report_player_w: print "LibMsg <report player waiting>";
        Q338_libmsg__report_npc_wait: print "LibMsg <report npc waiting>";
        default: print "<illegal library message id>";
    }
];

[ A_T44_library_message_id value;
    return (value % 315)+1;
];
[ B_T44_library_message_id value;
    return ((value+313) % 315)+1;
];
[ R_T44_library_message_id a b;
    if (a == 0 && b == 0) return (random(315));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T45_frequency value which rem ran;
    if (value == 0) jump Use_LP_0;
    if ((value - 0) >= 1) jump Use_LP_0;
    if ((value - 0) >= 1) jump Use_LP_1;
    if ((value - 0) >= 1) jump Use_LP_2;
    jump Use_LP_2;
    return;

    ! 100.9khz, with offset=0, multiplier=1

    .Use_LP_0;
    print value/10;
    ! Ran is 1, OM is 1
    if (rem > 0) {
        print ".";
        ran = 1;
        while ((rem % 10 == 0) && (rem > 0)) { rem=rem/10; ran=ran/10; }
        while (rem < ran/10) { print "0"; ran=ran/10; }
        print rem;
    }
    print ".";
    print (value/1)%10;
    print "k";
    print "H";
    print "z";
    return;

    ! 100.9 khz, with offset=0, multiplier=1

    .Use_LP_1;
    print value/10;
    ! Ran is 1, OM is 1
    if (rem > 0) {
        print ".";
        ran = 1;
        while ((rem % 10 == 0) && (rem > 0)) { rem=rem/10; ran=ran/10; }
        while (rem < ran/10) { print "0"; ran=ran/10; }
        print rem;
    }
    print ".";
    print (value/1)%10;
    print " ";
    print "kHz";
    return;

    ! 100.9, with offset=0, multiplier=1

    .Use_LP_2;
    print value/10;
    ! Ran is 1, OM is 1
    if (rem > 0) {
        print ".";
        ran = 1;
        while ((rem % 10 == 0) && (rem > 0)) { rem=rem/10; ran=ran/10; }
        while (rem < ran/10) { print "0"; ran=ran/10; }
        print rem;
    }
    print ".";
    print (value/1)%10;
    return;
];

[ R_T45_frequency a b;
    if (a == 0 && b == 0) return (random(MAX_POSITIVE_NUMBER));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintKindValuePair k v;
    k = KindAtomic(k);
      switch(k) {
        50: print (DA_Number) v;
        51: print (DA_Number) v;
        52: print (DA_Number) v;
        53: print (DA_Number) v;
        54: print (DA_Number) v;
        60: print (DecimalNumber) v;
        61: print (DecimalNumber) v;
        65: print (PrintShortName) v;
        66: print (DecimalNumber) v;
        67: print (DA_TruthState) v;
        68: print (PrintText) v;
        69: print (INDEXED_TEXT_TY_Say) v;
        70: print (PrintSnippet) v;
        71: print (DecimalNumber) v;
        72: print (PrintTableName) v;
        73: print (DA_Number) v;
        74: print (PrintUseOption) v;
        75: print (DA_Number) v;
        76: print (RulebookOutcomePrintingRule) v;
        77: print (DecimalNumber) v;
        78: print (LIST_OF_TY_Say) v;
        79: print (DecimalNumber) v;
        80: print (RELATION_TY_Say) v;
        81: print (RulePrintingRule) v;
        82: print (RulePrintingRule) v;
        83: print (DecimalNumber) v;
        84: print (SayPhraseName) v;
        85: print (PROPERTY_TY_Say) v;
        86: print (DecimalNumber) v;
        87: print (COMBINATION_TY_Say) v;
        88: print (DA_Number) v;
        89: print (DA_Number) v;
        90: print (DecimalNumber) v;
        91: print (STORED_ACTION_TY_Say) v;
        92: print (SayActionName) v;
        93: print (PrintTimeOfDay) v;
        94: print (PrintSceneName) v;
        95: print (PrintFigureName) v;
        96: print (PrintSoundName) v;
        97: print (PrintExternalFileName) v;
        100: print (T42_command_parser_error) v;
        101: print (T43_protocol_type) v;
        102: print (T44_library_message_id) v;
        103: print (T45_frequency) v;
        default: print v;
    }
];
[ DefaultValueOfKOV sk k;
    k = KindAtomic(sk);
    switch(k) {
        60: return ;
        61: return ;
        65: return nothing;
        66: return 0;
        67: return false;
        68: return EMPTY_TEXT_VALUE;
        69: return BlkValueCreate(k, 0, sk);
        70: return 101;
        71: return 32;
        72: return TheEmptyTable;
        73: return 0;
        74: return 0;
        75: return ;
        76: return ;
        77: return DefaultTopic;
        78: return BlkValueCreate(k, 0, sk);
        79: return Prop_Falsity;
        80: return BlkValueCreate(k, 0, sk);
        81: return LITTLE_USED_DO_NOTHING_R;
        82: return 0;
        83: return PRINTING_THE_NAME_ACT;
        84: return Default_Value_0;
        85: return ;
        86: return ;
        87: return BlkValueCreate(k, 0, sk);
        90: return ;
        91: return BlkValueCreate(k, 0, sk);
        92: return ##Wait;
        93: return 540;
        94: return Q1_entire_game;
        95: return Q0_figure_of_cover;
        96: return ;
        97: return ;
        100: return Q2_didn_t_understand_error;
        101: return Q22_implicit;
        102: return Q24_libmsg__you_have_died_;
        103: return 0;
        default: return 0;
    }
];
[ KOVComparisonFunction k;
    k = KindAtomic(k);
    switch(k) {
        60: return UnsignedCompare;
        61: return UnsignedCompare;
        65: return UnsignedCompare;
        67: return UnsignedCompare;
        68: return UnsignedCompare;
        69: return BlkValueCompare;
        70: return UnsignedCompare;
        71: return UnsignedCompare;
        72: return UnsignedCompare;
        73: return UnsignedCompare;
        74: return UnsignedCompare;
        75: return UnsignedCompare;
        76: return UnsignedCompare;
        77: return UnsignedCompare;
        78: return BlkValueCompare;
        79: return UnsignedCompare;
        80: return BlkValueCompare;
        81: return UnsignedCompare;
        82: return UnsignedCompare;
        83: return UnsignedCompare;
        84: return UnsignedCompare;
        85: return UnsignedCompare;
        86: return UnsignedCompare;
        87: return BlkValueCompare;
        90: return UnsignedCompare;
        91: return BlkValueCompare;
        92: return UnsignedCompare;
        94: return UnsignedCompare;
        95: return UnsignedCompare;
        96: return UnsignedCompare;
        97: return UnsignedCompare;
        default: return 0;
    }
];
[ KOVDomainSize k;
    k = KindAtomic(k);
    switch(k) {
        94: return 11;
        95: return 1;
        96: return 0;
        97: return 0;
        100: return 20;
        101: return 2;
        102: return 315;
        default: return 0;
    }
];
[ KOVIsBlockValue k;
    k = KindAtomic(k);
    if (k == 69 or 78 or 80 or 87 or 91) rtrue;
    rfalse;
];
[ KOVSupportFunction k;
    k = KindAtomic(k);
    switch(k) {
        69: return INDEXED_TEXT_TY_Support;
        78: return LIST_OF_TY_Support;
        80: return RELATION_TY_Support;
        87: return COMBINATION_TY_Support;
        91: return STORED_ACTION_TY_Support;
    }
    rfalse;
];

[ I7_Kind_Name k;
    if (k == K1_room) print "room";
    if (k == K2_thing) print "thing";
    if (k == K3_direction) print "direction";
    if (k == K4_door) print "door";
    if (k == K5_container) print "container";
    if (k == K6_supporter) print "supporter";
    if (k == K7_backdrop) print "backdrop";
    if (k == K8_person) print "person";
    if (k == K9_region) print "region";
    if (k == K23_man) print "man";
    if (k == K24_woman) print "woman";
    if (k == K25_animal) print "animal";
    if (k == K26_device) print "device";
    if (k == K27_vehicle) print "vehicle";
    if (k == K28_player_s_holdall) print "player's holdall";
    if (k == K29_subject) print "subject";
    if (k == K30_misc_suggestion) print "misc-suggestion";
    if (k == K43_memory) print "memory";
    if (k == K72_plan) print "plan";
    if (k == K78_talent) print "talent";
    if (k == K119_window) print "window";
    if (k == K150_desert_flotsam) print "Desert flotsam";
    if (k == K165_spirit_animal) print "spirit animal";
    if (k == K169_normal_animal) print "normal animal";
];

Constant RBNO_0 = "allow access";
Constant RBNO_1 = "deny access";
Constant RBNO_2 = "there is sufficient light";
Constant RBNO_3 = "there is insufficient light";
Constant RBNO_4 = "persuasion succeeds";
Constant RBNO_5 = "persuasion fails";
Constant RBNO_6 = "it is very likely";
Constant RBNO_7 = "it is likely";
Constant RBNO_8 = "it is possible";
Constant RBNO_9 = "it is unlikely";
Constant RBNO_10 = "it is very unlikely";
Constant RBNO_11 = "it does not";
Constant RBNO_12 = "it does";
Constant RBNO_13 = "allow undo";
Constant RBNO_14 = "deny undo";
[ RulebookOutcomePrintingRule rbno;
    print (string) rbno; rfalse;
];



Array KindHierarchy --> K0_kind (0) K1_room (0) K2_thing (0) K3_direction (0) K4_door (2) K5_container (2) K6_supporter (2) K7_backdrop (2) K8_person (2) K9_region (0) K23_man (8) K24_woman (8) K25_animal (8) K26_device (2) K27_vehicle (5) K28_player_s_holdall (5) K29_subject (2) K30_misc_suggestion (2) K43_memory (2) K72_plan (2) K78_talent (2) K119_window (4) K150_desert_flotsam (2) K165_spirit_animal (8) K169_normal_animal (12) ;
Constant IK0_First = nothing;
Constant IK1_First = O66_middle_of_nowhere;
Constant IK2_First = O31_yes_suggestion;
Constant IK3_First = O10_north;
Constant IK4_First = O116_boarded_up_door;
Constant IK5_First = O44_subconscious;
Constant IK6_First = O126_metal_desk;
Constant IK7_First = O64_sage;
Constant IK8_First = O37_knock;
Constant IK9_First = O164_tower_vicinity;
Constant IK23_First = O37_knock;
Constant IK24_First = nothing;
Constant IK25_First = O171_brown_lizard;
Constant IK26_First = O95_headlights;
Constant IK27_First = nothing;
Constant IK28_First = nothing;
Constant IK29_First = nothing;
Constant IK30_First = O31_yes_suggestion;
Constant IK43_First = O46_last_day_of_high_school;
Constant IK72_First = O73_staying_the_night;
Constant IK78_First = O79_strength;
Constant IK119_First = O120_pane_of_cracked_glass;
Constant IK150_First = O151_looming_cactus;
Constant IK165_First = O167_coyote;
Constant IK169_First = O171_brown_lizard;
Constant No_Directions = 12;
Array Map_Storage -->
!  O10_north O11_northeast O12_northwest O13_south O14_southeast O15_southwest O16_east O17_west O18_up O19_down in_obj out_obj
 O68_crumbling_concrete 0 0 O67_backtracking 0 0 O149_open_desert O149_open_desert 0 0 0 0 ! Exits from: O66_middle_of_nowhere
 O66_middle_of_nowhere 0 0 O149_open_desert 0 0 O149_open_desert O149_open_desert 0 0 0 0 ! Exits from: O67_backtracking
 O70_base_of_the_tower O116_boarded_up_door 0 O66_middle_of_nowhere 0 0 O88_weed_strewn_rust O149_open_desert 0 0 O120_pane_of_cracked_glass 0 ! Exits from: O68_crumbling_concrete
 O113_foreman_s_office 0 0 0 0 O116_boarded_up_door O114_break_room 0 0 0 0 O120_pane_of_cracked_glass ! Exits from: O69_staging_area
 O149_open_desert 0 0 O68_crumbling_concrete O88_weed_strewn_rust 0 O149_open_desert O149_open_desert 0 0 O128_dust_covered_window 0 ! Exits from: O70_base_of_the_tower
 O149_open_desert 0 O70_base_of_the_tower O149_open_desert 0 0 O149_open_desert O68_crumbling_concrete 0 0 O141_tiny_frosted_window 0 ! Exits from: O88_weed_strewn_rust
 0 0 0 0 0 0 0 0 O143_control_center O115_storage_room 0 0 ! Exits from: O89_roof
 0 0 0 O69_staging_area 0 0 0 0 0 0 0 O128_dust_covered_window ! Exits from: O113_foreman_s_office
 O115_storage_room 0 0 0 0 0 0 O69_staging_area 0 0 0 O141_tiny_frosted_window ! Exits from: O114_break_room
 0 0 0 O114_break_room 0 0 0 0 O89_roof 0 0 0 ! Exits from: O115_storage_room
 0 0 0 0 0 0 0 0 0 O89_roof 0 0 ! Exits from: O143_control_center
 O67_backtracking 0 0 O70_base_of_the_tower 0 0 O70_base_of_the_tower O70_base_of_the_tower 0 0 0 0 ! Exits from: O149_open_desert
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: O182_burrow
;

! Table of direction object alias constants:
Constant DirectionObject_0 = O10_north;
Constant DirectionObject_1 = O11_northeast;
Constant DirectionObject_2 = O12_northwest;
Constant DirectionObject_3 = O13_south;
Constant DirectionObject_4 = O14_southeast;
Constant DirectionObject_5 = O15_southwest;
Constant DirectionObject_6 = O16_east;
Constant DirectionObject_7 = O17_west;
Constant DirectionObject_8 = O18_up;
Constant DirectionObject_9 = O19_down;
Constant DirectionObject_10 = in_obj;
Constant DirectionObject_11 = out_obj;
Class K0_kind 
    with IK0_Link nothing
    with vector 0
    has ~pluralname
    has ~proper
    with short_name EMPTY_TEXT_VALUE
    with plural EMPTY_TEXT_VALUE
    with article EMPTY_TEXT_VALUE
;

Class K1_room 
    class K0_kind
    with IK0_Link nothing
    with vector 0
    has ~privately_named
    has ~light
    has ~visited
    with plural "rooms"
    with description EMPTY_TEXT_VALUE
    with map_region nothing
;

Class K2_thing 
    class K0_kind
    with action_bitmap 0 0 0 0 0 0 0 
    with IK0_Link nothing
    with component_parent nothing
    with component_child nothing
    with component_sibling nothing
    with vector 0
    has p81_hefty
    has ~p67_seen
    has ~p69_familiar
    has ~p71_ambiguously_plural
    has neuter
    has ~privately_named
    has ~light
    has ~edible
    has ~static
    has ~concealed
    has ~workflag
    has mentioned
    has ~scenery
    has ~clothing
    has ~pushable
    has ~moved
    with description EMPTY_TEXT_VALUE
    with initial EMPTY_TEXT_VALUE
    with with_key nothing
    with p78_suggested_memory nothing
    with p79_objective nothing
    has ~p80_noted_as_useful
;

Class K4_door 
    class K2_thing
     has door, 
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    has ~open
    has openable
    has ~lockable
    has ~locked
    has static
    has ~pushable
    with plural "doors"
    with door_to nothing
    with with_key nothing
;

Class K119_window 
    class K4_door
    with parse_name Parse_Name_GV141
    with IK2_Link nothing
    with IK4_Link nothing
    with vector 0
    has mark_as_thing
    has ~open
    has ~openable
    has concealed
    with plural "windows"
    with description text_routine_0
;

Class K5_container 
    class K2_thing
     has container, 
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    has ~transparent
    has open
    has ~openable
    has ~lockable
    has ~locked
    with plural "containers"
    with capacity 100
    has ~enterable
    with with_key nothing
;

Class K27_vehicle 
    class K5_container
    with IK2_Link nothing
    with IK5_Link nothing
    with vector 0
    has mark_as_thing
    has enterable
    has static
    with plural "vehicles"
;

Class K28_player_s_holdall 
    class K5_container
    with IK2_Link nothing
    with IK5_Link nothing
    with vector 0
    has mark_as_thing
    has openable
    has ~static
    with plural "player's holdalls"
;

Class K6_supporter 
    class K2_thing

    	has transparent supporter

    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    has static
    with plural "supporters"
    with capacity 100
    has ~enterable
;

Class K7_backdrop 
    class K2_thing
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    has static
    has scenery
    has ~pushable
    with plural "backdrops"
;

Class K8_person 
    class K2_thing

    	has transparent animate
    	with before NULL,

    with parse_name Parse_Name_GV96
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    has ~female
    has ~neuter
    with plural "people"
    with capacity 100
    with p13_ask_suggestions 0
    with p14_tell_suggestions 0
    with p15_other_suggestions 0
;

Class K23_man 
    class K8_person
    with IK2_Link nothing
    with IK8_Link nothing
    with vector 0
    has mark_as_thing
    has ~female
    has ~neuter
    with plural "men"
;

Class K24_woman 
    class K8_person
    with IK2_Link nothing
    with IK8_Link nothing
    with vector 0
    has mark_as_thing
    has female
    has ~neuter
    with plural "women"
;

Class K25_animal 
    class K8_person
    with IK2_Link nothing
    with IK8_Link nothing
    with vector 0
    has mark_as_thing
    with plural "animals"
;

Class K169_normal_animal 
    class K25_animal
    with IK2_Link nothing
    with IK8_Link nothing
    with IK25_Link nothing
    with vector 0
    has mark_as_thing
    with plural "normal animals"
;

Class K165_spirit_animal 
    class K8_person
    with IK2_Link nothing
    with IK8_Link nothing
    with vector 0
    has mark_as_thing
    with plural "spirit animals"
    with p21_price 0
;

Class K26_device 
    class K2_thing
     has switchable, 
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    has ~on
    with plural "devices"
;

Class K29_subject 
    class K2_thing
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    has p69_familiar
    with plural "subjects"
;

Class K30_misc_suggestion 
    class K2_thing
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    has p69_familiar
    has proper
    with plural "misc-suggestions"
    with p16_seqno 100
;

Class K43_memory 
    class K2_thing
    with parse_name Parse_Name_GV113
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    has ~p76_retrieved
    with plural "memories"
;

Class K72_plan 
    class K2_thing
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    with plural "plans"
;

Class K78_talent 
    class K2_thing
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    with plural "talents"
    with description text_routine_1
;

Class K150_desert_flotsam 
    class K2_thing
    with IK2_Link nothing
    with vector 0
    has mark_as_thing
    with plural "Desert flotsams"
    with initial text_routine_2
;

Class K3_direction 
    class K0_kind

    	has scenery, ! class CompassDirection,

    with IK0_Link nothing
    with vector 0
    has ~privately_named
    has ~workflag
    with plural "directions"
    with p9_opposite O10_north
;

Class K9_region 
    class K0_kind
    with IK0_Link nothing
    with vector 0
    has ~privately_named
    with plural "regions"
;

Object O10_north "" Compass
    class K3_direction
    with name 'north' 'n//' 
    with parse_name Parse_Name_GV1
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 0
    with IK3_Link O11_northeast
    with vector 0
    with short_name "north"
    with article SC_4
    with p9_opposite O13_south
;

Object O11_northeast "" Compass
    class K3_direction
    with name 'northeast' 'ne' 
    with parse_name Parse_Name_GV2
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 1
    with IK3_Link O12_northwest
    with vector 0
    with short_name "northeast"
    with article SC_4
    with p9_opposite O15_southwest
;

Object O12_northwest "" Compass
    class K3_direction
    with name 'northwest' 'nw' 
    with parse_name Parse_Name_GV3
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 2
    with IK3_Link O13_south
    with vector 0
    with short_name "northwest"
    with article SC_4
    with p9_opposite O14_southeast
;

Object O13_south "" Compass
    class K3_direction
    with name 'south' 's//' 
    with parse_name Parse_Name_GV4
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 3
    with IK3_Link O14_southeast
    with vector 0
    with short_name "south"
    with article SC_4
    with p9_opposite O10_north
;

Object O14_southeast "" Compass
    class K3_direction
    with name 'southeast' 'se' 
    with parse_name Parse_Name_GV5
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 4
    with IK3_Link O15_southwest
    with vector 0
    with short_name "southeast"
    with article SC_4
    with p9_opposite O12_northwest
;

Object O15_southwest "" Compass
    class K3_direction
    with name 'southwest' 'sw' 
    with parse_name Parse_Name_GV6
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 5
    with IK3_Link O16_east
    with vector 0
    with short_name "southwest"
    with article SC_4
    with p9_opposite O11_northeast
;

Object O16_east "" Compass
    class K3_direction
    with name 'east' 'e//' 
    with parse_name Parse_Name_GV7
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 6
    with IK3_Link O17_west
    with vector 0
    with short_name "east"
    with article SC_4
    with p9_opposite O17_west
;

Object O17_west "" Compass
    class K3_direction
    with name 'west' 'w//' 
    with parse_name Parse_Name_GV8
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 7
    with IK3_Link O18_up
    with vector 0
    with short_name "west"
    with article SC_4
    with p9_opposite O16_east
;

Object O18_up "" Compass
    class K3_direction
    with name 'up' 'u//' 
    with parse_name Parse_Name_GV9
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 8
    with IK3_Link O19_down
    with vector 0
    with short_name "up"
    with article SC_4
    with p9_opposite O19_down
;

Object O19_down "" Compass
    class K3_direction
    with name 'down' 'd//' 
    with parse_name Parse_Name_GV10
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 9
    with IK3_Link in_obj
    with vector 0
    with short_name "down"
    with article SC_4
    with p9_opposite O18_up
;

Object in_obj "" Compass
    class K3_direction
    with name 'inside' 'in' 
    with parse_name Parse_Name_GV11
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 10
    with IK3_Link out_obj
    with vector 0
    with short_name "inside"
    with article SC_4
    with p9_opposite out_obj
;

Object out_obj "" Compass
    class K3_direction
    with name 'outside' 'out' 
    with parse_name Parse_Name_GV12
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 3
    with IK_3 11
    with IK3_Link nothing
    with vector 0
    with short_name "outside"
    with article SC_4
    with p9_opposite in_obj
;

Object selfobj ""
    class K8_person

    	with saved_short_name "yourself",
     
    with name 'yourself' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Yourself"
    with list_together 0
    with IK_0 8
    with IK_2 0
    with IK2_Link O31_yes_suggestion
    with IK_8 0
    with IK8_Link O37_knock
    with vector 0
    has mark_as_thing
    has proper
    has concealed
    with short_name "yourself"
    with description SC_5
;

Object O31_yes_suggestion ""
    class K30_misc_suggestion
    with name 'yes-suggestion' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 1
    with IK2_Link O32_no_suggestion
    with IK_30 0
    with IK30_Link O32_no_suggestion
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_6
    with p16_seqno 10
;

Object O32_no_suggestion ""
    class K30_misc_suggestion
    with name 'no-suggestion' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 2
    with IK2_Link O33_yes_no_suggestion
    with IK_30 1
    with IK30_Link O33_yes_no_suggestion
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_7
    with p16_seqno 12
;

Object O33_yes_no_suggestion ""
    class K30_misc_suggestion
    with name 'yes-no-suggestion' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 3
    with IK2_Link O34_self_suggestion
    with IK_30 2
    with IK30_Link O204_trade_for_luck
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_8
    with p16_seqno 10
;

Object O34_self_suggestion ""
    class K2_thing
    with name 'self-suggestion' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 4
    with IK2_Link O35_library_message_debug
    with vector 0
    has mark_as_thing
    has p69_familiar
    has proper
    with short_name text_routine_3
;

Object O35_library_message_debug ""
    class K2_thing
    with name 'library' 'message' 'debug' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 5
    with IK2_Link O36_i7_librarymessages
    with vector 0
    has mark_as_thing
    has ~p74_on
    has proper
    with short_name "Library message debug"
;

Object O36_i7_librarymessages ""
    class K2_thing

      with before LibraryMessagesBefore,

    with name 'i7_librarymessages' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 6
    with IK2_Link O44_subconscious
    with vector 0
    has mark_as_thing
    has proper
    with short_name "I7_LibraryMessages"
;

Object O44_subconscious ""
    class K5_container
    with name 'subconscious' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 5
    with IK_2 13
    with IK2_Link O46_last_day_of_high_school
    with IK_5 2
    with IK5_Link O60_gas_can
    with vector 0
    has mark_as_thing
    with short_name "subconscious"
;

Object O46_last_day_of_high_school ""
    class K43_memory
    with name 'last' 'day' 'of' 'high' 'school' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 18
    with IK_2 15
    with IK2_Link O51_your_shit_job
    with IK_43 0
    with IK43_Link O51_your_shit_job
    with vector 0
    has mark_as_thing
    with short_name "last day of high school"
    with article SC_4
    with description SC_9
;

Object O51_your_shit_job ""
    class K43_memory
    with name 'my' 'shit' 'job' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Your shit job"
    with list_together 0
    with IK_0 18
    with IK_2 20
    with IK2_Link O53_grandma_s_stories
    with IK_43 1
    with IK43_Link O53_grandma_s_stories
    with vector 0
    has mark_as_thing
    has proper
    with short_name "your shit job"
    with description text_routine_4
;

Object O53_grandma_s_stories ""
    class K43_memory
    with name 'grandma^s' 'stories' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Grandma's stories"
    with list_together 0
    with IK_0 18
    with IK_2 22
    with IK2_Link O55_meeting_ocean
    with IK_43 2
    with IK43_Link O55_meeting_ocean
    with vector 0
    has mark_as_thing
    has proper
    with short_name "grandma's stories"
    with description SC_10
;

Object O55_meeting_ocean ""
    class K43_memory
    with name 'meeting' 'ocean' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Meeting Ocean"
    with list_together 0
    with IK_0 18
    with IK_2 24
    with IK2_Link O56_bunny_s_bow_tie
    with IK_43 3
    with IK43_Link O57_her_graduation_night
    with vector 0
    has mark_as_thing
    has proper
    with short_name "meeting Ocean"
    with description SC_11
;

Object O56_bunny_s_bow_tie ""
    class K2_thing
    with name 'bunny^s' 'bow' 'tie' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 25
    with IK2_Link O57_her_graduation_night
    with vector 0
    has mark_as_thing
    with p78_suggested_memory O57_her_graduation_night
    with short_name "bunny's bow tie"
;

Object O57_her_graduation_night ""
    class K43_memory
    with name 'her' 'graduation' 'night' 
    with parse_name Parse_Name_GV115
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Her graduation night"
    with list_together 0
    with IK_0 18
    with IK_2 26
    with IK2_Link O58_lingering_smell_of_orang
    with IK_43 4
    with IK43_Link O59_ocean_s_perfume
    with vector 0
    has mark_as_thing
    has proper
    with short_name "her graduation night"
    with description SC_12
;

Object O58_lingering_smell_of_orang ""
    class K2_thing
    with name 'lingering' 'smell' 'of' 'orange' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 27
    with IK2_Link O59_ocean_s_perfume
    with vector 0
    has mark_as_thing
    with p78_suggested_memory O59_ocean_s_perfume
    has concealed
    with short_name "lingering smell of orange"
;

Object O59_ocean_s_perfume ""
    class K43_memory
    with name 'ocean^s' 'perfume' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 18
    with IK_2 28
    with IK2_Link O60_gas_can
    with IK_43 5
    with IK43_Link O61_road_trips_through_the_d
    with vector 0
    has mark_as_thing
    has proper
    with short_name "Ocean's perfume"
    with description SC_13
;

Object O60_gas_can ""
    class K5_container
    with name 'gas' 'can' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 5
    with IK_2 29
    with IK2_Link O61_road_trips_through_the_d
    with IK_5 5
    with IK5_Link O42_pickup_truck
    with vector 0
    has mark_as_thing
    with p79_objective O77_fixing_the_truck
    with p78_suggested_memory O61_road_trips_through_the_d
    has ~open
    has openable
    with short_name "gas can"
    with description SC_14
;

Object O61_road_trips_through_the_d ""
    class K43_memory
    with name 'road' 'trips' 'through' 'the' 'desert' 'trip' 
    with parse_name Parse_Name_GV116
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Road trips through the desert"
    with list_together 0
    with IK_0 18
    with IK_2 30
    with IK2_Link O63_when_you_heard_the_news
    with IK_43 6
    with IK43_Link O63_when_you_heard_the_news
    with vector 0
    has mark_as_thing
    has proper
    with short_name "road trips through the desert"
    with description SC_15
;

Object O63_when_you_heard_the_news ""
    class K43_memory
    with name 'when' 'you' 'heard' 'the' 'news' 
    with parse_name Parse_Name_GV117
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "When you heard the news"
    with list_together 0
    with IK_0 18
    with IK_2 32
    with IK2_Link O64_sage
    with IK_43 7
    with IK43_Link O65_watching_family_guy
    with vector 0
    has mark_as_thing
    has proper
    with short_name "when you heard the news"
    with description SC_16
;

Object O64_sage ""
    class K7_backdrop
    with name 'sage' 
    with action_bitmap 0 0 0 0 0 0 0 
    has absent
    with list_together 0
    with IK_0 7
    with IK_2 33
    with IK2_Link O65_watching_family_guy
    with IK_7 0
    with IK7_Link O90_tire_tracks
    with found_in [; rfalse; ],
    with vector 0
    has mark_as_thing
    with p78_suggested_memory O65_watching_family_guy
    with short_name "sage"
;

Object O65_watching_family_guy ""
    class K43_memory
    with name 'watching' 'family' 'guy' 
    with parse_name Parse_Name_GV118
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 18
    with IK_2 34
    with IK2_Link O42_pickup_truck
    with IK_43 8
    with IK43_Link nothing
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_17
    with description SC_18
;

Object O66_middle_of_nowhere ""
    class K1_room
    with name 'middle' 'of' 'nowhere' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 0
    with IK1_Link O67_backtracking
    with vector 0
    has mark_as_room
    has proper
    has light
    with short_name "Middle of Nowhere"
    with description text_routine_5
    with map_region O87_around_the_tower
;

Object -> O42_pickup_truck ""
    class K5_container
    with name 'pickup' 'truck' 
    with parse_name Parse_Name_GV122
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 5
    with IK_2 12
    with IK2_Link O37_knock
    with IK_5 1
    with IK5_Link O45_emotional_baggage
    with component_child O94_windshield
    with vector 0
    has mark_as_thing
    has enterable
    has transparent
    has ~open
    has openable
    has static
    with short_name "pickup truck"
    with description text_routine_6
    with initial text_routine_7
;

Object -> -> O37_knock ""
    class K23_man
    with name 'knock' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 10
    with IK_2 7
    with IK2_Link O38_lighter
    with IK_8 1
    with IK8_Link O171_brown_lizard
    with IK_23 0
    with IK23_Link O172_voice
    with vector 0
    has mark_as_thing
    has proper
    with short_name "Knock"
    with description SC_19
;

Object -> -> -> O38_lighter ""
    class K2_thing
    with name 'lighter' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 8
    with IK2_Link O41_denim_jacket
    with vector 0
    has mark_as_thing
    with short_name "lighter"
;

Object -> -> -> O41_denim_jacket ""
    class K2_thing
    with name 'denim' 'jacket' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 11
    with IK2_Link O45_emotional_baggage
    with vector 0
    has mark_as_thing
    has worn
    has clothing
    with short_name "denim jacket"
;

Object -> -> -> O45_emotional_baggage ""
    class K5_container
    with name 'emotional' 'baggage' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Emotional baggage"
    with list_together 0
    with IK_0 5
    with IK_2 14
    with IK2_Link O48_wallet
    with IK_5 3
    with IK5_Link O48_wallet
    with vector 0
    has mark_as_thing
    has transparent
    has open
    has ~openable
    has proper
    with short_name "emotional baggage"
    with description SC_20
;

Object -> -> -> O48_wallet ""
    class K5_container
    with name 'wallet' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 5
    with IK_2 17
    with IK2_Link O49_driver_s_license
    with IK_5 4
    with IK5_Link O86_photo
    with vector 0
    has mark_as_thing
    has ~open
    has openable
    with short_name "wallet"
;

Object -> -> -> -> O49_driver_s_license ""
    class K2_thing
    with name 'driver^s' 'license' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 18
    with IK2_Link O50_receipt_from_big_jimmy_s
    with vector 0
    has mark_as_thing
    has ~p81_hefty
    with short_name "driver's license"
    with description SC_21
;

Object -> -> -> -> O50_receipt_from_big_jimmy_s ""
    class K2_thing
    with name 'receipt' 'from' 'big' 'jimmy^s' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 19
    with IK2_Link O86_photo
    with vector 0
    has mark_as_thing
    has ~p81_hefty
    with p78_suggested_memory O51_your_shit_job
    with short_name "receipt from Big Jimmy's"
;

Object -> -> -> O86_photo ""
    class K5_container
    with name 'photo' 
    with parse_name Parse_Name_GV121
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 5
    with IK_2 48
    with IK2_Link O62_ultrasound_of_ocean_s_ba
    with IK_5 6
    with IK5_Link O40_glove_box
    with vector 0
    has mark_as_thing
    has ~p81_hefty
    has ~open
    has openable
    with short_name text_routine_8
    with description text_routine_9
;

Object -> -> -> -> O62_ultrasound_of_ocean_s_ba ""
    class K2_thing
    with name 'ultrasound' 'of' 'ocean^s' 'baby' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 31
    with IK2_Link O40_glove_box
    with vector 0
    has mark_as_thing
    with p78_suggested_memory O63_when_you_heard_the_news
    with short_name "ultrasound of Ocean's baby"
    with description SC_22
;

Object -> -> O40_glove_box ""
    class K5_container
    with name 'glove' 'box' 
    with parse_name Parse_Name_GV123
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 5
    with IK_2 10
    with IK2_Link O39_pack_of_cigarettes
    with IK_5 0
    with IK5_Link O124_hole_in_the_floor
    with vector 0
    has mark_as_thing
    has ~open
    has openable
    has static
    with short_name "glove box"
;

Object -> -> -> O39_pack_of_cigarettes ""
    class K2_thing
    with name 'pack' 'of' 'cigarettes' 
    with parse_name Parse_Name_GV112
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 9
    with IK2_Link O52_piece_of_jade
    with vector 0
    has mark_as_thing
    has ~p81_hefty
    with short_name "pack of cigarettes"
    with description text_routine_10
    with p17_count 6
;

Object -> -> O52_piece_of_jade ""
    class K2_thing
    with name 'piece' 'of' 'jade' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 21
    with IK2_Link O97_whiffs_of_evaporating_ga
    with vector 0
    has mark_as_thing
    with p78_suggested_memory O53_grandma_s_stories
    with short_name "piece of jade"
    with description SC_23
;

Object -> O97_whiffs_of_evaporating_ga ""
    class K2_thing
    with name 'whiffs' 'of' 'evaporating' 'gasoline' 
    with parse_name Parse_Name_GV132
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 56
    with IK2_Link O98_tall_saguaro
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "whiffs of evaporating gasoline"
;

Object -> O98_tall_saguaro ""
    class K2_thing
    with name 'tall' 'saguaro' 'cactus' 
    with parse_name Parse_Name_GV133
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 57
    with IK2_Link O171_brown_lizard
    with vector 0
    has mark_as_thing
    has static
    with short_name "tall Saguaro"
    with description SC_24
;

Object -> O171_brown_lizard ""
    class K169_normal_animal
    with name 'brown' 'lizard' 
    with parse_name Parse_Name_GV152
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 24
    with IK_2 119
    with IK2_Link O111_withered_cactus
    with IK_8 6
    with IK8_Link O167_coyote
    with IK_25 1
    with IK25_Link O170_desert_hare
    with IK_169 1
    with IK169_Link O170_desert_hare
    with vector 0
    has mark_as_thing
    with short_name "brown lizard"
    with description text_routine_11
    with initial text_routine_12
;

Object O67_backtracking ""
    class K1_room
    with name 'backtracking' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 1
    with IK1_Link O68_crumbling_concrete
    with vector 0
    has mark_as_room
    has proper
    has light
    with short_name "Backtracking"
    with description text_routine_13
    with map_region O87_around_the_tower
;

Object -> O111_withered_cactus ""
    class K2_thing
    with name 'withered' 'cactus' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 70
    with IK2_Link O121_shafts_of_light
    with vector 0
    has mark_as_thing
    has static
    with short_name "withered cactus"
;

Object O68_crumbling_concrete ""
    class K1_room
    with name 'crumbling' 'concrete' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 2
    with IK1_Link O69_staging_area
    with vector 0
    has mark_as_room
    has proper
    has light
    with short_name "Crumbling Concrete"
    with description text_routine_14
    with map_region O87_around_the_tower
;

Object O69_staging_area ""
    class K1_room
    with name 'staging' 'area' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 3
    with IK1_Link O70_base_of_the_tower
    with vector 0
    has mark_as_room
    has p82_dim
    has proper
    has light
    with short_name "Staging Area"
    with description text_routine_15
    with map_region O112_office_interior
;

Object -> O121_shafts_of_light ""
    class K2_thing
    with name 'shafts' 'of' 'light' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 75
    with IK2_Link O122_holes_in_the_roof
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "shafts of light"
;

Object -> O122_holes_in_the_roof ""
    class K2_thing
    with name 'holes' 'in' 'the' 'roof' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 76
    with IK2_Link O123_patches_of_mold
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "holes in the roof"
;

Object -> O123_patches_of_mold ""
    class K2_thing
    with name 'patches' 'of' 'mold' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 77
    with IK2_Link O124_hole_in_the_floor
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "patches of mold"
;

Object -> O124_hole_in_the_floor ""
    class K5_container
    with name 'hole' 'in' 'the' 'floor' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 5
    with IK_2 78
    with IK2_Link O76_roll_of_duct_tape
    with IK_5 7
    with IK5_Link O140_wire_mesh_cage
    with vector 0
    has mark_as_thing
    has open
    has ~openable
    has static
    has concealed
    with short_name "hole in the floor"
    with initial text_routine_16
;

Object -> -> O76_roll_of_duct_tape ""
    class K2_thing
    with name 'roll' 'of' 'duct' 'tape' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 39
    with IK2_Link O125_cobwebs
    with vector 0
    has mark_as_thing
    with p79_objective O77_fixing_the_truck
    with short_name "roll of duct tape"
;

Object -> -> O125_cobwebs ""
    class K2_thing
    with name 'cobwebs' 
    with parse_name Parse_Name_GV142
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 79
    with IK2_Link O126_metal_desk
    with vector 0
    has mark_as_thing
    has pluralname
    with short_name "cobwebs"
;

Object -> O126_metal_desk ""
    class K6_supporter
    with name 'metal' 'desk' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 6
    with IK_2 80
    with IK2_Link O99_red_warning_light
    with IK_6 1
    with IK6_Link O110_overturned_barrel
    with component_child O127_drawer
    with vector 0
    has mark_as_thing
    has static
    has concealed
    with short_name "metal desk"
;

Object O70_base_of_the_tower ""
    class K1_room
    with name 'base' 'of' 'the' 'tower' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 4
    with IK1_Link O88_weed_strewn_rust
    with vector 0
    has mark_as_room
    has proper
    has light
    with short_name "Base of the Tower"
    with description text_routine_17
    with map_region O87_around_the_tower
;

Object -> O99_red_warning_light ""
    class K2_thing
    with name 'red' 'warning' 'light' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 58
    with IK2_Link O100_steel_girder
    with vector 0
    has mark_as_thing
    has static
    has scenery
    with short_name "red warning light"
;

Object -> O100_steel_girder ""
    class K2_thing
    with name 'steel' 'girder' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 59
    with IK2_Link O101_scrawny_weeds
    with vector 0
    has mark_as_thing
    has static
    has scenery
    with short_name "steel girder"
;

Object -> O101_scrawny_weeds ""
    class K2_thing
    with name 'scrawny' 'weeds' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 60
    with IK2_Link O102_bits_of_trash
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "scrawny weeds"
;

Object -> O102_bits_of_trash ""
    class K2_thing
    with name 'bits' 'of' 'trash' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 61
    with IK2_Link O103_tumbleweed
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "bits of trash"
    with description SC_25
;

Object -> O103_tumbleweed ""
    class K2_thing
    with name 'tumbleweed' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 62
    with IK2_Link O104_rusty_tin_can
    with vector 0
    has mark_as_thing
    has static
    has scenery
    with short_name "tumbleweed"
;

Object -> O104_rusty_tin_can ""
    class K2_thing
    with name 'rusty' 'tin' 'can' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 63
    with IK2_Link O73_staying_the_night
    with vector 0
    has mark_as_thing
    with short_name "rusty tin can"
    with initial SC_26
;

Object O73_staying_the_night ""
    class K72_plan
    with name 'staying' 'the' 'night' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 19
    with IK_2 36
    with IK2_Link O75_canned_oranges
    with IK_72 0
    with IK72_Link O77_fixing_the_truck
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_27
;

Object O75_canned_oranges ""
    class K2_thing
    with name 'canned' 'oranges' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 38
    with IK2_Link O77_fixing_the_truck
    with vector 0
    has mark_as_thing
    with p79_objective O73_staying_the_night
    has pluralname
    with short_name "canned oranges"
;

Object O77_fixing_the_truck ""
    class K72_plan
    with name 'fixing' 'the' 'truck' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 19
    with IK_2 40
    with IK2_Link O79_strength
    with IK_72 1
    with IK72_Link nothing
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_28
;

Object O79_strength ""
    class K78_talent
    with name 'strength' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Strength"
    with list_together 0
    with IK_0 20
    with IK_2 41
    with IK2_Link O80_courage
    with IK_78 0
    with IK78_Link O80_courage
    with vector 0
    has mark_as_thing
    has proper
    with short_name "strength"
;

Object O80_courage ""
    class K78_talent
    with name 'courage' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Courage"
    with list_together 0
    with IK_0 20
    with IK_2 42
    with IK2_Link O81_luck
    with IK_78 1
    with IK78_Link O81_luck
    with vector 0
    has mark_as_thing
    has proper
    with short_name "courage"
;

Object O81_luck ""
    class K78_talent
    with name 'luck' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Luck"
    with list_together 0
    with IK_0 20
    with IK_2 43
    with IK2_Link O82_scent
    with IK_78 2
    with IK78_Link O82_scent
    with vector 0
    has mark_as_thing
    has proper
    with short_name "luck"
;

Object O82_scent ""
    class K78_talent
    with name 'scent' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Scent"
    with list_together 0
    with IK_0 20
    with IK_2 44
    with IK2_Link O83_honor
    with IK_78 3
    with IK78_Link O83_honor
    with vector 0
    has mark_as_thing
    has proper
    with short_name "scent"
;

Object O83_honor ""
    class K78_talent
    with name 'honor' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Honor"
    with list_together 0
    with IK_0 20
    with IK_2 45
    with IK2_Link O84_spirit
    with IK_78 4
    with IK78_Link O84_spirit
    with vector 0
    has mark_as_thing
    has p69_familiar
    has proper
    with short_name "honor"
;

Object O84_spirit ""
    class K78_talent
    with name 'spirit' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Spirit"
    with list_together 0
    with IK_0 20
    with IK_2 46
    with IK2_Link O85_freedom
    with IK_78 5
    with IK78_Link O85_freedom
    with vector 0
    has mark_as_thing
    has p69_familiar
    has proper
    with short_name "spirit"
;

Object O85_freedom ""
    class K78_talent
    with name 'freedom' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Freedom"
    with list_together 0
    with IK_0 20
    with IK_2 47
    with IK2_Link O106_yellowing_weeds
    with IK_78 6
    with IK78_Link nothing
    with vector 0
    has mark_as_thing
    has p69_familiar
    has proper
    with short_name "freedom"
;

Object O88_weed_strewn_rust ""
    class K1_room
    with name 'weed-strewn' 'rust' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 5
    with IK1_Link O89_roof
    with vector 0
    has mark_as_room
    has proper
    with short_name "Weed-strewn Rust"
    with description text_routine_18
    with map_region O87_around_the_tower
;

Object -> O106_yellowing_weeds ""
    class K2_thing
    with name 'yellowing' 'weeds' 'weed' 
    with parse_name Parse_Name_GV137
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 65
    with IK2_Link O107_scattered_newspapers
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has concealed
    with short_name "yellowing weeds"
;

Object -> O107_scattered_newspapers ""
    class K2_thing
    with name 'scattered' 'newspapers' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 66
    with IK2_Link O108_collection_of_rusted_ba
    with vector 0
    has mark_as_thing
    has static
    has scenery
    with short_name "scattered newspapers"
    with description SC_29
;

Object -> O108_collection_of_rusted_ba ""
    class K2_thing
    with name 'collection' 'of' 'rusted' 'barrels' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 67
    with IK2_Link O109_leaking_pipe
    with vector 0
    has mark_as_thing
    has static
    has scenery
    with short_name "collection of rusted barrels"
;

Object -> O109_leaking_pipe ""
    class K2_thing
    with name 'leaking' 'pipe' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 68
    with IK2_Link O110_overturned_barrel
    with vector 0
    has mark_as_thing
    has static
    has scenery
    with short_name "leaking pipe"
;

Object -> O110_overturned_barrel ""
    class K6_supporter
    with name 'overturned' 'barrel' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 6
    with IK_2 69
    with IK2_Link O47_weather_worn_guidebook
    with IK_6 0
    with IK6_Link O144_huge_metal_barrel
    with vector 0
    has mark_as_thing
    has static
    with short_name "overturned barrel"
    with initial text_routine_19
;

Object -> -> O47_weather_worn_guidebook ""
    class K2_thing
    with name 'weather-worn' 'guidebook' 
    with parse_name Parse_Name_GV138
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 16
    with IK2_Link O142_metal_rungs
    with vector 0
    has mark_as_thing
    with p78_suggested_memory O46_last_day_of_high_school
    with short_name "weather-worn guidebook"
    with description SC_30
;

Object O89_roof ""
    class K1_room
    with name 'roof' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 6
    with IK1_Link O113_foreman_s_office
    with vector 0
    has mark_as_room
    has proper
    with short_name "Roof"
    with description text_routine_20
    with map_region O87_around_the_tower
;

Object -> O142_metal_rungs ""
    class K2_thing
    with name 'metal' 'rungs' 
    with parse_name Parse_Name_GV147
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 96
    with IK2_Link O144_huge_metal_barrel
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    with short_name "metal rungs"
;

Object -> O144_huge_metal_barrel ""
    class K6_supporter
    with name 'huge' 'metal' 'barrel' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 6
    with IK_2 97
    with IK2_Link O90_tire_tracks
    with IK_6 4
    with IK6_Link O129_half_collapsed_desk
    with vector 0
    has mark_as_thing
    has ~p84_placed_correctly
    has static
    with short_name "huge metal barrel"
    with description text_routine_21
;

Object O90_tire_tracks ""
    class K7_backdrop
    with name 'tire' 'tracks' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 7
    with IK_2 49
    with IK2_Link O91_desert_sand
    with IK_7 1
    with IK7_Link O91_desert_sand
    with found_in O66_middle_of_nowhere O67_backtracking 
    with vector 0
    has mark_as_thing
    has pluralname
    with short_name "tire tracks"
;

Object O91_desert_sand ""
    class K7_backdrop
    with name 'desert' 'sand' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 7
    with IK_2 50
    with IK2_Link O92_sagebrush
    with IK_7 2
    with IK7_Link O92_sagebrush
    with found_in [; if (TestRegionalContainment(location, O87_around_the_tower)) rtrue; ],
    with vector 0
    has mark_as_thing
    with short_name "desert sand"
;

Object O92_sagebrush ""
    class K7_backdrop
    with name 'sagebrush' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 7
    with IK_2 51
    with IK2_Link O93_concrete_building
    with IK_7 3
    with IK7_Link O93_concrete_building
    with found_in [; if (TestRegionalContainment(location, O87_around_the_tower)) rtrue; ],
    with vector 0
    has mark_as_thing
    has pluralname
    with short_name "sagebrush"
;

Object O93_concrete_building ""
    class K7_backdrop
    with name 'concrete' 'building' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 7
    with IK_2 52
    with IK2_Link O94_windshield
    with IK_7 4
    with IK7_Link O105_huge_electrical_tower
    with found_in [; if (TestRegionalContainment(location, O87_around_the_tower)) rtrue; ],
    with vector 0
    has mark_as_thing
    with short_name "concrete building"
;

Object O94_windshield ""
    class K2_thing
    with name 'windshield' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 53
    with IK2_Link O95_headlights
    with component_parent O42_pickup_truck
    with component_sibling O95_headlights
    with vector 0
    has mark_as_thing
    with short_name "windshield"
;

Object O95_headlights ""
    class K26_device
    with name 'headlights' 
    with parse_name Parse_Name_GV127
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 13
    with IK_2 54
    with IK2_Link O96_fuel_line
    with IK_26 1
    with IK26_Link O118_emergency_radio
    with component_parent O42_pickup_truck
    with component_sibling O96_fuel_line
    with vector 0
    has mark_as_thing
    has on
    has pluralname
    with short_name "headlights"
;

Object O96_fuel_line ""
    class K2_thing
    with name 'fuel' 'line' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 55
    with IK2_Link O105_huge_electrical_tower
    with component_parent O42_pickup_truck
    with vector 0
    has mark_as_thing
    with short_name "fuel line"
;

Object O105_huge_electrical_tower ""
    class K7_backdrop
    with name 'huge' 'electrical' 'tower' 
    with parse_name Parse_Name_GV136
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 7
    with IK_2 64
    with IK2_Link O129_half_collapsed_desk
    with IK_7 5
    with IK7_Link O117_layers_of_sand
    with found_in [; if (TestRegionalContainment(location, O87_around_the_tower)) rtrue; ],
    with vector 0
    has mark_as_thing
    with short_name "huge electrical tower"
    with description SC_31
;

Object O113_foreman_s_office ""
    class K1_room
    with name 'foreman^s' 'office' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 7
    with IK1_Link O114_break_room
    with vector 0
    has mark_as_room
    has proper
    with short_name "Foreman's Office"
    with description text_routine_22
    with map_region O112_office_interior
;

Object -> O129_half_collapsed_desk ""
    class K6_supporter
    with name 'half-collapsed' 'desk' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 6
    with IK_2 83
    with IK2_Link O54_rusted_key
    with IK_6 2
    with IK6_Link O136_rows_of_crumbling_shelv
    with vector 0
    has mark_as_thing
    with short_name "half-collapsed desk"
;

Object -> -> O54_rusted_key ""
    class K2_thing
    with name 'rusted' 'key' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 23
    with IK2_Link O130_faded_safety_poster
    with vector 0
    has mark_as_thing
    with p78_suggested_memory O55_meeting_ocean
    with short_name "rusted key"
;

Object -> O130_faded_safety_poster ""
    class K2_thing
    with name 'faded' 'safety' 'poster' 
    with parse_name Parse_Name_GV144
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 84
    with IK2_Link O118_emergency_radio
    with vector 0
    has mark_as_thing
    with short_name "faded safety poster"
    with description text_routine_23
    with initial SC_32
;

Object O114_break_room ""
    class K1_room
    with name 'break' 'room' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 8
    with IK1_Link O115_storage_room
    with vector 0
    has mark_as_room
    has proper
    with short_name "Break Room"
    with description text_routine_24
    with map_region O112_office_interior
;

Object -> O118_emergency_radio ""
    class K26_device
    with name 'emergency' 'radio' 
    with parse_name Parse_Name_GV139
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 13
    with IK_2 73
    with IK2_Link O138_rotting_picnic_tables
    with IK_26 2
    with IK26_Link O131_emergency_lights
    with vector 0
    has mark_as_thing
    has static
    with short_name "emergency radio"
    with description text_routine_25
    with p18_frequency_tuned_to 772
    with p19_maximum_frequency 1099
    with p20_minimum_frequency 670
;

Object -> O138_rotting_picnic_tables ""
    class K2_thing
    with name 'rotting' 'picnic' 'tables' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 92
    with IK2_Link O139_crumbling_trash
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "rotting picnic tables"
;

Object -> O139_crumbling_trash ""
    class K2_thing
    with name 'crumbling' 'trash' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 93
    with IK2_Link O140_wire_mesh_cage
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "crumbling trash"
;

Object -> O140_wire_mesh_cage ""
    class K5_container
    with name 'wire' 'mesh' 'cage' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 5
    with IK_2 94
    with IK2_Link O74_emergency_blanket
    with IK_5 10
    with IK5_Link O135_rusted_filing_cabinet
    with vector 0
    has mark_as_thing
    has transparent
    has ~open
    has openable
    has lockable
    has locked
    has static
    with short_name "wire mesh cage"
;

Object -> -> O74_emergency_blanket ""
    class K2_thing
    with name 'emergency' 'blanket' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 37
    with IK2_Link O131_emergency_lights
    with vector 0
    has mark_as_thing
    with p79_objective O73_staying_the_night
    has clothing
    with short_name "emergency blanket"
;

Object O115_storage_room ""
    class K1_room
    with name 'storage' 'room' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 9
    with IK1_Link O143_control_center
    with vector 0
    has mark_as_room
    has proper
    with short_name "Storage Room"
    with description text_routine_26
    with map_region O112_office_interior
;

Object -> O131_emergency_lights ""
    class K26_device
    with name 'emergency' 'lights' 
    with parse_name Parse_Name_GV145
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 13
    with IK_2 85
    with IK2_Link O132_bare_metal_shelves
    with IK_26 3
    with IK26_Link O71_flashlight
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    with short_name "emergency lights"
    with initial text_routine_27
;

Object -> O132_bare_metal_shelves ""
    class K2_thing
    with name 'bare' 'metal' 'shelves' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 86
    with IK2_Link O133_utility_ladder
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "bare metal shelves"
;

Object -> O133_utility_ladder ""
    class K2_thing
    with name 'utility' 'ladder' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 87
    with IK2_Link O134_broken_skylight
    with vector 0
    has mark_as_thing
    has static
    has scenery
    with short_name "utility ladder"
;

Object -> O134_broken_skylight ""
    class K2_thing
    with name 'broken' 'skylight' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 88
    with IK2_Link O135_rusted_filing_cabinet
    with vector 0
    has mark_as_thing
    has static
    has scenery
    with short_name "broken skylight"
;

Object -> O135_rusted_filing_cabinet ""
    class K5_container
    with name 'rusted' 'filing' 'cabinet' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 5
    with IK_2 89
    with IK2_Link O136_rows_of_crumbling_shelv
    with IK_5 9
    with IK5_Link O127_drawer
    with vector 0
    has mark_as_thing
    has ~open
    has openable
    has static
    with short_name "rusted filing cabinet"
    with description SC_33
;

Object -> O136_rows_of_crumbling_shelv ""
    class K6_supporter
    with name 'rows' 'of' 'crumbling' 'shelving' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 6
    with IK_2 90
    with IK2_Link O137_cans_of_food
    with IK_6 3
    with IK6_Link nothing
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    with short_name "rows of crumbling shelving"
;

Object -> -> O137_cans_of_food ""
    class K2_thing
    with name 'cans' 'of' 'food' 
    with parse_name Parse_Name_GV146
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 91
    with IK2_Link O116_boarded_up_door
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    with short_name "cans of food"
;

Object O116_boarded_up_door ""
    class K4_door
    with name 'boarded-up' 'door' 
    with parse_name Parse_Name_GV134
    with action_bitmap 0 0 0 0 0 0 0 
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == O69_staging_area) return O15_southwest; return O11_northeast; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == O69_staging_area) return O68_crumbling_concrete; return O69_staging_area; ],
    with list_together 0
    with IK_0 4
    with IK_2 71
    with IK2_Link O117_layers_of_sand
    with IK_4 0
    with IK4_Link O120_pane_of_cracked_glass
    with found_in O69_staging_area O68_crumbling_concrete
    with vector 0
    has mark_as_thing
    has ~open
    has concealed
    with short_name "boarded-up door"
;

Object O117_layers_of_sand ""
    class K7_backdrop
    with name 'layers' 'of' 'sand' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 7
    with IK_2 72
    with IK2_Link O120_pane_of_cracked_glass
    with IK_7 6
    with IK7_Link O180_rain
    with found_in [; if (TestRegionalContainment(location, O112_office_interior)) rtrue; ],
    with vector 0
    has mark_as_thing
    has pluralname
    with short_name "layers of sand"
;

Object O120_pane_of_cracked_glass ""
    class K119_window
    with name 'pane' 'of' 'cracked' 'glass' 'quiver' 'window' 
    with parse_name Parse_Name_GV135
    with action_bitmap 0 0 0 0 0 0 0 
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == O68_crumbling_concrete) return in_obj; return out_obj; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == O68_crumbling_concrete) return O69_staging_area; return O68_crumbling_concrete; ],
    with list_together 0
    with IK_0 21
    with IK_2 74
    with IK2_Link O127_drawer
    with IK_4 1
    with IK4_Link O128_dust_covered_window
    with IK_119 0
    with IK119_Link O128_dust_covered_window
    with found_in O68_crumbling_concrete O69_staging_area
    with vector 0
    has mark_as_thing
    with short_name "pane of cracked glass"
;

Object O127_drawer ""
    class K5_container
    with name 'drawer' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 5
    with IK_2 81
    with IK2_Link O71_flashlight
    with IK_5 8
    with IK5_Link nothing
    with component_parent O126_metal_desk
    with vector 0
    has mark_as_thing
    has ~open
    has openable
    with short_name "drawer"
;

Object -> O71_flashlight ""
    class K26_device
    with name 'flashlight' 'light' 
    with parse_name Parse_Name_GV143
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 13
    with IK_2 35
    with IK2_Link O128_dust_covered_window
    with IK_26 0
    with IK26_Link nothing
    with vector 0
    has mark_as_thing
    has ~static
    with short_name "flashlight"
    with description text_routine_28
;

Object O128_dust_covered_window ""
    class K119_window
    with name 'dust-covered' 'window' 'window' 
    with action_bitmap 0 0 0 0 0 0 0 
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == O70_base_of_the_tower) return in_obj; return out_obj; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == O70_base_of_the_tower) return O113_foreman_s_office; return O70_base_of_the_tower; ],
    with list_together 0
    with IK_0 21
    with IK_2 82
    with IK2_Link O141_tiny_frosted_window
    with IK_4 2
    with IK4_Link O141_tiny_frosted_window
    with IK_119 1
    with IK119_Link O141_tiny_frosted_window
    with found_in O70_base_of_the_tower O113_foreman_s_office
    with vector 0
    has mark_as_thing
    with short_name "dust-covered window"
;

Object O141_tiny_frosted_window ""
    class K119_window
    with name 'tiny' 'frosted' 'window' 'window' 
    with action_bitmap 0 0 0 0 0 0 0 
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == O88_weed_strewn_rust) return in_obj; return out_obj; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == O88_weed_strewn_rust) return O114_break_room; return O88_weed_strewn_rust; ],
    with list_together 0
    with IK_0 21
    with IK_2 95
    with IK2_Link O145_can_opener
    with IK_4 3
    with IK4_Link nothing
    with IK_119 2
    with IK119_Link nothing
    with found_in O88_weed_strewn_rust O114_break_room
    with vector 0
    has mark_as_thing
    with short_name "tiny frosted window"
;

Object O143_control_center ""
    class K1_room
    with name 'control' 'center' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 10
    with IK1_Link O149_open_desert
    with vector 0
    has mark_as_room
    with short_name "Control Center"
    with description text_routine_29
    with map_region O112_office_interior
;

Object -> O145_can_opener ""
    class K2_thing
    with parse_name Parse_Name_GV148
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 98
    with IK2_Link O146_piles_of_trash
    with vector 0
    has mark_as_thing
    has privately_named
    with short_name "can opener"
    with initial SC_34
;

Object -> O146_piles_of_trash ""
    class K2_thing
    with name 'piles' 'of' 'trash' 
    with parse_name Parse_Name_GV149
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 99
    with IK2_Link O147_smell_of_gasoline
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "piles of trash"
;

Object -> O147_smell_of_gasoline ""
    class K2_thing
    with name 'smell' 'of' 'gasoline' 
    with parse_name Parse_Name_GV150
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 100
    with IK2_Link O148_sheet_of_corrugated_met
    with vector 0
    has mark_as_thing
    has static
    with short_name "smell of gasoline"
    with initial text_routine_30
;

Object -> O148_sheet_of_corrugated_met ""
    class K2_thing
    with name 'sheet' 'of' 'corrugated' 'metal' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 101
    with IK2_Link O151_looming_cactus
    with vector 0
    has mark_as_thing
    has static
    has concealed
    with short_name "sheet of corrugated metal"
;

Object O149_open_desert ""
    class K1_room
    with name 'open' 'desert' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 11
    with IK1_Link O182_burrow
    with vector 0
    has mark_as_room
    with short_name "Open Desert"
    with description text_routine_31
;

Object O151_looming_cactus ""
    class K150_desert_flotsam
    with name 'looming' 'cactus' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 102
    with IK2_Link O152_dull_grey_boulder
    with IK_150 0
    with IK150_Link O152_dull_grey_boulder
    with vector 0
    has mark_as_thing
    with short_name "looming cactus"
;

Object O152_dull_grey_boulder ""
    class K150_desert_flotsam
    with name 'dull' 'grey' 'boulder' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 103
    with IK2_Link O153_dead_cow
    with IK_150 1
    with IK150_Link O153_dead_cow
    with vector 0
    has mark_as_thing
    with short_name "dull grey boulder"
;

Object O153_dead_cow ""
    class K150_desert_flotsam
    with name 'dead' 'cow' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 104
    with IK2_Link O154_low_bluff
    with IK_150 2
    with IK150_Link O154_low_bluff
    with vector 0
    has mark_as_thing
    with short_name "dead cow"
;

Object O154_low_bluff ""
    class K150_desert_flotsam
    with name 'low' 'bluff' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 105
    with IK2_Link O155_clutch_of_weeds
    with IK_150 3
    with IK150_Link O155_clutch_of_weeds
    with vector 0
    has mark_as_thing
    with short_name "low bluff"
;

Object O155_clutch_of_weeds ""
    class K150_desert_flotsam
    with name 'clutch' 'of' 'weeds' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 106
    with IK2_Link O156_dry_bones
    with IK_150 4
    with IK150_Link O156_dry_bones
    with vector 0
    has mark_as_thing
    with short_name "clutch of weeds"
;

Object O156_dry_bones ""
    class K150_desert_flotsam
    with name 'dry' 'bones' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 107
    with IK2_Link O157_clumps_of_sagebrush
    with IK_150 5
    with IK150_Link O157_clumps_of_sagebrush
    with vector 0
    has mark_as_thing
    has pluralname
    with short_name "dry bones"
;

Object O157_clumps_of_sagebrush ""
    class K150_desert_flotsam
    with name 'clumps' 'of' 'sagebrush' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 108
    with IK2_Link O158_dry_streambed
    with IK_150 6
    with IK150_Link O158_dry_streambed
    with vector 0
    has mark_as_thing
    has pluralname
    with short_name "clumps of sagebrush"
;

Object O158_dry_streambed ""
    class K150_desert_flotsam
    with name 'dry' 'streambed' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 109
    with IK2_Link O159_stand_of_cactus
    with IK_150 7
    with IK150_Link O159_stand_of_cactus
    with vector 0
    has mark_as_thing
    with short_name "dry streambed"
;

Object O159_stand_of_cactus ""
    class K150_desert_flotsam
    with name 'stand' 'of' 'cactus' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 110
    with IK2_Link O160_scattered_patch_of_dyin
    with IK_150 8
    with IK150_Link O160_scattered_patch_of_dyin
    with vector 0
    has mark_as_thing
    with short_name "stand of cactus"
;

Object O160_scattered_patch_of_dyin ""
    class K150_desert_flotsam
    with name 'scattered' 'patch' 'of' 'dying' 'sagebrush' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 111
    with IK2_Link O161_dead_pine_tree
    with IK_150 9
    with IK150_Link O161_dead_pine_tree
    with vector 0
    has mark_as_thing
    with short_name "scattered patch of dying sagebrush"
;

Object O161_dead_pine_tree ""
    class K150_desert_flotsam
    with name 'dead' 'pine' 'tree' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 112
    with IK2_Link O162_weatherbeaten_outcroppi
    with IK_150 10
    with IK150_Link O162_weatherbeaten_outcroppi
    with vector 0
    has mark_as_thing
    with short_name "dead pine tree"
;

Object O162_weatherbeaten_outcroppi ""
    class K150_desert_flotsam
    with name 'weatherbeaten' 'outcropping' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 113
    with IK2_Link O163_lizard_skin
    with IK_150 11
    with IK150_Link O163_lizard_skin
    with vector 0
    has mark_as_thing
    with short_name "weatherbeaten outcropping"
;

Object O163_lizard_skin ""
    class K150_desert_flotsam
    with name 'lizard' 'skin' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 22
    with IK_2 114
    with IK2_Link O167_coyote
    with IK_150 12
    with IK150_Link nothing
    with vector 0
    has mark_as_thing
    with short_name "lizard skin"
;

Object O164_tower_vicinity ""
    class K9_region
    with name 'tower' 'vicinity' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with regional_found_in [; if (TestRegionalContainment(location, O164_tower_vicinity)) rtrue; rfalse; ],
    with IK_0 9
    with IK_9 2
    with IK9_Link O87_around_the_tower
    with vector 0
    has proper
    with short_name "Tower Vicinity"
;

Object -> O87_around_the_tower ""
    class K9_region
    with name 'around' 'the' 'tower' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with regional_found_in [; if (TestRegionalContainment(location, O87_around_the_tower)) rtrue; rfalse; ],
    with IK_0 9
    with IK_9 0
    with IK9_Link O112_office_interior
    with vector 0
    has proper
    with short_name "Around the Tower"
;

Object -> O112_office_interior ""
    class K9_region
    with name 'office' 'interior' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with regional_found_in [; if (TestRegionalContainment(location, O112_office_interior)) rtrue; rfalse; ],
    with IK_0 9
    with IK_9 1
    with IK9_Link nothing
    with vector 0
    has proper
    with short_name "Office Interior"
;

Object O167_coyote ""
    class K165_spirit_animal
    with name 'coyote' 
    with parse_name Parse_Name_GV161
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 23
    with IK_2 116
    with IK2_Link O177_cigarette
    with IK_8 3
    with IK8_Link O168_sand_dancer
    with IK_165 1
    with IK165_Link O168_sand_dancer
    with vector 0
    has mark_as_thing
    has ~female
    with short_name "Coyote"
    with description text_routine_32
    with initial SC_35
    with p21_price 2
;

Object -> O177_cigarette ""
    class K2_thing
    with name 'cigarette' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 125
    with IK2_Link O178_sunglasses
    with vector 0
    has mark_as_thing
    with short_name "cigarette"
;

Object -> O178_sunglasses ""
    class K2_thing
    with name 'sunglasses' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 126
    with IK2_Link O179_faded_denim_jacket
    with vector 0
    has mark_as_thing
    has worn
    has pluralname
    has clothing
    with short_name "sunglasses"
;

Object -> O179_faded_denim_jacket ""
    class K2_thing
    with name 'faded' 'denim' 'jacket' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 127
    with IK2_Link O203_advice
    with vector 0
    has mark_as_thing
    has worn
    has clothing
    with short_name "faded denim jacket"
;

Object -> O203_advice ""
    class K2_thing
    with name 'advice' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Advice"
    with list_together 0
    with IK_0 2
    with IK_2 150
    with IK2_Link O204_trade_for_luck
    with vector 0
    has mark_as_thing
    has proper
    with short_name "advice"
;

Object -> O204_trade_for_luck ""
    class K30_misc_suggestion
    with name 'trade-for-luck' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 151
    with IK2_Link O205_trade_for_scent
    with IK_30 11
    with IK30_Link O205_trade_for_scent
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_36
;

Object -> O205_trade_for_scent ""
    class K30_misc_suggestion
    with name 'trade-for-scent' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 152
    with IK2_Link O168_sand_dancer
    with IK_30 12
    with IK30_Link O211_not_sure_if_i_m_happy
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_37
;

Object O168_sand_dancer ""
    class K165_spirit_animal
    with name 'sand-dancer' 'dancer' 
    with parse_name Parse_Name_GV151
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 23
    with IK_2 117
    with IK2_Link O207_hello
    with IK_8 4
    with IK8_Link O170_desert_hare
    with IK_165 2
    with IK165_Link O166_rabbit
    with vector 0
    has mark_as_thing
    has p69_familiar
    has ~female
    has proper
    with short_name "Sand-dancer"
    with description SC_38
    with initial text_routine_33
    with p21_price 3
    has ~p86_named
;

Object -> O207_hello ""
    class K2_thing
    with name 'hello' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 154
    with IK2_Link O208_path_selection
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_39
;

Object -> O208_path_selection ""
    class K2_thing
    with name 'path' 'selection' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Path selection"
    with list_together 0
    with IK_0 2
    with IK_2 155
    with IK2_Link O209_grab_something
    with vector 0
    has mark_as_thing
    has proper
    with short_name "path selection"
;

Object -> O209_grab_something ""
    class K2_thing
    with name 'grab' 'something' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 156
    with IK2_Link O210_final_choice
    with vector 0
    has mark_as_thing
    has proper
    with short_name text_routine_34
;

Object -> O210_final_choice ""
    class K2_thing
    with name 'final' 'choice' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 157
    with IK2_Link O211_not_sure_if_i_m_happy
    with vector 0
    has mark_as_thing
    has p69_familiar
    with short_name "final choice"
;

Object -> O211_not_sure_if_i_m_happy ""
    class K30_misc_suggestion
    with name 'not' 'sure' 'if' 'i^m' 'happy' 
    with parse_name Parse_Name_GV162
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 158
    with IK2_Link O212_doing_the_trade
    with IK_30 13
    with IK30_Link O213_trade_for_honor
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_40
;

Object -> O212_doing_the_trade ""
    class K2_thing
    with name 'doing' 'the' 'trade' 
    with parse_name Parse_Name_GV163
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 159
    with IK2_Link O213_trade_for_honor
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_41
;

Object -> O213_trade_for_honor ""
    class K30_misc_suggestion
    with name 'trade-for-honor' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 160
    with IK2_Link O214_trade_for_spirit
    with IK_30 14
    with IK30_Link O214_trade_for_spirit
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_42
;

Object -> O214_trade_for_spirit ""
    class K30_misc_suggestion
    with name 'trade-for-spirit' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 161
    with IK2_Link O215_trade_for_freedom
    with IK_30 15
    with IK30_Link O215_trade_for_freedom
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_43
;

Object -> O215_trade_for_freedom ""
    class K30_misc_suggestion
    with name 'trade-for-freedom' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 162
    with IK2_Link O170_desert_hare
    with IK_30 16
    with IK30_Link O176_switch_off_radio
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_44
;

Object O170_desert_hare ""
    class K169_normal_animal
    with name 'desert' 'hare' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 24
    with IK_2 118
    with IK2_Link O172_voice
    with IK_8 5
    with IK8_Link O172_voice
    with IK_25 0
    with IK25_Link O201_snarling_shadows
    with IK_169 0
    with IK169_Link nothing
    with vector 0
    has mark_as_thing
    with short_name "desert hare"
;

Object O172_voice ""
    class K23_man
    with name 'voice' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 10
    with IK_2 120
    with IK2_Link O173_never_mind
    with IK_8 7
    with IK8_Link O166_rabbit
    with IK_23 1
    with IK23_Link nothing
    with vector 0
    has mark_as_thing
    has concealed
    with short_name "voice"
;

Object -> O173_never_mind ""
    class K2_thing
    with name 'never' 'mind' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Never mind"
    with list_together 0
    with IK_0 2
    with IK_2 121
    with IK2_Link O174_what_that_means
    with vector 0
    has mark_as_thing
    has proper
    with short_name "never mind"
;

Object -> O174_what_that_means ""
    class K2_thing
    with name 'what' 'that' 'means' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "What that means"
    with list_together 0
    with IK_0 2
    with IK_2 122
    with IK2_Link O175_being_lost
    with vector 0
    has mark_as_thing
    has proper
    with short_name "what that means"
;

Object -> O175_being_lost ""
    class K2_thing
    with name 'being' 'lost' 
    with parse_name Parse_Name_GV153
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Being lost"
    with list_together 0
    with IK_0 2
    with IK_2 123
    with IK2_Link O176_switch_off_radio
    with vector 0
    has mark_as_thing
    has proper
    with short_name "being lost"
;

Object -> O176_switch_off_radio ""
    class K30_misc_suggestion
    with name 'switch-off-radio' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 124
    with IK2_Link O180_rain
    with IK_30 3
    with IK30_Link O185_go_insane
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_45
;

Object O180_rain ""
    class K7_backdrop
    with name 'rain' 
    with action_bitmap 0 0 0 0 0 0 0 
    has absent
    with list_together 0
    with IK_0 7
    with IK_2 128
    with IK2_Link O181_darting_shadow
    with IK_7 7
    with IK7_Link O200_distant_figure
    with found_in [; rfalse; ],
    with vector 0
    has mark_as_thing
    with short_name "rain"
    with initial SC_46
;

Object O181_darting_shadow ""
    class K2_thing
    with name 'darting' 'shadow' 
    with parse_name Parse_Name_GV156
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 129
    with IK2_Link O166_rabbit
    with vector 0
    has mark_as_thing
    with short_name "darting shadow"
    with initial text_routine_35
    with p23_times_followed 0
    with p22_path O10_north
;

Object O182_burrow ""
    class K1_room
    with name 'burrow' 
    with room_index -1
    with list_together 0
    with IK_0 1
    with IK_1 12
    with IK1_Link nothing
    with vector 0
    has mark_as_room
    has proper
    with short_name "Burrow"
    with description SC_47
;

Object -> O166_rabbit ""
    class K165_spirit_animal
    with name 'rabbit' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 23
    with IK_2 115
    with IK2_Link O185_go_insane
    with IK_8 2
    with IK8_Link O201_snarling_shadows
    with IK_165 0
    with IK165_Link nothing
    with vector 0
    has mark_as_thing
    has ~female
    with short_name "rabbit"
    with description SC_48
    with initial text_routine_36
    with p21_price 1
;

Object -> -> O185_go_insane ""
    class K30_misc_suggestion
    with name 'go' 'insane' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 132
    with IK2_Link O186_grandma
    with IK_30 4
    with IK30_Link O191_don_t_know_if_i_love_he
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_49
;

Object -> -> O186_grandma ""
    class K2_thing
    with name 'grandma' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Grandma"
    with list_together 0
    with IK_0 2
    with IK_2 133
    with IK2_Link O187_how_he_s_not_real
    with vector 0
    has mark_as_thing
    has proper
    with short_name "grandma"
;

Object -> -> O187_how_he_s_not_real ""
    class K2_thing
    with name 'how' 'he^s' 'not' 'real' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "How he's not real"
    with list_together 0
    with IK_0 2
    with IK_2 134
    with IK2_Link O188_rabbit_s_judgment
    with vector 0
    has mark_as_thing
    has proper
    with short_name "how he's not real"
;

Object -> -> O188_rabbit_s_judgment ""
    class K2_thing
    with name 'rabbit^s' 'judgment' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Rabbit's judgment"
    with list_together 0
    with IK_0 2
    with IK_2 135
    with IK2_Link O189_how_he_knows_so_much_ab
    with vector 0
    has mark_as_thing
    has proper
    with short_name "rabbit's judgment"
;

Object -> -> O189_how_he_knows_so_much_ab ""
    class K2_thing
    with name 'how' 'he' 'knows' 'so' 'much' 'about' 'everything' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "How he knows so much about everything"
    with list_together 0
    with IK_0 2
    with IK_2 136
    with IK2_Link O190_down_to_business
    with vector 0
    has mark_as_thing
    has proper
    with short_name "how he knows so much about everything"
;

Object -> -> O190_down_to_business ""
    class K2_thing
    with name 'down' 'to' 'business' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Down to business"
    with list_together 0
    with IK_0 2
    with IK_2 137
    with IK2_Link O191_don_t_know_if_i_love_he
    with vector 0
    has mark_as_thing
    has proper
    with short_name "down to business"
;

Object -> -> O191_don_t_know_if_i_love_he ""
    class K30_misc_suggestion
    with name 'don^t' 'know' 'if' 'i//' 'love' 'her' 
    with parse_name Parse_Name_GV157
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 138
    with IK2_Link O193_more_about_trading
    with IK_30 5
    with IK30_Link O194_trade_for_strength
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_50
;

Object -> -> O193_more_about_trading ""
    class K2_thing
    with name 'more' 'about' 'trading' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "More about trading"
    with list_together 0
    with IK_0 2
    with IK_2 140
    with IK2_Link O194_trade_for_strength
    with vector 0
    has mark_as_thing
    has p69_familiar
    has proper
    with short_name "more about trading"
;

Object -> -> O194_trade_for_strength ""
    class K30_misc_suggestion
    with name 'trade-for-strength' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 141
    with IK2_Link O195_trade_for_courage
    with IK_30 6
    with IK30_Link O195_trade_for_courage
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_51
;

Object -> -> O195_trade_for_courage ""
    class K30_misc_suggestion
    with name 'trade-for-courage' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 142
    with IK2_Link O196_you_don_t_want_to_trade
    with IK_30 7
    with IK30_Link O196_you_don_t_want_to_trade
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_52
;

Object -> -> O196_you_don_t_want_to_trade ""
    class K30_misc_suggestion
    with name 'you' 'don^t' 'want' 'to' 'trade' 'i//' 
    with parse_name Parse_Name_GV158
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 143
    with IK2_Link O197_take_inventory
    with IK_30 8
    with IK30_Link O197_take_inventory
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_53
;

Object -> -> O197_take_inventory ""
    class K30_misc_suggestion
    with name 'take-inventory' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 144
    with IK2_Link O183_roots
    with IK_30 9
    with IK30_Link O199_lookup_suggestion
    with vector 0
    has mark_as_thing
    has proper
    with short_name SC_54
;

Object -> O183_roots ""
    class K2_thing
    with name 'roots' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 130
    with IK2_Link O184_introduction
    with vector 0
    has mark_as_thing
    has pluralname
    has static
    has scenery
    with short_name "roots"
;

Object O184_introduction ""
    class K2_thing
    with name 'introduction' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "Introduction"
    with list_together 0
    with IK_0 2
    with IK_2 131
    with IK2_Link O192_easter_basket_filled_wi
    with vector 0
    has mark_as_thing
    has p69_familiar
    has proper
    with short_name "introduction"
;

Object O192_easter_basket_filled_wi ""
    class K2_thing
    with name 'easter' 'basket' 'filled' 'with' 'plastic' 'green' 'easter' 'grass' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 2
    with IK_2 139
    with IK2_Link O198_more_coming
    with vector 0
    has mark_as_thing
    with short_name "easter basket filled with plastic green easter grass"
;

Object O198_more_coming ""
    class K2_thing
    with name 'more' 'coming' 
    with action_bitmap 0 0 0 0 0 0 0 
    with cap_short_name "More coming"
    with list_together 0
    with IK_0 2
    with IK_2 145
    with IK2_Link O199_lookup_suggestion
    with vector 0
    has mark_as_thing
    has proper
    with short_name "more coming"
;

Object O199_lookup_suggestion ""
    class K30_misc_suggestion
    with name 'lookup-suggestion' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 17
    with IK_2 146
    with IK2_Link O200_distant_figure
    with IK_30 10
    with IK30_Link nothing
    with vector 0
    has mark_as_thing
    has ~p69_familiar
    has proper
    with short_name SC_55
;

Object O200_distant_figure ""
    class K7_backdrop
    with name 'distant' 'figure' 
    with action_bitmap 0 0 0 0 0 0 0 
    has absent
    with list_together 0
    with IK_0 7
    with IK_2 147
    with IK2_Link O201_snarling_shadows
    with IK_7 8
    with IK7_Link nothing
    with found_in [; rfalse; ],
    with vector 0
    has mark_as_thing
    with short_name "distant figure"
;

Object O201_snarling_shadows ""
    class K25_animal
    with name 'snarling' 'shadows' 
    with parse_name Parse_Name_GV159
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 12
    with IK_2 148
    with IK2_Link O202_circle_of_snarling_coyo
    with IK_8 8
    with IK8_Link O202_circle_of_snarling_coyo
    with IK_25 2
    with IK25_Link O202_circle_of_snarling_coyo
    with vector 0
    has mark_as_thing
    has concealed
    with short_name "snarling shadows"
;

Object O202_circle_of_snarling_coyo ""
    class K25_animal
    with name 'circle' 'of' 'snarling' 'coyotes' 'coyote' 
    with parse_name Parse_Name_GV160
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 12
    with IK_2 149
    with IK2_Link O206_thousands_of_lizards
    with IK_8 9
    with IK8_Link O206_thousands_of_lizards
    with IK_25 3
    with IK25_Link O206_thousands_of_lizards
    with vector 0
    has mark_as_thing
    with short_name "circle of snarling coyotes"
    with description SC_56
;

Object O206_thousands_of_lizards ""
    class K25_animal
    with name 'thousands' 'of' 'lizards' 
    with action_bitmap 0 0 0 0 0 0 0 
    with list_together 0
    with IK_0 12
    with IK_2 153
    with IK2_Link nothing
    with IK_8 10
    with IK8_Link nothing
    with IK_25 4
    with IK25_Link nothing
    with vector 0
    has mark_as_thing
    with short_name "thousands of lizards"
    with description SC_57
    with initial SC_58
;

Class VPH_Class;
Array KOV_representatives --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ValuePropertyHolder_94 0 0 0 0 0 0 0 ValuePropertyHolder_102 0 ;
VPH_Class ValuePropertyHolder_94
    with value_range 11
    with p65_recurring KOVP_94_P65
    with description KOVP_94_P6
    with p85_dramatic KOVP_94_P85
;
! Storage for property p65_recurring of KOV SCENE_TY
Array KOVP_94_P65 table 0 0 (true) (false) (false) (true) (false) (false) (false) (false) (false) (false) (false) ;
! Storage for property description of KOV SCENE_TY
Array KOVP_94_P6 table 0 0 (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (SC_59) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (SC_60) (text_routine_37) (text_routine_38) ;
! Storage for property p85_dramatic of KOV SCENE_TY
Array KOVP_94_P85 table 0 0 (false) (false) (false) (false) (true) (false) (true) (true) (false) (true) (false) ;
VPH_Class ValuePropertyHolder_102
    with value_range 315
    with p73_message_text tab_3_1
;
! Storage for property p73_message_text of KOV <type-102>
Array KOVP_102_P73 table 0 0 (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) ;
Constant Q0_figure_of_cover = 1;
Constant Q1_entire_game = 1;
Constant Q2_didn_t_understand_error = 1;
Constant Q3_only_understood_as_far_as = 2;
Constant Q4_didn_t_understand_that_nu = 3;
Constant Q5_can_only_do_that_to_somet = 4;
Constant Q6_can_t_see_any_such_thing_ = 5;
Constant Q7_said_too_little_error = 6;
Constant Q8_aren_t_holding_that_error = 7;
Constant Q9_can_t_use_multiple_object = 8;
Constant Q10_can_only_use_multiple_ob = 9;
Constant Q11_not_sure_what_it_refers_ = 10;
Constant Q12_excepted_something_not_i = 11;
Constant Q13_not_a_verb_i_recognise_e = 12;
Constant Q14_not_something_you_need_t = 13;
Constant Q15_can_t_see_it_at_the_mome = 14;
Constant Q16_didn_t_understand_the_wa = 15;
Constant Q17_not_enough_of_those_avai = 16;
Constant Q18_nothing_to_do_error = 17;
Constant Q19_noun_did_not_make_sense_ = 18;
Constant Q20_referred_to_a_determinat = 19;
Constant Q21_i_beg_your_pardon_error = 20;
Constant Q22_implicit = 1;
Constant Q23_explicit = 2;
Constant Q24_libmsg__you_have_died_ = 1;
Constant Q25_libmsg__you_have_won_ = 2;
Constant Q26_libmsg__player_self_desc = 3;
Constant Q27_libmsg__unimportant_obje = 4;
Constant Q28_libmsg__empty_line_ = 5;
Constant Q29_libmsg__confirm_quit_ = 6;
Constant Q30_libmsg__yes_or_no_prompt = 7;
Constant Q31_libmsg__restrict_answer_ = 8;
Constant Q32_libmsg__page_prompt_ = 9;
Constant Q33_libmsg__menu_prompt_ = 10;
Constant Q34_libmsg__comment_recorded = 11;
Constant Q35_libmsg__comment_not_reco = 12;
Constant Q36_libmsg__undo_succeeded_ = 13;
Constant Q37_libmsg__undo_failed_ = 14;
Constant Q38_libmsg__undo_not_provide = 15;
Constant Q39_libmsg__cannot_undo_noth = 16;
Constant Q40_libmsg__cannot_undo_twic = 17;
Constant Q41_libmsg__undo_forbidden_ = 18;
Constant Q42_libmsg__oops_failed_ = 19;
Constant Q43_libmsg__oops_too_many_ar = 20;
Constant Q44_libmsg__oops_no_argument = 21;
Constant Q45_libmsg__cannot_do_again_ = 22;
Constant Q46_libmsg__again_usage_ = 23;
Constant Q47_libmsg__command_not_unde = 24;
Constant Q48_libmsg__command_partly_u = 25;
Constant Q49_libmsg__command_badly_en = 26;
Constant Q50_libmsg__command_incomple = 27;
Constant Q51_libmsg__command_cut_shor = 28;
Constant Q52_libmsg__number_not_under = 29;
Constant Q53_libmsg__cannot_begin_at_ = 30;
Constant Q54_libmsg__extra_words_befo = 31;
Constant Q55_libmsg__unknown_object_ = 32;
Constant Q56_libmsg__object_not_held_ = 33;
Constant Q57_libmsg__unknown_verb_ = 34;
Constant Q58_libmsg__verb_cannot_have = 35;
Constant Q59_libmsg__noun_needed_ = 36;
Constant Q60_libmsg__noun_not_needed_ = 37;
Constant Q61_libmsg__object_needed_ = 38;
Constant Q62_libmsg__object_not_neede = 39;
Constant Q63_libmsg__second_object_ne = 40;
Constant Q64_libmsg__second_object_no = 41;
Constant Q65_libmsg__second_noun_need = 42;
Constant Q66_libmsg__second_noun_not_ = 43;
Constant Q67_libmsg__something_more_s = 44;
Constant Q68_libmsg__verb_cannot_have = 45;
Constant Q69_libmsg__too_many_multipl = 46;
Constant Q70_libmsg__not_that_many_av = 47;
Constant Q71_libmsg__no_objects_avail = 48;
Constant Q72_libmsg__zero_multiple_ob = 49;
Constant Q73_libmsg__first_n_objects_ = 50;
Constant Q74_libmsg__excepted_object_ = 51;
Constant Q75_libmsg__report_implicit_ = 52;
Constant Q76_libmsg__report_npc_impli = 53;
Constant Q77_libmsg__use_holdall_to_a = 54;
Constant Q78_libmsg__cannot_put_if_th = 55;
Constant Q79_libmsg__who_disambiguati = 56;
Constant Q80_libmsg__which_disambigua = 57;
Constant Q81_libmsg__whom_disambiguat = 58;
Constant Q82_libmsg__what_disambiguat = 59;
Constant Q83_libmsg__single_object_di = 60;
Constant Q84_libmsg__pronoun_not_set_ = 61;
Constant Q85_libmsg__pronoun_absent_ = 62;
Constant Q86_libmsg__pronouns_initial = 63;
Constant Q87_libmsg__pronouns__means_ = 64;
Constant Q88_libmsg__pronouns__unset_ = 65;
Constant Q89_libmsg__no_pronouns_know = 66;
Constant Q90_libmsg__person_ignores_c = 67;
Constant Q91_libmsg__cannot_talk_to_a = 68;
Constant Q92_libmsg__cannot_talk_to_i = 69;
Constant Q93_libmsg__npc_unable_to_do = 70;
Constant Q94_libmsg__confirm_restart_ = 71;
Constant Q95_libmsg__restart_failed_ = 72;
Constant Q96_libmsg__restore_failed_ = 73;
Constant Q97_libmsg__restore_succeede = 74;
Constant Q98_libmsg__save_failed_ = 75;
Constant Q99_libmsg__save_succeeded_ = 76;
Constant Q100_libmsg__verify_succeede = 77;
Constant Q101_libmsg__verify_failed_ = 78;
Constant Q102_libmsg__transcript_alre = 79;
Constant Q103_libmsg__transcript_alre = 80;
Constant Q104_libmsg__start_of_transc = 81;
Constant Q105_libmsg__end_of_transcri = 82;
Constant Q106_libmsg__transcript_fail = 83;
Constant Q107_libmsg__end_transcript_ = 84;
Constant Q108_libmsg__score_command_ = 85;
Constant Q109_libmsg__score_changed_ = 86;
Constant Q110_libmsg__score_notificat = 87;
Constant Q111_libmsg__score_notificat = 88;
Constant Q112_libmsg__no_scoring_ = 89;
Constant Q113_libmsg__score_rank_ = 90;
Constant Q114_libmsg__report_npc_taki = 91;
Constant Q115_libmsg__inventory_initi = 92;
Constant Q116_libmsg__inventory_no_po = 93;
Constant Q117_libmsg__entering_darkne = 94;
Constant Q118_libmsg__dark_descriptio = 95;
Constant Q119_libmsg__examine_while_d = 96;
Constant Q120_libmsg__search_while_da = 97;
Constant Q121_libmsg__look_under_whil = 98;
Constant Q122_libmsg__dark_room_name_ = 99;
Constant Q123_libmsg__report_player_t = 100;
Constant Q124_libmsg__report_npc_taki = 101;
Constant Q125_libmsg__cannot_take_you = 102;
Constant Q126_libmsg__cannot_take_oth = 103;
Constant Q127_libmsg__cannot_take_som = 104;
Constant Q128_libmsg__cannot_take_som = 105;
Constant Q129_libmsg__cannot_take_pos = 106;
Constant Q130_libmsg__cannot_take_com = 107;
Constant Q131_libmsg__cannot_take_hid = 108;
Constant Q132_libmsg__cannot_reach_wi = 109;
Constant Q133_libmsg__cannot_take_sce = 110;
Constant Q134_libmsg__cannot_take_som = 111;
Constant Q135_libmsg__cannot_reach_wi = 112;
Constant Q136_libmsg__cannot_exceed_c = 113;
Constant Q137_libmsg__report_player_r = 114;
Constant Q138_libmsg__report_npc_remo = 115;
Constant Q139_libmsg__cannot_remove_f = 116;
Constant Q140_libmsg__cannot_remove_s = 117;
Constant Q141_libmsg__report_player_d = 118;
Constant Q142_libmsg__report_npc_drop = 119;
Constant Q143_libmsg__cannot_drop_som = 120;
Constant Q144_libmsg__cannot_drop_not = 121;
Constant Q145_libmsg__cannot_drop_if_ = 122;
Constant Q146_libmsg__cannot_drop_clo = 123;
Constant Q147_libmsg__report_player_i = 124;
Constant Q148_libmsg__report_npc_inse = 125;
Constant Q149_libmsg__cannot_insert_s = 126;
Constant Q150_libmsg__cannot_insert_i = 127;
Constant Q151_libmsg__cannot_insert_i = 128;
Constant Q152_libmsg__need_to_take_of = 129;
Constant Q153_libmsg__cannot_insert_s = 130;
Constant Q154_libmsg__cannot_insert_i = 131;
Constant Q155_libmsg__cannot_insert_c = 132;
Constant Q156_libmsg__report_player_p = 133;
Constant Q157_libmsg__report_npc_putt = 134;
Constant Q158_libmsg__cannot_put_some = 135;
Constant Q159_libmsg__cannot_put_some = 136;
Constant Q160_libmsg__cannot_put_onto = 137;
Constant Q161_libmsg__cannot_put_onto = 138;
Constant Q162_libmsg__cannot_put_clot = 139;
Constant Q163_libmsg__report_player_g = 140;
Constant Q164_libmsg__report_npc_givi = 141;
Constant Q165_libmsg__report_npc_givi = 142;
Constant Q166_libmsg__cannot_give_wha = 143;
Constant Q167_libmsg__cannot_give_to_ = 144;
Constant Q168_libmsg__block_giving_ = 145;
Constant Q169_libmsg__unable_to_recei = 146;
Constant Q170_libmsg__cannot_show_wha = 147;
Constant Q171_libmsg__block_showing_ = 148;
Constant Q172_libmsg__report_player_e = 149;
Constant Q173_libmsg__report_npc_ente = 150;
Constant Q174_libmsg__cannot_enter_so = 151;
Constant Q175_libmsg__cannot_enter_so = 152;
Constant Q176_libmsg__cannot_enter_cl = 153;
Constant Q177_libmsg__cannot_enter_so = 154;
Constant Q178_libmsg__implicitly_pass = 155;
Constant Q179_libmsg__implicitly_pass = 156;
Constant Q180_libmsg__report_player_e = 157;
Constant Q181_libmsg__report_npc_exit = 158;
Constant Q182_libmsg__cannot_exit_whe = 159;
Constant Q183_libmsg__cannot_exit_clo = 160;
Constant Q184_libmsg__cannot_get_off_ = 161;
Constant Q185_libmsg__cannot_exit_thi = 162;
Constant Q186_libmsg__cannot_go_that_ = 163;
Constant Q187_libmsg__cannot_travel_i = 164;
Constant Q188_libmsg__cannot_go_throu = 165;
Constant Q189_libmsg__cannot_go_up_th = 166;
Constant Q190_libmsg__cannot_go_down_ = 167;
Constant Q191_libmsg__cannot_go_throu = 168;
Constant Q192_libmsg__nothing_through = 169;
Constant Q193_libmsg__block_vaguely_g = 170;
Constant Q194_libmsg__say_npc_goes_ = 171;
Constant Q195_libmsg__say_npc_arrives = 172;
Constant Q196_libmsg__say_npc_arrives = 173;
Constant Q197_libmsg__say_npc_arrives = 174;
Constant Q198_libmsg__say_npc_goes_th = 175;
Constant Q199_libmsg__say_npc_arrives = 176;
Constant Q200_libmsg__say_npc_vehicle = 177;
Constant Q201_libmsg__say_npc_pushing = 178;
Constant Q202_libmsg__say_npc_pushing = 179;
Constant Q203_libmsg__say_npc_pushing = 180;
Constant Q204_libmsg__say_npc_pushing = 181;
Constant Q205_libmsg__say_npc_taking_ = 182;
Constant Q206_libmsg__brief_look_mode = 183;
Constant Q207_libmsg__superbrief_look = 184;
Constant Q208_libmsg__verbose_look_mo = 185;
Constant Q209_libmsg__report_npc_look = 186;
Constant Q210_libmsg__top_line_what_o = 187;
Constant Q211_libmsg__top_line_what_i = 188;
Constant Q212_libmsg__top_line_what_a = 189;
Constant Q213_libmsg__say_things_with = 190;
Constant Q214_libmsg__say_things_also = 191;
Constant Q215_libmsg__say_things_on_ = 192;
Constant Q216_libmsg__report_npc_exam = 193;
Constant Q217_libmsg__examine_undescr = 194;
Constant Q218_libmsg__examine_directi = 195;
Constant Q219_libmsg__examine_devices = 196;
Constant Q220_libmsg__examine_in_dark = 197;
Constant Q221_libmsg__report_npc_sear = 198;
Constant Q222_libmsg__cannot_search_u = 199;
Constant Q223_libmsg__cannot_search_c = 200;
Constant Q224_libmsg__nothing_found_w = 201;
Constant Q225_libmsg__nothing_found_o = 202;
Constant Q226_libmsg__search_in_darkn = 203;
Constant Q227_libmsg__report_npc_look = 204;
Constant Q228_libmsg__look_under_ = 205;
Constant Q229_libmsg__look_under_in_d = 206;
Constant Q230_libmsg__report_player_o = 207;
Constant Q231_libmsg__report_npc_open = 208;
Constant Q232_libmsg__report_unseen_n = 209;
Constant Q233_libmsg__cannot_open_unl = 210;
Constant Q234_libmsg__cannot_open_som = 211;
Constant Q235_libmsg__cannot_open_som = 212;
Constant Q236_libmsg__reveal_any_newl = 213;
Constant Q237_libmsg__no_newly_visibl = 214;
Constant Q238_libmsg__report_player_c = 215;
Constant Q239_libmsg__report_npc_clos = 216;
Constant Q240_libmsg__report_unseen_n = 217;
Constant Q241_libmsg__cannot_close_un = 218;
Constant Q242_libmsg__cannot_close_so = 219;
Constant Q243_libmsg__report_player_l = 220;
Constant Q244_libmsg__report_npc_lock = 221;
Constant Q245_libmsg__cannot_lock_wit = 222;
Constant Q246_libmsg__cannot_lock_som = 223;
Constant Q247_libmsg__cannot_lock_som = 224;
Constant Q248_libmsg__cannot_lock_wit = 225;
Constant Q249_libmsg__report_player_u = 226;
Constant Q250_libmsg__report_npc_unlo = 227;
Constant Q251_libmsg__cannot_unlock_w = 228;
Constant Q252_libmsg__cannot_unlock_s = 229;
Constant Q253_libmsg__cannot_unlock_w = 230;
Constant Q254_libmsg__report_player_s = 231;
Constant Q255_libmsg__report_npc_swit = 232;
Constant Q256_libmsg__cannot_switch_o = 233;
Constant Q257_libmsg__cannot_switch_o = 234;
Constant Q258_libmsg__report_player_s = 235;
Constant Q259_libmsg__report_npc_swit = 236;
Constant Q260_libmsg__cannot_switch_o = 237;
Constant Q261_libmsg__cannot_switch_o = 238;
Constant Q262_libmsg__report_player_w = 239;
Constant Q263_libmsg__report_npc_wear = 240;
Constant Q264_libmsg__cannot_wear_som = 241;
Constant Q265_libmsg__cannot_wear_not = 242;
Constant Q266_libmsg__cannot_wear_som = 243;
Constant Q267_libmsg__report_player_t = 244;
Constant Q268_libmsg__report_npc_taki = 245;
Constant Q269_libmsg__cannot_take_off = 246;
Constant Q270_libmsg__report_player_e = 247;
Constant Q271_libmsg__report_npc_eati = 248;
Constant Q272_libmsg__cannot_eat_unle = 249;
Constant Q273_libmsg__block_drinking_ = 250;
Constant Q274_libmsg__block_tasting_ = 251;
Constant Q275_libmsg__block_smelling_ = 252;
Constant Q276_libmsg__block_listening = 253;
Constant Q277_libmsg__report_player_t = 254;
Constant Q278_libmsg__report_npc_touc = 255;
Constant Q279_libmsg__report_player_t = 256;
Constant Q280_libmsg__report_npc_touc = 257;
Constant Q281_libmsg__report_player_t = 258;
Constant Q282_libmsg__report_npc_touc = 259;
Constant Q283_libmsg__block_saying_ye = 260;
Constant Q284_libmsg__block_saying_no = 261;
Constant Q285_libmsg__block_saying_so = 262;
Constant Q286_libmsg__block_swearing_ = 263;
Constant Q287_libmsg__block_swearing_ = 264;
Constant Q288_libmsg__block_climbing_ = 265;
Constant Q289_libmsg__block_jumping_ = 266;
Constant Q290_libmsg__block_swinging_ = 267;
Constant Q291_libmsg__block_waving_ha = 268;
Constant Q292_libmsg__block_attacking = 269;
Constant Q293_libmsg__block_burning_ = 270;
Constant Q294_libmsg__block_cutting_ = 271;
Constant Q295_libmsg__block_rubbing_ = 272;
Constant Q296_libmsg__block_setting_t = 273;
Constant Q297_libmsg__block_tying_ = 274;
Constant Q298_libmsg__report_player_w = 275;
Constant Q299_libmsg__report_npc_wavi = 276;
Constant Q300_libmsg__cannot_wave_som = 277;
Constant Q301_libmsg__squeezing_peopl = 278;
Constant Q302_libmsg__report_player_s = 279;
Constant Q303_libmsg__report_npc_sque = 280;
Constant Q304_libmsg__block_throwing_ = 281;
Constant Q305_libmsg__throw_at_inanim = 282;
Constant Q306_libmsg__report_player_p = 283;
Constant Q307_libmsg__report_npc_push = 284;
Constant Q308_libmsg__report_player_p = 285;
Constant Q309_libmsg__report_npc_pull = 286;
Constant Q310_libmsg__report_player_t = 287;
Constant Q311_libmsg__report_npc_turn = 288;
Constant Q312_libmsg__block_pushing_i = 289;
Constant Q313_libmsg__not_pushed_in_a = 290;
Constant Q314_libmsg__pushed_in_illeg = 291;
Constant Q315_libmsg__cannot_push_som = 292;
Constant Q316_libmsg__cannot_pull_som = 293;
Constant Q317_libmsg__cannot_turn_som = 294;
Constant Q318_libmsg__cannot_push_sce = 295;
Constant Q319_libmsg__cannot_pull_sce = 296;
Constant Q320_libmsg__cannot_turn_sce = 297;
Constant Q321_libmsg__cannot_push_peo = 298;
Constant Q322_libmsg__cannot_pull_peo = 299;
Constant Q323_libmsg__cannot_turn_peo = 300;
Constant Q324_libmsg__block_answering = 301;
Constant Q325_libmsg__block_asking_ = 302;
Constant Q326_libmsg__block_buying_ = 303;
Constant Q327_libmsg__block_kissing_ = 304;
Constant Q328_libmsg__block_singing_ = 305;
Constant Q329_libmsg__block_telling_ = 306;
Constant Q330_libmsg__telling_yoursel = 307;
Constant Q331_libmsg__block_thinking_ = 308;
Constant Q332_libmsg__block_player_co = 309;
Constant Q333_libmsg__block_npc_consu = 310;
Constant Q334_libmsg__block_sleeping_ = 311;
Constant Q335_libmsg__block_waking_up = 312;
Constant Q336_libmsg__block_waking_ot = 313;
Constant Q337_libmsg__report_player_w = 314;
Constant Q338_libmsg__report_npc_wait = 315;
Constant Q339_sinister_voices = 2;
Constant Q340_rainstorm = 3;
Constant Q341_pursuit = 4;
Constant Q342_rabbit_s_offer = 5;
Constant Q343_temptation = 6;
Constant Q344_chase = 7;
Constant Q345_fight = 8;
Constant Q346_coyote_s_offer = 9;
Constant Q347_sand_dancer_s_arrival = 10;
Constant Q348_sand_dancer_s_offer = 11;
Array Global_Vars -->
  (false) ! 7
  (SC_61) ! 24
  (SC_3) ! 29
  (SC_2) ! 30
  (SC_62) ! 31
  (SC_63) ! 32
  (4) ! 33
  (2010) ! 34
  (0) ! 43
  (nothing) ! 51
  (Q23_explicit) ! 52
  (Q23_explicit) ! 53
  (selfobj) ! 54
  (0) ! 55
  (0) ! 56
  (0) ! 57
  (1) ! 58
  (Q23_explicit) ! 59
  (1) ! 60
  (1) ! 61
  (O66_middle_of_nowhere) ! 62
  (Q24_libmsg__you_have_died_) ! 63
  (0) ! 64
  (nothing) ! 65
  (nothing) ! 66
  (false) ! 67
  (6) ! 68
  (1023) ! 69
  (false) ! 70
  (false) ! 71
  (false) ! 72
  (false) ! 73
  (false) ! 74
;



Array T0_final_question_options table  tab_0_0 tab_0_1 tab_0_2 tab_0_3 tab_0_4;
Array tab_0_0 table $0064 0  (SC_64)  (SC_65)  (SC_66)  (SC_67)  (SC_68) ;
Array tab_0_1 table $0465 1  (0)  (0)  (1)  (0)  (0) ;
Array tab_0_2 table $2066 2  (Consult_Grammar_164)  (Consult_Grammar_165)  (Consult_Grammar_166)  (Consult_Grammar_167)  (Consult_Grammar_168) ;
Array tab_0_3 table $0067 3  (IMMEDIATELY_RESTART_VM_R)  (IMMEDIATELY_RESTORE_SAVED_R)  TABLE_NOVALUE (IMMEDIATELY_QUIT_R)  (IMMEDIATELY_UNDO_R) ;
Array tab_0_4 table $0068 4  TABLE_NOVALUE TABLE_NOVALUE (V26_amusing_a_victorious_pla)  TABLE_NOVALUE TABLE_NOVALUE;
Array T1_locale_priorities table  tab_1_0 tab_1_1;
Array tab_1_0 table $0869 NULL  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array tab_1_1 table $446a 5  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T2_custom_library_messages table  tab_2_0 tab_2_1;
Array tab_2_0 table $4c6b NULL  TABLE_NOVALUE;
Array tab_2_1 table $006c 26  TABLE_NOVALUE;
Array T3_library_messages table  tab_3_0 tab_3_1;
Array tab_3_0 table $5c6b NULL  (Q24_libmsg__you_have_died_)  (Q25_libmsg__you_have_won_)  (Q26_libmsg__player_self_desc)  (Q27_libmsg__unimportant_obje)  (Q28_libmsg__empty_line_)  (Q29_libmsg__confirm_quit_)  (Q30_libmsg__yes_or_no_prompt)  (Q31_libmsg__restrict_answer_)  (Q32_libmsg__page_prompt_)  (Q33_libmsg__menu_prompt_)  (Q34_libmsg__comment_recorded)  (Q35_libmsg__comment_not_reco)  (Q36_libmsg__undo_succeeded_)  (Q37_libmsg__undo_failed_)  (Q38_libmsg__undo_not_provide)  (Q39_libmsg__cannot_undo_noth)  (Q40_libmsg__cannot_undo_twic)  (Q41_libmsg__undo_forbidden_)  (Q42_libmsg__oops_failed_)  (Q43_libmsg__oops_too_many_ar)  (Q44_libmsg__oops_no_argument)  (Q45_libmsg__cannot_do_again_)  (Q46_libmsg__again_usage_)  (Q47_libmsg__command_not_unde)  (Q48_libmsg__command_partly_u)  (Q49_libmsg__command_badly_en)  (Q50_libmsg__command_incomple)  (Q51_libmsg__command_cut_shor)  (Q52_libmsg__number_not_under)  (Q53_libmsg__cannot_begin_at_)  (Q54_libmsg__extra_words_befo)  (Q55_libmsg__unknown_object_)  (Q56_libmsg__object_not_held_)  (Q57_libmsg__unknown_verb_)  (Q58_libmsg__verb_cannot_have)  (Q59_libmsg__noun_needed_)  (Q60_libmsg__noun_not_needed_)  (Q61_libmsg__object_needed_)  (Q62_libmsg__object_not_neede)  (Q63_libmsg__second_object_ne)  (Q64_libmsg__second_object_no)  (Q65_libmsg__second_noun_need)  (Q66_libmsg__second_noun_not_)  (Q67_libmsg__something_more_s)  (Q68_libmsg__verb_cannot_have)  (Q69_libmsg__too_many_multipl)  (Q70_libmsg__not_that_many_av)  (Q71_libmsg__no_objects_avail)  (Q72_libmsg__zero_multiple_ob)  (Q73_libmsg__first_n_objects_)  (Q74_libmsg__excepted_object_)  (Q75_libmsg__report_implicit_)  (Q76_libmsg__report_npc_impli)  (Q77_libmsg__use_holdall_to_a)  (Q78_libmsg__cannot_put_if_th)  (Q79_libmsg__who_disambiguati)  (Q80_libmsg__which_disambigua)  (Q81_libmsg__whom_disambiguat)  (Q82_libmsg__what_disambiguat)  (Q83_libmsg__single_object_di)  (Q84_libmsg__pronoun_not_set_)  (Q85_libmsg__pronoun_absent_)  (Q86_libmsg__pronouns_initial)  (Q87_libmsg__pronouns__means_)  (Q88_libmsg__pronouns__unset_)  (Q89_libmsg__no_pronouns_know)  (Q90_libmsg__person_ignores_c)  (Q91_libmsg__cannot_talk_to_a)  (Q92_libmsg__cannot_talk_to_i)  (Q93_libmsg__npc_unable_to_do)  (Q94_libmsg__confirm_restart_)  (Q95_libmsg__restart_failed_)  (Q96_libmsg__restore_failed_)  (Q97_libmsg__restore_succeede)  (Q98_libmsg__save_failed_)  (Q99_libmsg__save_succeeded_)  (Q100_libmsg__verify_succeede)  (Q101_libmsg__verify_failed_)  (Q102_libmsg__transcript_alre)  (Q103_libmsg__transcript_alre)  (Q104_libmsg__start_of_transc)  (Q105_libmsg__end_of_transcri)  (Q106_libmsg__transcript_fail)  (Q107_libmsg__end_transcript_)  (Q108_libmsg__score_command_)  (Q109_libmsg__score_changed_)  (Q110_libmsg__score_notificat)  (Q111_libmsg__score_notificat)  (Q112_libmsg__no_scoring_)  (Q113_libmsg__score_rank_)  (Q114_libmsg__report_npc_taki)  (Q115_libmsg__inventory_initi)  (Q116_libmsg__inventory_no_po)  (Q117_libmsg__entering_darkne)  (Q118_libmsg__dark_descriptio)  (Q119_libmsg__examine_while_d)  (Q120_libmsg__search_while_da)  (Q121_libmsg__look_under_whil)  (Q122_libmsg__dark_room_name_)  (Q123_libmsg__report_player_t)  (Q124_libmsg__report_npc_taki)  (Q125_libmsg__cannot_take_you)  (Q126_libmsg__cannot_take_oth)  (Q127_libmsg__cannot_take_som)  (Q128_libmsg__cannot_take_som)  (Q129_libmsg__cannot_take_pos)  (Q130_libmsg__cannot_take_com)  (Q131_libmsg__cannot_take_hid)  (Q132_libmsg__cannot_reach_wi)  (Q133_libmsg__cannot_take_sce)  (Q134_libmsg__cannot_take_som)  (Q135_libmsg__cannot_reach_wi)  (Q136_libmsg__cannot_exceed_c)  (Q137_libmsg__report_player_r)  (Q138_libmsg__report_npc_remo)  (Q139_libmsg__cannot_remove_f)  (Q140_libmsg__cannot_remove_s)  (Q141_libmsg__report_player_d)  (Q142_libmsg__report_npc_drop)  (Q143_libmsg__cannot_drop_som)  (Q144_libmsg__cannot_drop_not)  (Q145_libmsg__cannot_drop_if_)  (Q146_libmsg__cannot_drop_clo)  (Q147_libmsg__report_player_i)  (Q148_libmsg__report_npc_inse)  (Q149_libmsg__cannot_insert_s)  (Q150_libmsg__cannot_insert_i)  (Q151_libmsg__cannot_insert_i)  (Q152_libmsg__need_to_take_of)  (Q153_libmsg__cannot_insert_s)  (Q154_libmsg__cannot_insert_i)  (Q155_libmsg__cannot_insert_c)  (Q156_libmsg__report_player_p)  (Q157_libmsg__report_npc_putt)  (Q158_libmsg__cannot_put_some)  (Q159_libmsg__cannot_put_some)  (Q160_libmsg__cannot_put_onto)  (Q161_libmsg__cannot_put_onto)  (Q162_libmsg__cannot_put_clot)  (Q163_libmsg__report_player_g)  (Q164_libmsg__report_npc_givi)  (Q165_libmsg__report_npc_givi)  (Q166_libmsg__cannot_give_wha)  (Q167_libmsg__cannot_give_to_)  (Q168_libmsg__block_giving_)  (Q169_libmsg__unable_to_recei)  (Q170_libmsg__cannot_show_wha)  (Q171_libmsg__block_showing_)  (Q172_libmsg__report_player_e)  (Q173_libmsg__report_npc_ente)  (Q174_libmsg__cannot_enter_so)  (Q175_libmsg__cannot_enter_so)  (Q176_libmsg__cannot_enter_cl)  (Q177_libmsg__cannot_enter_so)  (Q178_libmsg__implicitly_pass)  (Q179_libmsg__implicitly_pass)  (Q180_libmsg__report_player_e)  (Q181_libmsg__report_npc_exit)  (Q182_libmsg__cannot_exit_whe)  (Q183_libmsg__cannot_exit_clo)  (Q184_libmsg__cannot_get_off_)  (Q185_libmsg__cannot_exit_thi)  (Q186_libmsg__cannot_go_that_)  (Q187_libmsg__cannot_travel_i)  (Q188_libmsg__cannot_go_throu)  (Q189_libmsg__cannot_go_up_th)  (Q190_libmsg__cannot_go_down_)  (Q191_libmsg__cannot_go_throu)  (Q192_libmsg__nothing_through)  (Q193_libmsg__block_vaguely_g)  (Q194_libmsg__say_npc_goes_)  (Q195_libmsg__say_npc_arrives)  (Q196_libmsg__say_npc_arrives)  (Q197_libmsg__say_npc_arrives)  (Q198_libmsg__say_npc_goes_th)  (Q199_libmsg__say_npc_arrives)  (Q200_libmsg__say_npc_vehicle)  (Q201_libmsg__say_npc_pushing)  (Q202_libmsg__say_npc_pushing)  (Q203_libmsg__say_npc_pushing)  (Q204_libmsg__say_npc_pushing)  (Q205_libmsg__say_npc_taking_)  (Q206_libmsg__brief_look_mode)  (Q207_libmsg__superbrief_look)  (Q208_libmsg__verbose_look_mo)  (Q209_libmsg__report_npc_look)  (Q210_libmsg__top_line_what_o)  (Q211_libmsg__top_line_what_i)  (Q212_libmsg__top_line_what_a)  (Q213_libmsg__say_things_with)  (Q214_libmsg__say_things_also)  (Q215_libmsg__say_things_on_)  (Q216_libmsg__report_npc_exam)  (Q217_libmsg__examine_undescr)  (Q218_libmsg__examine_directi)  (Q219_libmsg__examine_devices)  (Q220_libmsg__examine_in_dark)  (Q221_libmsg__report_npc_sear)  (Q222_libmsg__cannot_search_u)  (Q223_libmsg__cannot_search_c)  (Q224_libmsg__nothing_found_w)  (Q225_libmsg__nothing_found_o)  (Q226_libmsg__search_in_darkn)  (Q227_libmsg__report_npc_look)  (Q228_libmsg__look_under_)  (Q229_libmsg__look_under_in_d)  (Q230_libmsg__report_player_o)  (Q231_libmsg__report_npc_open)  (Q232_libmsg__report_unseen_n)  (Q233_libmsg__cannot_open_unl)  (Q234_libmsg__cannot_open_som)  (Q235_libmsg__cannot_open_som)  (Q236_libmsg__reveal_any_newl)  (Q237_libmsg__no_newly_visibl)  (Q238_libmsg__report_player_c)  (Q239_libmsg__report_npc_clos)  (Q240_libmsg__report_unseen_n)  (Q241_libmsg__cannot_close_un)  (Q242_libmsg__cannot_close_so)  (Q243_libmsg__report_player_l)  (Q244_libmsg__report_npc_lock)  (Q245_libmsg__cannot_lock_wit)  (Q246_libmsg__cannot_lock_som)  (Q247_libmsg__cannot_lock_som)  (Q248_libmsg__cannot_lock_wit)  (Q249_libmsg__report_player_u)  (Q250_libmsg__report_npc_unlo)  (Q251_libmsg__cannot_unlock_w)  (Q252_libmsg__cannot_unlock_s)  (Q253_libmsg__cannot_unlock_w)  (Q254_libmsg__report_player_s)  (Q255_libmsg__report_npc_swit)  (Q256_libmsg__cannot_switch_o)  (Q257_libmsg__cannot_switch_o)  (Q258_libmsg__report_player_s)  (Q259_libmsg__report_npc_swit)  (Q260_libmsg__cannot_switch_o)  (Q261_libmsg__cannot_switch_o)  (Q262_libmsg__report_player_w)  (Q263_libmsg__report_npc_wear)  (Q264_libmsg__cannot_wear_som)  (Q265_libmsg__cannot_wear_not)  (Q266_libmsg__cannot_wear_som)  (Q267_libmsg__report_player_t)  (Q268_libmsg__report_npc_taki)  (Q269_libmsg__cannot_take_off)  (Q270_libmsg__report_player_e)  (Q271_libmsg__report_npc_eati)  (Q272_libmsg__cannot_eat_unle)  (Q273_libmsg__block_drinking_)  (Q274_libmsg__block_tasting_)  (Q275_libmsg__block_smelling_)  (Q276_libmsg__block_listening)  (Q277_libmsg__report_player_t)  (Q278_libmsg__report_npc_touc)  (Q279_libmsg__report_player_t)  (Q280_libmsg__report_npc_touc)  (Q281_libmsg__report_player_t)  (Q282_libmsg__report_npc_touc)  (Q283_libmsg__block_saying_ye)  (Q284_libmsg__block_saying_no)  (Q285_libmsg__block_saying_so)  (Q286_libmsg__block_swearing_)  (Q287_libmsg__block_swearing_)  (Q288_libmsg__block_climbing_)  (Q289_libmsg__block_jumping_)  (Q290_libmsg__block_swinging_)  (Q291_libmsg__block_waving_ha)  (Q292_libmsg__block_attacking)  (Q293_libmsg__block_burning_)  (Q294_libmsg__block_cutting_)  (Q295_libmsg__block_rubbing_)  (Q296_libmsg__block_setting_t)  (Q297_libmsg__block_tying_)  (Q298_libmsg__report_player_w)  (Q299_libmsg__report_npc_wavi)  (Q300_libmsg__cannot_wave_som)  (Q301_libmsg__squeezing_peopl)  (Q302_libmsg__report_player_s)  (Q303_libmsg__report_npc_sque)  (Q304_libmsg__block_throwing_)  (Q305_libmsg__throw_at_inanim)  (Q306_libmsg__report_player_p)  (Q307_libmsg__report_npc_push)  (Q308_libmsg__report_player_p)  (Q309_libmsg__report_npc_pull)  (Q310_libmsg__report_player_t)  (Q311_libmsg__report_npc_turn)  (Q312_libmsg__block_pushing_i)  (Q313_libmsg__not_pushed_in_a)  (Q314_libmsg__pushed_in_illeg)  (Q315_libmsg__cannot_push_som)  (Q316_libmsg__cannot_pull_som)  (Q317_libmsg__cannot_turn_som)  (Q318_libmsg__cannot_push_sce)  (Q319_libmsg__cannot_pull_sce)  (Q320_libmsg__cannot_turn_sce)  (Q321_libmsg__cannot_push_peo)  (Q322_libmsg__cannot_pull_peo)  (Q323_libmsg__cannot_turn_peo)  (Q324_libmsg__block_answering)  (Q325_libmsg__block_asking_)  (Q326_libmsg__block_buying_)  (Q327_libmsg__block_kissing_)  (Q328_libmsg__block_singing_)  (Q329_libmsg__block_telling_)  (Q330_libmsg__telling_yoursel)  (Q331_libmsg__block_thinking_)  (Q332_libmsg__block_player_co)  (Q333_libmsg__block_npc_consu)  (Q334_libmsg__block_sleeping_)  (Q335_libmsg__block_waking_up)  (Q336_libmsg__block_waking_ot)  (Q337_libmsg__report_player_w)  (Q338_libmsg__report_npc_wait) ;
Array tab_3_1 table $106c 27  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69)  (SC_69) ;
Array TB_Blanks -> 
  ! For table T0_final_question_options
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  $04  ! Column 3
  $1b  ! Column 4
  
  ! For table T1_locale_priorities
  $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $0f  ! Column 1
  
  ! For table T2_custom_library_messages
  $01  ! Column 1
  
  ! For table T3_library_messages
  $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00  ! Column 1
  
  ! End of table
  NULL NULL;
[ TC_KOV tc;
    switch (tc) {
        100: return TEXT_TY; ! final question wording: text
        101: return TRUTH_STATE_TY; ! only if victorious: truth state
        102: return UNDERSTANDING_TY; ! topic: topic
        103: return KD1_values_based_rule_producin; ! final response rule: values based rule producing values
        104: return KD2_activity; ! final response activity: activity
        105: return OBJECT_TY; ! notable-object: object
        106: return NUMBER_TY; ! locale description priority: number
        107: return 102; ! message id: library message id
        108: return TEXT_TY; ! message text: text
    }
    return UNKNOWN_TY;
];

Array TableOfTables --> TheEmptyTable T0_final_question_options  T1_locale_priorities  T2_custom_library_messages  T3_library_messages  0 0;






[ NAP_0;
    if ((action ==##A85_implicit_quizzing)) rtrue;
    if ((action ==##A86_implicit_informing)) rtrue;
    if ((action ==##A87_implicit_requesting)) rtrue;
    if ((action ==##A88_implicit_imploring)) rtrue;
    if ((action ==##Yes)) rtrue;
    if ((action ==##No)) rtrue;
    if ((action ==##Sorry)) rtrue;
    rfalse;
];
[ NAP_1;
    if ((action ==##Ask) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##Tell) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##A83_quizzing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A84_informing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##Answer) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##AskFor) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A81_requesting_it_for) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A82_imploring_it_for) && ((noun ofclass K8_person)) && (true)) rtrue;
    rfalse;
];
[ NAP_2;
    if ((action ==##A81_requesting_it_for) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##Ask) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##Tell) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##A83_quizzing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A84_informing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##Answer) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##AskFor) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A82_imploring_it_for) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##Yes)) rtrue;
    if ((action ==##No)) rtrue;
    if ((action ==##Sorry)) rtrue;
    rfalse;
];
[ NAP_3;
    if ((action ==##A92_saying_goodbye_to) && ((noun ofclass K8_person))) rtrue;
    if ((action ==##Go)) rtrue;
    rfalse;
];
[ NAP_4;
    if ((action ==##Go) && ((noun == out_obj) && (true))) rtrue;
    if ((action ==##Go) && ((noun == O15_southwest) && (true))) rtrue;
    if ((action ==##Enter) && ((noun ofclass K119_window))) rtrue;
    rfalse;
];
[ NAP_5;
    if ( (noun) && (noun == inp1) && ((noun == O118_emergency_radio) && (true))) rtrue;
    if ( (noun) && (noun == inp1) && ((noun == O137_cans_of_food) && (true))) rtrue;
    if ((action ==##Examine) && ((noun ofclass K2_thing))) rtrue;
    rfalse;
];


Array ActionData table
  ##Inv  $$00000000  OBJECT_TY OBJECT_TY  0 20000
  ##Take  $$00001001  OBJECT_TY OBJECT_TY  0 20001
  ##Remove  $$00011011  OBJECT_TY OBJECT_TY  0 20002
  ##Drop  $$00001001  OBJECT_TY OBJECT_TY  0 20003
  ##PutOn  $$00011011  OBJECT_TY OBJECT_TY  0 20004
  ##Insert  $$00011011  OBJECT_TY OBJECT_TY  0 20005
  ##Eat  $$01001001  OBJECT_TY OBJECT_TY  0 20006
  ##Go  $$00001000  OBJECT_TY OBJECT_TY  ANSTVC_7 20007
  ##Enter  $$00001001  OBJECT_TY OBJECT_TY  0 20008
  ##Exit  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_9 20009
  ##GetOff  $$00001001  OBJECT_TY OBJECT_TY  0 20010
  ##Look  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_11 20011
  ##Examine  $$00001100  OBJECT_TY OBJECT_TY  ANSTVC_12 20012
  ##LookUnder  $$00001100  OBJECT_TY OBJECT_TY  0 20013
  ##Search  $$00001101  OBJECT_TY OBJECT_TY  0 20014
  ##Consult  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20015
  ##Lock  $$10011011  OBJECT_TY OBJECT_TY  0 20016
  ##Unlock  $$10011011  OBJECT_TY OBJECT_TY  0 20017
  ##SwitchOn  $$00001001  OBJECT_TY OBJECT_TY  0 20018
  ##SwitchOff  $$00001001  OBJECT_TY OBJECT_TY  0 20019
  ##Open  $$00001001  OBJECT_TY OBJECT_TY  0 20020
  ##Close  $$00001001  OBJECT_TY OBJECT_TY  0 20021
  ##Wear  $$01001001  OBJECT_TY OBJECT_TY  0 20022
  ##Disrobe  $$01001001  OBJECT_TY OBJECT_TY  0 20023
  ##Give  $$01011011  OBJECT_TY OBJECT_TY  0 20024
  ##Show  $$01011001  OBJECT_TY OBJECT_TY  0 20025
  ##WakeOther  $$00001001  OBJECT_TY OBJECT_TY  0 20026
  ##ThrowAt  $$01011001  OBJECT_TY OBJECT_TY  0 20027
  ##Attack  $$00001001  OBJECT_TY OBJECT_TY  0 20028
  ##Kiss  $$00001001  OBJECT_TY OBJECT_TY  0 20029
  ##Answer  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20030
  ##Tell  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20031
  ##Ask  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20032
  ##AskFor  $$00011011  OBJECT_TY OBJECT_TY  0 20033
  ##Wait  $$00000000  OBJECT_TY OBJECT_TY  0 20034
  ##Touch  $$00001001  OBJECT_TY OBJECT_TY  0 20035
  ##Wave  $$00001001  OBJECT_TY OBJECT_TY  0 20036
  ##Pull  $$00001001  OBJECT_TY OBJECT_TY  0 20037
  ##Push  $$00001001  OBJECT_TY OBJECT_TY  0 20038
  ##Turn  $$00001001  OBJECT_TY OBJECT_TY  0 20039
  ##PushDir  $$00011001  OBJECT_TY OBJECT_TY  0 20040
  ##Squeeze  $$00001001  OBJECT_TY OBJECT_TY  0 20041
  ##Yes  $$00000000  OBJECT_TY OBJECT_TY  0 20042
  ##No  $$00000000  OBJECT_TY OBJECT_TY  0 20043
  ##Burn  $$00001001  OBJECT_TY OBJECT_TY  0 20044
  ##Wake  $$00000000  OBJECT_TY OBJECT_TY  0 20045
  ##Think  $$00000000  OBJECT_TY OBJECT_TY  0 20046
  ##Smell  $$00001001  OBJECT_TY OBJECT_TY  0 20047
  ##Listen  $$00001001  OBJECT_TY OBJECT_TY  0 20048
  ##Taste  $$00001001  OBJECT_TY OBJECT_TY  0 20049
  ##Cut  $$00001001  OBJECT_TY OBJECT_TY  0 20050
  ##Jump  $$00000000  OBJECT_TY OBJECT_TY  0 20051
  ##Tie  $$00011011  OBJECT_TY OBJECT_TY  0 20052
  ##Drink  $$00001001  OBJECT_TY OBJECT_TY  0 20053
  ##Sorry  $$00000000  OBJECT_TY OBJECT_TY  0 20054
  ##Strong  $$00000000  OBJECT_TY OBJECT_TY  0 20055
  ##Mild  $$00000000  OBJECT_TY OBJECT_TY  0 20056
  ##Swing  $$00001001  OBJECT_TY OBJECT_TY  0 20057
  ##Rub  $$00001001  OBJECT_TY OBJECT_TY  0 20058
  ##SetTo  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20059
  ##WaveHands  $$00000000  OBJECT_TY OBJECT_TY  0 20060
  ##Buy  $$00001001  OBJECT_TY OBJECT_TY  0 20061
  ##Sing  $$00000000  OBJECT_TY OBJECT_TY  0 20062
  ##Climb  $$00001001  OBJECT_TY OBJECT_TY  0 20063
  ##Sleep  $$00000000  OBJECT_TY OBJECT_TY  0 20064
  ##Quit  $$00100000  OBJECT_TY OBJECT_TY  0 20065
  ##Save  $$00100000  OBJECT_TY OBJECT_TY  0 20066
  ##Restore  $$00100000  OBJECT_TY OBJECT_TY  0 20067
  ##Restart  $$00100000  OBJECT_TY OBJECT_TY  0 20068
  ##Verify  $$00100000  OBJECT_TY OBJECT_TY  0 20069
  ##ScriptOn  $$00100000  OBJECT_TY OBJECT_TY  0 20070
  ##ScriptOff  $$00100000  OBJECT_TY OBJECT_TY  0 20071
  ##Version  $$00100000  OBJECT_TY OBJECT_TY  0 20072
  ##Score  $$00100000  OBJECT_TY OBJECT_TY  0 20073
  ##LMode3  $$00100000  OBJECT_TY OBJECT_TY  0 20074
  ##LMode2  $$00100000  OBJECT_TY OBJECT_TY  0 20075
  ##LMode1  $$00100000  OBJECT_TY OBJECT_TY  0 20076
  ##NotifyOn  $$00100000  OBJECT_TY OBJECT_TY  0 20077
  ##NotifyOff  $$00100000  OBJECT_TY OBJECT_TY  0 20078
  ##Pronouns  $$00100000  OBJECT_TY OBJECT_TY  0 20079
  ##A80_requesting_epistemic_sta  $$00101000  OBJECT_TY OBJECT_TY  0 20080
  ##A81_requesting_it_for  $$00011000  OBJECT_TY OBJECT_TY  0 20081
  ##A82_imploring_it_for  $$00011000  OBJECT_TY UNDERSTANDING_TY  0 20082
  ##A83_quizzing_it_about  $$00011000  OBJECT_TY OBJECT_TY  0 20083
  ##A84_informing_it_about  $$00011000  OBJECT_TY OBJECT_TY  0 20084
  ##A85_implicit_quizzing  $$00001000  OBJECT_TY OBJECT_TY  0 20085
  ##A86_implicit_informing  $$00001000  OBJECT_TY OBJECT_TY  0 20086
  ##A87_implicit_requesting  $$00001000  OBJECT_TY OBJECT_TY  0 20087
  ##A88_implicit_imploring  $$00001000  UNDERSTANDING_TY OBJECT_TY  0 20088
  ##A89_saying_hello_to  $$00001000  OBJECT_TY OBJECT_TY  0 20089
  ##A90_hailing  $$00000000  OBJECT_TY OBJECT_TY  0 20090
  ##A91_leavetaking  $$00000000  OBJECT_TY OBJECT_TY  0 20091
  ##A92_saying_goodbye_to  $$00001000  OBJECT_TY OBJECT_TY  0 20092
  ##A93_listing_suggested_topics  $$00000000  OBJECT_TY OBJECT_TY  0 20093
  ##A94_standing  $$00000000  OBJECT_TY OBJECT_TY  0 20094
  ##A95_retreating  $$00000000  OBJECT_TY OBJECT_TY  0 20095
  ##A96_using  $$00001001  OBJECT_TY OBJECT_TY  0 20096
  ##A97_brooding  $$00001001  OBJECT_TY OBJECT_TY  0 20097
  ##A98_smoking  $$00001001  OBJECT_TY OBJECT_TY  0 20098
  ##A99_tuning_it_to  $$00011001  OBJECT_TY 103  0 20099
  ##A100_coarse_tuning  $$00011001  OBJECT_TY NUMBER_TY  0 20100
  ##A101_trading  $$00011011  OBJECT_TY OBJECT_TY  ANSTVC_101 20101
;
Constant AD_RECORDS = 102;
[ ANSTVC_7 pos state;
    if (state == 1) {
        MStack-->pos = O66_middle_of_nowhere; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 5;
];
[ ANSTVC_9 pos state;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_11 pos state;
    if (state == 1) {
        MStack-->pos = ##Wait; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 4;
];
[ ANSTVC_12 pos state;
    if (state == 1) {
        MStack-->pos = false; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_101 pos state;
    if (state == 1) {
        MStack-->pos = selfobj; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ DB_Action_Details act n s for_say;
    switch (act) {
        ##Inv: print "taking inventory"; 
        ##Take: print "taking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Remove: print "removing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "from"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drop: print "dropping"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PutOn: print "putting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "on"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Insert: print "inserting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "into"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Eat: print "eating"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Go: print "going"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Enter: print "entering"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Exit: print "exiting"; 
        ##GetOff: print "getting off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Look: print "looking"; 
        ##Examine: print "examining"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##LookUnder: print "looking under"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Search: print "searching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Consult: print "consulting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Lock: print "locking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Unlock: print "unlocking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##SwitchOn: print "switching on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SwitchOff: print "switching off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Open: print "opening"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Close: print "closing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wear: print "wearing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Disrobe: print "taking off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Give: print "giving"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Show: print "showing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##WakeOther: print "waking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##ThrowAt: print "throwing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "at"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Attack: print "attacking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Kiss: print "kissing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Answer: print "answering"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "that"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Tell: print "telling"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Ask: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##AskFor: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Wait: print "waiting"; 
        ##Touch: print "touching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wave: print "waving"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Pull: print "pulling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Push: print "pushing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Turn: print "turning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PushDir: print "pushing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Squeeze: print "squeezing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Yes: print "saying yes"; 
        ##No: print "saying no"; 
        ##Burn: print "burning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wake: print "waking up"; 
        ##Think: print "thinking"; 
        ##Smell: print "smelling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Listen: print "listening to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Taste: print "tasting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Cut: print "cutting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Jump: print "jumping"; 
        ##Tie: print "tying"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drink: print "drinking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sorry: print "saying sorry"; 
        ##Strong: print "swearing obscenely"; 
        ##Mild: print "swearing mildly"; 
        ##Swing: print "swinging"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Rub: print "rubbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SetTo: print "setting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##WaveHands: print "waving hands"; 
        ##Buy: print "buying"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sing: print "singing"; 
        ##Climb: print "climbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sleep: print "sleeping"; 
        ##Quit: print "quitting the game"; 
        ##Save: print "saving the game"; 
        ##Restore: print "restoring the game"; 
        ##Restart: print "restarting the game"; 
        ##Verify: print "verifying the story file"; 
        ##ScriptOn: print "switching the story transcript on"; 
        ##ScriptOff: print "switching the story transcript off"; 
        ##Version: print "requesting the story file version"; 
        ##Score: print "requesting the score"; 
        ##LMode3: print "preferring abbreviated room descriptions"; 
        ##LMode2: print "preferring unabbreviated room descriptions"; 
        ##LMode1: print "preferring sometimes abbreviated room descriptions"; 
        ##NotifyOn: print "switching score notification on"; 
        ##NotifyOff: print "switching score notification off"; 
        ##Pronouns: print "requesting the pronoun meanings"; 
        ##A80_requesting_epistemic_sta: print "requesting epistemic status of"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A81_requesting_it_for: print "requesting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A82_imploring_it_for: print "imploring"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##A83_quizzing_it_about: print "quizzing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A84_informing_it_about: print "informing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A85_implicit_quizzing: print "implicit-quizzing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A86_implicit_informing: print "implicit-informing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A87_implicit_requesting: print "implicit-requesting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A88_implicit_imploring: print "implicit-imploring"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##A89_saying_hello_to: print "saying hello to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A90_hailing: print "hailing"; 
        ##A91_leavetaking: print "leavetaking"; 
        ##A92_saying_goodbye_to: print "saying goodbye to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A93_listing_suggested_topics: print "listing suggested topics"; 
        ##A94_standing: print "standing"; 
        ##A95_retreating: print "retreating"; 
        ##A96_using: print "using"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A97_brooding: print "brooding"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A98_smoking: print "smoking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A99_tuning_it_to: print "tuning"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; T45_frequency(parsed_number); }
        ##A100_coarse_tuning: print "coarse tuning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A101_trading: print "trading"; if (for_say ~= 2) { print " "; DA_Name(n); }
    }
];

Array ActionCoding -->
    ##Inv ##Take ##Remove ##Drop ##PutOn ##Insert ##Eat ##Go
    ##Enter ##Exit ##GetOff ##Look ##Examine ##LookUnder ##Search ##Consult
    ##Lock ##Unlock ##SwitchOn ##SwitchOff ##Open ##Close ##Wear ##Disrobe
    ##Give ##Show ##WakeOther ##ThrowAt ##Attack ##Kiss ##Answer ##Tell
    ##Ask ##AskFor ##Wait ##Touch ##Wave ##Pull ##Push ##Turn
    ##PushDir ##Squeeze ##Yes ##No ##Burn ##Wake ##Think ##Smell
    ##Listen ##Taste ##Cut ##Jump ##Tie ##Drink ##Sorry ##Strong
    ##Mild ##Swing ##Rub ##SetTo ##WaveHands ##Buy ##Sing ##Climb
    ##Sleep ##Quit ##Save ##Restore ##Restart ##Verify ##ScriptOn ##ScriptOff
    ##Version ##Score ##LMode3 ##LMode2 ##LMode1 ##NotifyOn ##NotifyOff ##Pronouns
    ##A80_requesting_epistemic_sta ##A81_requesting_it_for ##A82_imploring_it_for ##A83_quizzing_it_about ##A84_informing_it_about ##A85_implicit_quizzing ##A86_implicit_informing ##A87_implicit_requesting
    ##A88_implicit_imploring ##A89_saying_hello_to ##A90_hailing ##A91_leavetaking ##A92_saying_goodbye_to ##A93_listing_suggested_topics ##A94_standing ##A95_retreating
    ##A96_using ##A97_brooding ##A98_smoking ##A99_tuning_it_to ##A100_coarse_tuning ##A101_trading;


Array ActionHappened --> 0 0 0 0 0 0 0;


[ InvSub; return GenericVerbSub(125,126,127); ];
[ TakeSub; return GenericVerbSub(128,129,130); ];
[ RemoveSub; return GenericVerbSub(131,132,133); ];
[ DropSub; return GenericVerbSub(134,135,136); ];
[ PutOnSub; return GenericVerbSub(137,138,139); ];
[ InsertSub; return GenericVerbSub(140,141,142); ];
[ EatSub; return GenericVerbSub(143,144,145); ];
[ GoSub; return GenericVerbSub(146,147,148); ];
[ EnterSub; return GenericVerbSub(149,150,151); ];
[ ExitSub; return GenericVerbSub(152,153,154); ];
[ GetOffSub; return GenericVerbSub(155,156,157); ];
[ LookSub; return GenericVerbSub(158,159,160); ];
[ ExamineSub; return GenericVerbSub(161,162,163); ];
[ LookUnderSub; return GenericVerbSub(164,165,166); ];
[ SearchSub; return GenericVerbSub(167,168,169); ];
[ ConsultSub; return GenericVerbSub(170,171,172); ];
[ LockSub; return GenericVerbSub(173,174,175); ];
[ UnlockSub; return GenericVerbSub(176,177,178); ];
[ SwitchOnSub; return GenericVerbSub(179,180,181); ];
[ SwitchOffSub; return GenericVerbSub(182,183,184); ];
[ OpenSub; return GenericVerbSub(185,186,187); ];
[ CloseSub; return GenericVerbSub(188,189,190); ];
[ WearSub; return GenericVerbSub(191,192,193); ];
[ DisrobeSub; return GenericVerbSub(194,195,196); ];
[ GiveSub; return GenericVerbSub(197,198,199); ];
[ ShowSub; return GenericVerbSub(200,201,202); ];
[ WakeOtherSub; return GenericVerbSub(203,204,205); ];
[ ThrowAtSub; return GenericVerbSub(206,207,208); ];
[ AttackSub; return GenericVerbSub(209,210,211); ];
[ KissSub; return GenericVerbSub(212,213,214); ];
[ AnswerSub; return GenericVerbSub(215,216,217); ];
[ TellSub; return GenericVerbSub(218,219,220); ];
[ AskSub; return GenericVerbSub(221,222,223); ];
[ AskForSub; return GenericVerbSub(224,225,226); ];
[ WaitSub; return GenericVerbSub(227,228,229); ];
[ TouchSub; return GenericVerbSub(230,231,232); ];
[ WaveSub; return GenericVerbSub(233,234,235); ];
[ PullSub; return GenericVerbSub(236,237,238); ];
[ PushSub; return GenericVerbSub(239,240,241); ];
[ TurnSub; return GenericVerbSub(242,243,244); ];
[ PushDirSub; return GenericVerbSub(245,246,247); ];
[ SqueezeSub; return GenericVerbSub(248,249,250); ];
[ YesSub; return GenericVerbSub(251,252,253); ];
[ NoSub; return GenericVerbSub(254,255,256); ];
[ BurnSub; return GenericVerbSub(257,258,259); ];
[ WakeSub; return GenericVerbSub(260,261,262); ];
[ ThinkSub; return GenericVerbSub(263,264,265); ];
[ SmellSub; return GenericVerbSub(266,267,268); ];
[ ListenSub; return GenericVerbSub(269,270,271); ];
[ TasteSub; return GenericVerbSub(272,273,274); ];
[ CutSub; return GenericVerbSub(275,276,277); ];
[ JumpSub; return GenericVerbSub(278,279,280); ];
[ TieSub; return GenericVerbSub(281,282,283); ];
[ DrinkSub; return GenericVerbSub(284,285,286); ];
[ SorrySub; return GenericVerbSub(287,288,289); ];
[ StrongSub; return GenericVerbSub(290,291,292); ];
[ MildSub; return GenericVerbSub(293,294,295); ];
[ SwingSub; return GenericVerbSub(296,297,298); ];
[ RubSub; return GenericVerbSub(299,300,301); ];
[ SetToSub; return GenericVerbSub(302,303,304); ];
[ WaveHandsSub; return GenericVerbSub(305,306,307); ];
[ BuySub; return GenericVerbSub(308,309,310); ];
[ SingSub; return GenericVerbSub(311,312,313); ];
[ ClimbSub; return GenericVerbSub(314,315,316); ];
[ SleepSub; return GenericVerbSub(317,318,319); ];
[ QuitSub; return GenericVerbSub(320,321,322); ];
[ SaveSub; return GenericVerbSub(323,324,325); ];
[ RestoreSub; return GenericVerbSub(326,327,328); ];
[ RestartSub; return GenericVerbSub(329,330,331); ];
[ VerifySub; return GenericVerbSub(332,333,334); ];
[ ScriptOnSub; return GenericVerbSub(335,336,337); ];
[ ScriptOffSub; return GenericVerbSub(338,339,340); ];
[ VersionSub; return GenericVerbSub(341,342,343); ];
[ ScoreSub; return GenericVerbSub(344,345,346); ];
[ LMode3Sub; return GenericVerbSub(347,348,349); ];
[ LMode2Sub; return GenericVerbSub(350,351,352); ];
[ LMode1Sub; return GenericVerbSub(353,354,355); ];
[ NotifyOnSub; return GenericVerbSub(356,357,358); ];
[ NotifyOffSub; return GenericVerbSub(359,360,361); ];
[ PronounsSub; return GenericVerbSub(362,363,364); ];
[ A80_requesting_epistemic_staSub; return GenericVerbSub(365,366,367); ];
[ A81_requesting_it_forSub; return GenericVerbSub(368,369,370); ];
[ A82_imploring_it_forSub; return GenericVerbSub(371,372,373); ];
[ A83_quizzing_it_aboutSub; return GenericVerbSub(374,375,376); ];
[ A84_informing_it_aboutSub; return GenericVerbSub(377,378,379); ];
[ A85_implicit_quizzingSub; return GenericVerbSub(380,381,382); ];
[ A86_implicit_informingSub; return GenericVerbSub(383,384,385); ];
[ A87_implicit_requestingSub; return GenericVerbSub(386,387,388); ];
[ A88_implicit_imploringSub; return GenericVerbSub(389,390,391); ];
[ A89_saying_hello_toSub; return GenericVerbSub(392,393,394); ];
[ A90_hailingSub; return GenericVerbSub(395,396,397); ];
[ A91_leavetakingSub; return GenericVerbSub(398,399,400); ];
[ A92_saying_goodbye_toSub; return GenericVerbSub(401,402,403); ];
[ A93_listing_suggested_topicsSub; return GenericVerbSub(405,406,407); ];
[ A94_standingSub; return GenericVerbSub(408,409,410); ];
[ A95_retreatingSub; return GenericVerbSub(411,412,413); ];
[ A96_usingSub; return GenericVerbSub(414,415,416); ];
[ A97_broodingSub; return GenericVerbSub(423,424,425); ];
[ A98_smokingSub; return GenericVerbSub(426,427,428); ];
[ A99_tuning_it_toSub; return GenericVerbSub(429,430,431); ];
[ A100_coarse_tuningSub; return GenericVerbSub(432,433,434); ];
[ A101_tradingSub; return GenericVerbSub(435,436,437); ];

[ MistakeActionSub;
    switch(understand_as_mistake_number) {
        346: ParserError(SC_70);
        347: ParserError(SC_70);
        348: ParserError(SC_70);
        349: ParserError(SC_70);
        350: ParserError(SC_70);
        351: ParserError(SC_70);
        352: ParserError(SC_70);
        353: ParserError(SC_70);
        361: ParserError(SC_71);
        362: ParserError(SC_71);
        363: ParserError(SC_71);
        364: ParserError(SC_71);
        365: ParserError(SC_71);
        366: ParserError(SC_71);
        367: ParserError(SC_71);
        368: ParserError(SC_71);
        369: ParserError(SC_71);
        370: ParserError(SC_71);
        386: ParserError(SC_72);
        411: ParserError(SC_73);
        412: ParserError(text_routine_39);
        414: ParserError(SC_74);
        default: "I didn't understand that sentence.";
    }
    say__p = 1;
];



! Definitions of rule phrases


! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Startup (B1_startup)
! ----------------------------------------------------------------------------------------------------
! Rule 1/10: INITIALISE_MEMORY_R
!   === which is equally specific with ===
! Rule 2/10: VIRTUAL_MACHINE_STARTUP_R
!   === which is equally specific with ===
! Rule 3/10: SEED_RANDOM_NUMBER_GENERATOR_R
!   === which is equally specific with ===
! Rule 4/10: UPDATE_CHRONOLOGICAL_RECORDS_R
!   === which is equally specific with ===
! Rule 5/10: POSITION_PLAYER_IN_MODEL_R
!   === which is equally specific with ===
! Rule 6/10 ! This is the start in the correct scenes rule:
! --- now the mid-placed rules ---
! Rule 7/10 ! This is the when play begins stage rule:
!   === which is equally specific with ===
! Rule 8/10 ! This is the fix baseline scoring rule:
!   === which is equally specific with ===
! Rule 9/10 ! This is the display banner rule:
!   === which is equally specific with ===
! Rule 10/10 ! This is the initial room description rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the start in the correct scenes rule:
[ R_8 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
       ProcessRulebook(4); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the when play begins stage rule:
[ R_9 ;
      ! phrase 1
      ! [1: follow the when play begins rulebook]
       FollowRulebook(5); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the fix baseline scoring rule:
[ R_10 ;
      ! phrase 1
      ! [1: now the last notified score is the score]
       last_score = score; 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the display banner rule:
[ R_11 ;
      ! phrase 1
      ! [1: say ~[banner text]~]
      say__p=1;ParaContent();  Banner();  .L_Say0; .L_SayX0;
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the initial room description rule:
[ R_12 ;
      ! phrase 1
      ! [1: try looking]
       TryAction(0, player, ##Look, 0, 0);; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Turn sequence (B2_turn_sequence)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11: PARSE_COMMAND_R
!   === which is equally specific with ===
! Rule 2/11: GENERATE_ACTION_R
!   === which is equally specific with ===
! Rule 3/11 ! A first turn sequence rule:
!   === which is equally specific with ===
! Rule 4/11 ! A first turn sequence rule ( this is the every turn stage rule ):
! --- now the mid-placed rules ---
! Rule 5/11: TIMED_EVENTS_R
!   === which is equally specific with ===
! Rule 6/11: ADVANCE_TIME_R
!   === which is equally specific with ===
! Rule 7/11: UPDATE_CHRONOLOGICAL_RECORDS_R
! --- now the last-placed rules ---
! Rule 8/11 ! A last turn sequence rule:
!   === which is equally specific with ===
! Rule 9/11: ADJUST_LIGHT_R
!   === which is equally specific with ===
! Rule 10/11: NOTE_OBJECT_ACQUISITIONS_R
!   === which is equally specific with ===
! Rule 11/11 ! This is the notify score changes rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! A first turn sequence rule:
[ R_14 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
       ProcessRulebook(4); 
   rfalse;
];
! No specific request
! From the Standard Rules
! A first turn sequence rule ( this is the every turn stage rule ):
[ R_13 ;
      ! phrase 1
      ! [1: follow the every turn rules]
       FollowRulebook(9); 
   rfalse;
];
! No specific request
! From the Standard Rules
! A last turn sequence rule:
[ R_15 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
       ProcessRulebook(4); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the notify score changes rule:
[ R_16 ;
      ! phrase 1
      ! [1: if the score is not the last notified score begin]
       if (((~~((score == last_score)))))  {
         ! phrase 2
         ! [2: issue score notification message]
          NotifyTheScore(); 
         ! phrase 3
         ! [3: now the last notified score is the score]
          last_score = score; 
         ! phrase 4
         ! [4: end if]
         }

   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Shutdown (B3_shutdown)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! This is the when play ends stage rule:
! --- now the last-placed rules ---
! Rule 2/4: RESURRECT_PLAYER_IF_ASKED_R
!   === which is equally specific with ===
! Rule 3/4 ! This is the print player's obituary rule:
!   === which is equally specific with ===
! Rule 4/4: ASK_FINAL_QUESTION_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the when play ends stage rule:
[ R_17 ;
      ! phrase 1
      ! [1: follow the when play ends rulebook]
       FollowRulebook(6); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the print player's obituary rule:
[ R_18 ;
      ! phrase 1
      ! [1: carry out the printing the player's obituary activity]
       CarryOutActivity(V27_printing_the_player_s_ob); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When play begins (B5_when_play_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! When play begins:
!   === which is equally specific with ===
! Rule 2/5 ! When play begins:
!   === which is equally specific with ===
! Rule 3/5 ! When play begins:
!   === which is equally specific with ===
! Rule 4/5 ! When play begins:
!   === which is equally specific with ===
! Rule 5/5 ! When play begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! When play begins:
[ R_764 ;
      ! phrase 1
      ! [1: reset the interlocutor]
      (PHR_765_r3 ());
   rfalse;
];
! No specific request
! From "Default Messages" by David Fisher
! When play begins:
[ R_885 ;
      ! phrase 1
      ! [1: init library messages]
       InitLibraryMessages(); 
      ! phrase 2
      ! [2: add the custom library messages]
      (PHR_886_r4 ());
   rfalse;
];
! No specific request
! When play begins:
[ R_910 ;
      ! phrase 1
      ! [1: set libmsg <block swearing obscenely> to ~Mos def, [bro].[/n]~]
      (PHR_887_r5 (Q286_libmsg__block_swearing_,text_routine_40));
      ! phrase 2
      ! [2: set libmsg <empty line> to ~Say what?[/n]~]
      (PHR_887_r5 (Q28_libmsg__empty_line_,text_routine_41));
      ! phrase 3
      ! [3: set libmsg <unknown object> to ~[one of]Uh, not sure about the noun there, [bro].[or]Try a different noun with that command.[stopping][/n]~]
      (PHR_887_r5 (Q55_libmsg__unknown_object_,text_routine_42));
      ! phrase 4
      ! [4: set libmsg <inventory initial text> to ~You've got~]
      (PHR_887_r5 (Q115_libmsg__inventory_initi,SC_75));
      ! phrase 5
      ! [5: set libmsg <cannot take yourself> to ~Yeah, you do need to get a hold of yourself.[/n]~]
      (PHR_887_r5 (Q125_libmsg__cannot_take_you,text_routine_43));
      ! phrase 6
      ! [6: set libmsg <cannot take other people> to ~What is this, [bro], weight training?[/n]~]
      (PHR_887_r5 (Q126_libmsg__cannot_take_oth,text_routine_44));
      ! phrase 7
      ! [7: set libmsg <cannot take something already taken> to ~You already got that shit, [bro].[/n]~]
      (PHR_887_r5 (Q128_libmsg__cannot_take_som,text_routine_45));
      ! phrase 8
      ! [8: set libmsg <report player taking> to ~[one of]Snagged[or]Got [if noun acts plural][']em[otherwise]it[end if][or]Sure thing, [bro][at random].[/n]~]
      (PHR_887_r5 (Q123_libmsg__report_player_t,text_routine_46));
      ! phrase 9
      ! [9: set libmsg <examine undescribed things> to ~[one of]About what you'd expect.[or]Looks normal.[or]Yeah, it's [a noun].[as decreasingly likely outcomes][/n]~]
      (PHR_887_r5 (Q217_libmsg__examine_undescr,text_routine_47));
      ! phrase 10
      ! [10: set libmsg <look under> to ~[one of]Nada[or]El zilcho[or]Nothin[at random].[/n]~]
      (PHR_887_r5 (Q228_libmsg__look_under_,text_routine_48));
      ! phrase 11
      ! [11: set libmsg <cannot eat unless edible> to ~You ain't that hungry, [bro].[/n]~]
      (PHR_887_r5 (Q272_libmsg__cannot_eat_unle,text_routine_49));
      ! phrase 12
      ! [12: set libmsg <report player touching things> to ~No surprises.[/n]~]
      (PHR_887_r5 (Q277_libmsg__report_player_t,text_routine_50));
      ! phrase 13
      ! [13: set libmsg <report player touching other people> to ~He's real.[/n]~]
      (PHR_887_r5 (Q281_libmsg__report_player_t,text_routine_51));
      ! phrase 14
      ! [14: set libmsg <block climbing> to ~Uh, [bro], probably not a good plan.[/n]~]
      (PHR_887_r5 (Q288_libmsg__block_climbing_,text_routine_52));
      ! phrase 15
      ! [15: set libmsg <block attacking> to ~Come on [bro], they already think you have anger management issues.[/n]~]
      (PHR_887_r5 (Q292_libmsg__block_attacking,text_routine_53));
      ! phrase 16
      ! [16: set libmsg <block burning> to ~Heh heh... fire... fire.[/n]~]
      (PHR_887_r5 (Q293_libmsg__block_burning_,text_routine_54));
      ! phrase 17
      ! [17: set libmsg <block throwing at> to ~Hey, let's not just piss people off for no reason.[/n]~]
      (PHR_887_r5 (Q304_libmsg__block_throwing_,text_routine_55));
      ! phrase 18
      ! [18: set libmsg <block sleeping> to ~For whatever reason you've never felt more awake.[/n]~]
      (PHR_887_r5 (Q334_libmsg__block_sleeping_,text_routine_56));
      ! phrase 19
      ! [19: set libmsg <block waking up> to ~Good call, [bro], but you can't seem to snap yourself out of whatever this is. Doesn't feel like a dream, anyway.[/n]~]
      (PHR_887_r5 (Q335_libmsg__block_waking_up,text_routine_57));
   rfalse;
];
! No specific request
! When play begins:
[ R_922 ;
      ! phrase 1
      ! [1: say ~but it's too late, you're crashing, you're crashing, you crash...~]
      say__p=1;ParaContent();  print (PrintText) SC_76;  new_line; .L_Say1; .L_SayX1;
   rfalse;
];
! No specific request
! When play begins:
[ R_927 ;
      ! phrase 1
      ! [1: now every memory is in the subconscious]
       Prop_0(); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When scene begins (B7_when_scene_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When a scene ( called the event ) begins ( this is the scene description text rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! When a scene ( called the event ) begins ( this is the scene description text rule ):
[ R_57 
    t_0 ! Local variable e.g. 'event' = scene
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (true))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_57, 57);
      ! phrase 1
      ! [1: if the description of the event is not ~~ , say ~[the description of the event][paragraph break]~]
       if (((~~((GProperty(SCENE_TY, t_0,description) == EMPTY_TEXT_VALUE))))) { say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(SCENE_TY, self=t_0,description); @pull self; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say2; .L_SayX2;  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_57, 57, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Every turn (B9_every_turn)
! ----------------------------------------------------------------------------------------------------
! Rule 1/16 ! Every turn when going and location is Break Room during Sinister Voices:
!   === which is equally specific with ===
! Rule 2/16 ! Every turn when a random chance of 1 in 3 succeeds and player is in Office Interior during Rainstorm:
!   >>> I - Number of aspects constrained >>>
! Rule 3/16 ! Every turn when current interlocutor is a person and show topics every turn is true:
!   === which is equally specific with ===
! Rule 4/16 ! Every turn when a dramatic scene is not happening and Coyote's Offer has not ended and a random chance of 1 in 40 succeeds:
!   === which is equally specific with ===
! Rule 5/16 ! Every turn when a charged thing ( called the item ) is visible:
!   === which is equally specific with ===
! Rule 6/16 ! Every turn when noun is a thing and noun is required by a plan and noun is not noted as useful:
!   === which is equally specific with ===
! Rule 7/16 ! Every turn when doing something to smell of gasoline and gas can is not noted as useful:
!   === which is equally specific with ===
! Rule 8/16 ! Every turn when doing something to cans of food and canned oranges are not noted as useful:
!   === which is equally specific with ===
! Rule 9/16 ! Every turn when radio is switched on and frequency tuned to of radio is emergency frequency and voice has not been visible:
!   === which is equally specific with ===
! Rule 10/16 ! Every turn when circle of snarling coyotes is visible:
!   >>> II - When/while requirement >>>
! Rule 11/16 ! Every turn during Temptation:
!   === which is equally specific with ===
! Rule 12/16 ! Every turn during Chase:
!   === which is equally specific with ===
! Rule 13/16 ! Every turn during Sand-dancer's Arrival:
!   >>> I - Number of aspects constrained >>>
! Rule 14/16 ! Every turn ( this is the reset protocol rule ):
!   === which is equally specific with ===
! Rule 15/16 ! Every turn ( this is the decide whether the action prevents undo rule ):
!   === which is equally specific with ===
! Rule 16/16 ! Every turn:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Every turn when going and location is Break Room during Sinister Voices:
[ R_1112 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if ((((((action ==##Go) &&  (actor==player)) && (((real_location == O114_break_room))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1112, 1112);
      ! phrase 1
      ! [1: now radio is switched on]
       (Adj_84_t2_v65(O118_emergency_radio)); 
      ! phrase 2
      ! [2: now frequency tuned to of radio is emergency frequency]
       WriteGProperty(OBJECT_TY, O118_emergency_radio,p18_frequency_tuned_to,(Global_Vars-->27)); 
      ! phrase 3
      ! [3: say ~[one of][sinister-radio-1][or][sinister-radio-2][or][sinister-radio-3][stopping].~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->0 =
	i7_soo_stop(I7_ST_say_one_of-->0, 3);
	switch((I7_ST_say_one_of-->0)%(3+1)-1) {
		0: ParaContent(); (PHR_1113_r6 ());ParaContent();  @nop; 1: ParaContent(); (PHR_1115_r7 ());ParaContent();  @nop; 2: ParaContent(); (PHR_1116_r8 ());ParaContent();  } ParaContent();  print (PrintText) SC_77;  new_line; .L_Say3; .L_SayX3;
   } ! Runs only during scene
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1112, 1112, true);
   rfalse;
];
! No specific request
! Every turn when a random chance of 1 in 3 succeeds and player is in Office Interior during Rainstorm:
[ R_1120 ;
   if (scene_status-->2 == 1) { ! Runs only during scene
   if (((((( (GenerateRandomNumber(1, 3) <= 1) )) && (((TestRegionalContainment(player,O112_office_interior)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1120, 1120);
      ! phrase 1
      ! [1: say ~[one of]The building groans as wind and rain lash it from outside[or]Water from the storm trickles down from unseen cracks and holes[or]Rain beats constantly on the roof, loud and furious[in random order].~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->1 =
	i7_soo_shu(I7_ST_say_one_of-->1, 3);
	switch((I7_ST_say_one_of-->1)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_78; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_79; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_80; ParaContent();  } ParaContent();  print (PrintText) SC_77;  new_line; .L_Say4; .L_SayX4;
   } ! Runs only during scene
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1120, 1120, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Every turn when current interlocutor is a person and show topics every turn is true:
[ R_849 ;
   if ((((((((Global_Vars-->9) ofclass K8_person))) && ((((Global_Vars-->19) == 1))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_849, 849);
      ! phrase 1
      ! [1: try listing suggested topics]
       TryAction(0, player, ##A93_listing_suggested_topics, 0, 0);; 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_849, 849, true);
   rfalse;
];
! No specific request
! Every turn when a dramatic scene is not happening and Coyote's Offer has not ended and a random chance of 1 in 40 succeeds:
[ R_911 ;
   if ((((((Prop_1())) && ((( (scene_endings-->(Q346_coyote_s_offer-1) <= 1) )) && (( (GenerateRandomNumber(1, 40) <= 1) ))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_911, 911);
      ! phrase 1
      ! [1: say ~[one of]You shiver in the cold air[or]The cold night air swirls around you, and you pull your jacket closer[or]The air is frigid, and turns your breath into clouds[at random].~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->2 =
	i7_soo_ran(I7_ST_say_one_of-->2, 3);
	switch((I7_ST_say_one_of-->2)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_81; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_82; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_83; ParaContent();  } ParaContent();  print (PrintText) SC_77;  new_line; .L_Say5; .L_SayX5;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_911, 911, true);
   rfalse;
];
! No specific request
! Every turn when a charged thing ( called the item ) is visible:
[ R_929 
    t_0 ! Local variable e.g. 'item' = object
    ;
   if (((((Prop_2() && (t_0=deferred_calling_list-->0, true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_929, 929);
      ! phrase 1
      ! [1: move the suggested memory of the item to emotional baggage]
       MoveObject(GProperty(OBJECT_TY, t_0,p78_suggested_memory), O45_emotional_baggage, 0, false); 
      ! phrase 2
      ! [2: say ~Something about [the item] makes you want to brood about [the suggested memory of item].~]
      say__p=1;ParaContent();  print (PrintText) SC_84; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_85; ParaContent(); @push self;  print (the) GProperty(OBJECT_TY, self=t_0,p78_suggested_memory); @pull self; ParaContent();  print (PrintText) SC_77;  new_line; .L_Say6; .L_SayX6;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_929, 929, true);
   rfalse;
];
! No specific request
! Every turn when noun is a thing and noun is required by a plan and noun is not noted as useful:
[ R_953 ;
   if (((((((noun ofclass K2_thing))) && (((((noun.p79_objective) ofclass K72_plan))) && (((~~(((Adj_98_t1_v65(noun)))))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_953, 953);
      ! phrase 1
      ! [1: note noun as useful]
      (Resolver_0(noun,"source", 283));
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_953, 953, true);
   rfalse;
];
! No specific request
! Every turn when doing something to smell of gasoline and gas can is not noted as useful:
[ R_955 ;
   if ((((( (actor==player) &&  (noun) && (noun == inp1) && ((noun == O147_smell_of_gasoline) && (true))) && (((~~(((Adj_98_t1_v65(O60_gas_can))))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_955, 955);
      ! phrase 1
      ! [1: note gas can as useful]
      (PHR_954_r9 (O60_gas_can));
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_955, 955, true);
   rfalse;
];
! No specific request
! Every turn when doing something to cans of food and canned oranges are not noted as useful:
[ R_956 ;
   if ((((( (actor==player) &&  (noun) && (noun == inp1) && ((noun == O137_cans_of_food) && (true))) && (((~~(((Adj_98_t1_v65(O75_canned_oranges))))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_956, 956);
      ! phrase 1
      ! [1: note canned oranges as useful]
      (PHR_954_r9 (O75_canned_oranges));
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_956, 956, true);
   rfalse;
];
! No specific request
! Every turn when radio is switched on and frequency tuned to of radio is emergency frequency and voice has not been visible:
[ R_1090 ;
   if ((((((((Adj_84_t1_v65(O118_emergency_radio))))) && ((((GProperty(OBJECT_TY, O118_emergency_radio,p18_frequency_tuned_to) == (Global_Vars-->27)))) && (~~(TestSinglePastState(0, 0, false, 5)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1090, 1090);
      ! phrase 1
      ! [1: move voice to location]
       MoveObject(O172_voice, real_location, 0, false); 
      ! phrase 2
      ! [2: try quizzing voice about introduction]
       TryAction(0, player, ##A83_quizzing_it_about, O172_voice, O184_introduction);; 
      ! phrase 3
      ! [3: try listing suggested topics]
       TryAction(0, player, ##A93_listing_suggested_topics, 0, 0);; 
      ! phrase 4
      ! [4: have the parser notice voice]
      (PHR_828_r10 (O172_voice));
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1090, 1090, true);
   rfalse;
];
! No specific request
! Every turn when circle of snarling coyotes is visible:
[ R_1170 ;
   if (((((((Adj_3_t1_v65(O202_circle_of_snarling_coyo)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1170, 1170);
      ! phrase 1
      ! [1: say ~[one of]A coyote snaps his teeth, lunging forward then fading back into the pack.[or]The circle of snarling coyotes tightens.[or]The coyotes growl, pulling closer, snapping at your heels.[in random order]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->3 =
	i7_soo_shu(I7_ST_say_one_of-->3, 3);
	switch((I7_ST_say_one_of-->3)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_86;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_87;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_88;  new_line;ParaContent();  }  .L_Say7; .L_SayX7;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1170, 1170, true);
   rfalse;
];
! No specific request
! Every turn during Temptation:
[ R_1161 ;
   if (scene_status-->5 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1161, 1161);
      ! phrase 1
      ! [1: if a random chance of 1 in 4 succeeds and location is not regionally in office interior , say ~The [distant figure] waves again, out in the deep desert.~]
       if ((( (GenerateRandomNumber(1, 4) <= 1) )) && (((~~((TestRegionalContainment(real_location,O112_office_interior))))))) { say__p=1;ParaContent();  print (PrintText) SC_89; ParaContent();  print (PrintShortName) O200_distant_figure; ParaContent();  print (PrintText) SC_90;  new_line; .L_Say8; .L_SayX8;  }
   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1161, 1161, true);
   rfalse;
];
! No specific request
! Every turn during Chase:
[ R_1164 ;
   if (scene_status-->6 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1164, 1164);
      ! phrase 1
      ! [1: say ~[one of]Something snarls off in the distance, a warning growl.[or]A howl from behind you, and an answer from somewhere ahead. Coyotes. Hungry, sounds like.[or]Coyotes call all around you now, circling in the dark, unseen, but coming closer, closer.[or]You can smell them now, wild, feral. Shifting shadows whirl around you, panting, whining with the thrill of the chase.[or]The pack's at your heels, snapping, growling, and you've never in your life been this terrified.[or]Snarls and teeth and mangy fur on every side.[stopping]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->4 =
	i7_soo_stop(I7_ST_say_one_of-->4, 6);
	switch((I7_ST_say_one_of-->4)%(6+1)-1) {
		0: ParaContent();  print (PrintText) SC_91;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_92;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_93;  new_line;ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_94;  new_line;ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_95;  new_line;ParaContent();  @nop; 5: ParaContent();  print (PrintText) SC_96;  new_line;ParaContent();  }  .L_Say9; .L_SayX9;
   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1164, 1164, true);
   rfalse;
];
! No specific request
! Every turn during Sand-dancer's Arrival:
[ R_1199 ;
   if (scene_status-->9 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1199, 1199);
      ! phrase 1
      ! [1: say ~The building shakes and groans as sand continues to pour in, rising higher and higher.~]
      say__p=1;ParaContent();  print (PrintText) SC_97;  new_line; .L_Say10; .L_SayX10;
   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1199, 1199, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Every turn ( this is the reset protocol rule ):
[ R_774 ;
      ! phrase 1
      ! [1: now the farewell type is explicit]
       (Global_Vars-->11) = Q23_explicit; 
      ! phrase 2
      ! [2: now the greeting type is explicit]
       (Global_Vars-->10) = Q23_explicit; 
   rfalse;
];
! No specific request
! From "Conditional Undo" by Jesse McGrew
! Every turn ( this is the decide whether the action prevents undo rule ):
[ R_917 ;
      ! phrase 1
      ! [1: begin the deciding whether the action prevents undo activity]
       BeginActivity(V33_deciding_whether_the_act); 
      ! phrase 2
      ! [2: unless handling the deciding whether the action prevents undo activity begin]
       if (~~(( (~~(ForActivity(V33_deciding_whether_the_act))) )))  {
         ! phrase 3
         ! [3: if the rule succeeded , prevent undo]
          if (( (RulebookSucceeded()) )) { (PHR_913_r11 ());  }
         ! phrase 4
         ! [4: if the rule failed , do not prevent undo]
          if (( (RulebookFailed()) )) { (PHR_914_r12 ());  }
         ! phrase 5
         ! [5: end unless]
         }

      ! phrase 6
      ! [6: end the deciding whether the action prevents undo activity]
       EndActivity(V33_deciding_whether_the_act); 
   rfalse;
];
! No specific request
! From "Plurality" by Emily Short
! Every turn:
[ R_825 ;
      ! phrase 1
      ! [1: if the noun is a thing and the noun is ambiguously plural , notice the plurality of the noun]
       if ((((noun ofclass K2_thing))) && ((((Adj_92_t1_v65(noun)))))) {  PlugPlural(noun);   }
      ! phrase 2
      ! [2: if the second noun is a thing and the second noun is ambiguously plural , notice the plurality of the second noun]
       if ((((second ofclass K2_thing))) && ((((Adj_92_t1_v65(second)))))) {  PlugPlural(second);   }
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Action-processing (B10_action_processing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11 ! This is the announce items from multiple object lists rule:
!   === which is equally specific with ===
! Rule 2/11 ! This is the set pronouns from items from multiple object lists rule:
!   === which is equally specific with ===
! Rule 3/11 ! This is the before stage rule:
! --- now the mid-placed rules ---
! Rule 4/11: BASIC_VISIBILITY_R
!   === which is equally specific with ===
! Rule 5/11: BASIC_ACCESSIBILITY_R
!   === which is equally specific with ===
! Rule 6/11: CARRYING_REQUIREMENTS_R
! --- now the last-placed rules ---
! Rule 7/11 ! This is the instead stage rule:
!   === which is equally specific with ===
! Rule 8/11: REQUESTED_ACTIONS_REQUIRE_R
!   === which is equally specific with ===
! Rule 9/11: CARRY_OUT_REQUESTED_ACTIONS_R
!   === which is equally specific with ===
! Rule 10/11: DESCEND_TO_SPECIFIC_ACTION_R
!   === which is equally specific with ===
! Rule 11/11 ! This is the end action-processing in success rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the announce items from multiple object lists rule:
[ R_20 ;
      ! phrase 1
      ! [1: if the current item from the multiple object list is not nothing , say ~[current item from the multiple object list]: [run paragraph on]~]
       if (((~~((multiple_object_item == nothing))))) { say__p=1;ParaContent();  print (PrintShortName) multiple_object_item; ParaContent();  print (PrintText) SC_98; ParaContent();  RunParagraphOn();  .L_Say11; .L_SayX11;  }
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the set pronouns from items from multiple object lists rule:
[ R_19 ;
      ! phrase 1
      ! [1: if the current item from the multiple object list is not nothing , set pronouns from the current item from the multiple object list]
       if (((~~((multiple_object_item == nothing))))) {  PronounNotice(multiple_object_item);   }
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the before stage rule:
[ R_21 ;
      ! phrase 1
      ! [1: abide by the before rules]
       if (ProcessRulebook(20)) rtrue; 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the instead stage rule:
[ R_22 ;
      ! phrase 1
      ! [1: abide by the instead rules]
       if (ProcessRulebook(21)) rtrue; 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the end action-processing in success rule:
[ R_23 ;
      ! phrase 1
      ! [1: rule succeeds]
       RulebookSucceeds(); rtrue; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Setting action variables (B11_setting_action_variables)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Rule for setting action variables for going ( this is the standard set going variables rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Setting action variables for looking ( this is the determine visibility ceiling rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Setting action variables for exiting:
!   === which is equally specific with ===
! Rule 4/4 ! Rule for setting action variables for trading:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for setting action variables for going ( this is the standard set going variables rule ):
[ R_137 
    t_0 ! Local variable e.g. 'carriage' = object
    t_1 ! Local variable e.g. 'target' = object
    t_2 ! Local variable e.g. 'direction D' = object
    ;
   if ((action ==##Go)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_137, 137);
      ! phrase 1
      ! [1: now the thing gone with is the item-pushed-between-rooms]
       (MStack-->MstVO(20007,4)) = move_pushing; 
      ! phrase 2
      ! [2: now the room gone from is the location of the actor]
       (MStack-->MstVO(20007,0)) =  LocationOf(actor) ; 
      ! phrase 3
      ! [3: if the actor is in an enterable vehicle ( called the carriage ) , now the vehicle gone by is the carriage]
       if (((ContainerOf(actor) ofclass K27_vehicle) && (t_0=(ContainerOf(actor)), true) && ((Adj_71_t1_v65(ContainerOf(actor)))))) {  (MStack-->MstVO(20007,3)) = t_0;   }
      ! phrase 4
      ! [4: let the target be nothing]
       t_1 = nothing; 
      ! phrase 5
      ! [5: if the noun is a direction begin]
       if (((noun ofclass K3_direction)))  {
         ! phrase 6
         ! [6: let direction d be the noun]
          t_2 = noun; 
         ! phrase 7
         ! [7: let the target be the room-or-door direction d from the room gone from]
          t_1 = (Resolver_1(t_2,(MStack-->MstVO(20007,0)),"source", 1948)); 
         ! phrase 8
         ! [8: otherwise]
         } else {

         ! phrase 9
         ! [9: if the noun is a door , let the target be the noun]
          if (((noun ofclass K4_door))) {  t_1 = noun;   }
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: if the target is a door begin]
       if (((t_1 ofclass K4_door)))  {
         ! phrase 12
         ! [12: now the door gone through is the target]
          (MStack-->MstVO(20007,2)) = t_1; 
         ! phrase 13
         ! [13: now the target is the other side of the target from the room gone from]
          t_1 = (Resolver_2(t_1,(MStack-->MstVO(20007,0)),"source", 1953)); 
         ! phrase 14
         ! [14: end if]
         }

      ! phrase 15
      ! [15: now the room gone to is the target]
       (MStack-->MstVO(20007,1)) = t_1; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_137, 137, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Setting action variables for looking ( this is the determine visibility ceiling rule ):
[ R_171 ;
   if ((action ==##Look)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_171, 171);
      ! phrase 1
      ! [1: if the actor is the player , calculate visibility ceiling at low level]
       if (((actor == player))) {  FindVisibilityLevels();   }
      ! phrase 2
      ! [2: now the visibility level count is the visibility ceiling count calculated]
       (MStack-->MstVO(20011,2)) =  visibility_levels ; 
      ! phrase 3
      ! [3: now the visibility ceiling is the visibility ceiling calculated]
       (MStack-->MstVO(20011,3)) =  visibility_ceiling ; 
      ! phrase 4
      ! [4: now the room-describing action is the looking action]
       (MStack-->MstVO(20011,0)) = ##Look; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_171, 171, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Setting action variables for exiting:
[ R_159 ;
   if ((action ==##Exit)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_159, 159);
      ! phrase 1
      ! [1: now the container exited from is the holder of the actor]
       (MStack-->MstVO(20009,0)) =  (HolderOf(actor)) ; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_159, 159, true);
   rfalse;
];
! No specific request
! Rule for setting action variables for trading:
[ R_1098 ;
   if ((action ==##A101_trading)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1098, 1098);
      ! phrase 1
      ! [1: now the trader is a random visible spirit animal]
       (MStack-->MstVO(20101,0)) =  (Prop_3()) ; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1098, 1098, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: specific action-processing (B12_specific_action_processi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8: WORK_OUT_DETAILS_OF_SPECIFIC_R
! --- now the mid-placed rules ---
! Rule 2/8 ! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
!   === which is equally specific with ===
! Rule 3/8 ! A specific action-processing rule ( this is the check stage rule ):
!   === which is equally specific with ===
! Rule 4/8 ! A specific action-processing rule ( this is the carry out stage rule ):
!   === which is equally specific with ===
! Rule 5/8 ! A specific action-processing rule ( this is the after stage rule ):
!   === which is equally specific with ===
! Rule 6/8 ! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
!   === which is equally specific with ===
! Rule 7/8 ! A specific action-processing rule ( this is the report stage rule ):
! --- now the last-placed rules ---
! Rule 8/8 ! The last specific action-processing rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
[ R_24 ;
      ! phrase 1
      ! [1: consider the player's action awareness rules]
       ProcessRulebook(13); 
      ! phrase 2
      ! [2: if rule succeeded , now within the player's sight is true]
       if (( (RulebookSucceeded()) )) {  (MStack-->MstVO(12,5)) = 1;   }
      ! phrase 3
      ! [3: otherwise now within the player's sight is false]
       else {  (MStack-->MstVO(12,5)) = 0;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the check stage rule ):
[ R_25 ;
      ! phrase 1
      ! [1: anonymously abide by the specific check rulebook]
       if (temporary_value = ProcessRulebook((MStack-->MstVO(12,2)))) {
		if (RulebookSucceeded()) ActRulebookSucceeds(temporary_value);
		else ActRulebookFails(temporary_value);
		rtrue;
	} 
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the carry out stage rule ):
[ R_26 ;
      ! phrase 1
      ! [1: consider the specific carry out rulebook]
       ProcessRulebook((MStack-->MstVO(12,3))); 
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the after stage rule ):
[ R_27 ;
      ! phrase 1
      ! [1: if action in world is true , abide by the after rules]
       if ((((MStack-->MstVO(12,0)) == 1))) {  if (ProcessRulebook(24)) rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
[ R_28 ;
      ! phrase 1
      ! [1: if within the player's sight is false begin]
       if ((((MStack-->MstVO(12,5)) == 0)))  {
         ! phrase 2
         ! [2: consider the player's action awareness rules]
          ProcessRulebook(13); 
         ! phrase 3
         ! [3: if rule succeeded , now within the player's sight is true]
          if (( (RulebookSucceeded()) )) {  (MStack-->MstVO(12,5)) = 1;   }
         ! phrase 4
         ! [4: end if]
         }

   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the report stage rule ):
[ R_29 ;
      ! phrase 1
      ! [1: if within the player's sight is true and action keeping silent is false , consider the specific report rulebook]
       if (((((MStack-->MstVO(12,5)) == 1))) && ((((MStack-->MstVO(12,1)) == 0)))) {  ProcessRulebook((MStack-->MstVO(12,4)));   }
   rfalse;
];
! No specific request
! From the Standard Rules
! The last specific action-processing rule:
[ R_30 ;
      ! phrase 1
      ! [1: rule succeeds]
       RulebookSucceeds(); rtrue; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: player's action awareness (B13_player_s_action_awarenes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! A player's action awareness rule ( this is the player aware of his own actions rule ):
!   === which is equally specific with ===
! Rule 2/4 ! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
!   === which is equally specific with ===
! Rule 3/4 ! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
!   === which is equally specific with ===
! Rule 4/4 ! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of his own actions rule ):
[ R_31 ;
      ! phrase 1
      ! [1: if the player is the actor , rule succeeds]
       if (((player == actor))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
[ R_32 ;
      ! phrase 1
      ! [1: if the player is not the actor and the player can see the actor , rule succeeds]
       if ((((~~((player == actor))))) && (((TestVisibility(player,actor))))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
[ R_33 ;
      ! phrase 1
      ! [1: if the noun is a thing and the player can see the noun , rule succeeds]
       if ((((noun ofclass K2_thing))) && (((TestVisibility(player,noun))))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
[ R_34 ;
      ! phrase 1
      ! [1: if the second noun is a thing and the player can see the second noun , rule succeeds]
       if ((((second ofclass K2_thing))) && (((TestVisibility(player,second))))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Reaching inside (B15_reaching_inside)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Rule for reaching inside the wire mesh cage when we are touching:
!   >>> I - Number of aspects constrained >>>
! Rule 2/4 ! Rule for reaching inside photo:
! --- now the last-placed rules ---
! Rule 3/4: CANT_REACH_INSIDE_ROOMS_R
!   === which is equally specific with ===
! Rule 4/4: CANT_REACH_INSIDE_CLOSED_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for reaching inside the wire mesh cage when we are touching:
[ R_1059 ;
   if (((parameter_object == O140_wire_mesh_cage) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Touch) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1059, 1059);
      ! phrase 1
      ! [1: allow access]
      RulebookSucceeds(true, RBNO_0); rtrue;

   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1059, 1059, true);
   rfalse;
];
! No specific request
! Rule for reaching inside photo:
[ R_983 ;
   if (((parameter_object == O86_photo) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_983, 983);
      ! phrase 1
      ! [1: say ~Just a photo.~]
      say__p=1;ParaContent();  print (PrintText) SC_99;  new_line; .L_Say12; .L_SayX12;
      ! phrase 2
      ! [2: rule fails]
       RulebookFails(); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_983, 983, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Visibility (B17_visibility)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last visibility rule ( this is the can't act in the dark rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! The last visibility rule ( this is the can't act in the dark rule ):
[ R_35 ;
      ! phrase 1
      ! [1: if in darkness , rule succeeds]
       if (( (location==thedark) )) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Persuasion (B18_persuasion)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Persuasion rule for asking people to try hailing ( this is the allow hailing rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Persuasion rule for asking people to try leavetaking ( this is the alllow leavetaking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Persuasion rule for asking people to try hailing ( this is the allow hailing rule ):
[ R_763 ;
   if ((action ==##A90_hailing) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_763, 763);
      ! phrase 1
      ! [1: persuasion succeeds]
      RulebookSucceeds(true, RBNO_4); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_763, 763, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Persuasion rule for asking people to try leavetaking ( this is the alllow leavetaking rule ):
[ R_770 ;
   if ((action ==##A91_leavetaking) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_770, 770);
      ! phrase 1
      ! [1: persuasion succeeds]
      RulebookSucceeds(true, RBNO_4); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_770, 770, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Before (B20_before)
! ----------------------------------------------------------------------------------------------------
! Rule 1/31 ! Before switching on flashlight in dim Staging Area:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 2/31 ! Before going south in Backtracking:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 3/31 ! Before going to The Open Desert when The Open Desert is unvisited:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 4/31 ! Before taking cans of food when player holds can opener and player holds luck:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 5/31 ! Before entering truck when truck is closed:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 6/31 ! Before going up during Sand-dancer's Arrival:
!   >>> I - Number of aspects constrained >>>
! Rule 7/31 ! Before asking someone to try hailing ( this is the change greeting command to greeting rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 8/31 ! Before asking someone to try doing something when the person asked is not the current interlocutor ( this is the giving orders needs an interlocutor rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 9/31 ! Before going somewhere when the player is in a container ( called the platform ) ( this is the small kindnesses automatically get out of containers before going rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 10/31 ! Before going from Around the Tower to Open Desert:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 11/31 ! Before going to Open Desert:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 12/31 ! Before answering someone that ~yes~ ( this is the change answering yes to saying yes rule ):
!   === which is equally specific with ===
! Rule 13/31 ! Before answering someone that ~no~ ( this is the change answering no to saying no rule ):
!   === which is equally specific with ===
! Rule 14/31 ! Before answering someone that ~sorry~ ( this is the change answering sorry to saying sorry rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 15/31 ! Before showing something ( called the item ) to someone ( called the viewer ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 16/31 ! Before saying hello to the emergency radio:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 17/31 ! Before eating an inedible thing ( this is the small kindnesses don't implicitly take inedibles rule ):
!   === which is equally specific with ===
! Rule 18/31 ! Before wearing a not wearable thing ( this is the small kindnesses don't implicitly take unwearables rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 19/31 ! Before asking someone to try saying yes ( this is the greet before saying yes rule ):
!   === which is equally specific with ===
! Rule 20/31 ! Before asking someone to try saying no ( this is the greet before saying no rule ):
!   === which is equally specific with ===
! Rule 21/31 ! Before asking someone to try saying sorry ( this is the greet before saying sorry rule ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 22/31 ! Before implicit-conversing when the current interlocutor is not visible and the current interlocutor is not nothing ( this is the can't converse with absent interlocutor rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 23/31 ! Before conversing when the noun is not the current interlocutor ( this is the greet a new interlocutor rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 24/31 ! Before implicit-conversing when the current interlocutor is nothing ( this is the implicit-conversing needs current interlocutor rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 25/31 ! Before wasting time during Sand-dancer's Arrival:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 26/31 ! Before saying hello to when noun is not a spirit animal and noun is not voice:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 27/31 ! Before smoking when lighter is not held and lighter is visible:
!   === which is equally specific with ===
! Rule 28/31 ! Before smoking when pack of cigarettes is not held and pack of cigarettes is visible:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 29/31 ! Before exiting when player is in truck and truck is closed:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 30/31 ! Before going during Pursuit:
!   >>> I - Number of aspects constrained >>>
! Rule 31/31 ! Before listing suggested topics:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Before switching on flashlight in dim Staging Area:
[ R_1041 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == O71_flashlight) && (true)) && ((real_location == O69_staging_area) && ((Adj_100_t1_v65(real_location))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1041, 1041);
      ! phrase 1
      ! [1: now metal desk is described]
       (Adj_65_t2_v65(O126_metal_desk)); 
      ! phrase 2
      ! [2: now hole in the floor is described]
       (Adj_65_t2_v65(O124_hole_in_the_floor)); 
      ! phrase 3
      ! [3: now every handled visible thing is described]
       Prop_4(); 
      ! phrase 4
      ! [4: now staging area is bright]
       (Adj_101_t2_v65(O69_staging_area)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1041, 1041, true);
   rfalse;
];
! No specific request
! Before going south in Backtracking:
[ R_998 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == O13_south) && (true)) && ((real_location == O67_backtracking) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_998, 998);
      ! phrase 1
      ! [1: say ~[first time]You stare back down the pickup's path uneasily. The tracks are swallowed by blackness, quickly melding, blending, and vanishing into a maze of ATV tracks, coyote trails, rocky outcrops, and shadows. You squint at the horizon. There's no distant sweep of headlights, no sound of trucks shifting through lonely gears. Nothing. Nothing at all. [only]You're way off the road, and there's no chance at all of finding it again in this demon dark.~ instead]
      say__p=1;ParaContent();  
	if ((I7_ST_say_first_time-->0)++ == 0) {
		ParaContent();  print (PrintText) SC_100; ParaContent();  } ParaContent();  print (PrintText) SC_101;  new_line; rtrue; .L_Say13; .L_SayX13; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_998, 998, true);
   rfalse;
];
! No specific request
! Before going to The Open Desert when The Open Desert is unvisited:
[ R_1082 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == O149_open_desert) && (true)) && (self=actor,true) && ((((Adj_54_t1_v65(O149_open_desert)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1082, 1082);
      ! phrase 1
      ! [1: repeat with heading running through cardinal directions begin]
       for (t_0=Prop_5(0), t_1=Prop_5(t_0): t_0: t_0=t_1, t_1=Prop_5(t_1))  {
                  ! phrase 2
         ! [2: change the heading exit of the open desert to the open desert]
         (Resolver_3(t_0,O149_open_desert,O149_open_desert,"source", 830));
         ! phrase 3
         ! [3: end repeat]
         }

         } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1082, 1082, true);
   rfalse;
];
! No specific request
! Before taking cans of food when player holds can opener and player holds luck:
[ R_939 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O137_cans_of_food) && (true)) && (self=actor,true) && ((((player == HolderOf(O145_can_opener)))) && (((player == HolderOf(O81_luck)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_939, 939);
      ! phrase 1
      ! [1: move lingering smell of orange to location]
       MoveObject(O58_lingering_smell_of_orang, real_location, 0, false); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_939, 939, true);
   rfalse;
];
! No specific request
! Before entering truck when truck is closed:
[ R_990 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == O42_pickup_truck) && (true)) && (self=actor,true) && ((((Adj_75_t1_v65(O42_pickup_truck)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_990, 990);
      ! phrase 1
      ! [1: try opening the truck]
       TryAction(0, player, ##Open, O42_pickup_truck, 0);; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_990, 990, true);
   rfalse;
];
! No specific request
! Before going up during Sand-dancer's Arrival:
[ R_1209 ;
   if (scene_status-->9 == 1) { ! Runs only during scene
   if ((action ==##Go) &&  (actor==player) && ((noun == O18_up) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1209, 1209);
      ! phrase 1
      ! [1: now description of roof is ~Except it's more like a foundation now, the building's sunken almost entirely into the sand.~]
       WriteGProperty(OBJECT_TY, O89_roof,description,SC_102); 
      ! phrase 2
      ! [2: now metal rungs are off-stage]
       (Adj_9_t3_v65(O142_metal_rungs)); 
      ! phrase 3
      ! [3: now huge metal barrel is off-stage]
       (Adj_9_t3_v65(O144_huge_metal_barrel)); 
      ! phrase 4
      ! [4: change the up exit of roof to nothing]
       AssertMapConnection(O89_roof,O18_up,nothing); 
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1209, 1209, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before asking someone to try hailing ( this is the change greeting command to greeting rule ):
[ R_760 ;
   if ((action ==##A90_hailing) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_760, 760);
      ! phrase 1
      ! [1: now the greeting type is explicit]
       (Global_Vars-->10) = Q23_explicit; 
      ! phrase 2
      ! [2: try saying hello to the person asked]
       TryAction(0, player, ##A89_saying_hello_to, actor, 0);; 
      ! phrase 3
      ! [3: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_760, 760, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before asking someone to try doing something when the person asked is not the current interlocutor ( this is the giving orders needs an interlocutor rule ):
[ R_754 ;
   if ( (actor~=player) && (act_requester) && ((actor ofclass K8_person)) && (self=actor,true) && (((~~((actor == (Global_Vars-->9))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_754, 754);
      ! phrase 1
      ! [1: implicitly greet the person asked]
      (Resolver_4(actor,"source", 157));
      ! phrase 2
      ! [2: if the person asked is not the current interlocutor , stop the action]
       if (((~~((actor == (Global_Vars-->9)))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_754, 754, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Before going somewhere when the player is in a container ( called the platform ) ( this is the small kindnesses automatically get out of containers before going rule ):
[ R_872 
    t_0 ! Local variable e.g. 'platform' = object
    ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) ofclass K1_room)) && (self=actor,true) && (((ContainerOf(player) ofclass K5_container) && (t_0=(ContainerOf(player)), true)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_872, 872);
      ! phrase 1
      ! [1: say ~(first getting out of [the platform])[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_103; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_104; ParaContent();  new_line;  .L_Say14; .L_SayX14;
      ! phrase 2
      ! [2: silently try getting off the platform]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##GetOff, t_0, 0);; @pull keep_silent; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_872, 872, true);
   rfalse;
];
! No specific request
! Before going from Around the Tower to Open Desert:
[ R_1080 ;
   if ((action ==##Go) &&  (actor==player) && (TestRegionalContainment((MStack-->MstVON(20007,0)),O87_around_the_tower)) && (((MStack-->MstVON(20007,1)) == O149_open_desert) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1080, 1080);
      ! phrase 1
      ! [1: if flashlight is not held , instead say ~Better not. [if headlights are switched on]Outside the wavering glow of your headlights, i[otherwise]I[end if]t's black. Pitch. Storm must have rolled in; there's no stars above, no anything but blackness around. Only the smell of the desert tells you it's still out there.~]
       if (((~~(((Adj_2_t1_v65(O71_flashlight))))))) { say__p=1;ParaContent();  print (PrintText) SC_105; 
	if (~~(((((Adj_84_t1_v65(O95_headlights))))))) jump L_Say15;
		ParaContent();  print (PrintText) SC_106; 
	jump L_SayX15; .L_Say15;
		ParaContent();  print (PrintText) SC_107; 
	.L_Say16; .L_SayX15;
		ParaContent();  print (PrintText) SC_108;  new_line; rtrue; .L_Say17; .L_SayX16; rtrue;  }
      ! phrase 2
      ! [2: if flashlight is not switched on , try switching on the flashlight]
       if (((~~(((Adj_84_t1_v65(O71_flashlight))))))) {  TryAction(0, player, ##SwitchOn, O71_flashlight, 0);;   }
      ! phrase 3
      ! [3: if emergency lights are switched off or voice has not been visible or insufficient memories found , instead say ~You heft your flashlight nervously, licking your lips, but decide not to head out into the desert just yet. There might be more around here you should investigate before taking such a drastic step.~]
       if (((((Adj_85_t1_v65(O131_emergency_lights))))) || ((~~(TestSinglePastState(0, 1, false, 5))) || (((PHR_932_r14 ()))))) { say__p=1;ParaContent();  print (PrintText) SC_109;  new_line; rtrue; .L_Say18; .L_SayX17; rtrue;  }
      ! phrase 4
      ! [4: if rainstorm is happening , instead say ~In a storm like this? No way.~]
       if ((((scene_status-->(Q340_rainstorm-1)==1)))) { say__p=1;ParaContent();  print (PrintText) SC_110;  new_line; rtrue; .L_Say19; .L_SayX18; rtrue;  }
      ! phrase 5
      ! [5: if coyote's offer has ended , instead say ~You have some feeling that when the last spirit animal decides to make an appearance, it will find you.~]
       if (( (scene_endings-->(Q346_coyote_s_offer-1) > 1) )) { say__p=1;ParaContent();  print (PrintText) SC_111;  new_line; rtrue; .L_Say20; .L_SayX19; rtrue;  }
      ! phrase 6
      ! [6: if pursuit is not happening and temptation is not happening , instead say ~On a night as freakishly dark as this, that's insane.~]
       if ((((~~(((scene_status-->(Q341_pursuit-1)==1)))))) && (((~~(((scene_status-->(Q343_temptation-1)==1))))))) { say__p=1;ParaContent();  print (PrintText) SC_112;  new_line; rtrue; .L_Say21; .L_SayX20; rtrue;  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1080, 1080, true);
   rfalse;
];
! No specific request
! Before going to Open Desert:
[ R_1085 ;blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 2;
    blockv_stack-->(blockv_sp++) = R_SHELL_0(blockv_sp-2);
    blockv_sp = blockv_sp - 3;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+2);
];
[ R_SHELL_0 I7BASPL 
    t_0 ! Local variable e.g. 'decorations' = list of objects
    t_1 ! Local variable e.g. 'density' = number
    t_2 ! Local variable e.g. '?-1,-1?' = object
    t_3 ! Local variable e.g. '?-1,-1?' = number
    ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == O149_open_desert) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1085, 1085);
      ! phrase 1
      ! [1: repeat with item running through visible desert flotsam begin]
       for (t_0=Prop_6(0), t_1=Prop_6(t_0): t_0: t_0=t_1, t_1=Prop_6(t_1))  {
                  ! phrase 2
         ! [2: now item is off-stage]
          (Adj_9_t3_v65(t_0)); 
         ! phrase 3
         ! [3: end repeat]
         }

            ! phrase 4
      ! [4: let decorations be the list of desert flotsam]
       t_0 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_0,  LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+1)), Prop_7, OBJECT_TY) ); 
      ! phrase 5
      ! [5: sort decorations in random order]
       LIST_OF_TY_Sort(t_0, 2); 
      ! phrase 6
      ! [6: let density be a random number from 0 to 2]
       t_1 =  R_DecimalNumber(0, 2) ; 
      ! phrase 7
      ! [7: truncate decorations to the first density entries]
       LIST_OF_TY_SetLength(t_0, t_1, -1, 1); 
      ! phrase 8
      ! [8: repeat with item running through decorations begin]
       for (t_3=1, t_2=LIST_OF_TY_GetItem(t_0, t_3, true): t_3<=LIST_OF_TY_GetLength(t_0): t_3++, t_2=LIST_OF_TY_GetItem(t_0, t_3, true))  {
                  ! phrase 9
         ! [9: now item is in the open desert]
          MoveObject(t_2,O149_open_desert); 
         ! phrase 10
         ! [10: end repeat]
         }

         } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1085, 1085, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before answering someone that ~yes~ ( this is the change answering yes to saying yes rule ):
[ R_778 ;
   if ((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person)) && (Consult_Grammar_169(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_778, 778);
      ! phrase 1
      ! [1: try saying yes instead]
       TryAction(0, player, ##Yes, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_778, 778, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before answering someone that ~no~ ( this is the change answering no to saying no rule ):
[ R_779 ;
   if ((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person)) && (Consult_Grammar_170(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_779, 779);
      ! phrase 1
      ! [1: try saying no instead]
       TryAction(0, player, ##No, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_779, 779, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before answering someone that ~sorry~ ( this is the change answering sorry to saying sorry rule ):
[ R_780 ;
   if ((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person)) && (Consult_Grammar_171(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_780, 780);
      ! phrase 1
      ! [1: try asking the noun to try saying sorry instead]
       TryAction(1, noun, ##Sorry, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_780, 780, true);
   rfalse;
];
! No specific request
! Before showing something ( called the item ) to someone ( called the viewer ):
[ R_881 
    t_0 ! Local variable e.g. 'item' = object
    t_1 ! Local variable e.g. 'viewer' = object
    ;
   if ((action ==##Show) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing)))) && (t_1 = second, (((t_1=(second), true) && (second ofclass K8_person))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_881, 881);
      ! phrase 1
      ! [1: try giving the item to the viewer instead]
       TryAction(0, player, ##Give, t_0, t_1);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_881, 881, true);
   rfalse;
];
! No specific request
! Before saying hello to the emergency radio:
[ R_1118 ;
   if ((action ==##A89_saying_hello_to) &&  (actor==player) && ((noun == O118_emergency_radio) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1118, 1118);
      ! phrase 1
      ! [1: if emergency radio is switched off , try switching on emergency radio instead]
       if ((((Adj_85_t1_v65(O118_emergency_radio))))) {  TryAction(0, player, ##SwitchOn, O118_emergency_radio, 0);;   rtrue; }
      ! phrase 2
      ! [2: otherwise say ~You try to raise someone, but there's no response[if frequency tuned to of radio is not the emergency frequency], at least on this frequency[end if].~ instead]
       else { say__p=1;ParaContent();  print (PrintText) SC_113; 
	if (~~((((~~((GProperty(OBJECT_TY, O118_emergency_radio,p18_frequency_tuned_to) == (Global_Vars-->27)))))))) jump L_Say22;
		ParaContent();  print (PrintText) SC_114; 
	.L_Say22; .L_SayX21;
		ParaContent();  print (PrintText) SC_77;  new_line; .L_Say23; .L_SayX22;  rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1118, 1118, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Before eating an inedible thing ( this is the small kindnesses don't implicitly take inedibles rule ):
[ R_878 ;
   if ((action ==##Eat) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_58_t1_v65(noun))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_878, 878);
      ! phrase 1
      ! [1: stop the action with library message eating action number 1 for the noun]
       return GL__M(##Eat,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_878, 878, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Before wearing a not wearable thing ( this is the small kindnesses don't implicitly take unwearables rule ):
[ R_879 ;
   if ((action ==##Wear) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((Adj_62_t1_v65(noun)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_879, 879);
      ! phrase 1
      ! [1: stop the action with library message wearing action number 1 for the noun]
       return GL__M(##Wear,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_879, 879, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before asking someone to try saying yes ( this is the greet before saying yes rule ):
[ R_775 ;
   if ((action ==##Yes) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_775, 775);
      ! phrase 1
      ! [1: if the person asked is not the current interlocutor , implicitly greet the person asked]
       if (((~~((actor == (Global_Vars-->9)))))) { (Resolver_4(actor,"source", 275));  }
      ! phrase 2
      ! [2: try saying yes instead]
       TryAction(0, player, ##Yes, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_775, 775, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before asking someone to try saying no ( this is the greet before saying no rule ):
[ R_776 ;
   if ((action ==##No) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_776, 776);
      ! phrase 1
      ! [1: if the person asked is not the current interlocutor , implicitly greet the person asked]
       if (((~~((actor == (Global_Vars-->9)))))) { (Resolver_4(actor,"source", 279));  }
      ! phrase 2
      ! [2: try saying no instead]
       TryAction(0, player, ##No, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_776, 776, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before asking someone to try saying sorry ( this is the greet before saying sorry rule ):
[ R_777 ;
   if ((action ==##Sorry) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_777, 777);
      ! phrase 1
      ! [1: if the person asked is not the current interlocutor , implicitly greet the person asked]
       if (((~~((actor == (Global_Vars-->9)))))) { (Resolver_4(actor,"source", 283));  }
      ! phrase 2
      ! [2: try saying sorry instead]
       TryAction(0, player, ##Sorry, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_777, 777, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before implicit-conversing when the current interlocutor is not visible and the current interlocutor is not nothing ( this is the can't converse with absent interlocutor rule ):
[ R_748 ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && ((((~~(((Adj_3_t1_v65((Global_Vars-->9)))))))) && (((~~(((Global_Vars-->9) == nothing))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_748, 748);
      ! phrase 1
      ! [1: say ~[The current interlocutor] isn't here.~]
      say__p=1;ParaContent();  print (The) (Global_Vars-->9); ParaContent();  print (PrintText) SC_115;  new_line; .L_Say24; .L_SayX23;
      ! phrase 2
      ! [2: reset the interlocutor instead]
      (PHR_765_r3 ()); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_748, 748, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before conversing when the noun is not the current interlocutor ( this is the greet a new interlocutor rule ):
[ R_753 ;
   if ((NAP_1()) &&  (actor==player) && (self=actor,true) && (((~~((noun == (Global_Vars-->9))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_753, 753);
      ! phrase 1
      ! [1: implicitly greet the noun]
      (Resolver_4(noun,"source", 151));
      ! phrase 2
      ! [2: if the noun is not the current interlocutor , stop the action]
       if (((~~((noun == (Global_Vars-->9)))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_753, 753, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before implicit-conversing when the current interlocutor is nothing ( this is the implicit-conversing needs current interlocutor rule ):
[ R_747 
    t_0 ! Local variable e.g. 'np' = number
    t_1 ! Local variable e.g. 'interlocutor' = object
    t_2 ! Local variable e.g. 'sn' = object
    ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->9) == nothing)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_747, 747);
      ! phrase 1
      ! [1: let np be the number of visible people who are not the player]
       t_0 =  (Prop_8()) ; 
      ! phrase 2
      ! [2: if np is 0 , say ~There's no one here to talk to.~]
       if (((t_0 == 0))) { say__p=1;ParaContent();  print (PrintText) SC_116;  new_line; .L_Say25; .L_SayX24;  }
      ! phrase 3
      ! [3: if np > 1 , say ~You need to specify who you want to speak to.~]
       if (((t_0 > 1))) { say__p=1;ParaContent();  print (PrintText) SC_117;  new_line; .L_Say26; .L_SayX25;  }
      ! phrase 4
      ! [4: if np is not 1 , stop the action]
       if (((~~((t_0 == 1))))) {  rtrue;   }
      ! phrase 5
      ! [5: let the interlocutor be a random visible person who is not the player]
       t_1 =  (Prop_9()) ; 
      ! phrase 6
      ! [6: if the interlocutor is a person begin]
       if (((t_1 ofclass K8_person)))  {
         ! phrase 7
         ! [7: say ~(addressing [the interlocutor])~]
         say__p=1;ParaContent();  print (PrintText) SC_118; ParaContent();  print (the) t_1; ParaContent();  print (PrintText) SC_104;  .L_Say27; .L_SayX26;
         ! phrase 8
         ! [8: let sn be the second noun]
          t_2 = second; 
         ! phrase 9
         ! [9: implicitly greet the interlocutor]
         (Resolver_4(t_1,"source", 96));
         ! phrase 10
         ! [10: now the second noun is sn]
          second = t_2; 
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~You're not talking to anyone.~]
         say__p=1;ParaContent();  print (PrintText) SC_119;  new_line; .L_Say28; .L_SayX27;
         ! phrase 13
         ! [13: stop the action]
          rtrue; 
         ! phrase 14
         ! [14: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_747, 747, true);
   rfalse;
];
! No specific request
! Before wasting time during Sand-dancer's Arrival:
[ R_1207 ;
   if (scene_status-->9 == 1) { ! Runs only during scene
   if ((NAP_5()) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1207, 1207);
      ! phrase 1
      ! [1: say ~There's no time, man! The room's filling with sand!~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_120;  new_line; rtrue; .L_Say29; .L_SayX28; rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1207, 1207, true);
   rfalse;
];
! No specific request
! Before saying hello to when noun is not a spirit animal and noun is not voice:
[ R_912 ;
   if ((action ==##A89_saying_hello_to) &&  (actor==player) && (self=actor,true) && ((((~~((noun ofclass K165_spirit_animal))))) && (((~~((noun == O172_voice))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_912, 912);
      ! phrase 1
      ! [1: instead say ~You can't really get into a good conversation right now.~]
      say__p=1;ParaContent();  print (PrintText) SC_121;  new_line; rtrue; .L_Say30; .L_SayX29; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_912, 912, true);
   rfalse;
];
! No specific request
! Before smoking when lighter is not held and lighter is visible:
[ R_971 ;
   if ((action ==##A98_smoking) &&  (actor==player) && (self=actor,true) && ((((~~(((Adj_2_t1_v65(O38_lighter))))))) && ((((Adj_3_t1_v65(O38_lighter))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_971, 971);
      ! phrase 1
      ! [1: say ~(first taking the lighter)~]
      say__p=1;ParaContent();  print (PrintText) SC_122;  .L_Say31; .L_SayX30;
      ! phrase 2
      ! [2: try silently taking lighter]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##Take, O38_lighter, 0);; @pull keep_silent; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_971, 971, true);
   rfalse;
];
! No specific request
! Before smoking when pack of cigarettes is not held and pack of cigarettes is visible:
[ R_972 ;
   if ((action ==##A98_smoking) &&  (actor==player) && (self=actor,true) && ((((~~(((Adj_2_t1_v65(O39_pack_of_cigarettes))))))) && ((((Adj_3_t1_v65(O39_pack_of_cigarettes))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_972, 972);
      ! phrase 1
      ! [1: say ~(first taking the cigarettes)~]
      say__p=1;ParaContent();  print (PrintText) SC_123;  .L_Say32; .L_SayX31;
      ! phrase 2
      ! [2: try silently taking pack of cigarettes]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##Take, O39_pack_of_cigarettes, 0);; @pull keep_silent; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_972, 972, true);
   rfalse;
];
! No specific request
! Before exiting when player is in truck and truck is closed:
[ R_991 ;
   if ((action ==##Exit) &&  (actor==player) && (self=actor,true) && ((((O42_pickup_truck == ContainerOf(player)))) && ((((Adj_75_t1_v65(O42_pickup_truck))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_991, 991);
      ! phrase 1
      ! [1: try opening the truck]
       TryAction(0, player, ##Open, O42_pickup_truck, 0);; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_991, 991, true);
   rfalse;
];
! No specific request
! Before going during Pursuit:
[ R_1131 ;
   if (scene_status-->3 == 1) { ! Runs only during scene
   if ((action ==##Go) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1131, 1131);
      ! phrase 1
      ! [1: if noun is path of darting shadow begin]
       if (((noun == GProperty(OBJECT_TY, O181_darting_shadow,p22_path))))  {
         ! phrase 2
         ! [2: increase the times followed of darting shadow by 1]
          WriteGProperty(OBJECT_TY, O181_darting_shadow,p23_times_followed,GProperty(OBJECT_TY, O181_darting_shadow,p23_times_followed) + 1); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: now times followed of darting shadow is 0]
          WriteGProperty(OBJECT_TY, O181_darting_shadow,p23_times_followed,0); 
         ! phrase 5
         ! [5: now darting shadow is off-stage]
          (Adj_9_t3_v65(O181_darting_shadow)); 
         ! phrase 6
         ! [6: say ~You lose sight of whatever it was.~]
         say__p=1;ParaContent();  print (PrintText) SC_124;  new_line; .L_Say33; .L_SayX32;
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1131, 1131, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Before listing suggested topics:
[ R_855 ;
   if ((action ==##A93_listing_suggested_topics) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_855, 855);
      ! phrase 1
      ! [1: say ~[italic type][run paragraph on]~]
      say__p=1;ParaContent();  style underline; ParaContent();  RunParagraphOn();  .L_Say34; .L_SayX33;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_855, 855, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Instead (B21_instead)
! ----------------------------------------------------------------------------------------------------
! Rule 1/132 ! Instead of going up in Roof when player does not hold courage and huge metal barrel is not placed correctly:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 2/132 ! Instead of going inside from Crumbling Concrete when pane of cracked glass is closed:
!   >>> I - Number of aspects constrained >>>
! Rule 3/132 ! Instead of examining anything in dim Staging Area:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 4/132 ! Instead of going nowhere from dim Staging Area:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 5/132 ! Instead of going to The Open Desert during Rainstorm:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 6/132 ! Instead of quizzing Sand-dancer about final choice when the number of complete plans is 0:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 7/132 ! Instead of throwing anything at circle of snarling coyotes during Fight:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 8/132 ! Instead of throwing something at a window during Sand-dancer's Arrival:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 9/132 ! Instead of pushing the not placed correctly huge metal barrel when player does not hold strength:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 10/132 ! Instead of attacking closed cage when player holds strength:
!   === which is equally specific with ===
! Rule 11/132 ! Instead of pushing the not placed correctly huge metal barrel when player holds strength:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 12/132 ! Instead of taking cans of food when player holds can opener and player holds luck and canned oranges are not handled:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 13/132 ! Instead of opening photo when the number of retrieved memories is less than 4:
!   === which is equally specific with ===
! Rule 14/132 ! Instead of taking cobwebs when player holds courage:
!   === which is equally specific with ===
! Rule 15/132 ! Instead of taking cans of food when player holds can opener:
!   === which is equally specific with ===
! Rule 16/132 ! Instead of taking cans of food when canned oranges are handled:
!   === which is equally specific with ===
! Rule 17/132 ! Instead of touching blanket when blanket is in cage:
!   === which is equally specific with ===
! Rule 18/132 ! Instead of looking under piles of trash when player holds scent:
!   === which is equally specific with ===
! Rule 19/132 ! Instead of switching off radio when current interlocutor is voice:
!   === which is equally specific with ===
! Rule 20/132 ! Instead of examining up when lookup-suggestion is familiar:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 21/132 ! Instead of switching on flashlight during Coyote's Offer:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 22/132 ! Instead of entering concrete building when location is Backtracking or location is Middle of Nowhere:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 23/132 ! Instead of touching or rubbing or attacking or pulling the cobwebs when player holds courage:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 24/132 ! Instead of going path of darting shadow when times followed of darting shadow is at least 4 and darting shadow is visible:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 25/132 ! Instead of smelling location when sage is visible:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 26/132 ! Instead of taking something enclosed by the hole when player does not hold courage:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 27/132 ! Instead of taking a not held talent when a spirit animal ( called the potential trader ) is visible:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 28/132 ! Instead of dropping something when location is The Open Desert:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 29/132 ! Instead of smoking when player holds cigarette during Coyote's Offer:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 30/132 ! Instead of going nowhere when the holder of the player is an enterable thing ( called the divan ) ( this is the no motion without purpose rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 31/132 ! Instead of going nowhere when the player is in a container ( this is the small kindnesses don't get out of containers automatically when nowhere to go rule ):
!   === which is equally specific with ===
! Rule 32/132 ! Instead of going nowhere when location is Roof:
!   >>> I - Number of aspects constrained >>>
! Rule 33/132 ! Instead of going through tiny frosted window:
!   === which is equally specific with ===
! Rule 34/132 ! Instead of going through dust-covered window:
!   >>> III.2.1 - Action/Where/Going In Exotic Ways >>>
! Rule 35/132 ! Instead of going to a room regionally in Office Interior from dim Staging Area:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 36/132 ! Instead of unlocking cage with rusted key:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 37/132 ! Instead of inserting something hefty into the wallet:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 38/132 ! Instead of inserting anything into photo:
!   === which is equally specific with ===
! Rule 39/132 ! Instead of inserting anything into the hole:
!   === which is equally specific with ===
! Rule 40/132 ! Instead of giving anything to the lizard:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 41/132 ! Instead of consulting the guidebook about ~sand-dancer/sand/dancer/lizard/lizards/brown~:
!   === which is equally specific with ===
! Rule 42/132 ! Instead of consulting the guidebook about ~hare/rabbit~:
!   === which is equally specific with ===
! Rule 43/132 ! Instead of consulting the guidebook about ~coyote~:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 44/132 ! Instead of throwing something not hefty at a closed window:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 45/132 ! Instead of throwing something ( called the missile ) at a closed window ( called the targeted window ):
!   === which is equally specific with ===
! Rule 46/132 ! Instead of throwing something at an open window ( called the broken window ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 47/132 ! Instead of giving something to a spirit animal ( called the potential trader ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 48/132 ! Instead of inserting a talent into something:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 49/132 ! Instead of attacking closed cage:
!   === which is equally specific with ===
! Rule 50/132 ! Instead of pushing the placed correctly huge metal barrel:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 51/132 ! Instead of entering or climbing the placed correctly huge metal barrel:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 52/132 ! Instead of doing anything to the bunny's bow tie:
!   === which is equally specific with ===
! Rule 53/132 ! Instead of doing anything to whiffs of evaporating gasoline:
!   === which is equally specific with ===
! Rule 54/132 ! Instead of doing anything to smell of gasoline:
!   === which is equally specific with ===
! Rule 55/132 ! Instead of doing anything to the darting shadow:
!   === which is equally specific with ===
! Rule 56/132 ! Instead of doing anything to easter basket:
!   === which is equally specific with ===
! Rule 57/132 ! Instead of doing anything to the distant figure:
!   === which is equally specific with ===
! Rule 58/132 ! Instead of doing anything to snarling shadows:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 59/132 ! Instead of saying hello to yourself:
!   === which is equally specific with ===
! Rule 60/132 ! Instead of dropping flashlight:
!   === which is equally specific with ===
! Rule 61/132 ! Instead of burning the lighter:
!   === which is equally specific with ===
! Rule 62/132 ! Instead of burning the pack of cigarettes:
!   === which is equally specific with ===
! Rule 63/132 ! Instead of taking the desert sand:
!   === which is equally specific with ===
! Rule 64/132 ! Instead of attacking pickup truck:
!   === which is equally specific with ===
! Rule 65/132 ! Instead of touching the Saguaro:
!   === which is equally specific with ===
! Rule 66/132 ! Instead of taking the Saguaro:
!   === which is equally specific with ===
! Rule 67/132 ! Instead of entering concrete building:
!   === which is equally specific with ===
! Rule 68/132 ! Instead of taking the tumbleweed:
!   === which is equally specific with ===
! Rule 69/132 ! Instead of opening desk:
!   === which is equally specific with ===
! Rule 70/132 ! Instead of entering half-collapsed desk:
!   === which is equally specific with ===
! Rule 71/132 ! Instead of taking poster:
!   === which is equally specific with ===
! Rule 72/132 ! Instead of taking cans of food:
!   === which is equally specific with ===
! Rule 73/132 ! Instead of attacking cage:
!   === which is equally specific with ===
! Rule 74/132 ! Instead of smelling Control Center:
!   === which is equally specific with ===
! Rule 75/132 ! Instead of looking under piles of trash:
!   === which is equally specific with ===
! Rule 76/132 ! Instead of opening gas can:
!   === which is equally specific with ===
! Rule 77/132 ! Instead of kissing the lizard:
!   === which is equally specific with ===
! Rule 78/132 ! Instead of attacking radio:
!   === which is equally specific with ===
! Rule 79/132 ! Instead of smelling sage:
!   === which is equally specific with ===
! Rule 80/132 ! Instead of taking cigarette:
!   === which is equally specific with ===
! Rule 81/132 ! Instead of dropping cigarette:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 82/132 ! Instead of switching on or switching off lighter:
!   === which is equally specific with ===
! Rule 83/132 ! Instead of switching on or switching off pickup truck:
!   === which is equally specific with ===
! Rule 84/132 ! Instead of climbing or entering the utility ladder:
!   === which is equally specific with ===
! Rule 85/132 ! Instead of opening or eating cans of food:
!   === which is equally specific with ===
! Rule 86/132 ! Instead of climbing or entering metal rungs:
!   === which is equally specific with ===
! Rule 87/132 ! Instead of entering or climbing the huge metal barrel:
!   === which is equally specific with ===
! Rule 88/132 ! Instead of searching or taking piles of trash:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 89/132 ! Instead of opening , entering , or attacking boarded-up door:
!   === which is equally specific with ===
! Rule 90/132 ! Instead of turning or pushing or pulling emergency radio:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 91/132 ! Instead of touching or rubbing or attacking or pulling the cobwebs:
!   === which is equally specific with ===
! Rule 92/132 ! Instead of attacking or taking or pushing or touching the lizard:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 93/132 ! Instead of searching or taking or looking under or pushing or pulling sheet of corrugated metal:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 94/132 ! Instead of attacking an open window:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 95/132 ! Instead of doing anything other than quizzing , implicit-quizzing or trading to a not held talent:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 96/132 ! Instead of doing anything to desert flotsam:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 97/132 ! Instead of dropping a talent:
!   === which is equally specific with ===
! Rule 98/132 ! Instead of attacking a window:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 99/132 ! Instead of opening or closing a window:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 100/132 ! Instead of doing anything other than brooding or trading to a memory:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 101/132 ! Instead of finishing conversation when current interlocutor is a person and can't leave conversation early is true:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 102/132 ! Instead of leaving the building when time for arrival:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 103/132 ! Instead of saying yes when yes-no-suggestion is familiar and location is The Burrow:
!   === which is equally specific with ===
! Rule 104/132 ! Instead of saying no when yes-no-suggestion is familiar and location is The Burrow:
!   === which is equally specific with ===
! Rule 105/132 ! Instead of saying yes when yes-no-suggestion is familiar and Coyote is visible:
!   === which is equally specific with ===
! Rule 106/132 ! Instead of saying no when yes-no-suggestion is familiar and Coyote is visible:
!   === which is equally specific with ===
! Rule 107/132 ! Instead of saying yes when yes-no-suggestion is familiar and Sand-dancer is visible:
!   === which is equally specific with ===
! Rule 108/132 ! Instead of saying no when yes-no-suggestion is familiar and Sand-dancer is visible:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 109/132 ! Instead of going when player holds freedom:
!   === which is equally specific with ===
! Rule 110/132 ! Instead of going when player holds honor:
!   === which is equally specific with ===
! Rule 111/132 ! Instead of going when player holds spirit:
!   === which is equally specific with ===
! Rule 112/132 ! Instead of brooding when noun suggests a memory:
!   === which is equally specific with ===
! Rule 113/132 ! Instead of jumping when location is Roof:
!   === which is equally specific with ===
! Rule 114/132 ! Instead of going when circle of snarling coyotes is visible:
!   === which is equally specific with ===
! Rule 115/132 ! Instead of hailing when Sand-dancer is visible:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 116/132 ! Instead of listening during Rainstorm:
!   === which is equally specific with ===
! Rule 117/132 ! Instead of waving hands during Temptation:
!   === which is equally specific with ===
! Rule 118/132 ! Instead of brooding during Fight:
!   === which is equally specific with ===
! Rule 119/132 ! Instead of attacking during Fight:
!   === which is equally specific with ===
! Rule 120/132 ! Instead of smoking during Coyote's Offer:
!   >>> I - Number of aspects constrained >>>
! Rule 121/132 ! Instead of smoking during a dramatic scene:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 122/132 ! Instead of doing anything other than examining when noun is emotional baggage or second noun is emotional baggage:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 123/132 ! Instead of going nowhere ( this is the small kindnesses reporting on exits rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 124/132 ! Instead of implicit-quizzing:
!   === which is equally specific with ===
! Rule 125/132 ! Instead of implicit-informing:
!   === which is equally specific with ===
! Rule 126/132 ! Instead of implicit-requesting:
!   === which is equally specific with ===
! Rule 127/132 ! Instead of implicit-imploring:
!   === which is equally specific with ===
! Rule 128/132 ! Instead of saying yes:
!   === which is equally specific with ===
! Rule 129/132 ! Instead of saying no:
!   === which is equally specific with ===
! Rule 130/132 ! Instead of hailing:
!   === which is equally specific with ===
! Rule 131/132 ! Instead of waiting:
!   === which is equally specific with ===
! Rule 132/132 ! Instead of thinking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Instead of going up in Roof when player does not hold courage and huge metal barrel is not placed correctly:
[ R_1064 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == O18_up) && (true)) && ((real_location == O89_roof) && (true)) && (self=actor,true) && ((((~~((player == HolderOf(O80_courage)))))) && (((~~(((Adj_102_t1_v65(O144_huge_metal_barrel))))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1064, 1064);
      ! phrase 1
      ! [1: say ~The metal rungs have rusted away and crumbled; the lowest are well above your head. You don't have the courage to make the jump.~]
      say__p=1;ParaContent();  print (PrintText) SC_125;  new_line; .L_Say35; .L_SayX34;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1064, 1064, true);
   rfalse;
];
! No specific request
! Instead of going inside from Crumbling Concrete when pane of cracked glass is closed:
[ R_1002 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == in_obj) && (true)) && (((MStack-->MstVON(20007,0)) == O68_crumbling_concrete) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && ((((Adj_75_t1_v65(O120_pane_of_cracked_glass)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1002, 1002);
      ! phrase 1
      ! [1: try going northeast]
       TryAction(0, player, ##Go, O11_northeast, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1002, 1002, true);
   rfalse;
];
! No specific request
! Instead of examining anything in dim Staging Area:
[ R_1036 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun ofclass K2_thing)) && ((real_location == O69_staging_area) && ((Adj_100_t1_v65(real_location))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1036, 1036);
      ! phrase 1
      ! [1: say ~You can hardly see anything in here; touch is about the only way you could navigate.~]
      say__p=1;ParaContent();  print (PrintText) SC_126;  new_line; .L_Say36; .L_SayX35;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1036, 1036, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from dim Staging Area:
[ R_1035 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == O69_staging_area) && ((Adj_100_t1_v65((MStack-->MstVON(20007,0)))))) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1035, 1035);
      ! phrase 1
      ! [1: try going north]
       TryAction(0, player, ##Go, O10_north, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1035, 1035, true);
   rfalse;
];
! No specific request
! Instead of going to The Open Desert during Rainstorm:
[ R_1124 ;
   if (scene_status-->2 == 1) { ! Runs only during scene
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == O149_open_desert) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1124, 1124);
      ! phrase 1
      ! [1: say ~That's not the best idea in a storm like this.~]
      say__p=1;ParaContent();  print (PrintText) SC_127;  new_line; .L_Say37; .L_SayX36;
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1124, 1124, true);
   rfalse;
];
! No specific request
! Instead of quizzing Sand-dancer about final choice when the number of complete plans is 0:
[ R_1217 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O210_final_choice) && (true)) && (self=actor,true) && ((( (Prop_10())  == 0)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1217, 1217);
      ! phrase 1
      ! [1: try quizzing sand-dancer about path selection]
       TryAction(0, player, ##A83_quizzing_it_about, O168_sand_dancer, O208_path_selection);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1217, 1217, true);
   rfalse;
];
! No specific request
! Instead of throwing anything at circle of snarling coyotes during Fight:
[ R_1174 ;
   if (scene_status-->7 == 1) { ! Runs only during scene
   if ((action ==##ThrowAt) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == O202_circle_of_snarling_coyo) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1174, 1174);
      ! phrase 1
      ! [1: say ~Maybe you could just attack them directly.~]
      say__p=1;ParaContent();  print (PrintText) SC_128;  new_line; .L_Say38; .L_SayX37;
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1174, 1174, true);
   rfalse;
];
! No specific request
! Instead of throwing something at a window during Sand-dancer's Arrival:
[ R_1206 ;
   if (scene_status-->9 == 1) { ! Runs only during scene
   if ((action ==##ThrowAt) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K119_window))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1206, 1206);
      ! phrase 1
      ! [1: say ~It's no good; the window shatters and sand rushes in through it.~]
      say__p=1;ParaContent();  print (PrintText) SC_129;  new_line; .L_Say39; .L_SayX38;
      ! phrase 2
      ! [2: now noun is off-stage]
       (Adj_9_t3_v65(noun)); 
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1206, 1206, true);
   rfalse;
];
! No specific request
! Instead of pushing the not placed correctly huge metal barrel when player does not hold strength:
[ R_1069 ;
   if ((action ==##Push) &&  (actor==player) && ((noun == O144_huge_metal_barrel) && (~~((Adj_102_t1_v65(noun))))) && (self=actor,true) && (((~~((player == HolderOf(O79_strength))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1069, 1069);
      ! phrase 1
      ! [1: say ~You push against the side, but you're not strong enough to move the barrel.~]
      say__p=1;ParaContent();  print (PrintText) SC_130;  new_line; .L_Say40; .L_SayX39;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1069, 1069, true);
   rfalse;
];
! No specific request
! Instead of attacking closed cage when player holds strength:
[ R_1055 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == O140_wire_mesh_cage) && ((Adj_75_t1_v65(noun)))) && (self=actor,true) && (((player == HolderOf(O79_strength))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1055, 1055);
      ! phrase 1
      ! [1: say ~You grip the mesh in one hand and pull, and realize it's so rusted you can easily peel it back. The door rips free and you drop it to the floor.~]
      say__p=1;ParaContent();  print (PrintText) SC_131;  new_line; .L_Say41; .L_SayX40;
      ! phrase 2
      ! [2: now cage is open]
       (Adj_74_t2_v65(O140_wire_mesh_cage)); 
      ! phrase 3
      ! [3: now cage is unopenable]
       (Adj_77_t2_v65(O140_wire_mesh_cage)); 
      ! phrase 4
      ! [4: now cage is not lockable]
       (Adj_78_t3_v65(O140_wire_mesh_cage)); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1055, 1055, true);
   rfalse;
];
! No specific request
! Instead of pushing the not placed correctly huge metal barrel when player holds strength:
[ R_1070 ;
   if ((action ==##Push) &&  (actor==player) && ((noun == O144_huge_metal_barrel) && (~~((Adj_102_t1_v65(noun))))) && (self=actor,true) && (((player == HolderOf(O79_strength))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1070, 1070);
      ! phrase 1
      ! [1: now huge metal barrel is placed correctly]
       (Adj_102_t2_v65(O144_huge_metal_barrel)); 
      ! phrase 2
      ! [2: say ~Heaving, you push against the barrel, and with a horrible grating noise, it slides across the roof till it rests underneath the metal rungs.~]
      say__p=1;ParaContent();  print (PrintText) SC_132;  new_line; .L_Say42; .L_SayX41;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1070, 1070, true);
   rfalse;
];
! No specific request
! Instead of taking cans of food when player holds can opener and player holds luck and canned oranges are not handled:
[ R_1052 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O137_cans_of_food) && (true)) && (self=actor,true) && ((((player == HolderOf(O145_can_opener)))) && ((((player == HolderOf(O81_luck)))) && (((~~(((Adj_64_t1_v65(O75_canned_oranges)))))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1052, 1052);
      ! phrase 1
      ! [1: say ~You run your fingers along the cans, waiting until one feels right. There's nothing, nothing, but then... yeah. That's the one. You snag it down, twist it open, and boom: mandarin oranges, unspoiled and delicious. You scarf them down, picking them out segment by segment with your chilly fingers. By the time you've polished them off you're a lot less hungry. You grab the next can down for later.~]
      say__p=1;ParaContent();  print (PrintText) SC_133;  new_line; .L_Say43; .L_SayX42;
      ! phrase 2
      ! [2: move canned oranges to player]
       MoveObject(O75_canned_oranges, player, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1052, 1052, true);
   rfalse;
];
! No specific request
! Instead of opening photo when the number of retrieved memories is less than 4:
[ R_982 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == O86_photo) && (true)) && (self=actor,true) && ((( (Prop_11())  < 4)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_982, 982);
      ! phrase 1
      ! [1: try examining photo]
       TryAction(0, player, ##Examine, O86_photo, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_982, 982, true);
   rfalse;
];
! No specific request
! Instead of taking cobwebs when player holds courage:
[ R_1032 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O125_cobwebs) && (true)) && (self=actor,true) && (((player == HolderOf(O80_courage))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1032, 1032);
      ! phrase 1
      ! [1: say ~You impatiently brush the cobwebs away.~]
      say__p=1;ParaContent();  print (PrintText) SC_134;  new_line; .L_Say44; .L_SayX43;
      ! phrase 2
      ! [2: now cobwebs are off-stage]
       (Adj_9_t3_v65(O125_cobwebs)); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1032, 1032, true);
   rfalse;
];
! No specific request
! Instead of taking cans of food when player holds can opener:
[ R_1051 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O137_cans_of_food) && (true)) && (self=actor,true) && (((player == HolderOf(O145_can_opener))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1051, 1051);
      ! phrase 1
      ! [1: say ~You pull down a can from the shelf, grip it with the rusty can opener, and peel open the lid. Yuck: [one of]moldy peas[or]rotten condensed milk[or]black and mold-covered mushrooms[or]something nasty-smelling and green[as decreasingly likely outcomes]. [one of]Just your luck.[or]Not your lucky day.[or]Some of these should still be good, right?[as decreasingly likely outcomes]~]
      say__p=1;ParaContent();  print (PrintText) SC_135; ParaContent();  I7_ST_say_one_of-->5 =
	i7_soo_tap(I7_ST_say_one_of-->5, 4);
	switch((I7_ST_say_one_of-->5)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_136; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_137; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_138; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_139; ParaContent();  } ParaContent();  print (PrintText) SC_140; ParaContent();  I7_ST_say_one_of-->6 =
	i7_soo_tap(I7_ST_say_one_of-->6, 3);
	switch((I7_ST_say_one_of-->6)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_141;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_142;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_143;  new_line;ParaContent();  }  .L_Say45; .L_SayX44;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1051, 1051, true);
   rfalse;
];
! No specific request
! Instead of taking cans of food when canned oranges are handled:
[ R_1053 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O137_cans_of_food) && (true)) && (self=actor,true) && ((((Adj_64_t1_v65(O75_canned_oranges)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1053, 1053);
      ! phrase 1
      ! [1: say ~You won't be hungry again till morning.~]
      say__p=1;ParaContent();  print (PrintText) SC_144;  new_line; .L_Say46; .L_SayX45;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1053, 1053, true);
   rfalse;
];
! No specific request
! Instead of touching blanket when blanket is in cage:
[ R_1058 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == O74_emergency_blanket) && (true)) && (self=actor,true) && (((O140_wire_mesh_cage == ContainerOf(O74_emergency_blanket))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1058, 1058);
      ! phrase 1
      ! [1: say ~You can touch the warm wool through the mesh, but you can't get it out.~]
      say__p=1;ParaContent();  print (PrintText) SC_145;  new_line; .L_Say47; .L_SayX46;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1058, 1058, true);
   rfalse;
];
! No specific request
! Instead of looking under piles of trash when player holds scent:
[ R_1078 ;
   if ((action ==##LookUnder) &&  (actor==player) && ((noun == O146_piles_of_trash) && (true)) && (self=actor,true) && (((player == HolderOf(O82_scent))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1078, 1078);
      ! phrase 1
      ! [1: say ~Your sense of smell leads you straight to a [sheet of corrugated metal]. You lift it [if player holds strength]effortlessly [end if]and throw it aside, revealing a gas can.~]
      say__p=1;ParaContent();  print (PrintText) SC_146; ParaContent();  print (PrintShortName) O148_sheet_of_corrugated_met; ParaContent();  print (PrintText) SC_147; 
	if (~~((((player == HolderOf(O79_strength)))))) jump L_Say48;
		ParaContent();  print (PrintText) SC_148; 
	.L_Say48; .L_SayX47;
		ParaContent();  print (PrintText) SC_149;  new_line; .L_Say49; .L_SayX48;
      ! phrase 2
      ! [2: move gas can to location]
       MoveObject(O60_gas_can, real_location, 0, false); 
      ! phrase 3
      ! [3: now smell of gasoline is off-stage]
       (Adj_9_t3_v65(O147_smell_of_gasoline)); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1078, 1078, true);
   rfalse;
];
! No specific request
! Instead of switching off radio when current interlocutor is voice:
[ R_1096 ;
   if ((action ==##SwitchOff) &&  (actor==player) && ((noun == O118_emergency_radio) && (true)) && (self=actor,true) && ((((Global_Vars-->9) == O172_voice)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1096, 1096);
      ! phrase 1
      ! [1: say ~You reach for the switch, but hesitate, hand hovering above it as the static whirls and roars.[paragraph break][voice explains choices]?~]
      say__p=1;ParaContent();  print (PrintText) SC_150; ParaContent();  DivideParagraphPoint(); new_line; ParaContent(); (PHR_1097_r15 ());ParaContent();  print (PrintText) SC_151;  new_line; .L_Say50; .L_SayX49;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1096, 1096, true);
   rfalse;
];
! No specific request
! Instead of examining up when lookup-suggestion is familiar:
[ R_1157 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == O18_up) && (true)) && (self=actor,true) && ((((Adj_90_t1_v65(O199_lookup_suggestion)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1157, 1157);
      ! phrase 1
      ! [1: say ~Stupidly, you tilt your head back and stare up at the dirt ceiling, and all you can see is blackness.[paragraph break]No wait... there's patterns, slowly shifting, barely visible in the darkness, and miles away. Like clouds. And then a drop of water falls on your face, and then another, and you realize suddenly you're outside, and it's starting to rain...~]
      say__p=1;ParaContent();  print (PrintText) SC_152; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_153;  new_line; .L_Say51; .L_SayX50;
      ! phrase 2
      ! [2: move player to backtracking]
       MoveObject(player, O67_backtracking, 0, false); 
      ! phrase 3
      ! [3: now lookup-suggestion is unfamiliar]
       (Adj_91_t2_v65(O199_lookup_suggestion)); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1157, 1157, true);
   rfalse;
];
! No specific request
! Instead of switching on flashlight during Coyote's Offer:
[ R_1180 ;
   if (scene_status-->8 == 1) { ! Runs only during scene
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == O71_flashlight) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1180, 1180);
      ! phrase 1
      ! [1: say ~You think you'd rather keep him on your side.~]
      say__p=1;ParaContent();  print (PrintText) SC_154;  new_line; .L_Say52; .L_SayX51;
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1180, 1180, true);
   rfalse;
];
! No specific request
! Instead of entering concrete building when location is Backtracking or location is Middle of Nowhere:
[ R_1000 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == O93_concrete_building) && (true)) && (self=actor,true) && ((((real_location == O67_backtracking))) || (((real_location == O66_middle_of_nowhere))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1000, 1000);
      ! phrase 1
      ! [1: say ~You aren't close enough to the building.~]
      say__p=1;ParaContent();  print (PrintText) SC_155;  new_line; .L_Say53; .L_SayX52;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1000, 1000, true);
   rfalse;
];
! No specific request
! Instead of touching or rubbing or attacking or pulling the cobwebs when player holds courage:
[ R_1028 ;
   if ((action ==##Pull or ##Attack or ##Rub or ##Touch) &&  (actor==player) && ((noun == O125_cobwebs) && (true)) && (self=actor,true) && (((player == HolderOf(O80_courage))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1028, 1028);
      ! phrase 1
      ! [1: try taking cobwebs]
       TryAction(0, player, ##Take, O125_cobwebs, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1028, 1028, true);
   rfalse;
];
! No specific request
! Instead of going path of darting shadow when times followed of darting shadow is at least 4 and darting shadow is visible:
[ R_1133 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == GProperty(OBJECT_TY, O181_darting_shadow,p22_path)) && (true)) && (self=actor,true) && ((((GProperty(OBJECT_TY, O181_darting_shadow,p23_times_followed) >= 4))) && ((((Adj_3_t1_v65(O181_darting_shadow))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1133, 1133);
      ! phrase 1
      ! [1: say ~Dodging after the fleeing, skittering shadow, you're almost caught up to it when your foot trips on a rock and you stumble to the ground. But the ground doesn't stop your fall, it collapses, and you're tumbling in a shower of dirt clods down a hole, rolling down some crazy underground tunnel clutching at mud and roots, till finally you slide into some damp, fetid place, and come up a stop against something soft, huge, warm. And furry.~]
      say__p=1;ParaContent();  print (PrintText) SC_156;  new_line; .L_Say54; .L_SayX53;
      ! phrase 2
      ! [2: now player is in burrow]
       MoveObject(player,O182_burrow); 
      ! phrase 3
      ! [3: now darting shadow is off-stage]
       (Adj_9_t3_v65(O181_darting_shadow)); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1133, 1133, true);
   rfalse;
];
! No specific request
! Instead of smelling location when sage is visible:
[ R_1122 ;
   if ((action ==##Smell) &&  (actor==player) && ((noun == real_location) && (true)) && (self=actor,true) && ((((Adj_3_t1_v65(O64_sage)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1122, 1122);
      ! phrase 1
      ! [1: try smelling sage]
       TryAction(0, player, ##Smell, O64_sage, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1122, 1122, true);
   rfalse;
];
! No specific request
! Instead of taking something enclosed by the hole when player does not hold courage:
[ R_1030 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (IndirectlyContains(O124_hole_in_the_floor,noun))) && (self=actor,true) && (((~~((player == HolderOf(O80_courage))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1030, 1030);
      ! phrase 1
      ! [1: say ~[one of]You reach your hand towards the hole, then pull back with a start as you brush cobwebs. Nightmare visions of fat black spiders shudder through your brain. No way are you reaching in there.[or]Yeah, sorry, but you're not putting your hand in there.[stopping]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->7 =
	i7_soo_stop(I7_ST_say_one_of-->7, 2);
	switch((I7_ST_say_one_of-->7)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_157;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_158;  new_line;ParaContent();  }  .L_Say55; .L_SayX54;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1030, 1030, true);
   rfalse;
];
! No specific request
! Instead of taking a not held talent when a spirit animal ( called the potential trader ) is visible:
[ R_1108 
    t_0 ! Local variable e.g. 'potential trader' = object
    ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K78_talent) && (~~((Adj_2_t1_v65(noun))))) && (self=actor,true) && ((Prop_12() && (t_0=deferred_calling_list-->0, true)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1108, 1108);
      ! phrase 1
      ! [1: say ~'You can't just have it,' [the potential trader] says. 'That's not how it works. You have to TRADE something for it.'~]
      say__p=1;ParaContent();  print (PrintText) SC_159; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_160;  new_line; .L_Say56; .L_SayX55;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1108, 1108, true);
   rfalse;
];
! No specific request
! Instead of dropping something when location is The Open Desert:
[ R_1086 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((real_location == O149_open_desert)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1086, 1086);
      ! phrase 1
      ! [1: say ~Sounds like a good way to lose something forever.~]
      say__p=1;ParaContent();  print (PrintText) SC_161;  new_line; .L_Say57; .L_SayX56;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1086, 1086, true);
   rfalse;
];
! No specific request
! Instead of smoking when player holds cigarette during Coyote's Offer:
[ R_1183 ;
   if (scene_status-->8 == 1) { ! Runs only during scene
   if ((action ==##A98_smoking) &&  (actor==player) && (self=actor,true) && (((player == HolderOf(O177_cigarette))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1183, 1183);
      ! phrase 1
      ! [1: say ~You take a drag, thoughts and adrenaline whirring through your head.~]
      say__p=1;ParaContent();  print (PrintText) SC_162;  new_line; .L_Say58; .L_SayX57;
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1183, 1183, true);
   rfalse;
];
! No specific request
! From "Modified Exit" by Emily Short
! Instead of going nowhere when the holder of the player is an enterable thing ( called the divan ) ( this is the no motion without purpose rule ):
[ R_861 
    t_0 ! Local variable e.g. 'divan' = object
    ;
   if ((action ==##Go) &&  (actor==player) && ((MStack-->MstVON(20007,1)) == nothing) && (self=actor,true) && ((( (HolderOf(player))  ofclass K2_thing) && (t_0=( (HolderOf(player)) ), true) && ((Adj_71_t1_v65( (HolderOf(player)) )))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_861, 861);
      ! phrase 1
      ! [1: if the noun is outside , try exiting instead]
       if (((noun == out_obj))) {  TryAction(0, player, ##Exit, 0, 0);;   rtrue; }
      ! phrase 2
      ! [2: say ~You couldn't go that way even if you weren't [if the divan is a supporter]on[otherwise]in[end if] [the divan].~]
      say__p=1;ParaContent();  print (PrintText) SC_163; 
	if (~~((((t_0 ofclass K6_supporter))))) jump L_Say59;
		ParaContent();  print (PrintText) SC_164; 
	jump L_SayX58; .L_Say59;
		ParaContent();  print (PrintText) SC_165; 
	.L_Say60; .L_SayX58;
		ParaContent();  print (PrintText) SC_166; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_77;  new_line; .L_Say61; .L_SayX59;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_861, 861, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Instead of going nowhere when the player is in a container ( this is the small kindnesses don't get out of containers automatically when nowhere to go rule ):
[ R_873 ;
   if ((action ==##Go) &&  (actor==player) && ((MStack-->MstVON(20007,1)) == nothing) && (self=actor,true) && (((ContainerOf(player) ofclass K5_container)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_873, 873);
      ! phrase 1
      ! [1: say ~You can't go that way.~]
      say__p=1;ParaContent();  print (PrintText) SC_167;  new_line; .L_Say62; .L_SayX60;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_873, 873, true);
   rfalse;
];
! No specific request
! Instead of going nowhere when location is Roof:
[ R_1063 ;
   if ((action ==##Go) &&  (actor==player) && ((MStack-->MstVON(20007,1)) == nothing) && (self=actor,true) && (((real_location == O89_roof)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1063, 1063);
      ! phrase 1
      ! [1: say ~It's a drop off on all sides.~]
      say__p=1;ParaContent();  print (PrintText) SC_168;  new_line; .L_Say63; .L_SayX61;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1063, 1063, true);
   rfalse;
];
! No specific request
! Instead of going through tiny frosted window:
[ R_1026 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,2)) == O141_tiny_frosted_window) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1026, 1026);
      ! phrase 1
      ! [1: say ~It's too small for you to wriggle through.~]
      say__p=1;ParaContent();  print (PrintText) SC_169;  new_line; .L_Say64; .L_SayX62;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1026, 1026, true);
   rfalse;
];
! No specific request
! Instead of going through dust-covered window:
[ R_1027 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,2)) == O128_dust_covered_window) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1027, 1027);
      ! phrase 1
      ! [1: say ~It's too high up for you to pull yourself through.~]
      say__p=1;ParaContent();  print (PrintText) SC_170;  new_line; .L_Say65; .L_SayX63;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1027, 1027, true);
   rfalse;
];
! No specific request
! Instead of going to a room regionally in Office Interior from dim Staging Area:
[ R_1034 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == O69_staging_area) && ((Adj_100_t1_v65((MStack-->MstVON(20007,0)))))) && (((MStack-->MstVON(20007,1)) ofclass K1_room) && (TestRegionalContainment((MStack-->MstVON(20007,1)),O112_office_interior)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1034, 1034);
      ! phrase 1
      ! [1: say ~You take a step and crack your shin against what feels like a metal desk. Ouch.~]
      say__p=1;ParaContent();  print (PrintText) SC_171;  new_line; .L_Say66; .L_SayX64;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1034, 1034, true);
   rfalse;
];
! No specific request
! Instead of unlocking cage with rusted key:
[ R_1054 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == O140_wire_mesh_cage) && (true)) && ((second == O54_rusted_key) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1054, 1054);
      ! phrase 1
      ! [1: say ~You sling the key into the lock, but as you turn it, the rusted metal snaps off inside. The crumbling fragments fall to the ground as you slam your fist against the wire mesh in frustration. This is not your day.~]
      say__p=1;ParaContent();  print (PrintText) SC_172;  new_line; .L_Say67; .L_SayX65;
      ! phrase 2
      ! [2: now rusted key is off-stage]
       (Adj_9_t3_v65(O54_rusted_key)); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1054, 1054, true);
   rfalse;
];
! No specific request
! Instead of inserting something hefty into the wallet:
[ R_1020 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_99_t1_v65(noun)))) && ((second == O48_wallet) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1020, 1020);
      ! phrase 1
      ! [1: say ~Not gonna fit.~]
      say__p=1;ParaContent();  print (PrintText) SC_173;  new_line; .L_Say68; .L_SayX66;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1020, 1020, true);
   rfalse;
];
! No specific request
! Instead of inserting anything into photo:
[ R_984 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == O86_photo) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_984, 984);
      ! phrase 1
      ! [1: say ~Just a photo.~]
      say__p=1;ParaContent();  print (PrintText) SC_99;  new_line; .L_Say69; .L_SayX67;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_984, 984, true);
   rfalse;
];
! No specific request
! Instead of inserting anything into the hole:
[ R_1033 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == O124_hole_in_the_floor) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1033, 1033);
      ! phrase 1
      ! [1: say ~Sounds like a good way to lose something forever.~]
      say__p=1;ParaContent();  print (PrintText) SC_161;  new_line; .L_Say70; .L_SayX68;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1033, 1033, true);
   rfalse;
];
! No specific request
! Instead of giving anything to the lizard:
[ R_1087 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == O171_brown_lizard) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1087, 1087);
      ! phrase 1
      ! [1: say ~You dangle [the noun] in front of it, but it just flicks its tongue in and out a little faster, staying put.~]
      say__p=1;ParaContent();  print (PrintText) SC_174; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_175;  new_line; .L_Say71; .L_SayX69;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1087, 1087, true);
   rfalse;
];
! No specific request
! Instead of consulting the guidebook about ~sand-dancer/sand/dancer/lizard/lizards/brown~:
[ R_1004 ;
   if ((action ==##Consult) &&  (actor==player) && ((noun == O47_weather_worn_guidebook) && (true)) && (Consult_Grammar_172(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1004, 1004);
      ! phrase 1
      ! [1: say ~You look up the brown-colored lizard in the guidebook and quickly identify it: those eyes are a dead giveaway. The entry says it's a 'rare subspecies of the common desert lizard found only in the deep desert near Oro Oeste, and known to native peoples as a [italic type]sand-dancer[roman type]. In legends, the sand-dancer was a clever trickster and twister of words, who created night by tricking the sun into spending half the day underground.' Huh.~]
      say__p=1;ParaContent();  print (PrintText) SC_176; ParaContent();  style underline; ParaContent();  print (PrintText) SC_177; ParaContent();  style roman; ParaContent();  print (PrintText) SC_178;  new_line; .L_Say72; .L_SayX70;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1004, 1004, true);
   rfalse;
];
! No specific request
! Instead of consulting the guidebook about ~hare/rabbit~:
[ R_1005 ;
   if ((action ==##Consult) &&  (actor==player) && ((noun == O47_weather_worn_guidebook) && (true)) && (Consult_Grammar_173(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1005, 1005);
      ! phrase 1
      ! [1: say ~You look up the hare in the guidebook. 'Common desert rabbit,' it says, 'frequently mistaken for a hare. Lives in underground burrows which it uses to keep warm through chill desert nights. Trusted by native peoples as a guide and symbol of rebirth.'~]
      say__p=1;ParaContent();  print (PrintText) SC_179;  new_line; .L_Say73; .L_SayX71;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1005, 1005, true);
   rfalse;
];
! No specific request
! Instead of consulting the guidebook about ~coyote~:
[ R_1006 ;
   if ((action ==##Consult) &&  (actor==player) && ((noun == O47_weather_worn_guidebook) && (true)) && (Consult_Grammar_174(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1006, 1006);
      ! phrase 1
      ! [1: say ~Weird, it looks like somebody's ripped out the page.~]
      say__p=1;ParaContent();  print (PrintText) SC_180;  new_line; .L_Say74; .L_SayX72;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1006, 1006, true);
   rfalse;
];
! No specific request
! Instead of throwing something not hefty at a closed window:
[ R_1019 ;
   if ((action ==##ThrowAt) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((Adj_99_t1_v65(noun))))) && ((second ofclass K119_window) && ((Adj_75_t1_v65(second))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1019, 1019);
      ! phrase 1
      ! [1: say ~Like that's going to break anything.~]
      say__p=1;ParaContent();  print (PrintText) SC_181;  new_line; .L_Say75; .L_SayX73;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1019, 1019, true);
   rfalse;
];
! No specific request
! Instead of throwing something ( called the missile ) at a closed window ( called the targeted window ):
[ R_1021 
    t_0 ! Local variable e.g. 'missile' = object
    t_1 ! Local variable e.g. 'targeted window' = object
    ;
   if ((action ==##ThrowAt) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing)))) && (t_1 = second, (((t_1=(second), true) && (second ofclass K119_window) && ((Adj_75_t1_v65(second))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1021, 1021);
      ! phrase 1
      ! [1: now missile is in the other side of the targeted window]
       MoveObject(t_0,GProperty(OBJECT_TY, t_1,door_to)); 
      ! phrase 2
      ! [2: if other side of targeted window is staging area begin]
       if (((GProperty(OBJECT_TY, t_1,door_to) == O69_staging_area)))  {
         ! phrase 3
         ! [3: now missile is undescribed]
          (Adj_66_t2_v65(t_0)); 
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: now the targeted window is open]
       (Adj_74_t2_v65(t_1)); 
      ! phrase 6
      ! [6: say ~[The missile] smashes through [the targeted window], shattering it.~]
      say__p=1;ParaContent();  print (The) t_0; ParaContent();  print (PrintText) SC_182; ParaContent();  print (the) t_1; ParaContent();  print (PrintText) SC_183;  new_line; .L_Say76; .L_SayX74;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1021, 1021, true);
   rfalse;
];
! No specific request
! Instead of throwing something at an open window ( called the broken window ):
[ R_1022 
    t_0 ! Local variable e.g. 'broken window' = object
    ;
   if ((action ==##ThrowAt) &&  (actor==player) && ((noun ofclass K2_thing)) && (t_0 = second, (((t_0=(second), true) && (second ofclass K119_window) && ((Adj_74_t1_v65(second))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1022, 1022);
      ! phrase 1
      ! [1: say ~[The broken window] is already broken.~]
      say__p=1;ParaContent();  print (The) t_0; ParaContent();  print (PrintText) SC_184;  new_line; .L_Say77; .L_SayX75;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1022, 1022, true);
   rfalse;
];
! No specific request
! Instead of giving something to a spirit animal ( called the potential trader ):
[ R_1109 
    t_0 ! Local variable e.g. 'potential trader' = object
    ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && (t_0 = second, (((t_0=(second), true) && (second ofclass K165_spirit_animal))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1109, 1109);
      ! phrase 1
      ! [1: say ~'No, not like that,' [the potential trader] says. 'You have to TRADE it for something.'~]
      say__p=1;ParaContent();  print (PrintText) SC_185; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_186;  new_line; .L_Say78; .L_SayX76;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1109, 1109, true);
   rfalse;
];
! No specific request
! Instead of inserting a talent into something:
[ R_964 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K78_talent)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_964, 964);
      ! phrase 1
      ! [1: try dropping noun]
       TryAction(0, player, ##Drop, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_964, 964, true);
   rfalse;
];
! No specific request
! Instead of attacking closed cage:
[ R_1056 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == O140_wire_mesh_cage) && ((Adj_75_t1_v65(noun))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1056, 1056);
      ! phrase 1
      ! [1: say ~You try to get a grip on the mesh to rip it open, but you're just not strong enough.~]
      say__p=1;ParaContent();  print (PrintText) SC_187;  new_line; .L_Say79; .L_SayX77;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1056, 1056, true);
   rfalse;
];
! No specific request
! Instead of pushing the placed correctly huge metal barrel:
[ R_1072 ;
   if ((action ==##Push) &&  (actor==player) && ((noun == O144_huge_metal_barrel) && ((Adj_102_t1_v65(noun))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1072, 1072);
      ! phrase 1
      ! [1: say ~Push it any more and it'll fall off the roof. Keep it here and you can get to the rungs.~]
      say__p=1;ParaContent();  print (PrintText) SC_188;  new_line; .L_Say80; .L_SayX78;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1072, 1072, true);
   rfalse;
];
! No specific request
! Instead of entering or climbing the placed correctly huge metal barrel:
[ R_1067 ;
   if ((action ==##Climb or ##Enter) &&  (actor==player) && ((noun == O144_huge_metal_barrel) && ((Adj_102_t1_v65(noun))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1067, 1067);
      ! phrase 1
      ! [1: try going up]
       TryAction(0, player, ##Go, O18_up, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1067, 1067, true);
   rfalse;
];
! No specific request
! Instead of doing anything to the bunny's bow tie:
[ R_938 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == O56_bunny_s_bow_tie) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_938, 938);
      ! phrase 1
      ! [1: say ~It's just a few lines on a silhouette.~]
      say__p=1;ParaContent();  print (PrintText) SC_189;  new_line; .L_Say81; .L_SayX79;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_938, 938, true);
   rfalse;
];
! No specific request
! Instead of doing anything to whiffs of evaporating gasoline:
[ R_995 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == O97_whiffs_of_evaporating_ga) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_995, 995);
      ! phrase 1
      ! [1: say ~Fading away in the chill night air, but enough to tell you something on your truck's busted bad.~]
      say__p=1;ParaContent();  print (PrintText) SC_190;  new_line; .L_Say82; .L_SayX80;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_995, 995, true);
   rfalse;
];
! No specific request
! Instead of doing anything to smell of gasoline:
[ R_1073 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == O147_smell_of_gasoline) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1073, 1073);
      ! phrase 1
      ! [1: say ~[if player holds scent]It's coming from beneath that [sheet of corrugated metal][else]You can't tell where the smell is coming from[end if].~]
      say__p=1;
	if (~~((((player == HolderOf(O82_scent)))))) jump L_Say83;
		ParaContent();  print (PrintText) SC_191; ParaContent();  print (PrintShortName) O148_sheet_of_corrugated_met; 
	jump L_SayX81; .L_Say83;
		ParaContent();  print (PrintText) SC_192; 
	.L_Say84; .L_SayX81;
		ParaContent();  print (PrintText) SC_77;  new_line; .L_Say85; .L_SayX82;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1073, 1073, true);
   rfalse;
];
! No specific request
! Instead of doing anything to the darting shadow:
[ R_1128 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == O181_darting_shadow) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1128, 1128);
      ! phrase 1
      ! [1: say ~Hey, you're not even sure you saw it.~]
      say__p=1;ParaContent();  print (PrintText) SC_193;  new_line; .L_Say86; .L_SayX83;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1128, 1128, true);
   rfalse;
];
! No specific request
! Instead of doing anything to easter basket:
[ R_1149 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == O192_easter_basket_filled_wi) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1149, 1149);
      ! phrase 1
      ! [1: say ~You aren't sure you believe in it enough for that.~]
      say__p=1;ParaContent();  print (PrintText) SC_194;  new_line; .L_Say87; .L_SayX84;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1149, 1149, true);
   rfalse;
];
! No specific request
! Instead of doing anything to the distant figure:
[ R_1159 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == O200_distant_figure) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1159, 1159);
      ! phrase 1
      ! [1: say ~He's too far away. You can barely see him.~]
      say__p=1;ParaContent();  print (PrintText) SC_195;  new_line; .L_Say88; .L_SayX85;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1159, 1159, true);
   rfalse;
];
! No specific request
! Instead of doing anything to snarling shadows:
[ R_1167 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == O201_snarling_shadows) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1167, 1167);
      ! phrase 1
      ! [1: say ~All you can do is run.~]
      say__p=1;ParaContent();  print (PrintText) SC_196;  new_line; .L_Say89; .L_SayX86;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1167, 1167, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Instead of saying hello to yourself:
[ R_857 ;
   if ((action ==##A89_saying_hello_to) &&  (actor==player) && ((noun == selfobj) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_857, 857);
      ! phrase 1
      ! [1: say ~You know you're crazy when you start talking to yourself.~]
      say__p=1;ParaContent();  print (PrintText) SC_197;  new_line; .L_Say90; .L_SayX87;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_857, 857, true);
   rfalse;
];
! No specific request
! Instead of dropping flashlight:
[ R_946 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun == O71_flashlight) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_946, 946);
      ! phrase 1
      ! [1: say ~Better keep it with you. It's hella dark out.~]
      say__p=1;ParaContent();  print (PrintText) SC_198;  new_line; .L_Say91; .L_SayX88;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_946, 946, true);
   rfalse;
];
! No specific request
! Instead of burning the lighter:
[ R_947 ;
   if ((action ==##Burn) &&  (actor==player) && ((noun == O38_lighter) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_947, 947);
      ! phrase 1
      ! [1: if it's effectively dark , say ~You flick the lighter, but the light seems grey and tiny in the face of the dark. All you can really see is[if location is Staging Area] [a desk] by your feet, and[end if][if there is at least one brighter direction] a slightly brighter place to [the list of brighter directions][otherwise] your shivering hand[end if]. As your thumb starts to burn you let the puny light go out.~]
       if (((PHR_948_r16 ()))) { say__p=1;ParaContent();  print (PrintText) SC_199; 
	if (~~((((real_location == O69_staging_area))))) jump L_Say92;
		ParaContent();  print (PrintText) SC_166; ParaContent();  print (a) O126_metal_desk; ParaContent();  print (PrintText) SC_200; 
	.L_Say92; .L_SayX89;
		
	if (~~(((Prop_13())))) jump L_Say93;
		ParaContent();  print (PrintText) SC_201; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K3_direction) && ((Adj_40_t1_v65(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+DEFART_BIT);
		@pull subst__v; 
	jump L_SayX90; .L_Say93;
		ParaContent();  print (PrintText) SC_202; 
	.L_Say94; .L_SayX90;
		ParaContent();  print (PrintText) SC_203;  new_line; .L_Say95; .L_SayX91;  }
      ! phrase 2
      ! [2: otherwise say ~You flick it open and shut a few times, an old habit.~]
       else { say__p=1;ParaContent();  print (PrintText) SC_204;  new_line; .L_Say96; .L_SayX92;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_947, 947, true);
   rfalse;
];
! No specific request
! Instead of burning the pack of cigarettes:
[ R_966 ;
   if ((action ==##Burn) &&  (actor==player) && ((noun == O39_pack_of_cigarettes) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_966, 966);
      ! phrase 1
      ! [1: try smoking the pack of cigarettes]
       TryAction(0, player, ##A98_smoking, O39_pack_of_cigarettes, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_966, 966, true);
   rfalse;
];
! No specific request
! Instead of taking the desert sand:
[ R_985 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O91_desert_sand) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_985, 985);
      ! phrase 1
      ! [1: say ~[if Rainstorm is happening]More like mud right now.[otherwise]You kneel down and let some run through your fingers, vague memories of better times slipping through your fingers. But the ground is freezing and you get back to your feet.~]
      say__p=1;
	if (~~(((((scene_status-->(Q340_rainstorm-1)==1)))))) jump L_Say97;
		ParaContent();  print (PrintText) SC_205;  new_line;
	jump L_SayX93; .L_Say97;
		ParaContent();  print (PrintText) SC_206;  new_line; .L_Say98; .L_SayX93;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_985, 985, true);
   rfalse;
];
! No specific request
! Instead of attacking pickup truck:
[ R_987 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == O42_pickup_truck) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_987, 987);
      ! phrase 1
      ! [1: say ~You smack [if player is in truck]the wheel[otherwise]the hood[end if] in exasperation. How did you get into this mess?~]
      say__p=1;ParaContent();  print (PrintText) SC_207; 
	if (~~((((O42_pickup_truck == ContainerOf(player)))))) jump L_Say99;
		ParaContent();  print (PrintText) SC_208; 
	jump L_SayX94; .L_Say99;
		ParaContent();  print (PrintText) SC_209; 
	.L_Say100; .L_SayX94;
		ParaContent();  print (PrintText) SC_210;  new_line; .L_Say101; .L_SayX95;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_987, 987, true);
   rfalse;
];
! No specific request
! Instead of touching the Saguaro:
[ R_996 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == O98_tall_saguaro) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_996, 996);
      ! phrase 1
      ! [1: say ~Yeah, you did that once as a kid, on accident. Not happening again.~]
      say__p=1;ParaContent();  print (PrintText) SC_211;  new_line; .L_Say102; .L_SayX96;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_996, 996, true);
   rfalse;
];
! No specific request
! Instead of taking the Saguaro:
[ R_997 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O98_tall_saguaro) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_997, 997);
      ! phrase 1
      ! [1: try touching the saguaro]
       TryAction(0, player, ##Touch, O98_tall_saguaro, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_997, 997, true);
   rfalse;
];
! No specific request
! Instead of entering concrete building:
[ R_1001 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == O93_concrete_building) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1001, 1001);
      ! phrase 1
      ! [1: try going inside]
       TryAction(0, player, ##Go, in_obj, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1001, 1001, true);
   rfalse;
];
! No specific request
! Instead of taking the tumbleweed:
[ R_1003 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O103_tumbleweed) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1003, 1003);
      ! phrase 1
      ! [1: say ~Let it blow on. Wherever it's going is bound to be better than here.~]
      say__p=1;ParaContent();  print (PrintText) SC_212;  new_line; .L_Say103; .L_SayX97;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1003, 1003, true);
   rfalse;
];
! No specific request
! Instead of opening desk:
[ R_1039 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == O126_metal_desk) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1039, 1039);
      ! phrase 1
      ! [1: try opening drawer]
       TryAction(0, player, ##Open, O127_drawer, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1039, 1039, true);
   rfalse;
];
! No specific request
! Instead of entering half-collapsed desk:
[ R_1043 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == O129_half_collapsed_desk) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1043, 1043);
      ! phrase 1
      ! [1: say ~It's already on its last legs.~]
      say__p=1;ParaContent();  print (PrintText) SC_213;  new_line; .L_Say104; .L_SayX98;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1043, 1043, true);
   rfalse;
];
! No specific request
! Instead of taking poster:
[ R_1044 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O130_faded_safety_poster) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1044, 1044);
      ! phrase 1
      ! [1: say ~It would disintegrate if you tried to remove it from the wall.~]
      say__p=1;ParaContent();  print (PrintText) SC_214;  new_line; .L_Say105; .L_SayX99;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1044, 1044, true);
   rfalse;
];
! No specific request
! Instead of taking cans of food:
[ R_1049 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O137_cans_of_food) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1049, 1049);
      ! phrase 1
      ! [1: say ~You grab one and turn it over and over in your hand, but water has soaked and crumbled away the label, and you don't have any way to get it open. Your stomach growls a little as you put it back on the shelf.~]
      say__p=1;ParaContent();  print (PrintText) SC_215;  new_line; .L_Say106; .L_SayX100;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1049, 1049, true);
   rfalse;
];
! No specific request
! Instead of attacking cage:
[ R_1057 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == O140_wire_mesh_cage) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1057, 1057);
      ! phrase 1
      ! [1: say ~You've already ripped it open. No point in going mental.~]
      say__p=1;ParaContent();  print (PrintText) SC_216;  new_line; .L_Say107; .L_SayX101;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1057, 1057, true);
   rfalse;
];
! No specific request
! Instead of smelling Control Center:
[ R_1074 ;
   if ((action ==##Smell) &&  (actor==player) && ((noun == O143_control_center) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1074, 1074);
      ! phrase 1
      ! [1: try smelling smell of gasoline]
       TryAction(0, player, ##Smell, O147_smell_of_gasoline, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1074, 1074, true);
   rfalse;
];
! No specific request
! Instead of looking under piles of trash:
[ R_1077 ;
   if ((action ==##LookUnder) &&  (actor==player) && ((noun == O146_piles_of_trash) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1077, 1077);
      ! phrase 1
      ! [1: say ~You root around in the trash hopelessly, but there's a lot of it. You don't turn up anything useful.~]
      say__p=1;ParaContent();  print (PrintText) SC_217;  new_line; .L_Say108; .L_SayX102;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1077, 1077, true);
   rfalse;
];
! No specific request
! Instead of opening gas can:
[ R_1079 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == O60_gas_can) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1079, 1079);
      ! phrase 1
      ! [1: say ~You don't want to spill it.~]
      say__p=1;ParaContent();  print (PrintText) SC_218;  new_line; .L_Say109; .L_SayX103;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1079, 1079, true);
   rfalse;
];
! No specific request
! Instead of kissing the lizard:
[ R_1089 ;
   if ((action ==##Kiss) &&  (actor==player) && ((noun == O171_brown_lizard) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1089, 1089);
      ! phrase 1
      ! [1: say ~Someone in elementary school dared you to do that once and you beat him up.~]
      say__p=1;ParaContent();  print (PrintText) SC_219;  new_line; .L_Say110; .L_SayX104;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1089, 1089, true);
   rfalse;
];
! No specific request
! Instead of attacking radio:
[ R_1117 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == O118_emergency_radio) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1117, 1117);
      ! phrase 1
      ! [1: say ~[one of]You slam a fist into the top of the radio, but it just keeps hissing with static.[or]You kick the radio off the table and it clatters to the ground, but still keeps laughing with hisses and whines.[or]You smash the radio over and over again, until it lies in pieces on the ground, but the static still continues, and more and more it sounds like sand.[or]The radio is destroyed, but the sound still plays, echoing and reverberating through the room.[stopping]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->8 =
	i7_soo_stop(I7_ST_say_one_of-->8, 4);
	switch((I7_ST_say_one_of-->8)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_220;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_221;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_222;  new_line;ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_223;  new_line;ParaContent();  }  .L_Say111; .L_SayX105;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1117, 1117, true);
   rfalse;
];
! No specific request
! Instead of smelling sage:
[ R_1123 ;
   if ((action ==##Smell) &&  (actor==player) && ((noun == O64_sage) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1123, 1123);
      ! phrase 1
      ! [1: say ~When you were a kid, it smelt like camping and adventure. Now it just smells like desert and confusion.~]
      say__p=1;ParaContent();  print (PrintText) SC_224;  new_line; .L_Say112; .L_SayX106;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1123, 1123, true);
   rfalse;
];
! No specific request
! Instead of taking cigarette:
[ R_1181 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O177_cigarette) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1181, 1181);
      ! phrase 1
      ! [1: move cigarette to player]
       MoveObject(O177_cigarette, player, 0, false); 
      ! phrase 2
      ! [2: try saying yes]
       TryAction(0, player, ##Yes, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1181, 1181, true);
   rfalse;
];
! No specific request
! Instead of dropping cigarette:
[ R_1182 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun == O177_cigarette) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1182, 1182);
      ! phrase 1
      ! [1: now cigarette is off-stage]
       (Adj_9_t3_v65(O177_cigarette)); 
      ! phrase 2
      ! [2: say ~You drop it to the ground and stub it out with your foot.~]
      say__p=1;ParaContent();  print (PrintText) SC_225;  new_line; .L_Say113; .L_SayX107;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1182, 1182, true);
   rfalse;
];
! No specific request
! Instead of switching on or switching off lighter:
[ R_950 ;
   if ((action ==##SwitchOff or ##SwitchOn) &&  (actor==player) && ((noun == O38_lighter) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_950, 950);
      ! phrase 1
      ! [1: try burning lighter]
       TryAction(0, player, ##Burn, O38_lighter, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_950, 950, true);
   rfalse;
];
! No specific request
! Instead of switching on or switching off pickup truck:
[ R_992 ;
   if ((action ==##SwitchOff or ##SwitchOn) &&  (actor==player) && ((noun == O42_pickup_truck) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_992, 992);
      ! phrase 1
      ! [1: say ~The engine just turns over. It won't start.~]
      say__p=1;ParaContent();  print (PrintText) SC_226;  new_line; .L_Say114; .L_SayX108;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_992, 992, true);
   rfalse;
];
! No specific request
! Instead of climbing or entering the utility ladder:
[ R_1048 ;
   if ((action ==##Enter or ##Climb) &&  (actor==player) && ((noun == O133_utility_ladder) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1048, 1048);
      ! phrase 1
      ! [1: try going up]
       TryAction(0, player, ##Go, O18_up, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1048, 1048, true);
   rfalse;
];
! No specific request
! Instead of opening or eating cans of food:
[ R_1050 ;
   if ((action ==##Eat or ##Open) &&  (actor==player) && ((noun == O137_cans_of_food) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1050, 1050);
      ! phrase 1
      ! [1: try taking cans of food]
       TryAction(0, player, ##Take, O137_cans_of_food, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1050, 1050, true);
   rfalse;
];
! No specific request
! Instead of climbing or entering metal rungs:
[ R_1062 ;
   if ((action ==##Enter or ##Climb) &&  (actor==player) && ((noun == O142_metal_rungs) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1062, 1062);
      ! phrase 1
      ! [1: try going up]
       TryAction(0, player, ##Go, O18_up, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1062, 1062, true);
   rfalse;
];
! No specific request
! Instead of entering or climbing the huge metal barrel:
[ R_1068 ;
   if ((action ==##Climb or ##Enter) &&  (actor==player) && ((noun == O144_huge_metal_barrel) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1068, 1068);
      ! phrase 1
      ! [1: say ~Yeah, you could get on top of it, but while it's over here you couldn't reach a whole lot.~]
      say__p=1;ParaContent();  print (PrintText) SC_227;  new_line; .L_Say115; .L_SayX109;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1068, 1068, true);
   rfalse;
];
! No specific request
! Instead of searching or taking piles of trash:
[ R_1075 ;
   if ((action ==##Take or ##Search) &&  (actor==player) && ((noun == O146_piles_of_trash) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1075, 1075);
      ! phrase 1
      ! [1: try looking under piles of trash]
       TryAction(0, player, ##LookUnder, O146_piles_of_trash, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1075, 1075, true);
   rfalse;
];
! No specific request
! Instead of opening , entering , or attacking boarded-up door:
[ R_999 ;
   if ((action ==##Attack or ##Enter or ##Open) &&  (actor==player) && ((noun == O116_boarded_up_door) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_999, 999);
      ! phrase 1
      ! [1: say ~The door won't budge. You slam your hands against the boards in frustration[if pane of cracked glass is closed], causing a nearby window to quiver in the reflected light[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_228; 
	if (~~(((((Adj_75_t1_v65(O120_pane_of_cracked_glass))))))) jump L_Say116;
		ParaContent();  print (PrintText) SC_229; 
	.L_Say116; .L_SayX110;
		ParaContent();  print (PrintText) SC_77;  new_line; .L_Say117; .L_SayX111;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_999, 999, true);
   rfalse;
];
! No specific request
! Instead of turning or pushing or pulling emergency radio:
[ R_1007 ;
   if ((action ==##Pull or ##Push or ##Turn) &&  (actor==player) && ((noun == O118_emergency_radio) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1007, 1007);
      ! phrase 1
      ! [1: say ~It looks like you can TUNE it to a frequency.~]
      say__p=1;ParaContent();  print (PrintText) SC_230;  new_line; .L_Say118; .L_SayX112;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1007, 1007, true);
   rfalse;
];
! No specific request
! Instead of touching or rubbing or attacking or pulling the cobwebs:
[ R_1029 ;
   if ((action ==##Pull or ##Attack or ##Rub or ##Touch) &&  (actor==player) && ((noun == O125_cobwebs) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1029, 1029);
      ! phrase 1
      ! [1: try taking the duct tape]
       TryAction(0, player, ##Take, O76_roll_of_duct_tape, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1029, 1029, true);
   rfalse;
];
! No specific request
! Instead of attacking or taking or pushing or touching the lizard:
[ R_1088 ;
   if ((action ==##Touch or ##Push or ##Take or ##Attack) &&  (actor==player) && ((noun == O171_brown_lizard) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1088, 1088);
      ! phrase 1
      ! [1: say ~You reach out to grab it, but in a flash it scurries around to the other side of the cactus and disappears.~]
      say__p=1;ParaContent();  print (PrintText) SC_231;  new_line; .L_Say119; .L_SayX113;
      ! phrase 2
      ! [2: now lizard is off-stage]
       (Adj_9_t3_v65(O171_brown_lizard)); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1088, 1088, true);
   rfalse;
];
! No specific request
! Instead of searching or taking or looking under or pushing or pulling sheet of corrugated metal:
[ R_1076 ;
   if ((action ==##Pull or ##Push or ##LookUnder or ##Take or ##Search) &&  (actor==player) && ((noun == O148_sheet_of_corrugated_met) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1076, 1076);
      ! phrase 1
      ! [1: try looking under piles of trash]
       TryAction(0, player, ##LookUnder, O146_piles_of_trash, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1076, 1076, true);
   rfalse;
];
! No specific request
! Instead of attacking an open window:
[ R_1024 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun ofclass K119_window) && ((Adj_74_t1_v65(noun))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1024, 1024);
      ! phrase 1
      ! [1: say ~You've already busted it open.~]
      say__p=1;ParaContent();  print (PrintText) SC_232;  new_line; .L_Say120; .L_SayX114;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1024, 1024, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than quizzing , implicit-quizzing or trading to a not held talent:
[ R_1110 ;
   if ((action ~=##A101_trading or ##A85_implicit_quizzing or ##A83_quizzing_it_about) &&  (actor==player) && ((noun ofclass K78_talent) && (~~((Adj_2_t1_v65(noun)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1110, 1110);
      ! phrase 1
      ! [1: say ~It's just potential, or something.~]
      say__p=1;ParaContent();  print (PrintText) SC_233;  new_line; .L_Say121; .L_SayX115;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1110, 1110, true);
   rfalse;
];
! No specific request
! Instead of doing anything to desert flotsam:
[ R_1084 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun ofclass K150_desert_flotsam))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1084, 1084);
      ! phrase 1
      ! [1: say ~It's not important, man.~]
      say__p=1;ParaContent();  print (PrintText) SC_234;  new_line; .L_Say122; .L_SayX116;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1084, 1084, true);
   rfalse;
];
! No specific request
! Instead of dropping a talent:
[ R_963 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun ofclass K78_talent))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_963, 963);
      ! phrase 1
      ! [1: say ~You can't imagine being without it, now.~]
      say__p=1;ParaContent();  print (PrintText) SC_235;  new_line; .L_Say123; .L_SayX117;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_963, 963, true);
   rfalse;
];
! No specific request
! Instead of attacking a window:
[ R_1023 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun ofclass K119_window))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1023, 1023);
      ! phrase 1
      ! [1: say ~Nice thought, but the last thing you need is a sliced open hand. Maybe you could use something less likely to bleed.~]
      say__p=1;ParaContent();  print (PrintText) SC_236;  new_line; .L_Say124; .L_SayX118;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1023, 1023, true);
   rfalse;
];
! No specific request
! Instead of opening or closing a window:
[ R_1018 ;
   if ((action ==##Close or ##Open) &&  (actor==player) && ((noun ofclass K119_window))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1018, 1018);
      ! phrase 1
      ! [1: say ~[if noun is open]It's already busted open.[otherwise]It looks like these windows have been rusted shut for years.~]
      say__p=1;
	if (~~(((((Adj_74_t1_v65(noun))))))) jump L_Say125;
		ParaContent();  print (PrintText) SC_237;  new_line;
	jump L_SayX119; .L_Say125;
		ParaContent();  print (PrintText) SC_238;  new_line; .L_Say126; .L_SayX119;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1018, 1018, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than brooding or trading to a memory:
[ R_935 ;
   if ((action ~=##A101_trading or ##A97_brooding) &&  (actor==player) && ((noun ofclass K43_memory))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_935, 935);
      ! phrase 1
      ! [1: say ~As if. All you can really do is BROOD ABOUT it.~]
      say__p=1;ParaContent();  print (PrintText) SC_239;  new_line; .L_Say127; .L_SayX120;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_935, 935, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Instead of finishing conversation when current interlocutor is a person and can't leave conversation early is true:
[ R_848 ;
   if ((NAP_3()) &&  (actor==player) && (self=actor,true) && (((((Global_Vars-->9) ofclass K8_person))) && ((((Global_Vars-->18) == 1))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_848, 848);
      ! phrase 1
      ! [1: say ~You have a feeling this conversation isn't over.~]
      say__p=1;ParaContent();  print (PrintText) SC_240;  new_line; .L_Say128; .L_SayX121;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_848, 848, true);
   rfalse;
];
! No specific request
! Instead of leaving the building when time for arrival:
[ R_1198 ;
   if ((NAP_4()) &&  (actor==player) && (self=actor,true) && (((PHR_1197_r17 ())))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1198, 1198);
      ! phrase 1
      ! [1: say ~[one of]You start to go out, but then you stop. Something's not right. Something's... weird.[or]The building's sinking into the sand! You've got to get out some other way![stopping]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->9 =
	i7_soo_stop(I7_ST_say_one_of-->9, 2);
	switch((I7_ST_say_one_of-->9)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_241;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_242;  new_line;ParaContent();  }  .L_Say129; .L_SayX122;
      ! phrase 2
      ! [2: now tried to leave is true]
       (Global_Vars-->32) = 1; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1198, 1198, true);
   rfalse;
];
! No specific request
! Instead of saying yes when yes-no-suggestion is familiar and location is The Burrow:
[ R_1145 ;
   if ((action ==##Yes) &&  (actor==player) && (self=actor,true) && (((((Adj_90_t1_v65(O33_yes_no_suggestion))))) && (((real_location == O182_burrow))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1145, 1145);
      ! phrase 1
      ! [1: say ~'Then you should probably get home and tell her,' the bunny says. 'Patch up that truck and fly down that highway before she gets away.' It winks.~]
      say__p=1;ParaContent();  print (PrintText) SC_243;  new_line; .L_Say130; .L_SayX123;
      ! phrase 2
      ! [2: introduce rabbit's choices]
      (PHR_1148_r18 ());
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1145, 1145, true);
   rfalse;
];
! No specific request
! Instead of saying no when yes-no-suggestion is familiar and location is The Burrow:
[ R_1146 ;
   if ((action ==##No) &&  (actor==player) && (self=actor,true) && (((((Adj_90_t1_v65(O33_yes_no_suggestion))))) && (((real_location == O182_burrow))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1146, 1146);
      ! phrase 1
      ! [1: say ~'Then what are you still doing with her?' the bunny says. 'Get out while the getting's good. You think either of you will be happier if you put that off? There's fish in other oceans kid. You've got your whole life ahead to swim.' It winks.~]
      say__p=1;ParaContent();  print (PrintText) SC_244;  new_line; .L_Say131; .L_SayX124;
      ! phrase 2
      ! [2: introduce rabbit's choices]
      (PHR_1148_r18 ());
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1146, 1146, true);
   rfalse;
];
! No specific request
! Instead of saying yes when yes-no-suggestion is familiar and Coyote is visible:
[ R_1185 ;
   if ((action ==##Yes) &&  (actor==player) && (self=actor,true) && (((((Adj_90_t1_v65(O33_yes_no_suggestion))))) && ((((Adj_3_t1_v65(O167_coyote))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1185, 1185);
      ! phrase 1
      ! [1: say ~You pull out your pack and [if count of pack of cigarettes is 0]see that it's empty, but Coyote grins and hands you his last one[otherwise]he grins, like he knew you'd say yes[end if], and leans forward for you to light up off him. His sunglasses reflect back nothing but your own face weirdly lit by the glow from the cig, and for a moment it's like the blackness behind them is deep, deeper than the sky, deeper than the universe...~]
      say__p=1;ParaContent();  print (PrintText) SC_245; 
	if (~~((((GProperty(OBJECT_TY, O39_pack_of_cigarettes,p17_count) == 0))))) jump L_Say132;
		ParaContent();  print (PrintText) SC_246; 
	jump L_SayX125; .L_Say132;
		ParaContent();  print (PrintText) SC_247; 
	.L_Say133; .L_SayX125;
		ParaContent();  print (PrintText) SC_248;  new_line; .L_Say134; .L_SayX126;
      ! phrase 2
      ! [2: if count of pack of cigarettes > 0 , decrease count of pack of cigarettes by 1]
       if (((GProperty(OBJECT_TY, O39_pack_of_cigarettes,p17_count) > 0))) {  WriteGProperty(OBJECT_TY, O39_pack_of_cigarettes,p17_count,GProperty(OBJECT_TY, O39_pack_of_cigarettes,p17_count) - 1);   }
      ! phrase 3
      ! [3: coyote-talks]
      (PHR_1187_r19 ());
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1185, 1185, true);
   rfalse;
];
! No specific request
! Instead of saying no when yes-no-suggestion is familiar and Coyote is visible:
[ R_1186 ;
   if ((action ==##No) &&  (actor==player) && (self=actor,true) && (((((Adj_90_t1_v65(O33_yes_no_suggestion))))) && ((((Adj_3_t1_v65(O167_coyote))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1186, 1186);
      ! phrase 1
      ! [1: say ~He shrugs, takes a puff on his, and exhales the smoke into the desert night. Wind whips it away and he stares towards the horizon, forehead wrinkling in something (annoyance, maybe contemplation) you can't read through the sunglasses.~]
      say__p=1;ParaContent();  print (PrintText) SC_249;  new_line; .L_Say135; .L_SayX127;
      ! phrase 2
      ! [2: coyote-talks]
      (PHR_1187_r19 ());
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1186, 1186, true);
   rfalse;
];
! No specific request
! Instead of saying yes when yes-no-suggestion is familiar and Sand-dancer is visible:
[ R_1222 ;
   if ((action ==##Yes) &&  (actor==player) && (self=actor,true) && (((((Adj_90_t1_v65(O33_yes_no_suggestion))))) && ((((Adj_3_t1_v65(O168_sand_dancer))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1222, 1222);
      ! phrase 1
      ! [1: say ~'Yes?' Sand-dancer says, and the lizards quiver anxiously. 'You're happy with the path you've chosen? [SD-tease].'~]
      say__p=1;ParaContent();  print (PrintText) SC_250; ParaContent(); (PHR_1224_r20 ());ParaContent();  print (PrintText) SC_251;  new_line; .L_Say136; .L_SayX128;
      ! phrase 2
      ! [2: try quizzing sand-dancer about doing the trade]
       TryAction(0, player, ##A83_quizzing_it_about, O168_sand_dancer, O212_doing_the_trade);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1222, 1222, true);
   rfalse;
];
! No specific request
! Instead of saying no when yes-no-suggestion is familiar and Sand-dancer is visible:
[ R_1223 ;
   if ((action ==##No) &&  (actor==player) && (self=actor,true) && (((((Adj_90_t1_v65(O33_yes_no_suggestion))))) && ((((Adj_3_t1_v65(O168_sand_dancer))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1223, 1223);
      ! phrase 1
      ! [1: say ~'No?' Sand-dancer says, and the lizards quiver anxiously. 'You're not happy with the path you've chosen? [SD-tease].'~]
      say__p=1;ParaContent();  print (PrintText) SC_252; ParaContent(); (PHR_1224_r20 ());ParaContent();  print (PrintText) SC_251;  new_line; .L_Say137; .L_SayX129;
      ! phrase 2
      ! [2: try quizzing sand-dancer about doing the trade]
       TryAction(0, player, ##A83_quizzing_it_about, O168_sand_dancer, O212_doing_the_trade);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1223, 1223, true);
   rfalse;
];
! No specific request
! Instead of going when player holds freedom:
[ R_923 ;
   if ((action ==##Go) &&  (actor==player) && (self=actor,true) && (((player == HolderOf(O85_freedom))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_923, 923);
      ! phrase 1
      ! [1: say ~You go, with a strange, kinda tingly feeling in the backs of your hands and inside your eyes. You feel powerful[if player holds strength], stronger than wind now[otherwise if player holds courage], braver than the sun now[end if] and free, most of all free. You walk backwards across the sand to your truck, sucking up your footprints as you go, and slip behind the wheel. There's this crazy wrenching bang and you jerk backwards as the engine starts, uncrashing your pickup off the cactus and juddering back onto the highway, and you smile. You're going back, back to a second chance, back to make it all right.^^You speed up, drive backwards at a thousand miles an hour to work, and unfix junkers and repack parts in a flash, faster and faster. The days rewind like videotape, unwork, unsleep, giving back kisses from Ocean one by one[if player holds scent], and the smell of the past unfurling is like wine and ozone[end if]. And then it's that night, the night you made the Big Mistake[if player holds luck] before your luck started turning around, yeah, cause[otherwise], but[end if] this time you unmake love. And the moment unpasses and your future is safe and uncomplicated, no kid, no nightmares, no arguments, no lectures, and you just have to get this thing out of reverse now and do it right this time (or mebbe not at all, it's too hot anyway ya know babe?) and this time you'll make everything perfecto.^^But you don't turn around. You try, but it's kinda like trying to stop falling, and you suddenly get that you [italic type]are[roman type] falling, plummeting back faster and faster like you got pushed off the cliff of now. You're unmeeting Ocean and unditching school and unsmoking for the first time behind the dumpsters, faster and faster, stomach in your throat, memories blowing back your hair as they rocket past. You're a kid again unskateboarding and unlearning video game combos, screaming backwards faster and faster and you get it now, you get the lizard's joke. He's making you free by unmaking you, fixing the burden by erasing the guy who's bearing it, and you're unlearning to read and unlearning to walk and uncrawling and uncrying and then some brilliant moment of light and noise and chaos comes shrieking towards you hella fast, fast, faster than anything and it's too late, you're crashing, you're crashing, you crash...~]
      say__p=1;ParaContent();  print (PrintText) SC_253; 
	if (~~((((player == HolderOf(O79_strength)))))) jump L_Say138;
		ParaContent();  print (PrintText) SC_254; ParaContent(); 
	jump L_SayX130; .L_Say138; if (~~((((player == HolderOf(O80_courage)))))) jump L_Say139;
		ParaContent();  print (PrintText) SC_255; 
	.L_Say139; .L_SayX130;
		ParaContent();  print (PrintText) SC_256; 
	if (~~((((player == HolderOf(O82_scent)))))) jump L_Say140;
		ParaContent();  print (PrintText) SC_257; 
	.L_Say140; .L_SayX131;
		ParaContent();  print (PrintText) SC_258; 
	if (~~((((player == HolderOf(O81_luck)))))) jump L_Say141;
		ParaContent();  print (PrintText) SC_259; 
	jump L_SayX132; .L_Say141;
		ParaContent();  print (PrintText) SC_260; 
	.L_Say142; .L_SayX132;
		ParaContent();  print (PrintText) SC_261; ParaContent();  style underline; ParaContent();  print (PrintText) SC_262; ParaContent();  style roman; ParaContent();  print (PrintText) SC_263;  new_line; .L_Say143; .L_SayX133;
      ! phrase 2
      ! [2: end the story]
       deadflag=3; story_complete=false; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_923, 923, true);
   rfalse;
];
! No specific request
! Instead of going when player holds honor:
[ R_924 ;
   if ((action ==##Go) &&  (actor==player) && (self=actor,true) && (((player == HolderOf(O83_honor))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_924, 924);
      ! phrase 1
      ! [1: say ~You go, and the clouds are gone and the stars are so bright you squint. You patch the fuel line and refill the tank and she starts like a beauty, and then you're back on the highway again, headed for Ocean, [if player holds luck]and you've never felt luckier[otherwise if player holds scent]and the urge to breathe the same air as her leads you on like a bloodhound[end if].^^You shut off the headlights as you pull up to the trailer, and climb in through her window for old times sake[if player holds courage], crazy courage her sister at least appreciated if not her old man[otherwise if player holds strength] even though you think you're finally strong enough to take her old man[end if]. She's awake of course, always no matter how quiet you are, and she holds out a hand from somewhere under the blankets. And as she's doing it you're suddenly exhausted, beyond exhausted but also safe, warm even before you slip under the covers. She half turns to kiss you as you fumble with the blankets but you're so tired all you can do is push your face against her neck and slip an arm around her warm skin, and she starts to ask you something but it's too late, you're crashing, you're crashing, you crash...~]
      say__p=1;ParaContent();  print (PrintText) SC_264; 
	if (~~((((player == HolderOf(O81_luck)))))) jump L_Say144;
		ParaContent();  print (PrintText) SC_265; ParaContent(); 
	jump L_SayX134; .L_Say144; if (~~((((player == HolderOf(O82_scent)))))) jump L_Say145;
		ParaContent();  print (PrintText) SC_266; 
	.L_Say145; .L_SayX134;
		ParaContent();  print (PrintText) SC_267; 
	if (~~((((player == HolderOf(O80_courage)))))) jump L_Say146;
		ParaContent();  print (PrintText) SC_268; ParaContent(); 
	jump L_SayX135; .L_Say146; if (~~((((player == HolderOf(O79_strength)))))) jump L_Say147;
		ParaContent();  print (PrintText) SC_269; 
	.L_Say147; .L_SayX135;
		ParaContent();  print (PrintText) SC_270;  new_line; .L_Say148; .L_SayX136;
      ! phrase 2
      ! [2: end the story]
       deadflag=3; story_complete=false; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_924, 924, true);
   rfalse;
];
! No specific request
! Instead of going when player holds spirit:
[ R_925 ;
   if ((action ==##Go) &&  (actor==player) && (self=actor,true) && (((player == HolderOf(O84_spirit))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_925, 925);
      ! phrase 1
      ! [1: say ~You go, and the night collapses in on you so hard you barely remember curling up in a corner with the blanket[if player holds courage], not afraid any more[otherwise if player holds strength], strong enough now to wait out the night[end if].^^In the morning some highway patrol dude shakes you awake with a lecture and a ride back to town. Oro Oeste? he asks but you tell him no, take a left instead, and you end up on a street corner in Pobre Vista and keep going. Seven Sticks and then Gallup and then Flagstaff, hitching west. The cash in your wallet runs out but a trucker buys you a value meal and [if player holds luck]with a little more luck you keep from being hungry[otherwise if player holds scent]you seem to have a knack for sniffing out enough to stay fed[end if] and your blanket keeps you warm and you keep going.^^When you hit the Pacific you roll up your jeans and wade into the surf for the first time in your life. And it's warm on the top and cool underneath and this is all you want, this moment, this here and now. You'll find work and you'll find love but you'll never find home and that's okay. It's okay. You wade deeper and the waves lap higher and then a big one rolls in, blue and white, and you feel [if player holds strength] strong, strong[otherwise]crazy brave[end if] as it crests and smashes into you with the force of all the water in the world, and you laugh and try to stay on your feet but it's too late, you're crashing, you're crashing, you crash...~]
      say__p=1;ParaContent();  print (PrintText) SC_271; 
	if (~~((((player == HolderOf(O80_courage)))))) jump L_Say149;
		ParaContent();  print (PrintText) SC_272; ParaContent(); 
	jump L_SayX137; .L_Say149; if (~~((((player == HolderOf(O79_strength)))))) jump L_Say150;
		ParaContent();  print (PrintText) SC_273; 
	.L_Say150; .L_SayX137;
		ParaContent();  print (PrintText) SC_274; 
	if (~~((((player == HolderOf(O81_luck)))))) jump L_Say151;
		ParaContent();  print (PrintText) SC_275; ParaContent(); 
	jump L_SayX138; .L_Say151; if (~~((((player == HolderOf(O82_scent)))))) jump L_Say152;
		ParaContent();  print (PrintText) SC_276; 
	.L_Say152; .L_SayX138;
		ParaContent();  print (PrintText) SC_277; 
	if (~~((((player == HolderOf(O79_strength)))))) jump L_Say153;
		ParaContent();  print (PrintText) SC_278; 
	jump L_SayX139; .L_Say153;
		ParaContent();  print (PrintText) SC_279; 
	.L_Say154; .L_SayX139;
		ParaContent();  print (PrintText) SC_280;  new_line; .L_Say155; .L_SayX140;
      ! phrase 2
      ! [2: end the story]
       deadflag=3; story_complete=false; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_925, 925, true);
   rfalse;
];
! No specific request
! Instead of brooding when noun suggests a memory:
[ R_937 ;
   if ((action ==##A97_brooding) &&  (actor==player) && (self=actor,true) && ((((noun.p78_suggested_memory) ofclass K43_memory)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_937, 937);
      ! phrase 1
      ! [1: say ~It's not [the noun] you want to brood about, it's [a random memory suggested by the noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_281; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_282; ParaContent();  print (a)  (Prop_14()) ; ParaContent();  print (PrintText) SC_77;  new_line; .L_Say156; .L_SayX141;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_937, 937, true);
   rfalse;
];
! No specific request
! Instead of jumping when location is Roof:
[ R_1061 ;
   if ((action ==##Jump) &&  (actor==player) && (self=actor,true) && (((real_location == O89_roof)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1061, 1061);
      ! phrase 1
      ! [1: try going up]
       TryAction(0, player, ##Go, O18_up, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1061, 1061, true);
   rfalse;
];
! No specific request
! Instead of going when circle of snarling coyotes is visible:
[ R_1171 ;
   if ((action ==##Go) &&  (actor==player) && (self=actor,true) && ((((Adj_3_t1_v65(O202_circle_of_snarling_coyo)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1171, 1171);
      ! phrase 1
      ! [1: say ~You try to flee and instantly teeth and claws block your path; you pull back to the center of the circle, terrified.~]
      say__p=1;ParaContent();  print (PrintText) SC_283;  new_line; .L_Say157; .L_SayX142;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1171, 1171, true);
   rfalse;
];
! No specific request
! Instead of hailing when Sand-dancer is visible:
[ R_1214 ;
   if ((action ==##A90_hailing) &&  (actor==player) && (self=actor,true) && ((((Adj_3_t1_v65(O168_sand_dancer)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1214, 1214);
      ! phrase 1
      ! [1: say ~[remove hello other suggestion]The ground rumbles as the lizards shift. 'Hello,' he says, [SD-business]. 'Yes, hello, little one. Strange thing to say when I've always been with you, watching, waiting. But hello, hello at last, Nakaibito.'~]
      say__p=1;ParaContent(); (PHR_832_r21 (O207_hello));ParaContent();  print (PrintText) SC_284; ParaContent(); (PHR_1211_r22 ());ParaContent();  print (PrintText) SC_285;  new_line; .L_Say158; .L_SayX143;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1214, 1214, true);
   rfalse;
];
! No specific request
! Instead of listening during Rainstorm:
[ R_1125 ;
   if (scene_status-->2 == 1) { ! Runs only during scene
   if ((action ==##Listen) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1125, 1125);
      ! phrase 1
      ! [1: say ~You can't hear anything at all above the pounding noise of water slapping sand.~]
      say__p=1;ParaContent();  print (PrintText) SC_286;  new_line; .L_Say159; .L_SayX144;
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1125, 1125, true);
   rfalse;
];
! No specific request
! Instead of waving hands during Temptation:
[ R_1160 ;
   if (scene_status-->5 == 1) { ! Runs only during scene
   if ((action ==##WaveHands) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1160, 1160);
      ! phrase 1
      ! [1: say ~The figure waves back, then seems to beckon you forward.~]
      say__p=1;ParaContent();  print (PrintText) SC_287;  new_line; .L_Say160; .L_SayX145;
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1160, 1160, true);
   rfalse;
];
! No specific request
! Instead of brooding during Fight:
[ R_1168 ;
   if (scene_status-->7 == 1) { ! Runs only during scene
   if ((action ==##A97_brooding) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1168, 1168);
      ! phrase 1
      ! [1: say ~No time for that now.~]
      say__p=1;ParaContent();  print (PrintText) SC_288;  new_line; .L_Say161; .L_SayX146;
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1168, 1168, true);
   rfalse;
];
! No specific request
! Instead of attacking during Fight:
[ R_1173 ;
   if (scene_status-->7 == 1) { ! Runs only during scene
   if ((action ==##Attack) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1173, 1173);
      ! phrase 1
      ! [1: say ~It's over. The coyotes dive in for the kill, jaws snapping, [if player holds strength]and without hardly realizing what you're doing you make a fist and slam it into the one that's closest.^^The coyote squeals, flung sideways by the strength of your punch, blood dripping from its nose, and the rest of the pack pulls back in sudden caution. Another coyote makes to lunge and you whirl towards it in fury, pulling back for another blow, but the pack breaks in some collective decision and scatters[otherwise if player holds courage]and suddenly this bolt of courage runs through you and without even thinking about it you leap towards the biggest coyote with a terrible scream.^^It flinches back, suddenly unsure, and you charge at it full speed, still screaming, arms outstretched, until it turns tail and bolts away. The other coyotes circle uncertainly, but you turn your snarling furious rage on them too and then they're all scattering[end if], mangy shadows slinking away into the desert. Except for one last coyote who stands his ground.~]
      say__p=1;ParaContent();  print (PrintText) SC_289; 
	if (~~((((player == HolderOf(O79_strength)))))) jump L_Say162;
		ParaContent();  print (PrintText) SC_290; ParaContent(); 
	jump L_SayX147; .L_Say162; if (~~((((player == HolderOf(O80_courage)))))) jump L_Say163;
		ParaContent();  print (PrintText) SC_291; 
	.L_Say163; .L_SayX147;
		ParaContent();  print (PrintText) SC_292;  new_line; .L_Say164; .L_SayX148;
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1173, 1173, true);
   rfalse;
];
! No specific request
! Instead of smoking during Coyote's Offer:
[ R_1184 ;
   if (scene_status-->8 == 1) { ! Runs only during scene
   if ((action ==##A98_smoking) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1184, 1184);
      ! phrase 1
      ! [1: try saying yes]
       TryAction(0, player, ##Yes, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1184, 1184, true);
   rfalse;
];
! No specific request
! Instead of smoking during a dramatic scene:
[ R_1111 ;
   if (DuringSceneMatching(Prop_15)) { ! Runs only during scene
   if ((action ==##A98_smoking) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1111, 1111);
      ! phrase 1
      ! [1: say ~This isn't really the best time for that, man.~]
      say__p=1;ParaContent();  print (PrintText) SC_293;  new_line; .L_Say165; .L_SayX149;
      RulebookFails(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1111, 1111, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining when noun is emotional baggage or second noun is emotional baggage:
[ R_930 ;
   if ((action ~=##Examine) &&  (actor==player) && (self=actor,true) && ((((noun == O45_emotional_baggage))) || (((second == O45_emotional_baggage))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_930, 930);
      ! phrase 1
      ! [1: say ~It's not real, bro.~]
      say__p=1;ParaContent();  print (PrintText) SC_294;  new_line; .L_Say166; .L_SayX150;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_930, 930, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Instead of going nowhere ( this is the small kindnesses reporting on exits rule ):
[ R_875 
    t_0 ! Local variable e.g. 'count of exits' = number
    ;
   if ((action ==##Go) &&  (actor==player) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_875, 875);
      ! phrase 1
      ! [1: if in darkness , say ~You can't see which way to go in this darkness.~ instead]
       if (( (location==thedark) )) { say__p=1;ParaContent();  print (PrintText) SC_295;  new_line; .L_Say167; .L_SayX151;  rtrue; }
      ! phrase 2
      ! [2: let count of exits be the number of viable directions]
       t_0 =  (Prop_16()) ; 
      ! phrase 3
      ! [3: issue library message going action number 2 for the room gone from]
       GL__M(##Go,2,(MStack-->MstVO(20007,0))); 
      ! phrase 4
      ! [4: if the count of exits is 0 , say ~[line break]In fact, you can't see any obvious exits.~ instead]
       if (((t_0 == 0))) { say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_296;  new_line; .L_Say168; .L_SayX152;  rtrue; }
      ! phrase 5
      ! [5: if the count of exits is 1 , say ~[line break]From here, the only way out is to [a list of viable directions].~]
       if (((t_0 == 1))) { say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_297; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K3_direction) && ((Adj_33_t1_v65(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_77;  new_line; .L_Say169; .L_SayX153;  }
      ! phrase 6
      ! [6: otherwise say ~[line break]From here, you can go [list of viable directions].~]
       else { say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_298; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K3_direction) && ((Adj_33_t1_v65(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+NOARTICLE_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_77;  new_line; .L_Say170; .L_SayX154;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_875, 875, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Instead of implicit-quizzing:
[ R_749 ;
   if ((action ==##A85_implicit_quizzing) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_749, 749);
      ! phrase 1
      ! [1: try quizzing the current interlocutor about the noun]
       TryAction(0, player, ##A83_quizzing_it_about, (Global_Vars-->9), noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_749, 749, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Instead of implicit-informing:
[ R_750 ;
   if ((action ==##A86_implicit_informing) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_750, 750);
      ! phrase 1
      ! [1: try informing the current interlocutor about the noun]
       TryAction(0, player, ##A84_informing_it_about, (Global_Vars-->9), noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_750, 750, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Instead of implicit-requesting:
[ R_751 ;
   if ((action ==##A87_implicit_requesting) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_751, 751);
      ! phrase 1
      ! [1: try requesting the current interlocutor for the noun]
       TryAction(0, player, ##A81_requesting_it_for, (Global_Vars-->9), noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_751, 751, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Instead of implicit-imploring:
[ R_752 ;
   if ((action ==##A88_implicit_imploring) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_752, 752);
      ! phrase 1
      ! [1: try imploring the current interlocutor for it]
       TryAction(0, player, ##A82_imploring_it_for, (Global_Vars-->9), 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_752, 752, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Instead of saying yes:
[ R_846 ;
   if ((action ==##Yes) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_846, 846);
      ! phrase 1
      ! [1: try informing the current interlocutor about yes-suggestion]
       TryAction(0, player, ##A84_informing_it_about, (Global_Vars-->9), O31_yes_suggestion);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_846, 846, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Instead of saying no:
[ R_847 ;
   if ((action ==##No) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_847, 847);
      ! phrase 1
      ! [1: try informing the current interlocutor about no-suggestion]
       TryAction(0, player, ##A84_informing_it_about, (Global_Vars-->9), O32_no_suggestion);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_847, 847, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Instead of hailing:
[ R_858 ;
   if ((action ==##A90_hailing) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_858, 858);
      ! phrase 1
      ! [1: do nothing]
       ; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_858, 858, true);
   rfalse;
];
! No specific request
! Instead of waiting:
[ R_931 
    t_0 ! Local variable e.g. 'selection' = object
    ;
   if ((action ==##Wait) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_931, 931);
      ! phrase 1
      ! [1: let selection be a random thing in emotional baggage]
       t_0 =  (Prop_17()) ; 
      ! phrase 2
      ! [2: if nothing is in emotional baggage , now selection is a random memory]
       if ((Prop_18())) {  t_0 =  (Prop_19()) ;   }
      ! phrase 3
      ! [3: say ~Nah, man, better keep busy or else it's back to brooding about [the selection].~]
      say__p=1;ParaContent();  print (PrintText) SC_299; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_77;  new_line; .L_Say171; .L_SayX155;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_931, 931, true);
   rfalse;
];
! No specific request
! Instead of thinking:
[ R_936 ;
   if ((action ==##Think) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_936, 936);
      ! phrase 1
      ! [1: say ~Most of the thinking you do nowadays comes from either smoking or brooding.~]
      say__p=1;ParaContent();  print (PrintText) SC_300;  new_line; .L_Say172; .L_SayX156;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_936, 936, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: After (B24_after)
! ----------------------------------------------------------------------------------------------------
! Rule 1/54 ! First after quizzing somebody about something ( called the thread ):
!   === which is equally specific with ===
! Rule 2/54 ! First after informing somebody about something ( called the thread ):
! --- now the mid-placed rules ---
! Rule 3/54 ! After touching desk in dim Staging Area:
!   === which is equally specific with ===
! Rule 4/54 ! After opening drawer in dim Staging Area:
!   === which is equally specific with ===
! Rule 5/54 ! After taking flashlight in dim Staging Area:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 6/54 ! After going up during Sand-dancer's Arrival:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 7/54 ! After taking something required by a plan during Sand-dancer's Offer:
!   >>> I - Number of aspects constrained >>>
! Rule 8/54 ! After quizzing voice about introduction:
!   === which is equally specific with ===
! Rule 9/54 ! After informing voice about never mind:
!   === which is equally specific with ===
! Rule 10/54 ! After quizzing voice about what that means:
!   === which is equally specific with ===
! Rule 11/54 ! After informing voice about being lost:
!   === which is equally specific with ===
! Rule 12/54 ! After informing voice about yes-suggestion:
!   === which is equally specific with ===
! Rule 13/54 ! After quizzing the rabbit about introduction:
!   === which is equally specific with ===
! Rule 14/54 ! After quizzing the rabbit about the rabbit:
!   === which is equally specific with ===
! Rule 15/54 ! After quizzing the rabbit about grandma:
!   === which is equally specific with ===
! Rule 16/54 ! After informing the rabbit about how he's not real:
!   === which is equally specific with ===
! Rule 17/54 ! After quizzing the rabbit about rabbit's judgment:
!   === which is equally specific with ===
! Rule 18/54 ! After quizzing the rabbit about how he knows so much about everything:
!   === which is equally specific with ===
! Rule 19/54 ! After quizzing the rabbit about down to business:
!   === which is equally specific with ===
! Rule 20/54 ! After informing the rabbit about don't know if I love her:
!   === which is equally specific with ===
! Rule 21/54 ! After quizzing the rabbit about strength:
!   === which is equally specific with ===
! Rule 22/54 ! After quizzing the rabbit about courage:
!   === which is equally specific with ===
! Rule 23/54 ! After quizzing the rabbit about more about trading:
!   === which is equally specific with ===
! Rule 24/54 ! After informing the rabbit about you don't want to trade:
!   === which is equally specific with ===
! Rule 25/54 ! After quizzing the rabbit about more coming:
!   === which is equally specific with ===
! Rule 26/54 ! After quizzing Coyote about introduction:
!   === which is equally specific with ===
! Rule 27/54 ! After quizzing the Coyote about advice:
!   === which is equally specific with ===
! Rule 28/54 ! After quizzing Coyote about Coyote:
!   === which is equally specific with ===
! Rule 29/54 ! After quizzing Coyote about the rabbit:
!   === which is equally specific with ===
! Rule 30/54 ! After quizzing Coyote about down to business:
!   === which is equally specific with ===
! Rule 31/54 ! After quizzing Coyote about luck:
!   === which is equally specific with ===
! Rule 32/54 ! After quizzing Coyote about scent:
!   === which is equally specific with ===
! Rule 33/54 ! After quizzing Coyote about more coming:
!   === which is equally specific with ===
! Rule 34/54 ! After quizzing Sand-dancer about introduction:
!   === which is equally specific with ===
! Rule 35/54 ! After quizzing Sand-dancer about Sand-dancer:
!   === which is equally specific with ===
! Rule 36/54 ! After quizzing Sand-dancer about thousands of lizards:
!   === which is equally specific with ===
! Rule 37/54 ! After quizzing Sand-dancer about path selection:
!   === which is equally specific with ===
! Rule 38/54 ! After quizzing Sand-dancer about final choice:
!   === which is equally specific with ===
! Rule 39/54 ! After informing Sand-dancer about not sure if I'm happy:
!   === which is equally specific with ===
! Rule 40/54 ! After quizzing Sand-dancer about doing the trade:
!   === which is equally specific with ===
! Rule 41/54 ! After quizzing Sand-dancer about spirit:
!   === which is equally specific with ===
! Rule 42/54 ! After quizzing Sand-dancer about honor:
!   === which is equally specific with ===
! Rule 43/54 ! After quizzing Sand-dancer about freedom:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 44/54 ! After opening the pickup truck:
!   === which is equally specific with ===
! Rule 45/54 ! After closing the truck:
!   === which is equally specific with ===
! Rule 46/54 ! After switching on the headlights:
!   === which is equally specific with ===
! Rule 47/54 ! After switching off the headlights:
!   === which is equally specific with ===
! Rule 48/54 ! After switching on radio:
!   === which is equally specific with ===
! Rule 49/54 ! After taking the duct tape:
!   === which is equally specific with ===
! Rule 50/54 ! After switching on flashlight:
!   === which is equally specific with ===
! Rule 51/54 ! After switching on the emergency lights:
!   === which is equally specific with ===
! Rule 52/54 ! After switching off the emergency lights:
!   === which is equally specific with ===
! Rule 53/54 ! After wearing blanket:
!   >>> I - Number of aspects constrained >>>
! Rule 54/54 ! After listing suggested topics:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! First after quizzing somebody about something ( called the thread ):
[ R_854 
    t_0 ! Local variable e.g. 'thread' = object
    ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && (t_0 = second, (((t_0=(second), true) && (second ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_854, 854);
      ! phrase 1
      ! [1: say ~[remove thread ask suggestion][run paragraph on]~]
      say__p=1;ParaContent(); (Resolver_5(t_0,"source", 564));ParaContent();  RunParagraphOn();  .L_Say173; .L_SayX157;
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_854, 854, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! First after informing somebody about something ( called the thread ):
[ R_853 
    t_0 ! Local variable e.g. 'thread' = object
    ;
   if ((action ==##A84_informing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && (t_0 = second, (((t_0=(second), true) && (second ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_853, 853);
      ! phrase 1
      ! [1: say ~[remove thread tell suggestion][run paragraph on]~]
      say__p=1;ParaContent(); (Resolver_6(t_0,"source", 560));ParaContent();  RunParagraphOn();  .L_Say174; .L_SayX158;
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_853, 853, true);
   rfalse;
];
! No specific request
! After touching desk in dim Staging Area:
[ R_1037 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == O126_metal_desk) && (true)) && ((real_location == O69_staging_area) && ((Adj_100_t1_v65(real_location))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1037, 1037);
      ! phrase 1
      ! [1: say ~You feel around the edge of the desk, and find that it has a drawer.~]
      say__p=1;ParaContent();  print (PrintText) SC_301;  new_line; .L_Say175; .L_SayX159;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1037, 1037, true);
   rfalse;
];
! No specific request
! After opening drawer in dim Staging Area:
[ R_1038 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == O127_drawer) && (true)) && ((real_location == O69_staging_area) && ((Adj_100_t1_v65(real_location))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1038, 1038);
      ! phrase 1
      ! [1: say ~You slide the drawer open by feel in the darkness. Something large and lumpy rolls around inside-- a flashlight?~]
      say__p=1;ParaContent();  print (PrintText) SC_302;  new_line; .L_Say176; .L_SayX160;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1038, 1038, true);
   rfalse;
];
! No specific request
! After taking flashlight in dim Staging Area:
[ R_1040 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O71_flashlight) && (true)) && ((real_location == O69_staging_area) && ((Adj_100_t1_v65(real_location))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1040, 1040);
      ! phrase 1
      ! [1: say ~Yeah, it's a flashlight all right. You grip it in sudden relief, turning it in your hands till your finger finds the switch.~]
      say__p=1;ParaContent();  print (PrintText) SC_303;  new_line; .L_Say177; .L_SayX161;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1040, 1040, true);
   rfalse;
];
! No specific request
! After going up during Sand-dancer's Arrival:
[ R_1208 ;
   if (scene_status-->9 == 1) { ! Runs only during scene
   if ((action ==##Go) &&  (actor==player) && ((noun == O18_up) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1208, 1208);
      ! phrase 1
      ! [1: say ~Barely able to reach the ladder through sand up to your waist, you haul yourself up the rungs and pull free just in time.~]
      say__p=1;ParaContent();  print (PrintText) SC_304;  new_line; .L_Say178; .L_SayX162;
      ! phrase 2
      ! [2: try looking]
       TryAction(0, player, ##Look, 0, 0);; 
      RulebookSucceeds(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1208, 1208, true);
   rfalse;
];
! No specific request
! After taking something required by a plan during Sand-dancer's Offer:
[ R_1220 ;blockv_stack-->(blockv_sp+2) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 3;
    blockv_stack-->(blockv_sp++) = R_SHELL_1(blockv_sp-3);
    blockv_sp = blockv_sp - 4;
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+3);
];
[ R_SHELL_1 I7BASPL 
    t_0 ! Local variable e.g. 'unclaimed things' = list of objects
    t_1 ! Local variable e.g. '?-1,-1?' = object
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ;
   if (scene_status-->10 == 1) { ! Runs only during scene
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && ((noun.p79_objective) ofclass K72_plan))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1220, 1220);
      ! phrase 1
      ! [1: now noun is handled]
       (Adj_64_t2_v65(noun)); 
      ! phrase 2
      ! [2: let unclaimed things be the list of things required by a plan]
       t_0 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_0,  LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+1)), Prop_20, OBJECT_TY) ); 
      ! phrase 3
      ! [3: remove the list of held things from unclaimed things]
       LIST_OF_TY_Remove_List(t_0,  LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+2)), Prop_21, OBJECT_TY) , 0); 
      ! phrase 4
      ! [4: repeat with item running through unclaimed things begin]
       for (t_2=1, t_1=LIST_OF_TY_GetItem(t_0, t_2, true): t_2<=LIST_OF_TY_GetLength(t_0): t_2++, t_1=LIST_OF_TY_GetItem(t_0, t_2, true))  {
                  ! phrase 5
         ! [5: now item is off-stage]
          (Adj_9_t3_v65(t_1)); 
         ! phrase 6
         ! [6: end repeat]
         }

            ! phrase 7
      ! [7: say ~As you take it, [unclaimed things with definite articles] sinks into the sand.[remove grab something other suggestion]~]
      say__p=1;ParaContent();  print (PrintText) SC_305; ParaContent();  LIST_OF_TY_Say(t_0, 2); ParaContent();  print (PrintText) SC_306;  new_line;ParaContent(); (PHR_832_r21 (O209_grab_something)); .L_Say179; .L_SayX163;
      ! phrase 8
      ! [8: try quizzing sand-dancer about final choice]
       TryAction(0, player, ##A83_quizzing_it_about, O168_sand_dancer, O210_final_choice);; 
      RulebookSucceeds(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1220, 1220, true);
   rfalse;
];
! No specific request
! After quizzing voice about introduction:
[ R_1091 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O172_voice) && (true)) && ((second == O184_introduction) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1091, 1091);
      ! phrase 1
      ! [1: say ~Not like you think anything's going to happen, but what the hell. You grab the dusty old mike, press the call button, and ask is there anybody[paragraph break]'...out there?' the speaker blurts and holy crap, someone's responding, and they say 'Roger roger, tower station nineteen, read you now loud and clear, what's your forty?' and the voice is staticky and whirled through with weird rhythmic distortions but you can hear it just fine and now what?[add what that means ask suggestion][add being lost tell suggestion][add never mind tell suggestion]~]
      say__p=1;ParaContent();  print (PrintText) SC_307; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_308;  new_line;ParaContent(); (PHR_834_r25 (O174_what_that_means));ParaContent(); (PHR_833_r26 (O175_being_lost));ParaContent(); (PHR_833_r26 (O173_never_mind)); .L_Say180; .L_SayX164;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1091, 1091, true);
   rfalse;
];
! No specific request
! After informing voice about never mind:
[ R_1092 ;
   if ((action ==##A84_informing_it_about) &&  (actor==player) && ((noun == O172_voice) && (true)) && ((second == O173_never_mind) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1092, 1092);
      ! phrase 1
      ! [1: say ~[remove what that means ask suggestion]You mutter something about how you think you've made a mistake and you have to go but the voice interrupts. 'Hang on, hang on, son, there shouldn't be anybody out there. Not at all, especially not this late. Why don't you tell me what's going on?'~]
      say__p=1;ParaContent(); (PHR_831_r23 (O174_what_that_means));ParaContent();  print (PrintText) SC_309;  new_line; .L_Say181; .L_SayX165;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1092, 1092, true);
   rfalse;
];
! No specific request
! After quizzing voice about what that means:
[ R_1093 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O172_voice) && (true)) && ((second == O174_what_that_means) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1093, 1093);
      ! phrase 1
      ! [1: say ~You try to make some joke about not having forty of anything, but the voice cuts you off. 'Ten forty means situation report, son. Obviously you're not on duty. Ain't nobody on duty out there anymore, specially not this time of night. What's going on?'~]
      say__p=1;ParaContent();  print (PrintText) SC_310;  new_line; .L_Say182; .L_SayX166;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1093, 1093, true);
   rfalse;
];
! No specific request
! After informing voice about being lost:
[ R_1094 ;
   if ((action ==##A84_informing_it_about) &&  (actor==player) && ((noun == O172_voice) && (true)) && ((second == O175_being_lost) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1094, 1094);
      ! phrase 1
      ! [1: say ~[remove what that means ask suggestion][remove never mind tell suggestion]Feeling a little stupid, you come clean and tell the voice that you drove off the road and aren't sure really exactly where you are.[paragraph break]'Copy that,' the voice says briskly after a moment. 'You're at tower station nineteen, son, about thirty-two miles southwest of Oro Oeste, fifteen miles or so from the state highway.' And if the mike wasn't attached to the radio you'd drop it on the floor. Fifteen miles? How in the [italic type]hell[roman type] could you have driven fifteen miles off the road and not remember? How is that even possible?[paragraph break]'Hello?' the radio says. 'Hello, son, do you copy?'[add yes-suggestion other suggestion][add switch-off-radio other suggestion]~]
      say__p=1;ParaContent(); (PHR_831_r23 (O174_what_that_means));ParaContent(); (PHR_830_r24 (O173_never_mind));ParaContent();  print (PrintText) SC_311; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_312; ParaContent();  style underline; ParaContent();  print (PrintText) SC_313; ParaContent();  style roman; ParaContent();  print (PrintText) SC_314; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_315;  new_line;ParaContent(); (PHR_835_r27 (O31_yes_suggestion));ParaContent(); (PHR_835_r27 (O176_switch_off_radio)); .L_Say183; .L_SayX167;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1094, 1094, true);
   rfalse;
];
! No specific request
! After informing voice about yes-suggestion:
[ R_1095 ;
   if ((action ==##A84_informing_it_about) &&  (actor==player) && ((noun == O172_voice) && (true)) && ((second == O31_yes_suggestion) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1095, 1095);
      ! phrase 1
      ! [1: say ~You jabber something positive and sit back, still shaken.[paragraph break][voice explains choices]?~]
      say__p=1;ParaContent();  print (PrintText) SC_316; ParaContent();  DivideParagraphPoint(); new_line; ParaContent(); (PHR_1097_r15 ());ParaContent();  print (PrintText) SC_151;  new_line; .L_Say184; .L_SayX168;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1095, 1095, true);
   rfalse;
];
! No specific request
! After quizzing the rabbit about introduction:
[ R_1138 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O184_introduction) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1138, 1138);
      ! phrase 1
      ! [1: say ~The rabbit breathes and stares. You wonder if it's going to start talking like in some crap disney movie and then jesus christ it does...[paragraph break]'So what'd you expect from an animal guardian?' it says, but like not with its lips, somewhere in your head instead. 'Were you thinking big, nasty, sharp, pointy teeth? Waistcoat and pocket watch? Nah. Tricks are for kids. What's up, Knock?' Its whiskers twitch.[add rabbit ask suggestion][add go insane other suggestion]~]
      say__p=1;ParaContent();  print (PrintText) SC_317; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_318;  new_line;ParaContent(); (PHR_834_r25 (O166_rabbit));ParaContent(); (PHR_835_r27 (O185_go_insane)); .L_Say185; .L_SayX169;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1138, 1138, true);
   rfalse;
];
! No specific request
! After quizzing the rabbit about the rabbit:
[ R_1139 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O166_rabbit) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1139, 1139);
      ! phrase 1
      ! [1: say ~[remove go insane other suggestion]'Oh come on, pal, you know me,' he says with this kind of stupid cheerful tone, and suddenly he looks more like Buster from Arthur, scrawny and poorly animated. 'I've been keeping an eye on you from the TV all these years. Your grandma asked me to, remember?' He grins, buck teeth protruding.[add grandma ask suggestion][add how he's not real tell suggestion]~]
      say__p=1;ParaContent(); (PHR_832_r21 (O185_go_insane));ParaContent();  print (PrintText) SC_319;  new_line;ParaContent(); (PHR_834_r25 (O186_grandma));ParaContent(); (PHR_833_r26 (O187_how_he_s_not_real)); .L_Say186; .L_SayX170;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1139, 1139, true);
   rfalse;
];
! No specific request
! After quizzing the rabbit about grandma:
[ R_1140 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O186_grandma) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1140, 1140);
      ! phrase 1
      ! [1: say ~'She was wrong about lots of stuff,' Buster says, scratching himself with a hind paw thoughtfully, 'but right about lots too. Oh, lots.'~]
      say__p=1;ParaContent();  print (PrintText) SC_320;  new_line; .L_Say187; .L_SayX171;
      ! phrase 2
      ! [2: try quizzing the rabbit about rabbit's judgment]
       TryAction(0, player, ##A83_quizzing_it_about, O166_rabbit, O188_rabbit_s_judgment);; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1140, 1140, true);
   rfalse;
];
! No specific request
! After informing the rabbit about how he's not real:
[ R_1141 ;
   if ((action ==##A84_informing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O187_how_he_s_not_real) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1141, 1141);
      ! phrase 1
      ! [1: say ~'Oh, don't say that!' the rabbit says, animated eyes going round like saucers. 'Then it'd be just you here all alone, and wouldn't that be boring. It's much more interesting if I'm really around.'~]
      say__p=1;ParaContent();  print (PrintText) SC_321;  new_line; .L_Say188; .L_SayX172;
      ! phrase 2
      ! [2: try quizzing the rabbit about rabbit's judgment]
       TryAction(0, player, ##A83_quizzing_it_about, O166_rabbit, O188_rabbit_s_judgment);; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1141, 1141, true);
   rfalse;
];
! No specific request
! After quizzing the rabbit about rabbit's judgment:
[ R_1142 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O188_rabbit_s_judgment) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1142, 1142);
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: say ~[one of][if count of pack of cigarettes is less than original cigarette count - 1]'Yo, you started smokin['] again?' Buster asks, sniffing disdainfully, except he's not Buster any more, more like Eminem. 'I thought you quit that shit, dawg. It's cool, I won't tell your grandma, but it makes Thumper cry a little, you know what I'm sayin[']?' [otherwise if at least 2 windows are open]'Yo, nice work breakin['] all those windows,' Buster says, except he's not Buster any more, more like Eminem. 'Way to stick it to the man. You hella bad, dawg. Maybe you can tag some shit when you get back to town too.' [otherwise]'Hey yo, you been hella good about keepin['] off those cancer sticks,' Buster says, except he's not Buster any more, more like Eminem. 'Don't think I ain't watchin['] ya.' [end if](Oh hey, Rabbit Smith, you get it.)[or]The rabbit just scratches his ear with a hind paw, smirking.[stopping][add how he knows so much about everything ask suggestion]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->10 =
	i7_soo_stop(I7_ST_say_one_of-->10, 2);
	switch((I7_ST_say_one_of-->10)%(2+1)-1) {
		0: 
	if (~~((((GProperty(OBJECT_TY, O39_pack_of_cigarettes,p17_count) <  ((Global_Vars-->26)-1) ))))) jump L_Say189;
		ParaContent();  print (PrintText) SC_322; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_323; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_324; ParaContent(); 
	jump L_SayX173; .L_Say189; if (~~(((Prop_22())))) jump L_Say190;
		ParaContent();  print (PrintText) SC_325; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_326; 
	jump L_SayX173; .L_Say190;
		ParaContent();  print (PrintText) SC_327; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_328; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_329; 
	.L_Say191; .L_SayX173;
		ParaContent();  print (PrintText) SC_330;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_331;  new_line;ParaContent();  } ParaContent(); (PHR_834_r25 (O189_how_he_knows_so_much_ab)); .L_Say192; .L_SayX174;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1142, 1142, true);
   rfalse;
];
! No specific request
! After quizzing the rabbit about how he knows so much about everything:
[ R_1143 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O189_how_he_knows_so_much_ab) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1143, 1143);
      ! phrase 1
      ! [1: say ~'Hey, back off, man,' he says, 'it's my ****in['] job.' And there's actually like a bleep, too, and now that you think of it you only ever saw 8 Mile on TV.~]
      say__p=1;ParaContent();  print (PrintText) SC_332; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_333;  new_line; .L_Say193; .L_SayX175;
      ! phrase 2
      ! [2: try quizzing rabbit about down to business]
       TryAction(0, player, ##A83_quizzing_it_about, O166_rabbit, O190_down_to_business);; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1143, 1143, true);
   rfalse;
];
! No specific request
! After quizzing the rabbit about down to business:
[ R_1144 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O190_down_to_business) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1144, 1144);
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: say ~'Anyway, look, man, we both know you're in trouble. I just gotta ask you one question.' And he changes again into like a giant silhouette, and it's the Playboy Bunny, ears and bow tie and all. 'Do you love her?'[add yes-no-suggestion other suggestion][add don't know if I love her other suggestion]~]
      say__p=1;ParaContent();  print (PrintText) SC_334;  new_line;ParaContent(); (PHR_835_r27 (O33_yes_no_suggestion));ParaContent(); (PHR_835_r27 (O191_don_t_know_if_i_love_he)); .L_Say194; .L_SayX176;
      ! phrase 3
      ! [3: move the bunny's bow tie to location]
       MoveObject(O56_bunny_s_bow_tie, real_location, 0, false); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1144, 1144, true);
   rfalse;
];
! No specific request
! After informing the rabbit about don't know if I love her:
[ R_1147 ;
   if ((action ==##A84_informing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O191_don_t_know_if_i_love_he) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1147, 1147);
      ! phrase 1
      ! [1: say ~'Yeah,' the bunny says, 'well this is the night to figure it out. Whether you decide to go home to her tonight or take care of yourself tonight might have consequences on a night with a storm like the one that's coming. Just sayin['].' It winks.~]
      say__p=1;ParaContent();  print (PrintText) SC_335; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_336;  new_line; .L_Say195; .L_SayX177;
      ! phrase 2
      ! [2: introduce rabbit's choices]
      (PHR_1148_r18 ());
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1147, 1147, true);
   rfalse;
];
! No specific request
! After quizzing the rabbit about strength:
[ R_1150 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O79_strength) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1150, 1150);
      ! phrase 1
      ! [1: say ~'Might be useful for surviving through the night,' he says, 'if that's what you're planning.'~]
      say__p=1;ParaContent();  print (PrintText) SC_337;  new_line; .L_Say196; .L_SayX178;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1150, 1150, true);
   rfalse;
];
! No specific request
! After quizzing the rabbit about courage:
[ R_1151 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O80_courage) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1151, 1151);
      ! phrase 1
      ! [1: say ~'You're going to need it to get home to Ocean,' he says, 'if that's what you want.'~]
      say__p=1;ParaContent();  print (PrintText) SC_338;  new_line; .L_Say197; .L_SayX179;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1151, 1151, true);
   rfalse;
];
! No specific request
! After quizzing the rabbit about more about trading:
[ R_1152 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O193_more_about_trading) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1152, 1152);
      ! phrase 1
      ! [1: say ~'You won't lose what you trade entirely,' he says, twitching his whiskers, 'but it will change, transverse, be resurrected as something else. Reborn.'~]
      say__p=1;ParaContent();  print (PrintText) SC_339;  new_line; .L_Say198; .L_SayX180;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1152, 1152, true);
   rfalse;
];
! No specific request
! After informing the rabbit about you don't want to trade:
[ R_1153 ;
   if ((action ==##A84_informing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O196_you_don_t_want_to_trade) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1153, 1153);
      ! phrase 1
      ! [1: say ~[remove you don't want to trade other suggestion]'I came all this way to help you,' the rabbit says, 'I'm even missing the big parade,' and it wiggles its tail with a smell of sugar and frosting. 'I think we'd better make a trade.'~]
      say__p=1;ParaContent(); (PHR_832_r21 (O196_you_don_t_want_to_trade));ParaContent();  print (PrintText) SC_340;  new_line; .L_Say199; .L_SayX181;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1153, 1153, true);
   rfalse;
];
! No specific request
! After quizzing the rabbit about more coming:
[ R_1156 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O166_rabbit) && (true)) && ((second == O198_more_coming) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1156, 1156);
      ! phrase 1
      ! [1: say ~'The others are coming,' he says, 'they'll be here soon,' and now he looks like Frank from Donnie Darko and his face is behind that freaky metal mask and his voice is distorted and makes your skin crawl.[paragraph break]'Watch out for them,' he says. 'We all want to help, but... the others are wilier than me. Look up.'[paragraph break]'Look up, Naki,' he says again.~]
      say__p=1;ParaContent();  print (PrintText) SC_341; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_342; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_343;  new_line; .L_Say200; .L_SayX182;
      ! phrase 2
      ! [2: now lookup-suggestion is familiar]
       (Adj_90_t2_v65(O199_lookup_suggestion)); 
      ! phrase 3
      ! [3: reset the interlocutor]
      (PHR_765_r3 ());
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1156, 1156, true);
   rfalse;
];
! No specific request
! After quizzing Coyote about introduction:
[ R_1178 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O167_coyote) && (true)) && ((second == O184_introduction) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1178, 1178);
      ! phrase 1
      ! [1: say ~He wears a couple days of stubble, a scuffed and [faded denim jacket], and, ridiculously in the darkness, a pair of cheap [sunglasses]. He lights a [cigarette], then holds up a hand in annoyance to block your flashlight beam. 'Turn that thing off,' he says, and either you do it or it goes off by itself, because the next thing you know it's darker and he's closer and the only light comes from the red glow of the cigarette.[paragraph break]'That's better,' he says. He takes a drag on the cigarette, then pulls another from behind his ear and offers it to you. 'Smoke?'[add yes-no-suggestion other suggestion]~]
      say__p=1;ParaContent();  print (PrintText) SC_344; ParaContent();  print (PrintShortName) O179_faded_denim_jacket; ParaContent();  print (PrintText) SC_345; ParaContent();  print (PrintShortName) O178_sunglasses; ParaContent();  print (PrintText) SC_346; ParaContent();  print (PrintShortName) O177_cigarette; ParaContent();  print (PrintText) SC_347; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_348;  new_line;ParaContent(); (PHR_835_r27 (O33_yes_no_suggestion)); .L_Say201; .L_SayX183;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1178, 1178, true);
   rfalse;
];
! No specific request
! After quizzing the Coyote about advice:
[ R_1189 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O167_coyote) && (true)) && ((second == O203_advice) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1189, 1189);
      ! phrase 1
      ! [1: say ~He laughs, [Coyote-business]. 'Kid,' he says, 'you don't want my advice. I could tell you some stories and you'll smile and be sure they'll never happen to you. I could tell you some stories and you'll yawn and think you know them already. I could tell you some stories and you'll think they're wise and not realize you don't understand them until you make the same mistakes yourself and try to turn your failure into advice and fail at that, too. I could tell you some stories.' He looks off towards the horizon, [Coyote-business]. 'But it's not my stories that will help you.'~]
      say__p=1;ParaContent();  print (PrintText) SC_349; ParaContent(); (PHR_1188_r29 ());ParaContent();  print (PrintText) SC_350; ParaContent(); (PHR_1188_r29 ());ParaContent();  print (PrintText) SC_351;  new_line; .L_Say202; .L_SayX184;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1189, 1189, true);
   rfalse;
];
! No specific request
! After quizzing Coyote about Coyote:
[ R_1190 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O167_coyote) && (true)) && ((second == O167_coyote) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1190, 1190);
      ! phrase 1
      ! [1: say ~'You know who I am,' he says, [Coyote-business]. 'I'm the one who runs on both sides of the fence. I'm the one who scouts ahead. I'm the one with songs in my blood and dirt under my nails and people owe me money in every trailer park town from here to Yuma, or maybe I owe them money but anyway they don't want to see me. You know who I am, Knock.'~]
      say__p=1;ParaContent();  print (PrintText) SC_352; ParaContent(); (PHR_1188_r29 ());ParaContent();  print (PrintText) SC_353;  new_line; .L_Say203; .L_SayX185;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1190, 1190, true);
   rfalse;
];
! No specific request
! After quizzing Coyote about the rabbit:
[ R_1191 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O167_coyote) && (true)) && ((second == O166_rabbit) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1191, 1191);
      ! phrase 1
      ! [1: say ~He grins, not unkindly but not exactly kindly either. 'That cute little jackalope?' he says, [Coyote-business]. 'He's got his upsides, I guess. [if player holds strength]Strength[otherwise]Bravery[end if] has its place. But if you're always in the spotlight, you'll never learn how to live in the shadows. And most of us spend a lot of time in the shadows.'~]
      say__p=1;ParaContent();  print (PrintText) SC_354; ParaContent(); (PHR_1188_r29 ());ParaContent();  print (PrintText) SC_355; 
	if (~~((((player == HolderOf(O79_strength)))))) jump L_Say204;
		ParaContent();  print (PrintText) SC_356; 
	jump L_SayX186; .L_Say204;
		ParaContent();  print (PrintText) SC_357; 
	.L_Say205; .L_SayX186;
		ParaContent();  print (PrintText) SC_358;  new_line; .L_Say206; .L_SayX187;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1191, 1191, true);
   rfalse;
];
! No specific request
! After quizzing Coyote about down to business:
[ R_1192 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O167_coyote) && (true)) && ((second == O190_down_to_business) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1192, 1192);
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: move luck to location]
       MoveObject(O81_luck, real_location, 0, false); 
      ! phrase 3
      ! [3: now luck is familiar]
       (Adj_90_t2_v65(O81_luck)); 
      ! phrase 4
      ! [4: move scent to location]
       MoveObject(O82_scent, real_location, 0, false); 
      ! phrase 5
      ! [5: now scent is familiar]
       (Adj_90_t2_v65(O82_scent)); 
      ! phrase 6
      ! [6: say ~He presses his hands together, still clutching the cigarette with thumb and index finger, and smoke rises past his hidden eyes as he slowly rubs his palms together. He mutters something rhythmic to himself and you realize it's a song, and you can't quite make out the lyrics but the melody is simple and makes you think of Johnny Cash and the end of the world. And then he stops, and pulls his hands apart, and in each he holds a talent.[paragraph break]'Here we have luck,' he says, bobbing the left, 'and scent. And look, I'll be straight with you. These are precious things and I can't afford whatever blue light special deal the bunny gave you. I need double his price. I need two memories to part with one of these. Oh, they're worth it, believe me. Both have saved my ass more times than you'd believe. Both could save yours. But it's up to you. Which'll it be?'[add luck ask suggestion][add scent ask suggestion][add trade-for-luck other suggestion][add trade-for-scent other suggestion][add take-inventory other suggestion]~]
      say__p=1;ParaContent();  print (PrintText) SC_359; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_360;  new_line;ParaContent(); (PHR_834_r25 (O81_luck));ParaContent(); (PHR_834_r25 (O82_scent));ParaContent(); (PHR_835_r27 (O204_trade_for_luck));ParaContent(); (PHR_835_r27 (O205_trade_for_scent));ParaContent(); (PHR_835_r27 (O197_take_inventory)); .L_Say207; .L_SayX188;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1192, 1192, true);
   rfalse;
];
! No specific request
! After quizzing Coyote about luck:
[ R_1193 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O167_coyote) && (true)) && ((second == O81_luck) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1193, 1193);
      ! phrase 1
      ! [1: say ~[if player holds strength]'Looks like you're already pretty tough,' he says appraisingly, looking you over. 'With a little luck, you ought to make it through the night and get on with the rest of your life.'[otherwise]'You found some cojones, kid,' he says, looking you over appraisingly, 'which'll be good for fixing your truck and getting back to your girl. I don't know if luck'll help you out much there, though.'~]
      say__p=1;
	if (~~((((player == HolderOf(O79_strength)))))) jump L_Say208;
		ParaContent();  print (PrintText) SC_361;  new_line;
	jump L_SayX189; .L_Say208;
		ParaContent();  print (PrintText) SC_362;  new_line; .L_Say209; .L_SayX189;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1193, 1193, true);
   rfalse;
];
! No specific request
! After quizzing Coyote about scent:
[ R_1194 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O167_coyote) && (true)) && ((second == O82_scent) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1194, 1194);
      ! phrase 1
      ! [1: say ~[if player holds courage]'You found some cojones, kid,' he says, 'If you can just sniff out the right finds, you can probably get back to that little lady you're so fond of, if that's what you want.'[otherwise]'You're pretty tough,' he says, 'but I don't know that a good nose is going to help you make it through the night and get on with the rest of your life, if that's what you're trying to do.'~]
      say__p=1;
	if (~~((((player == HolderOf(O80_courage)))))) jump L_Say210;
		ParaContent();  print (PrintText) SC_363;  new_line;
	jump L_SayX190; .L_Say210;
		ParaContent();  print (PrintText) SC_364;  new_line; .L_Say211; .L_SayX190;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1194, 1194, true);
   rfalse;
];
! No specific request
! After quizzing Coyote about more coming:
[ R_1196 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O167_coyote) && (true)) && ((second == O198_more_coming) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1196, 1196);
      ! phrase 1
      ! [1: say ~He tucks the other talent back in his jacket, and without its faint glow it seems darker than ever, the pulsing red tip of his cigarette all you can see.[paragraph break]'The last of us is coming,' Coyote's voice says out of the black, 'last and most powerful, and most dangerous, and most afraid. Sand-dancer. Be careful of him, Knock. [if player holds strength]Stay strong[otherwise]Stay brave[end if]. [if player holds luck]Stay lucky[otherwise]Keep your nose to the wind[end if]. Remember the shadows.'[paragraph break]And it seems like he's growing, larger and larger, the red tip of his cigarette pulsing and glowing now high up in the sky, and you stumble back, shivering, and suddenly remember your flashlight in your hand and switch it on...~]
      say__p=1;ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366; 
	if (~~((((player == HolderOf(O79_strength)))))) jump L_Say212;
		ParaContent();  print (PrintText) SC_367; 
	jump L_SayX191; .L_Say212;
		ParaContent();  print (PrintText) SC_368; 
	.L_Say213; .L_SayX191;
		ParaContent();  print (PrintText) SC_140; 
	if (~~((((player == HolderOf(O81_luck)))))) jump L_Say214;
		ParaContent();  print (PrintText) SC_369; 
	jump L_SayX192; .L_Say214;
		ParaContent();  print (PrintText) SC_370; 
	.L_Say215; .L_SayX192;
		ParaContent();  print (PrintText) SC_371; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_372;  new_line; .L_Say216; .L_SayX193;
      ! phrase 2
      ! [2: reset the interlocutor]
      (PHR_765_r3 ());
      ! phrase 3
      ! [3: now flashlight is switched on]
       (Adj_84_t2_v65(O71_flashlight)); 
      ! phrase 4
      ! [4: move player to base of the tower]
       MoveObject(player, O70_base_of_the_tower, 0, false); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1196, 1196, true);
   rfalse;
];
! No specific request
! After quizzing Sand-dancer about introduction:
[ R_1213 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O184_introduction) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1213, 1213);
      ! phrase 1
      ! [1: say ~The lizard's tongue snakes through the air, tasting it, tasting you. One slitted eye studies you intently. It pauses, as if waiting for you to say something.[add hello other suggestion][add Sand-dancer ask suggestion][add thousands of lizards ask suggestion]~]
      say__p=1;ParaContent();  print (PrintText) SC_373;  new_line;ParaContent(); (PHR_835_r27 (O207_hello));ParaContent(); (PHR_834_r25 (O168_sand_dancer));ParaContent(); (PHR_834_r25 (O206_thousands_of_lizards)); .L_Say217; .L_SayX194;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1213, 1213, true);
   rfalse;
];
! No specific request
! After quizzing Sand-dancer about Sand-dancer:
[ R_1215 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O168_sand_dancer) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1215, 1215);
      ! phrase 1
      ! [1: say ~[remove hello other suggestion]'I am Sand-dancer,' he breathes, [SD-business]. 'I am the desert and the dust and the rain and the wind. I was there the first time you went hungry and the first time you made love and the last time you asked for help, but I could not help you then. But tonight, Nakaibito, tonight I can.'~]
      say__p=1;ParaContent(); (PHR_832_r21 (O207_hello));ParaContent();  print (PrintText) SC_374; ParaContent(); (PHR_1211_r22 ());ParaContent();  print (PrintText) SC_375;  new_line; .L_Say218; .L_SayX195;
      ! phrase 2
      ! [2: try quizzing sand-dancer about final choice]
       TryAction(0, player, ##A83_quizzing_it_about, O168_sand_dancer, O210_final_choice);; 
      ! phrase 3
      ! [3: now sand-dancer is named]
       (Adj_104_t2_v65(O168_sand_dancer)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1215, 1215, true);
   rfalse;
];
! No specific request
! After quizzing Sand-dancer about thousands of lizards:
[ R_1216 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O206_thousands_of_lizards) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1216, 1216);
      ! phrase 1
      ! [1: say ~[remove hello other suggestion]The lizards hiss and writhe as you ask, almost as if they are laughing. 'Little sand-dancers,' he says, [SD-business], 'they come with me wherever I go. They will not bother you.'~]
      say__p=1;ParaContent(); (PHR_832_r21 (O207_hello));ParaContent();  print (PrintText) SC_376; ParaContent(); (PHR_1211_r22 ());ParaContent();  print (PrintText) SC_377;  new_line; .L_Say219; .L_SayX196;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1216, 1216, true);
   rfalse;
];
! No specific request
! After quizzing Sand-dancer about path selection:
[ R_1218 ;blockv_stack-->(blockv_sp+2) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 3;
    blockv_stack-->(blockv_sp++) = R_SHELL_2(blockv_sp-3);
    blockv_sp = blockv_sp - 4;
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+3);
];
[ R_SHELL_2 I7BASPL 
    t_0 ! Local variable e.g. 'unclaimed things' = list of objects
    t_1 ! Local variable e.g. '?-1,-1?' = object
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O208_path_selection) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1218, 1218);
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: say ~'Much has happened tonight. You've made bargains and plans. [Sand-dancer talent summary]But these things together do not help you. No, you still haven't decided.' The lizard stares at you with one eye, [SD-business]. 'But now is the time.'[paragraph break]~]
      say__p=1;ParaContent();  print (PrintText) SC_378; ParaContent(); (PHR_1219_r30 ());ParaContent();  print (PrintText) SC_379; ParaContent(); (PHR_1211_r22 ());ParaContent();  print (PrintText) SC_380; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say220; .L_SayX197;
      ! phrase 3
      ! [3: let unclaimed things be the list of things required by a plan]
       t_0 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_0,  LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+1)), Prop_23, OBJECT_TY) ); 
      ! phrase 4
      ! [4: remove the list of held things from unclaimed things]
       LIST_OF_TY_Remove_List(t_0,  LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+2)), Prop_24, OBJECT_TY) , 0); 
      ! phrase 5
      ! [5: repeat with item running through unclaimed things begin]
       for (t_2=1, t_1=LIST_OF_TY_GetItem(t_0, t_2, true): t_2<=LIST_OF_TY_GetLength(t_0): t_2++, t_1=LIST_OF_TY_GetItem(t_0, t_2, true))  {
                  ! phrase 6
         ! [6: now item is in location]
          MoveObject(t_1,real_location); 
         ! phrase 7
         ! [7: end repeat]
         }

            ! phrase 8
      ! [8: say ~The ground shudders and shifts beneath you, and out of the sand rise [unclaimed things with indefinite articles].[paragraph break]'The tape and the gas can will return you to her. The blanket and the can of food will look out for you. Take one.'[add grab something other suggestion]~]
      say__p=1;ParaContent();  print (PrintText) SC_381; ParaContent();  LIST_OF_TY_Say(t_0, 3); ParaContent();  print (PrintText) SC_77; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_382;  new_line;ParaContent(); (PHR_835_r27 (O209_grab_something)); .L_Say221; .L_SayX198;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1218, 1218, true);
   rfalse;
];
! No specific request
! After quizzing Sand-dancer about final choice:
[ R_1221 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O210_final_choice) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1221, 1221);
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: say ~'By your actions and through your talents, you have chosen [a random complete plan],' he says, [SD-business]. 'You have looked into yourself and found your story, the path you will walk tomorrow.'[paragraph break]He breathes. 'And are you happy with your story?' he asks, and there's some dangerous undertone to the question and you don't know why. The lizards tense, quivering, twisting their little heads back and forth as they await your answer.[add yes-no-suggestion other suggestion][add not sure if I'm happy other suggestion]~]
      say__p=1;ParaContent();  print (PrintText) SC_383; ParaContent();  print (a)  (Prop_25()) ; ParaContent();  print (PrintText) SC_384; ParaContent(); (PHR_1211_r22 ());ParaContent();  print (PrintText) SC_385; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_386;  new_line;ParaContent(); (PHR_835_r27 (O33_yes_no_suggestion));ParaContent(); (PHR_835_r27 (O211_not_sure_if_i_m_happy)); .L_Say222; .L_SayX199;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1221, 1221, true);
   rfalse;
];
! No specific request
! After informing Sand-dancer about not sure if I'm happy:
[ R_1225 ;
   if ((action ==##A84_informing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O211_not_sure_if_i_m_happy) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1225, 1225);
      ! phrase 1
      ! [1: say ~The lizard turns his head sharply, and all the lizards in the desert around writhe angrily, clawing and biting at each other in agitation. 'And when will you know, Knock?' the lizard asks. 'When will you own your life? When will you become a man? Tonight. It must be tonight.'~]
      say__p=1;ParaContent();  print (PrintText) SC_387;  new_line; .L_Say223; .L_SayX200;
      ! phrase 2
      ! [2: try quizzing sand-dancer about doing the trade]
       TryAction(0, player, ##A83_quizzing_it_about, O168_sand_dancer, O212_doing_the_trade);; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1225, 1225, true);
   rfalse;
];
! No specific request
! After quizzing Sand-dancer about doing the trade:
[ R_1226 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O212_doing_the_trade) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1226, 1226);
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: if staying the night is complete , now spirit is in location]
       if ((((Adj_42_t1_v65(O73_staying_the_night))))) {  MoveObject(O84_spirit,real_location);   }
      ! phrase 3
      ! [3: otherwise now honor is in location]
       else {  MoveObject(O83_honor,real_location);   }
      ! phrase 4
      ! [4: now freedom is in location]
       MoveObject(O85_freedom,real_location); 
      ! phrase 5
      ! [5: now spirit is familiar]
       (Adj_90_t2_v65(O84_spirit)); 
      ! phrase 6
      ! [6: now honor is familiar]
       (Adj_90_t2_v65(O83_honor)); 
      ! phrase 7
      ! [7: now freedom is familiar]
       (Adj_90_t2_v65(O85_freedom)); 
      ! phrase 8
      ! [8: say ~A glistening egg rises from the sand, glowing with neon potential, and the lizard glances down at it almost dismissively. 'This is [if staying the night is complete]spirit[otherwise]honor[end if],' he says, 'the last talent you need to achieve your goal, and you can have it for three memories. But perhaps I have something else to trade.'[paragraph break]The lizards whisper in anticipation as a second egg rises. This one's bigger, and almost blinding with its intensity, and the lizards draw back, chittering in awe and amazement. 'This,' Sand-dancer says, 'is freedom. Pure, undiluted, and absolute. Many crave it and few get a chance to take it. I offer it to you, Nakaibito, but it does not come cheaply.' He grins. 'For freedom, you must give up everything. You must give me all your memories.'[paragraph break]The lizards begin to circle restlessly as they wait for you to choose. Sand-dancer merely watches, and waits.[if spirit is visible][add spirit ask suggestion][add trade-for-spirit other suggestion][otherwise][add honor ask suggestion][add trade-for-honor other suggestion][end if][add freedom ask suggestion][add trade-for-freedom other suggestion]~]
      say__p=1;ParaContent();  print (PrintText) SC_388; 
	if (~~(((((Adj_42_t1_v65(O73_staying_the_night))))))) jump L_Say224;
		ParaContent();  print (PrintText) SC_389; 
	jump L_SayX201; .L_Say224;
		ParaContent();  print (PrintText) SC_390; 
	.L_Say225; .L_SayX201;
		ParaContent();  print (PrintText) SC_391; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_392; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_393;  new_line;
	if (~~(((((Adj_3_t1_v65(O84_spirit))))))) jump L_Say226;
		ParaContent(); (PHR_834_r25 (O84_spirit));ParaContent(); (PHR_835_r27 (O214_trade_for_spirit));
	jump L_SayX202; .L_Say226;
		ParaContent(); (PHR_834_r25 (O83_honor));ParaContent(); (PHR_835_r27 (O213_trade_for_honor));
	.L_Say227; .L_SayX202;
		ParaContent(); (PHR_834_r25 (O85_freedom));ParaContent(); (PHR_835_r27 (O215_trade_for_freedom)); .L_Say228; .L_SayX203;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1226, 1226, true);
   rfalse;
];
! No specific request
! After quizzing Sand-dancer about spirit:
[ R_1227 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O84_spirit) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1227, 1227);
      ! phrase 1
      ! [1: say ~'You have the warmth and energy you need to stay through the night,' he says, 'but to continue looking out for yourself, you will need spirit.'~]
      say__p=1;ParaContent();  print (PrintText) SC_394;  new_line; .L_Say229; .L_SayX204;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1227, 1227, true);
   rfalse;
];
! No specific request
! After quizzing Sand-dancer about honor:
[ R_1228 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O83_honor) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1228, 1228);
      ! phrase 1
      ! [1: say ~'You have the tools to fix your truck,' he says, 'but to return to Ocean and stand by her side you will need honor.'~]
      say__p=1;ParaContent();  print (PrintText) SC_395;  new_line; .L_Say230; .L_SayX205;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1228, 1228, true);
   rfalse;
];
! No specific request
! After quizzing Sand-dancer about freedom:
[ R_1229 ;
   if ((action ==##A83_quizzing_it_about) &&  (actor==player) && ((noun == O168_sand_dancer) && (true)) && ((second == O85_freedom) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1229, 1229);
      ! phrase 1
      ! [1: say ~'With freedom, Nakaibito, you can make your troubles vanish. True freedom is the power of unmaking the past, of undoing what's done and regretted. This power is great and terrible, but I promise you.' He flicks his tongue. 'It will set you free.'~]
      say__p=1;ParaContent();  print (PrintText) SC_396;  new_line; .L_Say231; .L_SayX206;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1229, 1229, true);
   rfalse;
];
! No specific request
! After opening the pickup truck:
[ R_988 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == O42_pickup_truck) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_988, 988);
      ! phrase 1
      ! [1: say ~The door creaks open with difficulty, rusted joints straining.~]
      say__p=1;ParaContent();  print (PrintText) SC_397;  new_line; .L_Say232; .L_SayX207;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_988, 988, true);
   rfalse;
];
! No specific request
! After closing the truck:
[ R_989 ;
   if ((action ==##Close) &&  (actor==player) && ((noun == O42_pickup_truck) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_989, 989);
      ! phrase 1
      ! [1: say ~You slam the door shut.~]
      say__p=1;ParaContent();  print (PrintText) SC_398;  new_line; .L_Say233; .L_SayX208;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_989, 989, true);
   rfalse;
];
! No specific request
! After switching on the headlights:
[ R_993 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == O95_headlights) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_993, 993);
      ! phrase 1
      ! [1: now every within range of headlights room is lighted]
       Prop_26(); 
      ! phrase 2
      ! [2: say ~The desert springs into existence around you.~]
      say__p=1;ParaContent();  print (PrintText) SC_399;  new_line; .L_Say234; .L_SayX209;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_993, 993, true);
   rfalse;
];
! No specific request
! After switching off the headlights:
[ R_994 ;
   if ((action ==##SwitchOff) &&  (actor==player) && ((noun == O95_headlights) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_994, 994);
      ! phrase 1
      ! [1: if emergency lights are switched off , now every within range of headlights room is dark]
       if ((((Adj_85_t1_v65(O131_emergency_lights))))) {  Prop_27();   }
      ! phrase 2
      ! [2: say ~You click the headlights off[if emergency lights are switched off and flashlight is switched off] and blackness swallows you up[otherwise if emergency lights are switched off and flashlight is switched on and flashlight is visible], leaving only the ghostly beam of your flashlight[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_400; 
	if (~~((((((Adj_85_t1_v65(O131_emergency_lights))))) && ((((Adj_85_t1_v65(O71_flashlight)))))))) jump L_Say235;
		ParaContent();  print (PrintText) SC_401; ParaContent(); 
	jump L_SayX210; .L_Say235; if (~~((((((Adj_85_t1_v65(O131_emergency_lights))))) && (((((Adj_84_t1_v65(O71_flashlight))))) && ((((Adj_3_t1_v65(O71_flashlight))))))))) jump L_Say236;
		ParaContent();  print (PrintText) SC_402; 
	.L_Say236; .L_SayX210;
		ParaContent();  print (PrintText) SC_77;  new_line; .L_Say237; .L_SayX211;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_994, 994, true);
   rfalse;
];
! No specific request
! After switching on radio:
[ R_1017 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == O118_emergency_radio) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1017, 1017);
      ! phrase 1
      ! [1: say ~You flip a bulky switch on the radio's side. A hiss of static pours from the speakers[one of], like tons of sand sliding over metal[or][stopping][if frequency tuned to of radio is emergency frequency], then quickly resolves into nothing more than a quiet hum[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_403; ParaContent();  I7_ST_say_one_of-->11 =
	i7_soo_stop(I7_ST_say_one_of-->11, 2);
	switch((I7_ST_say_one_of-->11)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_404; ParaContent();  @nop; 1: ParaContent();  } 
	if (~~((((GProperty(OBJECT_TY, O118_emergency_radio,p18_frequency_tuned_to) == (Global_Vars-->27)))))) jump L_Say238;
		ParaContent();  print (PrintText) SC_405; 
	.L_Say238; .L_SayX212;
		ParaContent();  print (PrintText) SC_77;  new_line; .L_Say239; .L_SayX213;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1017, 1017, true);
   rfalse;
];
! No specific request
! After taking the duct tape:
[ R_1031 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == O76_roll_of_duct_tape) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1031, 1031);
      ! phrase 1
      ! [1: say ~[one of]You reach down into the hole[if cobwebs are on-stage], brushing the cobwebs away impatiently,[end if] and pull out the duct tape.[or]Taken.[stopping]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->12 =
	i7_soo_stop(I7_ST_say_one_of-->12, 2);
	switch((I7_ST_say_one_of-->12)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_406; 
	if (~~(((((Adj_9_t1_v65(O125_cobwebs))))))) jump L_Say240;
		ParaContent();  print (PrintText) SC_407; 
	.L_Say240; .L_SayX214;
		ParaContent();  print (PrintText) SC_408;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_409;  new_line;ParaContent();  }  .L_Say241; .L_SayX215;
      ! phrase 2
      ! [2: now cobwebs are off-stage]
       (Adj_9_t3_v65(O125_cobwebs)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1031, 1031, true);
   rfalse;
];
! No specific request
! After switching on flashlight:
[ R_1042 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == O71_flashlight) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1042, 1042);
      ! phrase 1
      ! [1: say ~Your surroundings spring into brightness around you.~]
      say__p=1;ParaContent();  print (PrintText) SC_410;  new_line; .L_Say242; .L_SayX216;
      ! phrase 2
      ! [2: try looking]
       TryAction(0, player, ##Look, 0, 0);; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1042, 1042, true);
   rfalse;
];
! No specific request
! After switching on the emergency lights:
[ R_1046 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == O131_emergency_lights) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1046, 1046);
      ! phrase 1
      ! [1: now every room regionally in tower vicinity is lighted]
       Prop_28(); 
      ! phrase 2
      ! [2: say ~With a sharp buzz, a whiff of static and an electrical groan, bare light bulbs flicker on throughout the building.~]
      say__p=1;ParaContent();  print (PrintText) SC_411;  new_line; .L_Say243; .L_SayX217;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1046, 1046, true);
   rfalse;
];
! No specific request
! After switching off the emergency lights:
[ R_1047 ;
   if ((action ==##SwitchOff) &&  (actor==player) && ((noun == O131_emergency_lights) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1047, 1047);
      ! phrase 1
      ! [1: now every room regionally in tower vicinity is dark]
       Prop_29(); 
      ! phrase 2
      ! [2: if headlights are switched on begin]
       if ((((Adj_84_t1_v65(O95_headlights)))))  {
         ! phrase 3
         ! [3: now every within range of headlights room is lighted]
          Prop_30(); 
         ! phrase 4
         ! [4: say ~The lights die out, except for a ghostly glow from outside that must be your headlights.~]
         say__p=1;ParaContent();  print (PrintText) SC_412;  new_line; .L_Say244; .L_SayX218;
         ! phrase 5
         ! [5: otherwise if flashlight is switched on and flashlight is visible]
          } else if (((((Adj_84_t1_v65(O71_flashlight))))) && ((((Adj_3_t1_v65(O71_flashlight)))))) { 
         ! phrase 6
         ! [6: say ~The lights die out, leaving only the beam of your flashlight.~]
         say__p=1;ParaContent();  print (PrintText) SC_413;  new_line; .L_Say245; .L_SayX219;
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~The lights flicker and die out~]
         say__p=1;ParaContent();  print (PrintText) SC_414;  .L_Say246; .L_SayX220;
         ! phrase 9
         ! [9: if player holds courage begin]
          if (((player == HolderOf(O80_courage))))  {
            ! phrase 10
            ! [10: say ~, but you are not afraid~]
            say__p=1;ParaContent();  print (PrintText) SC_415;  .L_Say247; .L_SayX221;
            ! phrase 11
            ! [11: end if]
            }

         ! phrase 12
         ! [12: say ~.~]
         say__p=1;ParaContent();  print (PrintText) SC_77;  new_line; .L_Say248; .L_SayX222;
         ! phrase 13
         ! [13: end if]
         }

      ! phrase 14
      ! [14: say ~[line break]The generator whines as it powers off, slowly falling silent.~]
      say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_416;  new_line; .L_Say249; .L_SayX223;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1047, 1047, true);
   rfalse;
];
! No specific request
! After wearing blanket:
[ R_1060 ;
   if ((action ==##Wear) &&  (actor==player) && ((noun == O74_emergency_blanket) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1060, 1060);
      ! phrase 1
      ! [1: say ~You wrap it around your shoulders, and soon your shivering stops.~]
      say__p=1;ParaContent();  print (PrintText) SC_417;  new_line; .L_Say250; .L_SayX224;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1060, 1060, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! After listing suggested topics:
[ R_856 ;
   if ((action ==##A93_listing_suggested_topics) &&  (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_856, 856);
      ! phrase 1
      ! [1: say ~[roman type][run paragraph on]~]
      say__p=1;ParaContent();  style roman; ParaContent();  RunParagraphOn();  .L_Say251; .L_SayX225;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_856, 856, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: does the player mean (B26_does_the_player_mean)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/2 ! Does the player mean doing something to a memory:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
[ R_36 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (player == CarrierOf(noun)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_36, 36);
      ! phrase 1
      ! [1: it is very unlikely]
      RulebookSucceeds(true, RBNO_10); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_36, 36, true);
   rfalse;
];
! No specific request
! Does the player mean doing something to a memory:
[ R_926 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun ofclass K43_memory))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_926, 926);
      ! phrase 1
      ! [1: it is unlikely]
      RulebookSucceeds(true, RBNO_9); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_926, 926, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the name (B29_before_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Before printing the name of cobwebs when player holds courage:
!   === which is equally specific with ===
! Rule 2/4 ! Before printing the name of cage when player holds strength:
!   === which is equally specific with ===
! Rule 3/4 ! Before printing the name of piece of jade when player holds luck:
!   >>> I - Number of aspects constrained >>>
! Rule 4/4 ! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Before printing the name of cobwebs when player holds courage:
[ R_959 ;
   if (((parameter_object == O125_cobwebs) && (true))) { ! Runs only when pattern matches
   if ((((((player == HolderOf(O80_courage))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_959, 959);
      ! phrase 1
      ! [1: say ~hardly noticeable ~]
      say__p=1;ParaContent();  print (PrintText) SC_418;  .L_Say252; .L_SayX226;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_959, 959, true);
   rfalse;
];
! No specific request
! Before printing the name of cage when player holds strength:
[ R_960 ;
   if (((parameter_object == O140_wire_mesh_cage) && (true))) { ! Runs only when pattern matches
   if ((((((player == HolderOf(O79_strength))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_960, 960);
      ! phrase 1
      ! [1: say ~flimsy-looking ~]
      say__p=1;ParaContent();  print (PrintText) SC_419;  .L_Say253; .L_SayX227;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_960, 960, true);
   rfalse;
];
! No specific request
! Before printing the name of piece of jade when player holds luck:
[ R_961 ;
   if (((parameter_object == O52_piece_of_jade) && (true))) { ! Runs only when pattern matches
   if ((((((player == HolderOf(O81_luck))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_961, 961);
      ! phrase 1
      ! [1: say ~lucky ~]
      say__p=1;ParaContent();  print (PrintText) SC_420;  .L_Say254; .L_SayX228;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_961, 961, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
[ R_58 
    t_0 ! Local variable e.g. 'item being printed' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_58, 58);
      ! phrase 1
      ! [1: now the item being printed is mentioned]
       (Adj_69_t2_v65(t_0)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_58, 58, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the name (B30_for_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! For printing the name of canned oranges while canned oranges are off-stage:
!   === which is equally specific with ===
! Rule 2/3 ! For printing the name of gas can while gas can is off-stage:
! --- now the last-placed rules ---
! Rule 3/3: STANDARD_NAME_PRINTING_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! For printing the name of canned oranges while canned oranges are off-stage:
[ R_957 ;
   if (((parameter_object == O75_canned_oranges) && (true))) { ! Runs only when pattern matches
   if (((((((~~Adj_9_t1_v65(O75_canned_oranges)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_957, 957);
      ! phrase 1
      ! [1: say ~food~]
      say__p=1;ParaContent();  print (PrintText) SC_421;  .L_Say255; .L_SayX229;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_957, 957, true);
   rfalse;
];
! No specific request
! For printing the name of gas can while gas can is off-stage:
[ R_958 ;
   if (((parameter_object == O60_gas_can) && (true))) { ! Runs only when pattern matches
   if (((((((~~Adj_9_t1_v65(O60_gas_can)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_958, 958);
      ! phrase 1
      ! [1: say ~gas~]
      say__p=1;ParaContent();  print (PrintText) SC_422;  .L_Say256; .L_SayX230;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_958, 958, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Printing the name (B31_after_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! After printing the name of pickup when player holds scent:
!   === which is equally specific with ===
! Rule 2/4 ! After printing the name of the pack of cigarettes while taking inventory:
!   >>> I - Number of aspects constrained >>>
! Rule 3/4 ! After printing the name of an ambiguously plural thing ( called the suspect ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 4/4 ! After printing the name of something ( called the target ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! After printing the name of pickup when player holds scent:
[ R_962 ;
   if (((parameter_object == O42_pickup_truck) && (true))) { ! Runs only when pattern matches
   if ((((((player == HolderOf(O82_scent))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_962, 962);
      ! phrase 1
      ! [1: say ~, still smelling liked spilled gas~]
      say__p=1;ParaContent();  print (PrintText) SC_423;  .L_Say257; .L_SayX231;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_962, 962, true);
   rfalse;
];
! No specific request
! After printing the name of the pack of cigarettes while taking inventory:
[ R_981 ;
   if (((parameter_object == O39_pack_of_cigarettes) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Inv) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_981, 981);
      ! phrase 1
      ! [1: say ~ you should have given up months ago~]
      say__p=1;ParaContent();  print (PrintText) SC_424;  .L_Say258; .L_SayX232;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_981, 981, true);
   rfalse;
];
! No specific request
! From "Plurality" by Emily Short
! After printing the name of an ambiguously plural thing ( called the suspect ):
[ R_826 
    t_0 ! Local variable e.g. 'suspect' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing) && ((Adj_92_t1_v65(parameter_object))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_826, 826);
      ! phrase 1
      ! [1: if the manual pronouns option is active , do nothing]
       if ((((Adj_22_t1_v74(22))))) {  ;   }
      ! phrase 2
      ! [2: otherwise notice the plurality of the suspect]
       else {  PlugPlural(t_0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_826, 826, true);
   rfalse;
];
! No specific request
! From "Plurality" by Emily Short
! After printing the name of something ( called the target ):
[ R_784 
    t_0 ! Local variable e.g. 'target' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_784, 784);
      ! phrase 1
      ! [1: mark target in output]
      (Resolver_7(t_0,"source", 14));
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_784, 784, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the plural name (B33_for_printing_the_plural_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
[ R_59 
    t_0 ! Local variable e.g. 'item' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_59, 59);
      ! phrase 1
      ! [1: say the printed plural name of the item]
      say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(OBJECT_TY, self=t_0,plural); @pull self;  .L_Say259; .L_SayX233;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_59, 59, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a number (B36_for_printing_a_number)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
[ R_60 
    t_0 ! Local variable e.g. 'item' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_60, 60);
      ! phrase 1
      ! [1: say ~[listing group size in words] ~]
      say__p=1;ParaContent();  print (number) say__n=(listing_size); ParaContent();  print (PrintText) SC_166;  .L_Say260; .L_SayX234;
      ! phrase 2
      ! [2: carry out the printing the plural name activity with the item]
       CarryOutActivity(V1_printing_the_plural_name_, t_0); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_60, 60, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Listing contents (B41_before_listing_contents)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Before listing contents while taking inventory:
!   === which is equally specific with ===
! Rule 2/2 ! Before listing contents while taking inventory:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Before listing contents while taking inventory:
[ R_882 ;
   if (((((action ==##Inv) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_882, 882);
      ! phrase 1
      ! [1: group talents together]
       @push subst__v;
		objectloop (subst__v provides list_together) if (((subst__v ofclass K78_talent)))
		subst__v.list_together = LTR_0;
		@pull subst__v; 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_882, 882, true);
   rfalse;
];
! No specific request
! Before listing contents while taking inventory:
[ R_883 ;
   if (((((action ==##Inv) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_883, 883);
      ! phrase 1
      ! [1: group things required by a plan together]
       @push subst__v;
		objectloop (subst__v provides list_together) if (((subst__v ofclass K2_thing) && ((subst__v.p79_objective) ofclass K72_plan)))
		subst__v.list_together = LTR_1;
		@pull subst__v; 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_883, 883, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Grouping together (B44_before_grouping_together)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Before grouping together things required by a plan:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Before grouping together things required by a plan:
[ R_884 ;
   if (((parameter_object ofclass K2_thing) && ((parameter_object.p79_objective) ofclass K72_plan))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_884, 884);
      ! phrase 1
      ! [1: say ~useful stuff: ~]
      say__p=1;ParaContent();  print (PrintText) SC_425;  .L_Say261; .L_SayX235;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_884, 884, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Writing a paragraph about (B48_for_writing_a_paragraph_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! For writing a paragraph about the emergency lights:
!   === which is equally specific with ===
! Rule 2/2 ! For writing a paragraph about huge metal barrel:
! ----------------------------------------------------------------------------------------------------
! No specific request
! For writing a paragraph about the emergency lights:
[ R_1045 ;
   if (((parameter_object == O131_emergency_lights) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1045, 1045);
      ! phrase 1
      ! [1: say ~Near some [rows of crumbling shelving] supporting hundreds of dusty [cans of food] [if emergency lights are switched off]you spot a dark[otherwise]is the[end if] control panel for the building's emergency lights.~]
      say__p=1;ParaContent();  print (PrintText) SC_426; ParaContent();  print (PrintShortName) O136_rows_of_crumbling_shelv; ParaContent();  print (PrintText) SC_427; ParaContent();  print (PrintShortName) O137_cans_of_food; ParaContent();  print (PrintText) SC_166; 
	if (~~(((((Adj_85_t1_v65(O131_emergency_lights))))))) jump L_Say262;
		ParaContent();  print (PrintText) SC_428; 
	jump L_SayX236; .L_Say262;
		ParaContent();  print (PrintText) SC_429; 
	.L_Say263; .L_SayX236;
		ParaContent();  print (PrintText) SC_430;  new_line; .L_Say264; .L_SayX237;
      ! phrase 2
      ! [2: now cans of food are mentioned]
       (Adj_69_t2_v65(O137_cans_of_food)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1045, 1045, true);
   rfalse;
];
! No specific request
! For writing a paragraph about huge metal barrel:
[ R_1066 ;
   if (((parameter_object == O144_huge_metal_barrel) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1066, 1066);
      ! phrase 1
      ! [1: say ~[The rungs] once led to a control booth higher up the tower, but the lower handholds have rotted away and collapsed. [if huge metal barrel is placed correctly]You should be able to clamber up onto the [huge metal barrel] underneath, though[otherwise if player holds courage]You're pretty sure you could make the leap, though[otherwise if player holds strength]You could probably push that [huge metal barrel] over underneath, though[otherwise]A [huge metal barrel] rusts quietly some distance away[end if].~]
      say__p=1;ParaContent();  print (The) O142_metal_rungs; ParaContent();  print (PrintText) SC_431; 
	if (~~(((((Adj_102_t1_v65(O144_huge_metal_barrel))))))) jump L_Say265;
		ParaContent();  print (PrintText) SC_432; ParaContent();  print (PrintShortName) O144_huge_metal_barrel; ParaContent();  print (PrintText) SC_433; ParaContent(); 
	jump L_SayX238; .L_Say265; if (~~((((player == HolderOf(O80_courage)))))) jump L_Say266;
		ParaContent();  print (PrintText) SC_434; ParaContent(); 
	jump L_SayX238; .L_Say266; if (~~((((player == HolderOf(O79_strength)))))) jump L_Say267;
		ParaContent();  print (PrintText) SC_435; ParaContent();  print (PrintShortName) O144_huge_metal_barrel; ParaContent();  print (PrintText) SC_436; 
	jump L_SayX238; .L_Say267;
		ParaContent();  print (PrintText) SC_437; ParaContent();  print (PrintShortName) O144_huge_metal_barrel; ParaContent();  print (PrintText) SC_438; 
	.L_Say268; .L_SayX238;
		ParaContent();  print (PrintText) SC_77;  new_line; .L_Say269; .L_SayX239;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1066, 1066, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the announcement of light (B63_for_printing_the_announc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the look around once light available rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the look around once light available rule:
[ R_61 ;
      ! phrase 1
      ! [1: try looking]
       TryAction(0, player, ##Look, 0, 0);; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the banner text (B72_for_printing_the_banner_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing the banner text while turn count is 1:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for printing the banner text while turn count is 1:
[ R_920 ;
   if ((((((turns == 1)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_920, 920);
      ! phrase 1
      ! [1: say ~[paragraph break]         S A N D - D A N C E R[paragraph break][paragraph break]~]
      say__p=1;ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_439; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say270; .L_SayX240;
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_920, 920, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Printing the banner text (B73_after_printing_the_banne)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! After printing the banner text while turn count is not 1:
! ----------------------------------------------------------------------------------------------------
! No specific request
! After printing the banner text while turn count is not 1:
[ R_921 ;
   if ((((((~~((turns == 1)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_921, 921);
      ! phrase 1
      ! [1: say ~Beta testing courtesy of Duncan Bowsman, Jacqueline A. Lott, Juhana Leinonen, Sharon R., and Stephanie Camus.~]
      say__p=1;ParaContent();  print (PrintText) SC_440;  new_line; .L_Say271; .L_SayX241;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_921, 921, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Reading a command (B76_after_reading_a_command)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! After reading a command ( this is the reset the prevent undo flag rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conditional Undo" by Jesse McGrew
! After reading a command ( this is the reset the prevent undo flag rule ):
[ R_916 ;
      ! phrase 1
      ! [1: change the prevent undo flag to false]
       (Global_Vars-->25) = 0; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Deciding the scope (B79_after_deciding_the_scope)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! After deciding the scope of the player when in darkness ( this is the allow for switching things in darkness rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! After deciding the scope of the player when in darkness ( this is the allow for switching things in darkness rule ):
[ R_877 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if ((((( (location==thedark) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_877, 877);
      ! phrase 1
      ! [1: repeat with machine running through switchable things enclosed by location begin]
       for (t_0=Prop_31(0), t_1=Prop_31(t_0): t_0: t_0=t_1, t_1=Prop_31(t_1))  {
         ! phrase 2
         ! [2: unless the holder of machine is a closed opaque container and the holder of machine is not the holder of player , place machine in scope]
          if (~~(((( (HolderOf(t_0))  ofclass K5_container) && ((Adj_75_t1_v65( (HolderOf(t_0)) ))) && ((Adj_72_t1_v65( (HolderOf(t_0)) ))))) && (((~~(( (HolderOf(t_0))  ==  (HolderOf(player)) ))))))) {  PlaceInScope(t_0, 0);   }
         ! phrase 3
         ! [3: end repeat]
         }

   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_877, 877, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Deciding whether all includes (B84_for_deciding_whether_all)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Rule for deciding whether all includes scenery while taking ( this is the exclude scenery from take all rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Rule for deciding whether all includes fixed in place things while taking ( this is the exclude fixed in place things from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/3 ! Rule for deciding whether all includes people while taking ( this is the exclude people from take all rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for deciding whether all includes scenery while taking ( this is the exclude scenery from take all rule ):
[ R_62 ;
   if ((((Adj_61_t1_v65(parameter_object))))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_62, 62);
      ! phrase 1
      ! [1: rule fails]
       RulebookFails(); rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_62, 62, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for deciding whether all includes fixed in place things while taking ( this is the exclude fixed in place things from take all rule ):
[ R_64 ;
   if (((parameter_object ofclass K2_thing) && ((Adj_59_t1_v65(parameter_object))))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_64, 64);
      ! phrase 1
      ! [1: rule fails]
       RulebookFails(); rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_64, 64, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for deciding whether all includes people while taking ( this is the exclude people from take all rule ):
[ R_63 ;
   if (((parameter_object ofclass K8_person))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_63, 63);
      ! phrase 1
      ! [1: rule fails]
       RulebookFails(); rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_63, 63, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing noun (B96_for_supplying_a_missing_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Rule for supplying a missing noun while smoking:
! --- now the last-placed rules ---
! Rule 5/5 ! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
[ R_65 ;
   if (((((action ==##Smell) && (act_requester==nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_65, 65);
      ! phrase 1
      ! [1: now the noun is the location]
       noun = real_location; 
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_65, 65, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
[ R_66 ;
   if (((((action ==##Listen) && (act_requester==nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_66, 66);
      ! phrase 1
      ! [1: now the noun is the location]
       noun = real_location; 
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_66, 66, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
[ R_67 ;
   if (((((action ==##Go) && (act_requester==nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_67, 67);
      ! phrase 1
      ! [1: issue library message going action number 7]
       GL__M(##Go,7,noun); 
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_67, 67, true);
   rfalse;
];
! No specific request
! Rule for supplying a missing noun while smoking:
[ R_965 ;
   if (((((action ==##A98_smoking) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_965, 965);
      ! phrase 1
      ! [1: if pack of cigarettes is visible , now the noun is the pack of cigarettes]
       if ((((Adj_3_t1_v65(O39_pack_of_cigarettes))))) {  noun = O39_pack_of_cigarettes;   }
      ! phrase 2
      ! [2: otherwise say ~You slip your hand into your pocket and remember you don't have your smokes on you.~]
       else { say__p=1;ParaContent();  print (PrintText) SC_441;  new_line; .L_Say272; .L_SayX242;  }
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_965, 965, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
[ R_148 
    t_0 ! Local variable e.g. 'box' = object
    ;
   if (((((action ==##Enter) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_148, 148);
      ! phrase 1
      ! [1: if something enterable ( called the box ) is in the location , now the noun is the box]
       if ((Prop_32() && (t_0=deferred_calling_list-->0, true))) {  noun = t_0;   }
      ! phrase 2
      ! [2: otherwise continue the activity]
       else {  rfalse;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_148, 148, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Handling the final question (B113_before_handling_the_fin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! This is the print the final question rule:
!   === which is equally specific with ===
! Rule 2/3 ! This is the print the final prompt rule:
! --- now the last-placed rules ---
! Rule 3/3: READ_FINAL_ANSWER_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the print the final question rule:
[ R_69 
    t_0 ! Local variable e.g. 'named options count' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let named options count be 0]
       t_0 = 0; 
      ! phrase 2
      ! [2: repeat through the table of final question options begin]
       @push ct_0; @push ct_1;
		for (t_1=T0_final_question_options,t_2=1,ct_0=t_1,ct_1=t_2:
			t_2<=TableRows(t_1):t_2++,ct_0=t_1,ct_1=t_2)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 3
         ! [3: if the only if victorious entry is false or the story has ended finally begin]
          if ((((TableLookUpEntry(ct_0,101,ct_1) == 0))) || (( (story_complete) )))  {
            ! phrase 4
            ! [4: if there is a final response rule entry or the final response activity entry is not empty begin]
             if ((( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) || (((~~(((Adj_16_t1_v83(TableLookUpEntry(ct_0,104,ct_1)))))))))  {
               ! phrase 5
               ! [5: if there is a final question wording entry , increase named options count by 1]
                if (( (ExistsTableLookUpEntry(ct_0,100,ct_1)) )) {  t_0 = t_0 + 1;   }
               ! phrase 6
               ! [6: end if]
               }

            ! phrase 7
            ! [7: end if]
            }

         ! phrase 8
         ! [8: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 9
      ! [9: if the named options count is less than 1 , abide by the immediately quit rule]
       if (((t_0 < 1))) {  if (ProcessRulebook(IMMEDIATELY_QUIT_R)) rtrue;   }
      ! phrase 10
      ! [10: say ~Would you like to ~]
      say__p=1;ParaContent();  print (PrintText) SC_442;  .L_Say273; .L_SayX243;
      ! phrase 11
      ! [11: repeat through the table of final question options begin]
       @push ct_0; @push ct_1;
		for (t_1=T0_final_question_options,t_2=1,ct_0=t_1,ct_1=t_2:
			t_2<=TableRows(t_1):t_2++,ct_0=t_1,ct_1=t_2)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 12
         ! [12: if the only if victorious entry is false or the story has ended finally begin]
          if ((((TableLookUpEntry(ct_0,101,ct_1) == 0))) || (( (story_complete) )))  {
            ! phrase 13
            ! [13: if there is a final response rule entry or the final response activity entry is not empty begin]
             if ((( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) || (((~~(((Adj_16_t1_v83(TableLookUpEntry(ct_0,104,ct_1)))))))))  {
               ! phrase 14
               ! [14: if there is a final question wording entry begin]
                if (( (ExistsTableLookUpEntry(ct_0,100,ct_1)) ))  {
                  ! phrase 15
                  ! [15: say final question wording entry]
                  say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,100,ct_1);  .L_Say274; .L_SayX244;
                  ! phrase 16
                  ! [16: decrease named options count by 1]
                   t_0 = t_0 - 1; 
                  ! phrase 17
                  ! [17: if the named options count is 0 begin]
                   if (((t_0 == 0)))  {
                     ! phrase 18
                     ! [18: say ~?[line break]~]
                     say__p=1;ParaContent();  print (PrintText) SC_151; ParaContent();  new_line;  .L_Say275; .L_SayX245;
                     ! phrase 19
                     ! [19: otherwise if the named options count is 1]
                      } else if (((t_0 == 1))) { 
                     ! phrase 20
                     ! [20: if the serial comma option is active , say ~,~]
                      if ((((Adj_22_t1_v74(5))))) { say__p=1;ParaContent();  print (PrintText) SC_443;  .L_Say276; .L_SayX246;  }
                     ! phrase 21
                     ! [21: say ~ or ~]
                     say__p=1;ParaContent();  print (PrintText) SC_444;  .L_Say277; .L_SayX247;
                     ! phrase 22
                     ! [22: otherwise]
                     } else {

                     ! phrase 23
                     ! [23: say ~, ~]
                     say__p=1;ParaContent();  print (PrintText) SC_445;  .L_Say278; .L_SayX248;
                     ! phrase 24
                     ! [24: end if]
                     }

                  ! phrase 25
                  ! [25: end if]
                  }

               ! phrase 26
               ! [26: end if]
               }

            ! phrase 27
            ! [27: end if]
            }

         ! phrase 28
         ! [28: end repeat]
         }
@pull ct_1; @pull ct_0;
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the print the final prompt rule:
[ R_68 ;
      ! phrase 1
      ! [1: say ~> [run paragraph on]~]
      say__p=1;ParaContent();  print (PrintText) SC_446; ParaContent();  RunParagraphOn();  .L_Say279; .L_SayX249;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Handling the final question (B114_for_handling_the_final_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the standard respond to final question rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the standard respond to final question rule:
[ R_70 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: repeat through the table of final question options begin]
       @push ct_0; @push ct_1;
		for (t_0=T0_final_question_options,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 2
         ! [2: if the only if victorious entry is false or the story has ended finally begin]
          if ((((TableLookUpEntry(ct_0,101,ct_1) == 0))) || (( (story_complete) )))  {
            ! phrase 3
            ! [3: if there is a final response rule entry or the final response activity entry is not empty begin]
             if ((( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) || (((~~(((Adj_16_t1_v83(TableLookUpEntry(ct_0,104,ct_1)))))))))  {
               ! phrase 4
               ! [4: if the player's command matches the topic entry begin]
                if (( (SnippetMatches(players_command, TableLookUpEntry(ct_0,102,ct_1))) ))  {
                  ! phrase 5
                  ! [5: if there is a final response rule entry , abide by final response rule entry]
                   if (( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) {  if (ProcessRulebook(TableLookUpEntry(ct_0,103,ct_1))) rtrue;   }
                  ! phrase 6
                  ! [6: otherwise carry out the final response activity entry activity]
                   else {  CarryOutActivity(TableLookUpEntry(ct_0,104,ct_1));   }
                  ! phrase 7
                  ! [7: rule succeeds]
                   RulebookSucceeds(); rtrue; 
                  ! phrase 8
                  ! [8: end if]
                  }

               ! phrase 9
               ! [9: end if]
               }

            ! phrase 10
            ! [10: end if]
            }

         ! phrase 11
         ! [11: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 12
      ! [12: issue miscellaneous library message number 8]
       GL__M(##Miscellany,8); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the locale description (B116_before_printing_the_loc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Before printing the locale description ( this is the initialise locale description rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Before printing the locale description ( this is the find notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Before printing the locale description ( this is the initialise locale description rule ):
[ R_73 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: now the locale paragraph count is 0]
       (Global_Vars-->8) = 0; 
      ! phrase 2
      ! [2: repeat with item running through things begin]
       for (t_0=Prop_33(0), t_1=Prop_33(t_0): t_0: t_0=t_1, t_1=Prop_33(t_1))  {
         ! phrase 3
         ! [3: now the item is not mentioned]
          (Adj_69_t3_v65(t_0)); 
         ! phrase 4
         ! [4: end repeat]
         }

      ! phrase 5
      ! [5: repeat through the table of locale priorities begin]
       @push ct_0; @push ct_1;
		for (t_0=T1_locale_priorities,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 6
         ! [6: blank out the whole row]
          TableBlankOutRow(ct_0, ct_1); 
         ! phrase 7
         ! [7: end repeat]
         }
@pull ct_1; @pull ct_0;
   rfalse;
];
! No specific request
! From the Standard Rules
! Before printing the locale description ( this is the find notable locale objects rule ):
[ R_74 
    t_0 ! Local variable e.g. 'domain' = object
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: carry out the choosing notable locale objects activity with the domain]
       CarryOutActivity(V30_choosing_notable_locale_, t_0); 
      ! phrase 3
      ! [3: continue the activity]
       rfalse; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the locale description (B117_for_printing_the_locale)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! For printing the locale description ( this is the interesting locale paragraphs rule ):
!   === which is equally specific with ===
! Rule 2/2 ! For printing the locale description ( this is the you-can-also-see rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! For printing the locale description ( this is the interesting locale paragraphs rule ):
[ R_75 
    t_0 ! Local variable e.g. 'domain' = object
    t_1 ! Local variable e.g. '?-1,-1?' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: sort the table of locale priorities in locale description priority order]
       TableSort(T1_locale_priorities, 106, 1); 
      ! phrase 3
      ! [3: repeat through the table of locale priorities begin]
       @push ct_0; @push ct_1;
		for (t_1=T1_locale_priorities,t_2=1,ct_0=t_1,ct_1=t_2:
			t_2<=TableRows(t_1):t_2++,ct_0=t_1,ct_1=t_2)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 4
         ! [4: carry out the printing a locale paragraph about activity with the notable-object entry]
          CarryOutActivity(V31_printing_a_locale_paragr, TableLookUpEntry(ct_0,105,ct_1)); 
         ! phrase 5
         ! [5: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 6
      ! [6: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing the locale description ( this is the you-can-also-see rule ):
[ R_76 
    t_0 ! Local variable e.g. 'domain' = object
    t_1 ! Local variable e.g. 'mentionable count' = number
    t_2 ! Local variable e.g. 'common holder' = object
    t_3 ! Local variable e.g. 'contents form of list' = truth state
    t_4 ! Local variable e.g. '?-1,-1?' = object
    t_5 ! Local variable e.g. '?-1,-1?' = object
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: let the mentionable count be 0]
       t_1 = 0; 
      ! phrase 3
      ! [3: repeat with item running through things begin]
       for (t_2=Prop_34(0), t_3=Prop_34(t_2): t_2: t_2=t_3, t_3=Prop_34(t_3))  {
         ! phrase 4
         ! [4: now the item is not marked for listing]
          (Adj_67_t3_v65(t_2)); 
         ! phrase 5
         ! [5: end repeat]
         }

      ! phrase 6
      ! [6: repeat through the table of locale priorities begin]
       @push ct_0; @push ct_1;
		for (t_2=T1_locale_priorities,t_3=1,ct_0=t_2,ct_1=t_3:
			t_3<=TableRows(t_2):t_3++,ct_0=t_2,ct_1=t_3)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 7
         ! [7: if the locale description priority entry is greater than 0 , now the notable-object entry is marked for listing]
          if (((TableLookUpEntry(ct_0,106,ct_1) > 0))) {  (Adj_67_t2_v65(TableLookUpEntry(ct_0,105,ct_1)));   }
         ! phrase 8
         ! [8: increase the mentionable count by 1]
          t_1 = t_1 + 1; 
         ! phrase 9
         ! [9: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 10
      ! [10: if the mentionable count is greater than 0 begin]
       if (((t_1 > 0)))  {
         ! phrase 11
         ! [11: repeat with item running through things begin]
          for (t_4=Prop_35(0), t_5=Prop_35(t_4): t_4: t_4=t_5, t_5=Prop_35(t_5))  {
            ! phrase 12
            ! [12: if the item is mentioned begin]
             if ((((Adj_69_t1_v65(t_4)))))  {
               ! phrase 13
               ! [13: now the item is not marked for listing]
                (Adj_67_t3_v65(t_4)); 
               ! phrase 14
               ! [14: end if]
               }

            ! phrase 15
            ! [15: end repeat]
            }

         ! phrase 16
         ! [16: begin the listing nondescript items activity with the domain]
          BeginActivity(V7_listing_nondescript_items, t_0); 
         ! phrase 17
         ! [17: if the number of marked for listing things is 0 begin]
          if ((( (Prop_36())  == 0)))  {
            ! phrase 18
            ! [18: abandon the listing nondescript items activity with the domain]
             AbandonActivity(V7_listing_nondescript_items, t_0); 
            ! phrase 19
            ! [19: otherwise]
            } else {

            ! phrase 20
            ! [20: if handling the listing nondescript items activity begin]
             if (( (~~(ForActivity(V7_listing_nondescript_items))) ))  {
               ! phrase 21
               ! [21: if the domain is a room begin]
                if (((t_0 ofclass K1_room)))  {
                  ! phrase 22
                  ! [22: if the domain is the location , say ~You ~]
                   if (((t_0 == real_location))) { say__p=1;ParaContent();  print (PrintText) SC_447;  .L_Say280; .L_SayX250;  }
                  ! phrase 23
                  ! [23: otherwise say ~In [the domain] you ~]
                   else { say__p=1;ParaContent();  print (PrintText) SC_448; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_449;  .L_Say281; .L_SayX251;  }
                  ! phrase 24
                  ! [24: otherwise if the domain is a supporter]
                   } else if (((t_0 ofclass K6_supporter))) { 
                  ! phrase 25
                  ! [25: say ~On [the domain] you ~]
                  say__p=1;ParaContent();  print (PrintText) SC_450; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_449;  .L_Say282; .L_SayX252;
                  ! phrase 26
                  ! [26: otherwise if the domain is an animal]
                   } else if (((t_0 ofclass K25_animal))) { 
                  ! phrase 27
                  ! [27: say ~On [the domain] you ~]
                  say__p=1;ParaContent();  print (PrintText) SC_450; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_449;  .L_Say283; .L_SayX253;
                  ! phrase 28
                  ! [28: otherwise]
                  } else {

                  ! phrase 29
                  ! [29: say ~In [the domain] you ~]
                  say__p=1;ParaContent();  print (PrintText) SC_448; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_449;  .L_Say284; .L_SayX254;
                  ! phrase 30
                  ! [30: end if]
                  }

               ! phrase 31
               ! [31: say ~can [if the locale paragraph count is greater than 0]also [end if]see ~]
               say__p=1;ParaContent();  print (PrintText) SC_451; 
	if (~~(((((Global_Vars-->8) > 0))))) jump L_Say285;
		ParaContent();  print (PrintText) SC_452; 
	.L_Say285; .L_SayX255;
		ParaContent();  print (PrintText) SC_453;  .L_Say286; .L_SayX256;
               ! phrase 32
               ! [32: let the common holder be nothing]
                t_2 = nothing; 
               ! phrase 33
               ! [33: let contents form of list be true]
                t_3 = 1; 
               ! phrase 34
               ! [34: repeat with list item running through marked for listing things begin]
                for (t_4=Prop_37(0), t_5=Prop_37(t_4): t_4: t_4=t_5, t_5=Prop_37(t_5))  {
                  ! phrase 35
                  ! [35: if the holder of the list item is not the common holder begin]
                   if (((~~(( (HolderOf(t_4))  == t_2)))))  {
                     ! phrase 36
                     ! [36: if the common holder is nothing , now the common holder is the holder of the list item]
                      if (((t_2 == nothing))) {  t_2 =  (HolderOf(t_4)) ;   }
                     ! phrase 37
                     ! [37: otherwise now contents form of list is false]
                      else {  t_3 = 0;   }
                     ! phrase 38
                     ! [38: end if]
                     }

                  ! phrase 39
                  ! [39: if the list item is mentioned , now the list item is not marked for listing]
                   if ((((Adj_69_t1_v65(t_4))))) {  (Adj_67_t3_v65(t_4));   }
                  ! phrase 40
                  ! [40: end repeat]
                  }

               ! phrase 41
               ! [41: filter list recursion to unmentioned things]
                list_filter_routine = Prop_38; 
               ! phrase 42
               ! [42: if contents form of list is true and the common holder is not nothing , list the contents of the common holder , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , listing marked items only]
                if ((((t_3 == 1))) && (((~~((t_2 == nothing)))))) {  WriteListFrom(child(t_2), 2776);   }
               ! phrase 43
               ! [43: otherwise say ~[a list of marked for listing things including contents]~]
                else { say__p=1;ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && ((Adj_67_t1_v65(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+
			TERSE_BIT+CONCEAL_BIT);
		@pull subst__v;  .L_Say287; .L_SayX257;  }
               ! phrase 44
               ! [44: if the domain is the location , say ~ here~]
                if (((t_0 == real_location))) { say__p=1;ParaContent();  print (PrintText) SC_454;  .L_Say288; .L_SayX258;  }
               ! phrase 45
               ! [45: say ~.[paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) SC_77; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say289; .L_SayX259;
               ! phrase 46
               ! [46: unfilter list recursion]
                list_filter_routine = 0; 
               ! phrase 47
               ! [47: end if]
               }

            ! phrase 48
            ! [48: end the listing nondescript items activity with the domain]
             EndActivity(V7_listing_nondescript_items, t_0); 
            ! phrase 49
            ! [49: end if]
            }

         ! phrase 50
         ! [50: end if]
         }

      ! phrase 51
      ! [51: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Choosing notable locale objects (B120_for_choosing_notable_lo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For choosing notable locale objects ( this is the standard notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! For choosing notable locale objects ( this is the standard notable locale objects rule ):
[ R_77 
    t_0 ! Local variable e.g. 'domain' = object
    t_1 ! Local variable e.g. 'held item' = object
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: let the held item be the first thing held by the domain]
       t_1 =  (child(t_0)) ; 
      ! phrase 3
      ! [3: while the held item is a thing begin]
       while (((t_1 ofclass K2_thing)))  {
         ! phrase 4
         ! [4: set the locale priority of the held item to 5]
         (PHR_72_r32 (t_1,5));
         ! phrase 5
         ! [5: now the held item is the next thing held after the held item]
          t_1 =  (sibling(t_1)) ; 
         ! phrase 6
         ! [6: end while]
         }

      ! phrase 7
      ! [7: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a locale paragraph about (B123_for_printing_a_locale_p)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
!   === which is equally specific with ===
! Rule 2/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
!   === which is equally specific with ===
! Rule 3/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
!   === which is equally specific with ===
! Rule 4/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
!   === which is equally specific with ===
! Rule 5/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
!   === which is equally specific with ===
! Rule 6/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
!   === which is equally specific with ===
! Rule 7/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
[ R_78 
    t_0 ! Local variable e.g. 'item' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_78, 78);
      ! phrase 1
      ! [1: if the item encloses the player , set the locale priority of the item to 0]
       if (((IndirectlyContains(t_0,player)))) { (PHR_72_r32 (t_0,0));  }
      ! phrase 2
      ! [2: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_78, 78, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
[ R_79 
    t_0 ! Local variable e.g. 'item' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_79, 79);
      ! phrase 1
      ! [1: if the item is scenery , set the locale priority of the item to 0]
       if ((((Adj_61_t1_v65(t_0))))) { (PHR_72_r32 (t_0,0));  }
      ! phrase 2
      ! [2: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_79, 79, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
[ R_80 
    t_0 ! Local variable e.g. 'item' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_80, 80);
      ! phrase 1
      ! [1: if the item is undescribed , set the locale priority of the item to 0]
       if ((((Adj_66_t1_v65(t_0))))) { (PHR_72_r32 (t_0,0));  }
      ! phrase 2
      ! [2: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_80, 80, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
[ R_81 
    t_0 ! Local variable e.g. 'item' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_81, 81);
      ! phrase 1
      ! [1: if the item is not mentioned , set pronouns from the item]
       if (((~~(((Adj_69_t1_v65(t_0))))))) {  PronounNotice(t_0);   }
      ! phrase 2
      ! [2: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_81, 81, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
[ R_82 
    t_0 ! Local variable e.g. 'item' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_82, 82);
      ! phrase 1
      ! [1: if the item is not mentioned begin]
       if (((~~(((Adj_69_t1_v65(t_0)))))))  {
         ! phrase 2
         ! [2: if a paragraph break is pending , say ~[conditional paragraph break]~]
          if (( (say__p) )) { say__p=1;ParaContent();  DivideParagraphPoint();  .L_Say290; .L_SayX260;  }
         ! phrase 3
         ! [3: carry out the writing a paragraph about activity with the item]
          CarryOutActivity(V6_writing_a_paragraph_about, t_0); 
         ! phrase 4
         ! [4: if a paragraph break is pending begin]
          if (( (say__p) ))  {
            ! phrase 5
            ! [5: increase the locale paragraph count by 1]
             (Global_Vars-->8) = (Global_Vars-->8) + 1; 
            ! phrase 6
            ! [6: now the item is mentioned]
             (Adj_69_t2_v65(t_0)); 
            ! phrase 7
            ! [7: say ~[command clarification break]~]
            say__p=1;ParaContent();  CommandClarificationBreak();  .L_Say291; .L_SayX261;
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end if]
         }

      ! phrase 10
      ! [10: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_82, 82, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
[ R_83 
    t_0 ! Local variable e.g. 'item' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    t_2 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_83, 83);
      ! phrase 1
      ! [1: if the item is not mentioned begin]
       if (((~~(((Adj_69_t1_v65(t_0)))))))  {
         ! phrase 2
         ! [2: if the item provides the property initial appearance and the item is not handled and the initial appearance of the item is not ~~ begin]
          if ((((WhetherProvides(t_0, false, initial)))) && ((((~~(((Adj_64_t1_v65(t_0))))))) && (((~~((GProperty(OBJECT_TY, t_0,initial) == EMPTY_TEXT_VALUE)))))))  {
            ! phrase 3
            ! [3: increase the locale paragraph count by 1]
             (Global_Vars-->8) = (Global_Vars-->8) + 1; 
            ! phrase 4
            ! [4: say ~[initial appearance of the item]~]
            say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(OBJECT_TY, self=t_0,initial); @pull self;  .L_Say292; .L_SayX262;
            ! phrase 5
            ! [5: say ~[paragraph break]~]
            say__p=1;ParaContent();  DivideParagraphPoint(); new_line;  .L_Say293; .L_SayX263;
            ! phrase 6
            ! [6: if a locale-supportable thing is on the item begin]
             if ((Prop_39(,t_0)))  {
               ! phrase 7
               ! [7: repeat with possibility running through things on the item begin]
                for (t_1=Prop_40(,t_0,0), t_2=Prop_40(,t_0,t_1): t_1: t_1=t_2, t_2=Prop_40(,t_0,t_2))  {
                  ! phrase 8
                  ! [8: now the possibility is marked for listing]
                   (Adj_67_t2_v65(t_1)); 
                  ! phrase 9
                  ! [9: if the possibility is mentioned begin]
                   if ((((Adj_69_t1_v65(t_1)))))  {
                     ! phrase 10
                     ! [10: now the possibility is not marked for listing]
                      (Adj_67_t3_v65(t_1)); 
                     ! phrase 11
                     ! [11: end if]
                     }

                  ! phrase 12
                  ! [12: end repeat]
                  }

               ! phrase 13
               ! [13: say ~On [the item] ~]
               say__p=1;ParaContent();  print (PrintText) SC_450; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_166;  .L_Say294; .L_SayX264;
               ! phrase 14
               ! [14: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
                WriteListFrom(child(t_0), 3800); 
               ! phrase 15
               ! [15: say ~.[paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) SC_77; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say295; .L_SayX265;
               ! phrase 16
               ! [16: end if]
               }

            ! phrase 17
            ! [17: now the item is mentioned]
             (Adj_69_t2_v65(t_0)); 
            ! phrase 18
            ! [18: end if]
            }

         ! phrase 19
         ! [19: end if]
         }

      ! phrase 20
      ! [20: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_83, 83, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
[ R_85 
    t_0 ! Local variable e.g. 'item' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    t_2 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_85, 85);
      ! phrase 1
      ! [1: if the item is not undescribed and the item is scenery and the item does not enclose the player begin]
       if ((((~~(((Adj_66_t1_v65(t_0))))))) && (((((Adj_61_t1_v65(t_0))))) && (((~~((IndirectlyContains(t_0,player))))))))  {
         ! phrase 2
         ! [2: if a locale-supportable thing is on the item begin]
          if ((Prop_41(,t_0)))  {
            ! phrase 3
            ! [3: set pronouns from the item]
             PronounNotice(t_0); 
            ! phrase 4
            ! [4: repeat with possibility running through things on the item begin]
             for (t_1=Prop_42(,t_0,0), t_2=Prop_42(,t_0,t_1): t_1: t_1=t_2, t_2=Prop_42(,t_0,t_2))  {
               ! phrase 5
               ! [5: now the possibility is marked for listing]
                (Adj_67_t2_v65(t_1)); 
               ! phrase 6
               ! [6: if the possibility is mentioned begin]
                if ((((Adj_69_t1_v65(t_1)))))  {
                  ! phrase 7
                  ! [7: now the possibility is not marked for listing]
                   (Adj_67_t3_v65(t_1)); 
                  ! phrase 8
                  ! [8: end if]
                  }

               ! phrase 9
               ! [9: end repeat]
               }

            ! phrase 10
            ! [10: increase the locale paragraph count by 1]
             (Global_Vars-->8) = (Global_Vars-->8) + 1; 
            ! phrase 11
            ! [11: say ~On [the item] ~]
            say__p=1;ParaContent();  print (PrintText) SC_450; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_166;  .L_Say296; .L_SayX266;
            ! phrase 12
            ! [12: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
             WriteListFrom(child(t_0), 3800); 
            ! phrase 13
            ! [13: say ~.[paragraph break]~]
            say__p=1;ParaContent();  print (PrintText) SC_77; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say297; .L_SayX267;
            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: end if]
         }

      ! phrase 16
      ! [16: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_85, 85, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking inventory (B126_carry_out_taking_invent)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out taking inventory ( this is the print empty inventory rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Carry out taking inventory ( this is the print standard inventory rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out taking inventory ( this is the print empty inventory rule ):
[ R_86 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_86, 86);
      ! phrase 1
      ! [1: if the first thing held by the player is nothing , stop the action with library message taking inventory action number 1]
       if ((( (child(player))  == nothing))) {  return GL__M(##Inv,1,noun);   }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_86, 86, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out taking inventory ( this is the print standard inventory rule ):
[ R_87 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_87, 87);
      ! phrase 1
      ! [1: issue library message taking inventory action number 2]
       GL__M(##Inv,2,noun); 
      ! phrase 2
      ! [2: say ~:[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_455; ParaContent();  new_line;  .L_Say298; .L_SayX268;
      ! phrase 3
      ! [3: list the contents of the player , with newlines , indented , including contents , giving inventory information , with extra indentation]
       WriteListFrom(child(player), 8215); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_87, 87, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking inventory (B127_report_taking_inventory)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking inventory ( this is the report other people taking inventory rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor taking inventory ( this is the report other people taking inventory rule ):
[ R_88 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_88, 88);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message taking inventory action number 5 for the actor]
       if (((~~((actor == player))))) {  AGL__M(##Inv,5,actor);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_88, 88, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking (B128_check_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/12 ! Check an actor taking ( this is the can't take yourself rule ):
!   === which is equally specific with ===
! Rule 2/12 ! Check an actor taking ( this is the can't take other people rule ):
!   === which is equally specific with ===
! Rule 3/12 ! Check an actor taking ( this is the can't take component parts rule ):
!   === which is equally specific with ===
! Rule 4/12 ! Check an actor taking ( this is the can't take people's possessions rule ):
!   === which is equally specific with ===
! Rule 5/12 ! Check an actor taking ( this is the can't take items out of play rule ):
!   === which is equally specific with ===
! Rule 6/12 ! Check an actor taking ( this is the can't take what's already taken rule ):
!   === which is equally specific with ===
! Rule 7/12 ! Check an actor taking ( this is the can't take scenery rule ):
!   === which is equally specific with ===
! Rule 8/12 ! Check an actor taking ( this is the can only take things rule ):
!   === which is equally specific with ===
! Rule 9/12 ! Check an actor taking ( this is the can't take what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 10/12 ! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
!   === which is equally specific with ===
! Rule 11/12 ! Check an actor taking ( this is the can't exceed carrying capacity rule ):
!   === which is equally specific with ===
! Rule 12/12 ! Check an actor taking ( this is the clever can't take what you're inside rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take yourself rule ):
[ R_89 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_89, 89);
      ! phrase 1
      ! [1: if the actor is the noun , stop the action with library message taking action number 2 for the noun]
       if (((actor == noun))) {  return GL__M(##Take,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_89, 89, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take other people rule ):
[ R_90 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_90, 90);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message taking action number 3 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Take,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_90, 90, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take component parts rule ):
[ R_91 
    t_0 ! Local variable e.g. 'whole' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_91, 91);
      ! phrase 1
      ! [1: if the noun is part of something ( called the whole ) , stop the action with library message taking action number 7 for the whole]
       if ((((noun.component_parent) ofclass K2_thing) && (t_0=((noun.component_parent)), true))) {  return GL__M(##Take,7,t_0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_91, 91, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take people's possessions rule ):
[ R_92 
    t_0 ! Local variable e.g. 'local ceiling' = object
    t_1 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_92, 92);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: let h be the not-counting-parts holder of the noun]
       t_1 =  (CoreOfParentOfCoreOf(noun)) ; 
      ! phrase 3
      ! [3: while h is not nothing and h is not the local ceiling begin]
       while ((((~~((t_1 == nothing))))) && (((~~((t_1 == t_0))))))  {
         ! phrase 4
         ! [4: if h is a person , stop the action with library message taking action number 6 for h]
          if (((t_1 ofclass K8_person))) {  return GL__M(##Take,6,t_1);   }
         ! phrase 5
         ! [5: let h be the not-counting-parts holder of h]
          t_1 =  (CoreOfParentOfCoreOf(t_1)) ; 
         ! phrase 6
         ! [6: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_92, 92, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take items out of play rule ):
[ R_93 
    t_0 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_93, 93);
      ! phrase 1
      ! [1: let h be the noun]
       t_0 = noun; 
      ! phrase 2
      ! [2: while h is not nothing and h is not a room begin]
       while ((((~~((t_0 == nothing))))) && (((~~((t_0 ofclass K1_room))))))  {
         ! phrase 3
         ! [3: let h be the not-counting-parts holder of h]
          t_0 =  (CoreOfParentOfCoreOf(t_0)) ; 
         ! phrase 4
         ! [4: end while]
         }

      ! phrase 5
      ! [5: if h is nothing , stop the action with library message taking action number 8 for the noun]
       if (((t_0 == nothing))) {  return GL__M(##Take,8,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_93, 93, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take what's already taken rule ):
[ R_95 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_95, 95);
      ! phrase 1
      ! [1: if the actor is carrying the noun , stop the action with library message taking action number 5 for the noun]
       if (((actor == CarrierOf(noun)))) {  return GL__M(##Take,5,noun);   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , stop the action with library message taking action number 5 for the noun]
       if (((actor == WearerOf(noun)))) {  return GL__M(##Take,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_95, 95, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take scenery rule ):
[ R_96 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_96, 96);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message taking action number 10 for the noun]
       if ((((Adj_61_t1_v65(noun))))) {  return GL__M(##Take,10,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_96, 96, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can only take things rule ):
[ R_97 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_97, 97);
      ! phrase 1
      ! [1: if the noun is not a thing , stop the action with library message taking action number 15 for the noun]
       if (((~~((noun ofclass K2_thing))))) {  return GL__M(##Take,15,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_97, 97, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take what's fixed in place rule ):
[ R_98 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_98, 98);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message taking action number 11 for the noun]
       if ((((Adj_59_t1_v65(noun))))) {  return GL__M(##Take,11,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_98, 98, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
[ R_99 
    t_0 ! Local variable e.g. 'current working sack' = object
    t_1 ! Local variable e.g. 'transferred item' = object
    t_2 ! Local variable e.g. '?-1,-1?' = object
    t_3 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_99, 99);
      ! phrase 1
      ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor begin]
       if ((( (Prop_43())  >= GProperty(OBJECT_TY, actor,capacity))))  {
         ! phrase 2
         ! [2: if the actor is holding a player's holdall ( called the current working sack ) begin]
          if ((Prop_44() && (t_0=deferred_calling_list-->0, true)))  {
            ! phrase 3
            ! [3: let the transferred item be nothing]
             t_1 = nothing; 
            ! phrase 4
            ! [4: repeat with the possible item running through things carried by the actor begin]
             for (t_2=Prop_45(0), t_3=Prop_45(t_2): t_2: t_2=t_3, t_3=Prop_45(t_3))  {
               ! phrase 5
               ! [5: if the possible item is not lit and the possible item is not the current working sack , let the transferred item be the possible item]
                if ((((~~(((Adj_55_t1_v65(t_2))))))) && (((~~((t_2 == t_0)))))) {  t_1 = t_2;   }
               ! phrase 6
               ! [6: end repeat]
               }

            ! phrase 7
            ! [7: if the transferred item is not nothing begin]
             if (((~~((t_1 == nothing)))))  {
               ! phrase 8
               ! [8: issue library message taking action number 13 for the transferred item]
                GL__M(##Take,13,t_1); 
               ! phrase 9
               ! [9: silently try the actor trying inserting the transferred item into the current working sack]
                @push keep_silent; keep_silent=1; TryAction(0, actor, ##Insert, t_1, t_0);; @pull keep_silent; 
               ! phrase 10
               ! [10: if the transferred item is not in the current working sack , stop the action]
                if (((~~((t_0 == ContainerOf(t_1)))))) {  rtrue;   }
               ! phrase 11
               ! [11: end if]
               }

            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_99, 99, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't exceed carrying capacity rule ):
[ R_100 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_100, 100);
      ! phrase 1
      ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor , stop the action with library message taking action number 12 for the actor]
       if ((( (Prop_46())  >= GProperty(OBJECT_TY, actor,capacity)))) {  return GL__M(##Take,12,actor);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_100, 100, true);
   rfalse;
];
! No specific request
! From "Modified Exit" by Emily Short
! Check an actor taking ( this is the clever can't take what you're inside rule ):
[ R_860 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_860, 860);
      ! phrase 1
      ! [1: if the holder of the person asked is the noun , abide by the implicit exiting rule]
       if ((( (HolderOf(actor))  == noun))) {  if (ProcessRulebook(R_863)) rtrue;   }
      ! phrase 2
      ! [2: if the holder of the person asked is in the noun , rule fails]
       if (((noun == ContainerOf( (HolderOf(actor)) )))) {  RulebookFails(); rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_860, 860, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking (B129_carry_out_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking ( this is the standard taking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor taking ( this is the standard taking rule ):
[ R_101 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_101, 101);
      ! phrase 1
      ! [1: now the actor carries the noun]
       MoveObject(noun,actor); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_101, 101, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking (B130_report_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking ( this is the standard report taking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor taking ( this is the standard report taking rule ):
[ R_102 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_102, 102);
      ! phrase 1
      ! [1: if the actor is the player , issue library message taking action number 1 for the noun]
       if (((actor == player))) {  GL__M(##Take,1,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message taking action number 16 for the noun]
       else {  AGL__M(##Take,16,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_102, 102, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Removing it from (B131_check_removing_it_from)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor taking ( this is the can't take component parts rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/4 ! Check an actor removing something from ( this is the can't remove what's not inside rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor removing something from ( this is the can't remove from people rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor removing something from ( this is the convert remove to take rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor removing something from ( this is the can't remove what's not inside rule ):
[ R_103 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_103, 103);
      ! phrase 1
      ! [1: if the holder of the noun is not the second noun , stop the action with library message removing it from action number 2 for the noun]
       if (((~~(( (HolderOf(noun))  == second))))) {  return GL__M(##Remove,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_103, 103, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor removing something from ( this is the can't remove from people rule ):
[ R_104 
    t_0 ! Local variable e.g. 'owner' = object
    ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_104, 104);
      ! phrase 1
      ! [1: let the owner be the holder of the noun]
       t_0 =  (HolderOf(noun)) ; 
      ! phrase 2
      ! [2: if the owner is a person begin]
       if (((t_0 ofclass K8_person)))  {
         ! phrase 3
         ! [3: if the owner is the actor , convert to the taking off action on the noun]
          if (((t_0 == actor))) {  return GVS_Convert(##Disrobe,noun,0);   }
         ! phrase 4
         ! [4: stop the action with library message taking action number 6 for the owner]
          return GL__M(##Take,6,t_0); 
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_104, 104, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor removing something from ( this is the convert remove to take rule ):
[ R_105 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_105, 105);
      ! phrase 1
      ! [1: convert to the taking action on the noun]
       return GVS_Convert(##Take,noun,0); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_105, 105, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dropping (B134_check_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor dropping ( this is the can't drop yourself rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor dropping ( this is the can't drop what's already dropped rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor dropping ( this is the can't drop what's not held rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor dropping ( this is the can't drop clothes being worn rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop yourself rule ):
[ R_106 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_106, 106);
      ! phrase 1
      ! [1: if the noun is the actor , stop the action with library message putting it on action number 4]
       if (((noun == actor))) {  return GL__M(##PutOn,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_106, 106, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop what's already dropped rule ):
[ R_107 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_107, 107);
      ! phrase 1
      ! [1: if the noun is in the holder of the actor , stop the action with library message dropping action number 1 for the noun]
       if ((( (HolderOf(actor))  == ContainerOf(noun)))) {  return GL__M(##Drop,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_107, 107, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop what's not held rule ):
[ R_108 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_108, 108);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
       if (((actor == WearerOf(noun)))) {  rfalse;   }
      ! phrase 3
      ! [3: stop the action with library message dropping action number 2 for the noun]
       return GL__M(##Drop,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_108, 108, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop clothes being worn rule ):
[ R_109 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_109, 109);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_109, 109, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
[ R_110 
    t_0 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_110, 110);
      ! phrase 1
      ! [1: let h be the holder of the actor]
       t_0 =  (HolderOf(actor)) ; 
      ! phrase 2
      ! [2: if h is a room , continue the action]
       if (((t_0 ofclass K1_room))) {  rfalse;   }
      ! phrase 3
      ! [3: if h provides the property carrying capacity begin]
       if (((WhetherProvides(t_0, false, capacity))))  {
         ! phrase 4
         ! [4: if h is a supporter begin]
          if (((t_0 ofclass K6_supporter)))  {
            ! phrase 5
            ! [5: if the number of things on h is at least the carrying capacity of h begin]
             if ((( (Prop_47(,t_0))  >= GProperty(OBJECT_TY, t_0,capacity))))  {
               ! phrase 6
               ! [6: if the actor is the player , issue library message dropping action number 5 for h]
                if (((actor == player))) {  GL__M(##Drop,5,t_0);   }
               ! phrase 7
               ! [7: stop the action]
                rtrue; 
               ! phrase 8
               ! [8: end if]
               }

            ! phrase 9
            ! [9: otherwise if h is a container]
             } else if (((t_0 ofclass K5_container))) { 
            ! phrase 10
            ! [10: if the number of things in h is at least the carrying capacity of h begin]
             if ((( (Prop_48(,t_0))  >= GProperty(OBJECT_TY, t_0,capacity))))  {
               ! phrase 11
               ! [11: if the actor is the player , issue library message dropping action number 6 for h]
                if (((actor == player))) {  GL__M(##Drop,6,t_0);   }
               ! phrase 12
               ! [12: stop the action]
                rtrue; 
               ! phrase 13
               ! [13: end if]
               }

            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_110, 110, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dropping (B135_carry_out_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor dropping ( this is the standard dropping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor dropping ( this is the standard dropping rule ):
[ R_111 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_111, 111);
      ! phrase 1
      ! [1: now the noun is in the holder of the actor]
       MoveObject(noun, (HolderOf(actor)) ); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_111, 111, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dropping (B136_report_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor dropping ( this is the standard report dropping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor dropping ( this is the standard report dropping rule ):
[ R_112 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_112, 112);
      ! phrase 1
      ! [1: if the actor is the player , issue library message dropping action number 4 for the noun]
       if (((actor == player))) {  GL__M(##Drop,4,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message dropping action number 7 for the noun]
       else {  AGL__M(##Drop,7,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_112, 112, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Putting it on (B137_check_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor putting something on ( this is the convert put to drop where possible rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor putting something on ( this is the can't put what's not held rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor putting something on ( this is the can't put something on itself rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor putting something on ( this is the can't put onto something being carried rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor putting something on ( this is the can't put clothes being worn rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the convert put to drop where possible rule ):
[ R_113 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_113, 113);
      ! phrase 1
      ! [1: if the second noun is down or the actor is on the second noun , convert to the dropping action on the noun]
       if ((((second == O19_down))) || (((second == SupporterOf(actor))))) {  return GVS_Convert(##Drop,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_113, 113, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put what's not held rule ):
[ R_114 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_114, 114);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
       if (((actor == WearerOf(noun)))) {  rfalse;   }
      ! phrase 3
      ! [3: issue miscellaneous library message number 26 for the noun]
       GL__M(##Miscellany,26, noun); 
      ! phrase 4
      ! [4: silently try the actor taking the noun]
       @push keep_silent; keep_silent=1; TryAction(0, actor, ##Take, noun, 0);; @pull keep_silent; 
      ! phrase 5
      ! [5: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 6
      ! [6: stop the action with library message putting it on action number 1 for the noun]
       return GL__M(##PutOn,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_114, 114, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put something on itself rule ):
[ R_115 
    t_0 ! Local variable e.g. 'noun-CPC' = object
    t_1 ! Local variable e.g. 'second-CPC' = object
    t_2 ! Local variable e.g. 'transfer ceiling' = object
    ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_115, 115);
      ! phrase 1
      ! [1: let the noun-cpc be the component parts core of the noun]
       t_0 =  CoreOf(noun) ; 
      ! phrase 2
      ! [2: let the second-cpc be the component parts core of the second noun]
       t_1 =  CoreOf(second) ; 
      ! phrase 3
      ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]
       t_2 =  (CommonAncestor(t_0, t_1)) ; 
      ! phrase 4
      ! [4: if the transfer ceiling is the noun-cpc , stop the action with library message putting it on action number 2 for the noun]
       if (((t_2 == t_0))) {  return GL__M(##PutOn,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_115, 115, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
[ R_116 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_116, 116);
      ! phrase 1
      ! [1: if the second noun is not a supporter , stop the action with library message putting it on action number 3 for the second noun]
       if (((~~((second ofclass K6_supporter))))) {  return GL__M(##PutOn,3,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_116, 116, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put onto something being carried rule ):
[ R_117 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_117, 117);
      ! phrase 1
      ! [1: if the actor encloses the second noun , stop the action with library message putting it on action number 4 for the second noun]
       if (((IndirectlyContains(actor,second)))) {  return GL__M(##PutOn,4,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_117, 117, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put clothes being worn rule ):
[ R_118 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_118, 118);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message putting it on action number 5 for the noun]
          GL__M(##PutOn,5,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_118, 118, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
[ R_119 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_119, 119);
      ! phrase 1
      ! [1: if the second noun provides the property carrying capacity begin]
       if (((WhetherProvides(second, false, capacity))))  {
         ! phrase 2
         ! [2: if the number of things on the second noun is at least the carrying capacity of the second noun , stop the action with library message putting it on action number 6 for the second noun]
          if ((( (Prop_49())  >= GProperty(OBJECT_TY, second,capacity)))) {  return GL__M(##PutOn,6,second);   }
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_119, 119, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Putting it on (B138_carry_out_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor putting something on ( this is the standard putting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor putting something on ( this is the standard putting rule ):
[ R_120 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_120, 120);
      ! phrase 1
      ! [1: now the noun is on the second noun]
       MoveObject(noun,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_120, 120, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Putting it on (B139_report_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor putting something on ( this is the concise report putting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor putting something on ( this is the standard report putting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor putting something on ( this is the concise report putting rule ):
[ R_121 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_121, 121);
      ! phrase 1
      ! [1: if the actor is the player and the i6 parser is running multiple actions , stop the action with library message putting it on action number 7 for the noun]
       if ((((actor == player))) && (( (multiflag==1) ))) {  return GL__M(##PutOn,7,noun);   }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_121, 121, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor putting something on ( this is the standard report putting rule ):
[ R_122 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_122, 122);
      ! phrase 1
      ! [1: if the actor is the player , issue library message putting it on action number 8 for the noun]
       if (((actor == player))) {  GL__M(##PutOn,8,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message putting it on action number 9 for the noun]
       else {  AGL__M(##PutOn,9,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_122, 122, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Inserting it into (B140_check_inserting_it_into)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor inserting something into ( this is the can't insert what's not held rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor inserting something into ( this is the can't insert something into itself rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
[ R_123 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_123, 123);
      ! phrase 1
      ! [1: if the second noun is down or the actor is in the second noun , convert to the dropping action on the noun]
       if ((((second == O19_down))) || (((second == ContainerOf(actor))))) {  return GVS_Convert(##Drop,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_123, 123, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert what's not held rule ):
[ R_124 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_124, 124);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
       if (((actor == WearerOf(noun)))) {  rfalse;   }
      ! phrase 3
      ! [3: issue miscellaneous library message number 26 for the noun]
       GL__M(##Miscellany,26, noun); 
      ! phrase 4
      ! [4: silently try the actor taking the noun]
       @push keep_silent; keep_silent=1; TryAction(0, actor, ##Take, noun, 0);; @pull keep_silent; 
      ! phrase 5
      ! [5: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 6
      ! [6: stop the action]
       rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_124, 124, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert something into itself rule ):
[ R_125 
    t_0 ! Local variable e.g. 'noun-CPC' = object
    t_1 ! Local variable e.g. 'second-CPC' = object
    t_2 ! Local variable e.g. 'transfer ceiling' = object
    ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_125, 125);
      ! phrase 1
      ! [1: let the noun-cpc be the component parts core of the noun]
       t_0 =  CoreOf(noun) ; 
      ! phrase 2
      ! [2: let the second-cpc be the component parts core of the second noun]
       t_1 =  CoreOf(second) ; 
      ! phrase 3
      ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]
       t_2 =  (CommonAncestor(t_0, t_1)) ; 
      ! phrase 4
      ! [4: if the transfer ceiling is the noun-cpc , stop the action with library message inserting it into action number 5 for the noun]
       if (((t_2 == t_0))) {  return GL__M(##Insert,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_125, 125, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
[ R_126 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_126, 126);
      ! phrase 1
      ! [1: if the second noun is a closed container , stop the action with library message inserting it into action number 3 for the second noun]
       if (((second ofclass K5_container) && ((Adj_75_t1_v65(second))))) {  return GL__M(##Insert,3,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_126, 126, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
[ R_127 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_127, 127);
      ! phrase 1
      ! [1: if the second noun is not a container , stop the action with library message inserting it into action number 2 for the second noun]
       if (((~~((second ofclass K5_container))))) {  return GL__M(##Insert,2,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_127, 127, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
[ R_128 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_128, 128);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message inserting it into action number 6 for the noun]
          GL__M(##Insert,6,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_128, 128, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
[ R_129 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_129, 129);
      ! phrase 1
      ! [1: if the second noun provides the property carrying capacity begin]
       if (((WhetherProvides(second, false, capacity))))  {
         ! phrase 2
         ! [2: if the number of things in the second noun is at least the carrying capacity of the second noun , stop the action with library message inserting it into action number 7 for the second noun]
          if ((( (Prop_50())  >= GProperty(OBJECT_TY, second,capacity)))) {  return GL__M(##Insert,7,second);   }
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_129, 129, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Inserting it into (B141_carry_out_inserting_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor inserting something into ( this is the standard inserting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor inserting something into ( this is the standard inserting rule ):
[ R_130 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_130, 130);
      ! phrase 1
      ! [1: now the noun is in the second noun]
       MoveObject(noun,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_130, 130, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Inserting it into (B142_report_inserting_it_int)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor inserting something into ( this is the concise report inserting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor inserting something into ( this is the standard report inserting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor inserting something into ( this is the concise report inserting rule ):
[ R_131 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_131, 131);
      ! phrase 1
      ! [1: if the actor is the player and the i6 parser is running multiple actions , stop the action with library message inserting it into action number 8 for the noun]
       if ((((actor == player))) && (( (multiflag==1) ))) {  return GL__M(##Insert,8,noun);   }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_131, 131, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor inserting something into ( this is the standard report inserting rule ):
[ R_132 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_132, 132);
      ! phrase 1
      ! [1: if the actor is the player , issue library message inserting it into action number 9 for the noun]
       if (((actor == player))) {  GL__M(##Insert,9,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message inserting it into action number 10 for the noun]
       else {  AGL__M(##Insert,10,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_132, 132, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Eating (B143_check_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor eating ( this is the can't eat unless edible rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor eating ( this is the can't eat unless edible rule ):
[ R_133 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_133, 133);
      ! phrase 1
      ! [1: if the noun is not a thing or the noun is not edible , stop the action with library message eating action number 1 for the noun]
       if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_57_t1_v65(noun)))))))) {  return GL__M(##Eat,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_133, 133, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
[ R_134 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_134, 134);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: try the actor trying taking off the noun]
          TryAction(0, actor, ##Disrobe, noun, 0);; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_134, 134, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Eating (B144_carry_out_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor eating ( this is the standard eating rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor eating ( this is the standard eating rule ):
[ R_135 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_135, 135);
      ! phrase 1
      ! [1: remove the noun from play]
       RemoveFromPlay(noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_135, 135, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Eating (B145_report_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor eating ( this is the standard report eating rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor eating ( this is the standard report eating rule ):
[ R_136 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_136, 136);
      ! phrase 1
      ! [1: if the actor is the player , issue library message eating action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Eat,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message eating action number 3 for the noun]
       else {  AGL__M(##Eat,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_136, 136, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Going (B146_check_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor going somewhere when the holder of the person asked is an enterable thing ( called the chaise ) ( this is the rising before departure rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/6 ! Check an actor going when the actor is on a supporter ( called the chaise ) ( this is the stand up before going rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/6 ! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
!   === which is equally specific with ===
! Rule 4/6 ! Check an actor going ( this is the can't go through closed doors rule ):
!   === which is equally specific with ===
! Rule 5/6 ! Check an actor going ( this is the determine map connection rule ):
!   === which is equally specific with ===
! Rule 6/6 ! Check an actor going ( this is the can't go that way rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Modified Exit" by Emily Short
! Check an actor going somewhere when the holder of the person asked is an enterable thing ( called the chaise ) ( this is the rising before departure rule ):
[ R_862 
    t_0 ! Local variable e.g. 'chaise' = object
    ;
   if ((act_requester==nothing) && (((MStack-->MstVON(20007,1)) ofclass K1_room)) && (self=actor,true) && ((( (HolderOf(actor))  ofclass K2_thing) && (t_0=( (HolderOf(actor)) ), true) && ((Adj_71_t1_v65( (HolderOf(actor)) )))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_862, 862);
      ! phrase 1
      ! [1: if the chaise is a vehicle , make no decision]
       if (((t_0 ofclass K27_vehicle))) {  rfalse;   }
      ! phrase 2
      ! [2: while the holder of the person asked is an enterable thing ( called the chaise ) begin]
       while ((( (HolderOf(actor))  ofclass K2_thing) && (t_0=( (HolderOf(actor)) ), true) && ((Adj_71_t1_v65( (HolderOf(actor)) )))))  {
         ! phrase 3
         ! [3: abide by the implicit exiting rule]
          if (ProcessRulebook(R_863)) rtrue; 
         ! phrase 4
         ! [4: if the holder of the person asked is the chaise , stop the action]
          if ((( (HolderOf(actor))  == t_0))) {  rtrue;   }
         ! phrase 5
         ! [5: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_862, 862, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going when the actor is on a supporter ( called the chaise ) ( this is the stand up before going rule ):
[ R_138 
    t_0 ! Local variable e.g. 'chaise' = object
    ;
   if ((act_requester==nothing) && (self=actor,true) && (((SupporterOf(actor) ofclass K6_supporter) && (t_0=(SupporterOf(actor)), true)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_138, 138);
      ! phrase 1
      ! [1: issue library message going action number 27 for the chaise]
       GL__M(##Go,27,t_0); 
      ! phrase 2
      ! [2: silently try the actor exiting]
       @push keep_silent; keep_silent=1; TryAction(0, actor, ##Exit, 0, 0);; @pull keep_silent; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_138, 138, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
[ R_139 
    t_0 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_139, 139);
      ! phrase 1
      ! [1: let h be the holder of the actor]
       t_0 =  (HolderOf(actor)) ; 
      ! phrase 2
      ! [2: if h is the room gone from , continue the action]
       if (((t_0 == (MStack-->MstVO(20007,0))))) {  rfalse;   }
      ! phrase 3
      ! [3: if h is the vehicle gone by , continue the action]
       if (((t_0 == (MStack-->MstVO(20007,3))))) {  rfalse;   }
      ! phrase 4
      ! [4: stop the action with library message going action number 1 for h]
       return GL__M(##Go,1,t_0); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_139, 139, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't go through closed doors rule ):
[ R_141 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_141, 141);
      ! phrase 1
      ! [1: if the door gone through is not nothing and the door gone through is closed begin]
       if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_75_t1_v65((MStack-->MstVO(20007,2))))))))  {
         ! phrase 2
         ! [2: issue library message going action number 28 for the door gone through]
          GL__M(##Go,28,(MStack-->MstVO(20007,2))); 
         ! phrase 3
         ! [3: silently try the actor opening the door gone through]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Open, (MStack-->MstVO(20007,2)), 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the door gone through is open , continue the action]
          if ((((Adj_74_t1_v65((MStack-->MstVO(20007,2))))))) {  rfalse;   }
         ! phrase 5
         ! [5: stop the action]
          rtrue; 
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_141, 141, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the determine map connection rule ):
[ R_142 
    t_0 ! Local variable e.g. 'target' = object
    t_1 ! Local variable e.g. 'direction D' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_142, 142);
      ! phrase 1
      ! [1: let the target be nothing]
       t_0 = nothing; 
      ! phrase 2
      ! [2: if the noun is a direction begin]
       if (((noun ofclass K3_direction)))  {
         ! phrase 3
         ! [3: let direction d be the noun]
          t_1 = noun; 
         ! phrase 4
         ! [4: let the target be the room-or-door direction d from the room gone from]
          t_0 = (Resolver_1(t_1,(MStack-->MstVO(20007,0)),"source", 1982)); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: if the noun is a door , let the target be the noun]
          if (((noun ofclass K4_door))) {  t_0 = noun;   }
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: if the target is a door begin]
       if (((t_0 ofclass K4_door)))  {
         ! phrase 9
         ! [9: now the target is the other side of the target from the room gone from]
          t_0 = (Resolver_2(t_0,(MStack-->MstVO(20007,0)),"source", 1986)); 
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: now the room gone to is the target]
       (MStack-->MstVO(20007,1)) = t_0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_142, 142, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't go that way rule ):
[ R_143 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_143, 143);
      ! phrase 1
      ! [1: if the room gone to is nothing begin]
       if ((((MStack-->MstVO(20007,1)) == nothing)))  {
         ! phrase 2
         ! [2: if the door gone through is nothing , stop the action with library message going action number 2 for the room gone from]
          if ((((MStack-->MstVO(20007,2)) == nothing))) {  return GL__M(##Go,2,(MStack-->MstVO(20007,0)));   }
         ! phrase 3
         ! [3: stop the action with library message going action number 6 for the door gone through]
          return GL__M(##Go,6,(MStack-->MstVO(20007,2))); 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_143, 143, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Going (B147_carry_out_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! This is the say goodbye when moving rule:
!   === which is equally specific with ===
! Rule 2/7 ! First carry out going rule ( this is the store small kindnesses former location rule ):
! --- now the mid-placed rules ---
! Rule 3/7 ! Carry out going path of darting shadow when darting shadow is visible during Pursuit:
!   >>> I - Number of aspects constrained >>>
! Rule 4/7 ! Carry out going during Chase:
!   >>> I - Number of aspects constrained >>>
! Rule 5/7 ! Carry out an actor going ( this is the move player and vehicle rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Carry out an actor going ( this is the move floating objects rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Carry out an actor going ( this is the check light in new location rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! This is the say goodbye when moving rule:
[ R_773 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_773, 773);
      ! phrase 1
      ! [1: if the current interlocutor is a person in the location begin]
       if ((((Global_Vars-->9) ofclass K8_person) && (real_location == ContainerOf((Global_Vars-->9)))))  {
         ! phrase 2
         ! [2: now the farewell type is implicit]
          (Global_Vars-->11) = Q22_implicit; 
         ! phrase 3
         ! [3: try saying goodbye to the current interlocutor]
          TryAction(0, player, ##A92_saying_goodbye_to, (Global_Vars-->9), 0);; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_773, 773, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! First carry out going rule ( this is the store small kindnesses former location rule ):
[ R_870 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_870, 870);
      ! phrase 1
      ! [1: now the small kindnesses former location is the location]
       (Global_Vars-->20) = real_location; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_870, 870, true);
   rfalse;
];
! No specific request
! Carry out going path of darting shadow when darting shadow is visible during Pursuit:
[ R_1132 ;
   if (scene_status-->3 == 1) { ! Runs only during scene
   if ( (actor==player) && ((noun == GProperty(OBJECT_TY, O181_darting_shadow,p22_path)) && (true)) && (self=actor,true) && ((((Adj_3_t1_v65(O181_darting_shadow)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1132, 1132);
      ! phrase 1
      ! [1: say ~[if times followed of darting shadow is 1]You head off in the direction of the movement, scanning with your flashlight over the skittering shadows.[otherwise if times followed of darting shadow is 2]You chase after the shadow, faster and faster, breath misting in the cold air.[otherwise]Some crazy thrill comes over you. You feel like a hunter. You can almost smell the thing you're chasing in the air. You [italic type]can[roman type] smell it, sweaty fur and terror. You race after it.[end if]~]
      say__p=1;
	if (~~((((GProperty(OBJECT_TY, O181_darting_shadow,p23_times_followed) == 1))))) jump L_Say299;
		ParaContent();  print (PrintText) SC_456;  new_line;ParaContent(); 
	jump L_SayX269; .L_Say299; if (~~((((GProperty(OBJECT_TY, O181_darting_shadow,p23_times_followed) == 2))))) jump L_Say300;
		ParaContent();  print (PrintText) SC_457;  new_line;
	jump L_SayX269; .L_Say300;
		ParaContent();  print (PrintText) SC_458; ParaContent();  style underline; ParaContent();  print (PrintText) SC_459; ParaContent();  style roman; ParaContent();  print (PrintText) SC_460;  new_line;
	.L_Say301; .L_SayX269;
		 .L_Say302; .L_SayX270;
      ! phrase 2
      ! [2: now path of darting shadow is the bunny's path]
       WriteGProperty(OBJECT_TY, O181_darting_shadow,p22_path,(PHR_1135_r33 ())); 
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1132, 1132, true);
   rfalse;
];
! No specific request
! Carry out going during Chase:
[ R_1163 ;
   if (scene_status-->6 == 1) { ! Runs only during scene
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1163, 1163);
      ! phrase 1
      ! [1: say ~[one of]You move nervously forward.[or]You jog forward, eyes snapping left and right at the moving shadows around you.[or]You're running now, jumping over sagebrush and stumbling on rocks, as snarling animal forms close in around you.[or]You run.[stopping]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->13 =
	i7_soo_stop(I7_ST_say_one_of-->13, 4);
	switch((I7_ST_say_one_of-->13)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_461;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_462;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_463;  new_line;ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_464;  new_line;ParaContent();  }  .L_Say303; .L_SayX271;
   } ! Runs only during scene
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1163, 1163, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor going ( this is the move player and vehicle rule ):
[ R_144 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_144, 144);
      ! phrase 1
      ! [1: if the vehicle gone by is nothing , surreptitiously move the actor to the room gone to during going]
       if ((((MStack-->MstVO(20007,3)) == nothing))) {  MoveDuringGoing(actor, (MStack-->MstVO(20007,1)));   }
      ! phrase 2
      ! [2: otherwise surreptitiously move the vehicle gone by to the room gone to during going]
       else {  MoveDuringGoing((MStack-->MstVO(20007,3)), (MStack-->MstVO(20007,1)));   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_144, 144, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor going ( this is the move floating objects rule ):
[ R_145 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_145, 145);
      ! phrase 1
      ! [1: if the actor is the player , update backdrop positions]
       if (((actor == player))) {  MoveFloatingObjects();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_145, 145, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor going ( this is the check light in new location rule ):
[ R_146 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_146, 146);
      ! phrase 1
      ! [1: if the actor is the player , surreptitiously reckon darkness]
       if (((actor == player))) {  SilentlyConsiderLight();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_146, 146, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Going (B148_report_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Report going up from Roof when player holds courage:
!   === which is equally specific with ===
! Rule 2/7 ! Report going up from Roof when huge metal barrel is placed correctly:
!   >>> I - Number of aspects constrained >>>
! Rule 3/7 ! Report going from Crumbling Concrete to Staging Area during Rainstorm:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 4/7 ! Report going to The Open Desert when The Open Desert is unvisited:
!   >>> I - Number of aspects constrained >>>
! Rule 5/7 ! Report going through a window:
!   >>> III - Action requirement >>>
! Rule 6/7 ! Report going during Sand-dancer's Arrival:
!   >>> I - Number of aspects constrained >>>
! Rule 7/7 ! Report an actor going ( this is the describe room gone into rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report going up from Roof when player holds courage:
[ R_1065 ;
   if ( (actor==player) && ((noun == O18_up) && (true)) && (((MStack-->MstVON(20007,0)) == O89_roof) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && (((player == HolderOf(O80_courage))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1065, 1065);
      ! phrase 1
      ! [1: say ~[first time]You gather your courage and leap off the edge of the roof. Your hands grasp the metal of the bottommost rung, scraping and sliding, but holding. [only]You pull yourself up the rungs into the control center. Hey, it wasn't that hard after all.~]
      say__p=1;ParaContent();  
	if ((I7_ST_say_first_time-->1)++ == 0) {
		ParaContent();  print (PrintText) SC_465; ParaContent();  } ParaContent();  print (PrintText) SC_466;  new_line; .L_Say304; .L_SayX272;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1065, 1065, true);
   rfalse;
];
! No specific request
! Report going up from Roof when huge metal barrel is placed correctly:
[ R_1071 ;
   if ( (actor==player) && ((noun == O18_up) && (true)) && (((MStack-->MstVON(20007,0)) == O89_roof) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && ((((Adj_102_t1_v65(O144_huge_metal_barrel)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1071, 1071);
      ! phrase 1
      ! [1: say ~You climb up on the barrel, reach, grab the bottom rungs, and pull yourself up.~]
      say__p=1;ParaContent();  print (PrintText) SC_467;  new_line; .L_Say305; .L_SayX273;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1071, 1071, true);
   rfalse;
];
! No specific request
! Report going from Crumbling Concrete to Staging Area during Rainstorm:
[ R_1126 ;
   if (scene_status-->2 == 1) { ! Runs only during scene
   if ( (actor==player) && (((MStack-->MstVON(20007,0)) == O68_crumbling_concrete) && (true)) && (((MStack-->MstVON(20007,1)) == O69_staging_area) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1126, 1126);
      ! phrase 1
      ! [1: say ~Gratefully, you slip inside the building, out of the storm.~]
      say__p=1;ParaContent();  print (PrintText) SC_468;  new_line; .L_Say306; .L_SayX274;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1126, 1126, true);
   rfalse;
];
! No specific request
! Report going to The Open Desert when The Open Desert is unvisited:
[ R_1083 ;
   if ( (actor==player) && (((MStack-->MstVON(20007,1)) == O149_open_desert) && (true)) && (self=actor,true) && ((((Adj_54_t1_v65(O149_open_desert)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1083, 1083);
      ! phrase 1
      ! [1: say ~You walk for a long time, thoughts turning over like the sand under your sneakers. You think about [a random thing in emotional baggage]. You think about Ocean and how pissed she's gonna be that you're not home. Like you tell her not to wait up for you but she always does anyway.^^Some wind kicks up and chucks sand in your face. You blink it out and kinda realize while you're doing it that you haven't really been paying attention to where you've been going. Another gust whines through the sagebrush and you realize with a kind of heavy feeling that with all the dust this wind is kicking up you can't see a damn thing. You can't see your pickup, you can't see the electrical tower. Not even your damn footprints. You're lost. Well, shit.~]
      say__p=1;ParaContent();  print (PrintText) SC_469; ParaContent();  print (a)  (Prop_51()) ; ParaContent();  print (PrintText) SC_470;  new_line; .L_Say307; .L_SayX275;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1083, 1083, true);
   rfalse;
];
! No specific request
! Report going through a window:
[ R_1025 ;
   if ( (actor==player) && (((MStack-->MstVON(20007,2)) ofclass K119_window)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1025, 1025);
      ! phrase 1
      ! [1: say ~You [first time]brush away remnants of broken glass and [only]wriggle through the window.~]
      say__p=1;ParaContent();  print (PrintText) SC_447; ParaContent();  
	if ((I7_ST_say_first_time-->2)++ == 0) {
		ParaContent();  print (PrintText) SC_471; ParaContent();  } ParaContent();  print (PrintText) SC_472;  new_line; .L_Say308; .L_SayX276;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1025, 1025, true);
   rfalse;
];
! No specific request
! Report going during Sand-dancer's Arrival:
[ R_1200 ;
   if (scene_status-->9 == 1) { ! Runs only during scene
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1200, 1200);
      ! phrase 1
      ! [1: say ~You wade through the sand, which is rising all the time.~]
      say__p=1;ParaContent();  print (PrintText) SC_473;  new_line; .L_Say309; .L_SayX277;
   } ! Runs only during scene
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1200, 1200, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor going ( this is the describe room gone into rule ):
[ R_147 
    t_0 ! Local variable e.g. 'back way' = object
    t_1 ! Local variable e.g. 'room back the other way' = object
    t_2 ! Local variable e.g. 'room normally this way' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_147, 147);
      ! phrase 1
      ! [1: if the player is the actor begin]
       if (((player == actor)))  {
         ! phrase 2
         ! [2: produce a room description with going spacing conventions]
          LookAfterGoing(); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the noun is a direction begin]
          if (((noun ofclass K3_direction)))  {
            ! phrase 5
            ! [5: if the location is the room gone from begin]
             if (((real_location == (MStack-->MstVO(20007,0)))))  {
               ! phrase 6
               ! [6: if the location is the room gone to begin]
                if (((real_location == (MStack-->MstVO(20007,1)))))  {
                  ! phrase 7
                  ! [7: continue the action]
                   rfalse; 
                  ! phrase 8
                  ! [8: otherwise]
                  } else {

                  ! phrase 9
                  ! [9: if the noun is up begin]
                   if (((noun == O18_up)))  {
                     ! phrase 10
                     ! [10: issue actor-based library message going action number 8]
                      AGL__M(##Go,8,noun); 
                     ! phrase 11
                     ! [11: otherwise if the noun is down]
                      } else if (((noun == O19_down))) { 
                     ! phrase 12
                     ! [12: issue actor-based library message going action number 9]
                      AGL__M(##Go,9,noun); 
                     ! phrase 13
                     ! [13: otherwise]
                     } else {

                     ! phrase 14
                     ! [14: issue actor-based library message going action number 10 for the noun]
                      AGL__M(##Go,10,noun); 
                     ! phrase 15
                     ! [15: end if]
                     }

                  ! phrase 16
                  ! [16: end if]
                  }

               ! phrase 17
               ! [17: otherwise]
               } else {

               ! phrase 18
               ! [18: let the back way be the opposite of the noun]
                t_0 = GProperty(OBJECT_TY, noun,p9_opposite); 
               ! phrase 19
               ! [19: if the location is the room gone to begin]
                if (((real_location == (MStack-->MstVO(20007,1)))))  {
                  ! phrase 20
                  ! [20: let the room back the other way be the room back way from the location]
                   t_1 = (Resolver_8(t_0,real_location,"source", 2027)); 
                  ! phrase 21
                  ! [21: let the room normally this way be the room noun from the room gone from]
                   t_2 = (Resolver_9(noun,(MStack-->MstVO(20007,0)),"source", 2029)); 
                  ! phrase 22
                  ! [22: if the room back the other way is the room gone from or the room back the other way is the room normally this way begin]
                   if ((((t_1 == (MStack-->MstVO(20007,0))))) || (((t_1 == t_2))))  {
                     ! phrase 23
                     ! [23: if the back way is up begin]
                      if (((t_0 == O18_up)))  {
                        ! phrase 24
                        ! [24: issue actor-based library message going action number 11]
                         AGL__M(##Go,11,noun); 
                        ! phrase 25
                        ! [25: otherwise if the back way is down]
                         } else if (((t_0 == O19_down))) { 
                        ! phrase 26
                        ! [26: issue actor-based library message going action number 12]
                         AGL__M(##Go,12,noun); 
                        ! phrase 27
                        ! [27: otherwise]
                        } else {

                        ! phrase 28
                        ! [28: issue actor-based library message going action number 13 for the back way]
                         AGL__M(##Go,13,t_0); 
                        ! phrase 29
                        ! [29: end if]
                        }

                     ! phrase 30
                     ! [30: otherwise]
                     } else {

                     ! phrase 31
                     ! [31: issue actor-based library message going action number 14]
                      AGL__M(##Go,14,noun); 
                     ! phrase 32
                     ! [32: end if]
                     }

                  ! phrase 33
                  ! [33: otherwise]
                  } else {

                  ! phrase 34
                  ! [34: if the back way is up begin]
                   if (((t_0 == O18_up)))  {
                     ! phrase 35
                     ! [35: issue actor-based library message going action number 15 for the room gone to]
                      AGL__M(##Go,15,(MStack-->MstVO(20007,1))); 
                     ! phrase 36
                     ! [36: otherwise if the back way is down]
                      } else if (((t_0 == O19_down))) { 
                     ! phrase 37
                     ! [37: issue actor-based library message going action number 16 for the room gone to]
                      AGL__M(##Go,16,(MStack-->MstVO(20007,1))); 
                     ! phrase 38
                     ! [38: otherwise]
                     } else {

                     ! phrase 39
                     ! [39: issue actor-based library message going action number 17 for the room gone to and the back way]
                      AGL__M(##Go,17,(MStack-->MstVO(20007,1)),t_0); 
                     ! phrase 40
                     ! [40: end if]
                     }

                  ! phrase 41
                  ! [41: end if]
                  }

               ! phrase 42
               ! [42: end if]
               }

            ! phrase 43
            ! [43: otherwise if the location is the room gone from]
             } else if (((real_location == (MStack-->MstVO(20007,0))))) { 
            ! phrase 44
            ! [44: issue actor-based library message going action number 18 for the noun]
             AGL__M(##Go,18,noun); 
            ! phrase 45
            ! [45: otherwise]
            } else {

            ! phrase 46
            ! [46: issue actor-based library message going action number 19 for the noun]
             AGL__M(##Go,19,noun); 
            ! phrase 47
            ! [47: end if]
            }

         ! phrase 48
         ! [48: if the vehicle gone by is not nothing begin]
          if (((~~(((MStack-->MstVO(20007,3)) == nothing)))))  {
            ! phrase 49
            ! [49: say ~ ~]
            say__p=1;ParaContent();  print (PrintText) SC_166;  .L_Say310; .L_SayX278;
            ! phrase 50
            ! [50: if the vehicle gone by is a supporter , issue actor-based library message going action number 20 for the vehicle gone by]
             if ((((MStack-->MstVO(20007,3)) ofclass K6_supporter))) {  AGL__M(##Go,20,(MStack-->MstVO(20007,3)));   }
            ! phrase 51
            ! [51: otherwise issue actor-based library message going action number 21 for the vehicle gone by]
             else {  AGL__M(##Go,21,(MStack-->MstVO(20007,3)));   }
            ! phrase 52
            ! [52: end if]
            }

         ! phrase 53
         ! [53: if the thing gone with is not nothing begin]
          if (((~~(((MStack-->MstVO(20007,4)) == nothing)))))  {
            ! phrase 54
            ! [54: if the player is within the thing gone with begin]
             if ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))  {
               ! phrase 55
               ! [55: issue actor-based library message going action number 22 for the thing gone with]
                AGL__M(##Go,22,(MStack-->MstVO(20007,4))); 
               ! phrase 56
               ! [56: otherwise if the player is within the vehicle gone by]
                } else if ((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) { 
               ! phrase 57
               ! [57: issue actor-based library message going action number 23 for the thing gone with]
                AGL__M(##Go,23,(MStack-->MstVO(20007,4))); 
               ! phrase 58
               ! [58: otherwise if the location is the room gone from]
                } else if (((real_location == (MStack-->MstVO(20007,0))))) { 
               ! phrase 59
               ! [59: issue actor-based library message going action number 24 for the thing gone with]
                AGL__M(##Go,24,(MStack-->MstVO(20007,4))); 
               ! phrase 60
               ! [60: otherwise]
               } else {

               ! phrase 61
               ! [61: issue actor-based library message going action number 25 for the thing gone with]
                AGL__M(##Go,25,(MStack-->MstVO(20007,4))); 
               ! phrase 62
               ! [62: end if]
               }

            ! phrase 63
            ! [63: end if]
            }

         ! phrase 64
         ! [64: if the player is within the vehicle gone by and the player is not within the thing gone with begin]
          if (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) && (((~~(((MStack-->MstVO(20007,4)) == ContainerOf(player)))))))  {
            ! phrase 65
            ! [65: issue actor-based library message going action number 26]
             AGL__M(##Go,26,noun); 
            ! phrase 66
            ! [66: say ~.~]
            say__p=1;ParaContent();  print (PrintText) SC_77;  new_line; .L_Say311; .L_SayX279;
            ! phrase 67
            ! [67: try looking]
             TryAction(0, player, ##Look, 0, 0);; 
            ! phrase 68
            ! [68: continue the action]
             rfalse; 
            ! phrase 69
            ! [69: end if]
            }

         ! phrase 70
         ! [70: say ~.~]
         say__p=1;ParaContent();  print (PrintText) SC_77;  new_line; .L_Say312; .L_SayX280;
         ! phrase 71
         ! [71: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_147, 147, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Entering (B149_check_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor entering ( this is the convert enter door into go rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor entering ( this is the convert enter compass direction into go rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor entering ( this is the can't enter what's already entered rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor entering ( this is the can't enter what's not enterable rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor entering ( this is the can't enter closed containers rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor entering ( this is the can't enter something carried rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor entering ( this is the implicitly pass through other barriers rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the convert enter door into go rule ):
[ R_149 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_149, 149);
      ! phrase 1
      ! [1: if the noun is a door , convert to the going action on the noun]
       if (((noun ofclass K4_door))) {  return GVS_Convert(##Go,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_149, 149, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the convert enter compass direction into go rule ):
[ R_150 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_150, 150);
      ! phrase 1
      ! [1: if the noun is a direction , convert to the going action on the noun]
       if (((noun ofclass K3_direction))) {  return GVS_Convert(##Go,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_150, 150, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter what's already entered rule ):
[ R_151 
    t_0 ! Local variable e.g. 'local ceiling' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_151, 151);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: if the local ceiling is the noun , stop the action with library message entering action number 1 for the noun]
       if (((t_0 == noun))) {  return GL__M(##Enter,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_151, 151, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter what's not enterable rule ):
[ R_152 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_152, 152);
      ! phrase 1
      ! [1: if the noun is not enterable , stop the action with library message entering action number 2 for the noun]
       if (((~~(((Adj_71_t1_v65(noun))))))) {  return GL__M(##Enter,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_152, 152, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter closed containers rule ):
[ R_153 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_153, 153);
      ! phrase 1
      ! [1: if the noun is a closed container , stop the action with library message entering action number 3 for the noun]
       if (((noun ofclass K5_container) && ((Adj_75_t1_v65(noun))))) {  return GL__M(##Enter,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_153, 153, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter something carried rule ):
[ R_154 
    t_0 ! Local variable e.g. 'local ceiling' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_154, 154);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: if the local ceiling is the actor , stop the action with library message entering action number 4 for the noun]
       if (((t_0 == actor))) {  return GL__M(##Enter,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_154, 154, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the implicitly pass through other barriers rule ):
[ R_155 
    t_0 ! Local variable e.g. 'local ceiling' = object
    t_1 ! Local variable e.g. 'target' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_155, 155);
      ! phrase 1
      ! [1: if the holder of the actor is the holder of the noun , continue the action]
       if ((( (HolderOf(actor))  ==  (HolderOf(noun)) ))) {  rfalse;   }
      ! phrase 2
      ! [2: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 3
      ! [3: while the holder of the actor is not the local ceiling begin]
       while (((~~(( (HolderOf(actor))  == t_0)))))  {
         ! phrase 4
         ! [4: let the target be the holder of the actor]
          t_1 =  (HolderOf(actor)) ; 
         ! phrase 5
         ! [5: issue library message entering action number 6 for the target]
          GL__M(##Enter,6,t_1); 
         ! phrase 6
         ! [6: silently try the actor trying exiting]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Exit, 0, 0);; @pull keep_silent; 
         ! phrase 7
         ! [7: if the holder of the actor is the target , stop the action]
          if ((( (HolderOf(actor))  == t_1))) {  rtrue;   }
         ! phrase 8
         ! [8: end while]
         }

      ! phrase 9
      ! [9: if the holder of the actor is the noun , stop the action]
       if ((( (HolderOf(actor))  == noun))) {  rtrue;   }
      ! phrase 10
      ! [10: if the holder of the actor is the holder of the noun , continue the action]
       if ((( (HolderOf(actor))  ==  (HolderOf(noun)) ))) {  rfalse;   }
      ! phrase 11
      ! [11: let the target be the holder of the noun]
       t_1 =  (HolderOf(noun)) ; 
      ! phrase 12
      ! [12: if the noun is part of the target , let the target be the holder of the target]
       if (((t_1 == (noun.component_parent)))) {  t_1 =  (HolderOf(t_1)) ;   }
      ! phrase 13
      ! [13: while the target is a thing begin]
       while (((t_1 ofclass K2_thing)))  {
         ! phrase 14
         ! [14: if the holder of the target is the local ceiling begin]
          if ((( (HolderOf(t_1))  == t_0)))  {
            ! phrase 15
            ! [15: issue library message entering action number 7 for the target]
             GL__M(##Enter,7,t_1); 
            ! phrase 16
            ! [16: silently try the actor trying entering the target]
             @push keep_silent; keep_silent=1; TryAction(0, actor, ##Enter, t_1, 0);; @pull keep_silent; 
            ! phrase 17
            ! [17: if the holder of the actor is not the target , stop the action]
             if (((~~(( (HolderOf(actor))  == t_1))))) {  rtrue;   }
            ! phrase 18
            ! [18: convert to the entering action on the noun]
             return GVS_Convert(##Enter,noun,0); 
            ! phrase 19
            ! [19: continue the action]
             rfalse; 
            ! phrase 20
            ! [20: end if]
            }

         ! phrase 21
         ! [21: let the target be the holder of the target]
          t_1 =  (HolderOf(t_1)) ; 
         ! phrase 22
         ! [22: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_155, 155, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Entering (B150_carry_out_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor entering ( this is the standard entering rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor entering ( this is the standard entering rule ):
[ R_156 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_156, 156);
      ! phrase 1
      ! [1: surreptitiously move the actor to the noun]
       move actor to noun; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_156, 156, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Entering (B151_report_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor entering ( this is the standard report entering rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor entering ( this is the describe contents entered into rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor entering ( this is the standard report entering rule ):
[ R_157 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_157, 157);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message entering action number 5 for the noun]
          GL__M(##Enter,5,noun); 
         ! phrase 3
         ! [3: otherwise if the noun is a container]
          } else if (((noun ofclass K5_container))) { 
         ! phrase 4
         ! [4: issue actor-based library message entering action number 8 for the noun]
          AGL__M(##Enter,8,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message entering action number 9 for the noun]
          AGL__M(##Enter,9,noun); 
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_157, 157, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor entering ( this is the describe contents entered into rule ):
[ R_158 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_158, 158);
      ! phrase 1
      ! [1: if the actor is the player , describe locale for the noun]
       if (((actor == player))) { (PHR_71_r34 (noun));  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_158, 158, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Exiting (B152_check_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor exiting ( this is the small kindnesses exit leaves when there's only one way to go rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor exiting ( this is the can't exit when not inside anything rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor exiting ( this is the can't exit closed containers rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor exiting ( this is the convert exit into get off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Check an actor exiting ( this is the small kindnesses exit leaves when there's only one way to go rule ):
[ R_869 
    t_0 ! Local variable e.g. 'local room' = object
    t_1 ! Local variable e.g. 'way' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_869, 869);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
       t_0 =  LocationOf(actor) ; 
      ! phrase 2
      ! [2: if the container exited from is the local room begin]
       if ((((MStack-->MstVO(20009,0)) == t_0)))  {
         ! phrase 3
         ! [3: if the actor is the player and the number of adjacent rooms is 1 begin]
          if ((((actor == player))) && ((( (Prop_52())  == 1))))  {
            ! phrase 4
            ! [4: let way be best route from location to a random adjacent room , using even locked doors]
             t_1 =  MapRouteTo(real_location, (Prop_53()) ,0,2) ; 
            ! phrase 5
            ! [5: if way is a direction , convert to the going action on way]
             if (((t_1 ofclass K3_direction))) {  return GVS_Convert(##Go,t_1,0);   }
            ! phrase 6
            ! [6: otherwise if the room-or-door outside from the local room is not nothing]
             } else if (((~~(((Resolver_10(out_obj,t_0,"source", 21)) == nothing))))) { 
            ! phrase 7
            ! [7: convert to the going action on the outside]
             return GVS_Convert(##Go,out_obj,0); 
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_869, 869, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the can't exit when not inside anything rule ):
[ R_161 
    t_0 ! Local variable e.g. 'local room' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_161, 161);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
       t_0 =  LocationOf(actor) ; 
      ! phrase 2
      ! [2: if the container exited from is the local room , stop the action with library message exiting action number 1 for the actor]
       if ((((MStack-->MstVO(20009,0)) == t_0))) {  return GL__M(##Exit,1,actor);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_161, 161, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the can't exit closed containers rule ):
[ R_162 
    t_0 ! Local variable e.g. 'cage' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_162, 162);
      ! phrase 1
      ! [1: if the actor is in a closed container ( called the cage ) , stop the action with library message exiting action number 2 for the cage]
       if (((ContainerOf(actor) ofclass K5_container) && (t_0=(ContainerOf(actor)), true) && ((Adj_75_t1_v65(ContainerOf(actor)))))) {  return GL__M(##Exit,2,t_0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_162, 162, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the convert exit into get off rule ):
[ R_163 
    t_0 ! Local variable e.g. 'platform' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_163, 163);
      ! phrase 1
      ! [1: if the actor is on a supporter ( called the platform ) , convert to the getting off action on the platform]
       if (((SupporterOf(actor) ofclass K6_supporter) && (t_0=(SupporterOf(actor)), true))) {  return GVS_Convert(##GetOff,t_0,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_163, 163, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Exiting (B153_carry_out_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor exiting ( this is the standard exiting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor exiting ( this is the standard exiting rule ):
[ R_164 
    t_0 ! Local variable e.g. 'former exterior' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_164, 164);
      ! phrase 1
      ! [1: let the former exterior be the not-counting-parts holder of the container exited from]
       t_0 =  (CoreOfParentOfCoreOf((MStack-->MstVO(20009,0)))) ; 
      ! phrase 2
      ! [2: surreptitiously move the actor to the former exterior]
       move actor to t_0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_164, 164, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Exiting (B154_report_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor exiting ( this is the standard report exiting rule ):
!   >>> III - Action requirement >>>
! Rule 2/2 ! This is the new describe room emerged into rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor exiting ( this is the standard report exiting rule ):
[ R_165 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_165, 165);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message exiting action number 3 for the container exited from]
          GL__M(##Exit,3,(MStack-->MstVO(20009,0))); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: issue actor-based library message exiting action number 6 for the container exited from]
          AGL__M(##Exit,6,(MStack-->MstVO(20009,0))); 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_165, 165, true);
   rfalse;
];
! No specific request
! From "Modified Exit" by Emily Short
! This is the new describe room emerged into rule:
[ R_867 ;
      ! phrase 1
      ! [1: if the sequential action option is not active begin]
       if (((~~(((Adj_22_t1_v74(23)))))))  {
         ! phrase 2
         ! [2: abide by the describe room emerged into rule]
          if (ProcessRulebook(R_166)) rtrue; 
         ! phrase 3
         ! [3: end if]
         }

   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Getting off (B155_check_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the new can't get off things rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Modified Exit" by Emily Short
! This is the new can't get off things rule:
[ R_859 ;
      ! phrase 1
      ! [1: if the actor is on the noun , continue the action]
       if (((noun == SupporterOf(actor)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is carried by the noun , continue the action]
       if (((noun == CarrierOf(actor)))) {  rfalse;   }
      ! phrase 3
      ! [3: if the actor is in the noun , continue the action]
       if (((noun == ContainerOf(actor)))) {  rfalse;   }
      ! phrase 4
      ! [4: stop the action with library message getting off action number 1 for the noun]
       return GL__M(##GetOff,1,noun); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Getting off (B156_carry_out_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor getting off ( this is the standard getting off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor getting off ( this is the standard getting off rule ):
[ R_168 
    t_0 ! Local variable e.g. 'former exterior' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_168, 168);
      ! phrase 1
      ! [1: let the former exterior be the not-counting-parts holder of the noun]
       t_0 =  (CoreOfParentOfCoreOf(noun)) ; 
      ! phrase 2
      ! [2: surreptitiously move the actor to the former exterior]
       move actor to t_0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_168, 168, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Getting off (B157_report_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor getting off ( this is the standard report getting off rule ):
!   >>> III - Action requirement >>>
! Rule 2/2 ! This is the new describe room stood up into rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor getting off ( this is the standard report getting off rule ):
[ R_169 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_169, 169);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message exiting action number 3 for the noun]
          GL__M(##Exit,3,noun); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: issue actor-based library message exiting action number 5 for the noun]
          AGL__M(##Exit,5,noun); 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_169, 169, true);
   rfalse;
];
! No specific request
! From "Modified Exit" by Emily Short
! This is the new describe room stood up into rule:
[ R_868 ;
      ! phrase 1
      ! [1: if the sequential action option is not active begin]
       if (((~~(((Adj_22_t1_v74(23)))))))  {
         ! phrase 2
         ! [2: abide by the describe room stood up into rule]
          if (ProcessRulebook(R_170)) rtrue; 
         ! phrase 3
         ! [3: end if]
         }

   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking (B159_carry_out_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Carry out looking ( this is the room description heading rule ):
!   === which is equally specific with ===
! Rule 2/6 ! This is the Sand-dancer room description body text rule:
!   === which is equally specific with ===
! Rule 3/6 ! Carry out looking ( this is the room description paragraphs about objects rule ):
!   === which is equally specific with ===
! Rule 4/6 ! Carry out looking ( this is the check new arrival rule ):
!   === which is equally specific with ===
! Rule 5/6 ! Carry out looking ( this is the mark items as seen when looking rule ):
!   === which is equally specific with ===
! Rule 6/6 ! This is the Sand-dancer emergency exit rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out looking ( this is the room description heading rule ):
[ R_172 
    t_0 ! Local variable e.g. 'intermediate level' = object
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_172, 172);
      ! phrase 1
      ! [1: say bold type]
      say__p=1;ParaContent();  style bold;  .L_Say313; .L_SayX281;
      ! phrase 2
      ! [2: if the visibility level count is 0 begin]
       if ((((MStack-->MstVO(20011,2)) == 0)))  {
         ! phrase 3
         ! [3: begin the printing the name of a dark room activity]
          BeginActivity(V8_printing_the_name_of_a_da); 
         ! phrase 4
         ! [4: if handling the printing the name of a dark room activity , issue miscellaneous library message number 71]
          if (( (~~(ForActivity(V8_printing_the_name_of_a_da))) )) {  GL__M(##Miscellany,71);   }
         ! phrase 5
         ! [5: end the printing the name of a dark room activity]
          EndActivity(V8_printing_the_name_of_a_da); 
         ! phrase 6
         ! [6: otherwise if the visibility ceiling is the location]
          } else if ((((MStack-->MstVO(20011,3)) == real_location))) { 
         ! phrase 7
         ! [7: say ~[visibility ceiling]~]
         say__p=1;ParaContent();  print (PrintShortName) (MStack-->MstVO(20011,3));  .L_Say314; .L_SayX282;
         ! phrase 8
         ! [8: otherwise]
         } else {

         ! phrase 9
         ! [9: say ~[The visibility ceiling]~]
         say__p=1;ParaContent();  print (The) (MStack-->MstVO(20011,3));  .L_Say315; .L_SayX283;
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: say roman type]
      say__p=1;ParaContent();  style roman;  .L_Say316; .L_SayX284;
      ! phrase 12
      ! [12: let intermediate level be the visibility-holder of the actor]
       t_0 =  VisibilityParent(actor) ; 
      ! phrase 13
      ! [13: repeat with intermediate level count running from 2 to the visibility level count begin]
       for (t_1=2: t_1<=(MStack-->MstVO(20011,2)): t_1++)  {
         ! phrase 14
         ! [14: issue library message looking action number 8 for the intermediate level]
          GL__M(##Look,8,t_0); 
         ! phrase 15
         ! [15: let the intermediate level be the visibility-holder of the intermediate level]
          t_0 =  VisibilityParent(t_0) ; 
         ! phrase 16
         ! [16: end repeat]
         }

      ! phrase 17
      ! [17: say line break]
      say__p=1;ParaContent();  new_line;  .L_Say317; .L_SayX285;
      ! phrase 18
      ! [18: say run paragraph on with special look spacing]
      say__p=1;ParaContent();  SpecialLookSpacingBreak();  .L_Say318; .L_SayX286;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_172, 172, true);
   rfalse;
];
! No specific request
! This is the Sand-dancer room description body text rule:
[ R_1201 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1201, 1201);
      ! phrase 1
      ! [1: if sand-dancer's arrival is happening and location is in office interior , describe sand-filled room]
       if (((((scene_status-->(Q347_sand_dancer_s_arrival-1)==1)))) && (((TestRegionalContainment(real_location,O112_office_interior))))) { (PHR_1202_r35 ());  }
      ! phrase 2
      ! [2: otherwise abide by the room description body text rule]
       else {  if (ProcessRulebook(R_173)) rtrue;   }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1201, 1201, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out looking ( this is the room description paragraphs about objects rule ):
[ R_174 
    t_0 ! Local variable e.g. 'intermediate position' = object
    t_1 ! Local variable e.g. 'IP count' = number
    t_2 ! Local variable e.g. 'top-down IP count' = number
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_174, 174);
      ! phrase 1
      ! [1: if the visibility level count is greater than 0 begin]
       if ((((MStack-->MstVO(20011,2)) > 0)))  {
         ! phrase 2
         ! [2: let the intermediate position be the actor]
          t_0 = actor; 
         ! phrase 3
         ! [3: let the ip count be the visibility level count]
          t_1 = (MStack-->MstVO(20011,2)); 
         ! phrase 4
         ! [4: while the ip count is greater than 0 begin]
          while (((t_1 > 0)))  {
            ! phrase 5
            ! [5: now the intermediate position is marked for listing]
             (Adj_67_t2_v65(t_0)); 
            ! phrase 6
            ! [6: let the intermediate position be the visibility-holder of the intermediate position]
             t_0 =  VisibilityParent(t_0) ; 
            ! phrase 7
            ! [7: decrease the ip count by 1]
             t_1 = t_1 - 1; 
            ! phrase 8
            ! [8: end while]
            }

         ! phrase 9
         ! [9: let the top-down ip count be the visibility level count]
          t_2 = (MStack-->MstVO(20011,2)); 
         ! phrase 10
         ! [10: while the top-down ip count is greater than 0 begin]
          while (((t_2 > 0)))  {
            ! phrase 11
            ! [11: let the intermediate position be the actor]
             t_0 = actor; 
            ! phrase 12
            ! [12: let the ip count be 0]
             t_1 = 0; 
            ! phrase 13
            ! [13: while the ip count is less than the top-down ip count begin]
             while (((t_1 < t_2)))  {
               ! phrase 14
               ! [14: let the intermediate position be the visibility-holder of the intermediate position]
                t_0 =  VisibilityParent(t_0) ; 
               ! phrase 15
               ! [15: increase the ip count by 1]
                t_1 = t_1 + 1; 
               ! phrase 16
               ! [16: end while]
               }

            ! phrase 17
            ! [17: describe locale for the intermediate position]
            (PHR_71_r34 (t_0));
            ! phrase 18
            ! [18: decrease the top-down ip count by 1]
             t_2 = t_2 - 1; 
            ! phrase 19
            ! [19: end while]
            }

         ! phrase 20
         ! [20: end if]
         }

      ! phrase 21
      ! [21: continue the action]
       rfalse; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_174, 174, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out looking ( this is the check new arrival rule ):
[ R_175 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_175, 175);
      ! phrase 1
      ! [1: if in darkness begin]
       if (( (location==thedark) ))  {
         ! phrase 2
         ! [2: now the darkness witnessed is true]
          (Global_Vars-->0) = 1; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the location is a room , now the location is visited]
          if (((real_location ofclass K1_room))) {  (Adj_53_t2_v65(real_location));   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_175, 175, true);
   rfalse;
];
! No specific request
! From "Epistemology" by Eric Eve
! Carry out looking ( this is the mark items as seen when looking rule ):
[ R_739 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_739, 739);
      ! phrase 1
      ! [1: unless in darkness begin]
       if (~~(( (location==thedark) )))  {
         ! phrase 2
         ! [2: repeat with item running through things that are enclosed by the location begin]
          for (t_0=Prop_54(0), t_1=Prop_54(t_0): t_0: t_0=t_1, t_1=Prop_54(t_1))  {
            ! phrase 3
            ! [3: if the item is not enclosed by an opaque closed container , now the item is seen]
             if ((~~Prop_55(,t_0))) {  (Adj_88_t2_v65(t_0));   }
            ! phrase 4
            ! [4: end repeat]
            }

         ! phrase 5
         ! [5: end unless]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_739, 739, true);
   rfalse;
];
! No specific request
! This is the Sand-dancer emergency exit rule:
[ R_1203 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1203, 1203);
      ! phrase 1
      ! [1: if sand-dancer's arrival is happening and location is in office interior , say ~You glance wildly at the exits [list of viable directions]; [the random visible detrital thing] [one of]surfaces for a moment then gets buried[or]tumbles in the flow[or]vanishes under the sand[at random].~]
       if (((((scene_status-->(Q347_sand_dancer_s_arrival-1)==1)))) && (((TestRegionalContainment(real_location,O112_office_interior))))) { say__p=1;ParaContent();  print (PrintText) SC_474; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K3_direction) && ((Adj_33_t1_v65(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+NOARTICLE_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_475; ParaContent();  print (the)  (Prop_56()) ; ParaContent();  print (PrintText) SC_166; ParaContent();  I7_ST_say_one_of-->14 =
	i7_soo_ran(I7_ST_say_one_of-->14, 3);
	switch((I7_ST_say_one_of-->14)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_476; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_477; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_478; ParaContent();  } ParaContent();  print (PrintText) SC_77;  new_line; .L_Say319; .L_SayX287;  }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1203, 1203, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking (B160_report_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking ( this is the other people looking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor looking ( this is the other people looking rule ):
[ R_176 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_176, 176);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message looking action number 9]
       if (((~~((actor == player))))) {  AGL__M(##Look,9,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_176, 176, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Examining (B162_carry_out_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Carry out examining something visible ( this is the mark items as seen on examining rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/7 ! Carry out examining ( this is the standard examining rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Carry out examining ( this is the examine directions rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Carry out examining ( this is the examine containers rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Carry out examining ( this is the examine supporters rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Carry out examining ( this is the examine devices rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Carry out examining ( this is the examine undescribed things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Epistemology" by Eric Eve
! Carry out examining something visible ( this is the mark items as seen on examining rule ):
[ R_741 ;
   if ( (actor==player) && ((noun ofclass K2_thing) && ((Adj_3_t1_v65(noun))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_741, 741);
      ! phrase 1
      ! [1: now the noun is familiar]
       (Adj_90_t2_v65(noun)); 
      ! phrase 2
      ! [2: now the noun is seen]
       (Adj_88_t2_v65(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_741, 741, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the standard examining rule ):
[ R_177 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_177, 177);
      ! phrase 1
      ! [1: if the noun provides the property description and the description of the noun is not ~~ begin]
       if ((((WhetherProvides(noun, false, description)))) && (((~~((GProperty(OBJECT_TY, noun,description) == EMPTY_TEXT_VALUE))))))  {
         ! phrase 2
         ! [2: say ~[the description of the noun][line break]~]
         say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(OBJECT_TY, self=noun,description); @pull self; ParaContent();  new_line;  .L_Say320; .L_SayX288;
         ! phrase 3
         ! [3: now examine text printed is true]
          (MStack-->MstVO(20012,0)) = 1; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_177, 177, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine directions rule ):
[ R_178 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_178, 178);
      ! phrase 1
      ! [1: if the noun is a direction begin]
       if (((noun ofclass K3_direction)))  {
         ! phrase 2
         ! [2: issue library message examining action number 5 for the noun]
          GL__M(##Examine,5,noun); 
         ! phrase 3
         ! [3: now examine text printed is true]
          (MStack-->MstVO(20012,0)) = 1; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_178, 178, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine containers rule ):
[ R_179 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_179, 179);
      ! phrase 1
      ! [1: if the noun is a container begin]
       if (((noun ofclass K5_container)))  {
         ! phrase 2
         ! [2: if the noun is open or the noun is transparent begin]
          if (((((Adj_74_t1_v65(noun))))) || ((((Adj_73_t1_v65(noun))))))  {
            ! phrase 3
            ! [3: if something which is not scenery is in the noun and something which is not the player is in the noun begin]
             if (((Prop_57())) && ((Prop_58())))  {
               ! phrase 4
               ! [4: issue library message searching action number 7 for the noun]
                GL__M(##Search,7,noun); 
               ! phrase 5
               ! [5: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1; 
               ! phrase 6
               ! [6: otherwise if examine text printed is false]
                } else if ((((MStack-->MstVO(20012,0)) == 0))) { 
               ! phrase 7
               ! [7: if the player is in the noun begin]
                if (((noun == ContainerOf(player))))  {
                  ! phrase 8
                  ! [8: make no decision]
                   rfalse; 
                  ! phrase 9
                  ! [9: end if]
                  }

               ! phrase 10
               ! [10: issue library message searching action number 6 for the noun]
                GL__M(##Search,6,noun); 
               ! phrase 11
               ! [11: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1; 
               ! phrase 12
               ! [12: end if]
               }

            ! phrase 13
            ! [13: end if]
            }

         ! phrase 14
         ! [14: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_179, 179, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine supporters rule ):
[ R_180 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_180, 180);
      ! phrase 1
      ! [1: if the noun is a supporter begin]
       if (((noun ofclass K6_supporter)))  {
         ! phrase 2
         ! [2: if something which is not scenery is on the noun and something which is not the player is on the noun begin]
          if (((Prop_59())) && ((Prop_60())))  {
            ! phrase 3
            ! [3: issue library message looking action number 4 for the noun]
             GL__M(##Look,4,noun); 
            ! phrase 4
            ! [4: now examine text printed is true]
             (MStack-->MstVO(20012,0)) = 1; 
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_180, 180, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine devices rule ):
[ R_181 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_181, 181);
      ! phrase 1
      ! [1: if the noun is a device begin]
       if (((noun ofclass K26_device)))  {
         ! phrase 2
         ! [2: issue library message examining action number 3 for the noun]
          GL__M(##Examine,3,noun); 
         ! phrase 3
         ! [3: now examine text printed is true]
          (MStack-->MstVO(20012,0)) = 1; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_181, 181, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine undescribed things rule ):
[ R_182 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_182, 182);
      ! phrase 1
      ! [1: if examine text printed is false begin]
       if ((((MStack-->MstVO(20012,0)) == 0)))  {
         ! phrase 2
         ! [2: issue library message examining action number 2 for the noun]
          GL__M(##Examine,2,noun); 
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_182, 182, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Examining (B163_report_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor examining ( this is the report other people examining rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor examining ( this is the report other people examining rule ):
[ R_183 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_183, 183);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message examining action number 4 for the noun]
       if (((~~((actor == player))))) {  AGL__M(##Examine,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_183, 183, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking under (B165_carry_out_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor looking under ( this is the standard looking under rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor looking under ( this is the standard looking under rule ):
[ R_184 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_184, 184);
      ! phrase 1
      ! [1: stop the action with library message looking under action number 2 for the noun]
       return GL__M(##LookUnder,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_184, 184, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking under (B166_report_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking under ( this is the report other people looking under rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor looking under ( this is the report other people looking under rule ):
[ R_185 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_185, 185);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message looking under action number 3 for the noun]
       if (((~~((actor == player))))) {  AGL__M(##LookUnder,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_185, 185, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Searching (B167_check_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor searching ( this is the can't search unless container or supporter rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor searching ( this is the can't search closed opaque containers rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor searching ( this is the can't search unless container or supporter rule ):
[ R_186 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_186, 186);
      ! phrase 1
      ! [1: if the noun is not a container and the noun is not a supporter , stop the action with library message searching action number 4 for the noun]
       if ((((~~((noun ofclass K5_container))))) && (((~~((noun ofclass K6_supporter)))))) {  return GL__M(##Search,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_186, 186, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor searching ( this is the can't search closed opaque containers rule ):
[ R_187 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_187, 187);
      ! phrase 1
      ! [1: if the noun is a closed opaque container , stop the action with library message searching action number 5 for the noun]
       if (((noun ofclass K5_container) && ((Adj_75_t1_v65(noun))) && ((Adj_72_t1_v65(noun))))) {  return GL__M(##Search,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_187, 187, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Searching (B169_report_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report searching a container ( this is the standard search containers rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report searching a supporter ( this is the standard search supporters rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! Report an actor searching ( this is the report other people searching rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report searching a container ( this is the standard search containers rule ):
[ R_188 ;
   if ( (actor==player) && ((noun ofclass K5_container))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_188, 188);
      ! phrase 1
      ! [1: if the noun contains a described thing which is not scenery , issue library message searching action number 7 for the noun]
       if ((Prop_61())) {  GL__M(##Search,7,noun);   }
      ! phrase 2
      ! [2: otherwise issue library message searching action number 6 for the noun]
       else {  GL__M(##Search,6,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_188, 188, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report searching a supporter ( this is the standard search supporters rule ):
[ R_189 ;
   if ( (actor==player) && ((noun ofclass K6_supporter))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_189, 189);
      ! phrase 1
      ! [1: if the noun supports a described thing which is not scenery , issue library message searching action number 3 for the noun]
       if ((Prop_62())) {  GL__M(##Search,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue library message searching action number 2 for the noun]
       else {  GL__M(##Search,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_189, 189, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor searching ( this is the report other people searching rule ):
[ R_190 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_190, 190);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message searching action number 8 for the noun]
       if (((~~((actor == player))))) {  AGL__M(##Search,8,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_190, 190, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Consulting it about (B172_report_consulting_it_ab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor consulting something about ( this is the block consulting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor consulting something about ( this is the block consulting rule ):
[ R_191 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_191, 191);
      ! phrase 1
      ! [1: if the actor is the player , issue library message consulting it about action number 1 for the noun]
       if (((actor == player))) {  GL__M(##Consult,1,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message consulting it about action number 2 for the noun]
       else {  AGL__M(##Consult,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_191, 191, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Locking it with (B173_check_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor locking something with ( this is the can't lock without a lock rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor locking something with ( this is the can't lock what's already locked rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor locking something with ( this is the can't lock what's open rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor locking something with ( this is the can't lock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock without a lock rule ):
[ R_192 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_192, 192);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is lockable , continue the action]
       if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_78_t1_v65(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message locking it with action number 1 for the noun]
       return GL__M(##Lock,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_192, 192, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock what's already locked rule ):
[ R_193 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_193, 193);
      ! phrase 1
      ! [1: if the noun is locked , stop the action with library message locking it with action number 2 for the noun]
       if ((((Adj_79_t1_v65(noun))))) {  return GL__M(##Lock,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_193, 193, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock what's open rule ):
[ R_194 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_194, 194);
      ! phrase 1
      ! [1: if the noun is open , stop the action with library message locking it with action number 3 for the noun]
       if ((((Adj_74_t1_v65(noun))))) {  return GL__M(##Lock,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_194, 194, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock without the correct key rule ):
[ R_195 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_195, 195);
      ! phrase 1
      ! [1: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun , stop the action with library message locking it with action number 4 for the second noun]
       if ((((~~(( (HolderOf(second))  == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second))))))) {  return GL__M(##Lock,4,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_195, 195, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Locking it with (B174_carry_out_locking_it_wi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor locking something with ( this is the standard locking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor locking something with ( this is the standard locking rule ):
[ R_196 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_196, 196);
      ! phrase 1
      ! [1: now the noun is locked]
       (Adj_79_t2_v65(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_196, 196, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Locking it with (B175_report_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor locking something with ( this is the standard report locking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor locking something with ( this is the standard report locking rule ):
[ R_197 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_197, 197);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message locking it with action number 5 for the noun]
          GL__M(##Lock,5,noun); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the actor is visible , issue actor-based library message locking it with action number 6 for the noun]
          if ((((Adj_3_t1_v65(actor))))) {  AGL__M(##Lock,6,noun);   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_197, 197, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Unlocking it with (B176_check_unlocking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
[ R_198 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_198, 198);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is lockable , continue the action]
       if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_78_t1_v65(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message unlocking it with action number 1 for the noun]
       return GL__M(##Unlock,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_198, 198, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
[ R_199 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_199, 199);
      ! phrase 1
      ! [1: if the noun is not locked , stop the action with library message unlocking it with action number 2 for the noun]
       if (((~~(((Adj_79_t1_v65(noun))))))) {  return GL__M(##Unlock,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_199, 199, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
[ R_200 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_200, 200);
      ! phrase 1
      ! [1: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun , stop the action with library message unlocking it with action number 3 for the second noun]
       if ((((~~(( (HolderOf(second))  == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second))))))) {  return GL__M(##Unlock,3,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_200, 200, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Unlocking it with (B177_carry_out_unlocking_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
[ R_201 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_201, 201);
      ! phrase 1
      ! [1: now the noun is not locked]
       (Adj_79_t3_v65(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_201, 201, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Unlocking it with (B178_report_unlocking_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor unlocking something with ( this is the standard report unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor unlocking something with ( this is the standard report unlocking rule ):
[ R_202 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_202, 202);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message unlocking it with action number 4 for the noun]
          GL__M(##Unlock,4,noun); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the actor is visible , issue actor-based library message unlocking it with action number 5 for the noun]
          if ((((Adj_3_t1_v65(actor))))) {  AGL__M(##Unlock,5,noun);   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_202, 202, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching on (B179_check_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check switching on radio when emergency lights are switched off:
!   >>> I - Number of aspects constrained >>>
! Rule 2/3 ! Check an actor switching on ( this is the can't switch on unless switchable rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor switching on ( this is the can't switch on what's already on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check switching on radio when emergency lights are switched off:
[ R_1016 ;
   if ( (actor==player) && ((noun == O118_emergency_radio) && (true)) && (self=actor,true) && ((((Adj_85_t1_v65(O131_emergency_lights)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1016, 1016);
      ! phrase 1
      ! [1: instead say ~You flip the switch back and forth, but there doesn't seem to be any power. Damn.~]
      say__p=1;ParaContent();  print (PrintText) SC_479;  new_line; rtrue; .L_Say321; .L_SayX289; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1016, 1016, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor switching on ( this is the can't switch on unless switchable rule ):
[ R_203 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_203, 203);
      ! phrase 1
      ! [1: if the noun provides the property switched on , continue the action]
       if (((WhetherProvides(noun, true, on)))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message switching on action number 1 for the noun]
       return GL__M(##SwitchOn,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_203, 203, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor switching on ( this is the can't switch on what's already on rule ):
[ R_204 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_204, 204);
      ! phrase 1
      ! [1: if the noun is switched on , stop the action with library message switching on action number 2 for the noun]
       if ((((Adj_84_t1_v65(noun))))) {  return GL__M(##SwitchOn,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_204, 204, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching on (B180_carry_out_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out switching on flashlight:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out an actor switching on ( this is the standard switching on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out switching on flashlight:
[ R_944 ;
   if ( (actor==player) && ((noun == O71_flashlight) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_944, 944);
      ! phrase 1
      ! [1: now flashlight is lit]
       (Adj_55_t2_v65(O71_flashlight)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_944, 944, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor switching on ( this is the standard switching on rule ):
[ R_205 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_205, 205);
      ! phrase 1
      ! [1: now the noun is switched on]
       (Adj_84_t2_v65(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_205, 205, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching on (B181_report_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching on ( this is the standard report switching on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor switching on ( this is the standard report switching on rule ):
[ R_206 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_206, 206);
      ! phrase 1
      ! [1: if the actor is the player , issue library message switching on action number 3 for the noun]
       if (((actor == player))) {  GL__M(##SwitchOn,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message switching on action number 4 for the noun]
       else {  AGL__M(##SwitchOn,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_206, 206, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching off (B182_check_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching off ( this is the can't switch off unless switchable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor switching off ( this is the can't switch off what's already off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor switching off ( this is the can't switch off unless switchable rule ):
[ R_207 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_207, 207);
      ! phrase 1
      ! [1: if the noun provides the property switched on , continue the action]
       if (((WhetherProvides(noun, true, on)))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message switching off action number 1 for the noun]
       return GL__M(##SwitchOff,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_207, 207, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor switching off ( this is the can't switch off what's already off rule ):
[ R_208 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_208, 208);
      ! phrase 1
      ! [1: if the noun is switched off , stop the action with library message switching off action number 2 for the noun]
       if ((((Adj_85_t1_v65(noun))))) {  return GL__M(##SwitchOff,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_208, 208, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching off (B183_carry_out_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out switching off flashlight:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out an actor switching off ( this is the standard switching off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out switching off flashlight:
[ R_945 ;
   if ( (actor==player) && ((noun == O71_flashlight) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_945, 945);
      ! phrase 1
      ! [1: now flashlight is unlit]
       (Adj_56_t2_v65(O71_flashlight)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_945, 945, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor switching off ( this is the standard switching off rule ):
[ R_209 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_209, 209);
      ! phrase 1
      ! [1: now the noun is switched off]
       (Adj_85_t2_v65(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_209, 209, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching off (B184_report_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching off ( this is the standard report switching off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor switching off ( this is the standard report switching off rule ):
[ R_210 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_210, 210);
      ! phrase 1
      ! [1: if the actor is the player , issue library message switching off action number 3 for the noun]
       if (((actor == player))) {  GL__M(##SwitchOff,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message switching off action number 4 for the noun]
       else {  AGL__M(##SwitchOff,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_210, 210, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Opening (B185_check_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor opening ( this is the can't open unless openable rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor opening ( this is the can't open what's locked rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor opening ( this is the can't open what's already open rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor opening ( this is the can't open unless openable rule ):
[ R_211 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_211, 211);
      ! phrase 1
      ! [1: if the noun provides the property openable and the noun is openable , continue the action]
       if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_76_t1_v65(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message opening action number 1 for the noun]
       return GL__M(##Open,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_211, 211, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor opening ( this is the can't open what's locked rule ):
[ R_212 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_212, 212);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is locked , stop the action with library message opening action number 2 for the noun]
       if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_79_t1_v65(noun)))))) {  return GL__M(##Open,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_212, 212, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor opening ( this is the can't open what's already open rule ):
[ R_213 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_213, 213);
      ! phrase 1
      ! [1: if the noun is open , stop the action with library message opening action number 3 for the noun]
       if ((((Adj_74_t1_v65(noun))))) {  return GL__M(##Open,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_213, 213, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Opening (B186_carry_out_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out an actor opening ( this is the standard opening rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/2 ! Carry out opening a container ( this is the mark items as seen on opening a container rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor opening ( this is the standard opening rule ):
[ R_214 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_214, 214);
      ! phrase 1
      ! [1: now the noun is open]
       (Adj_74_t2_v65(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_214, 214, true);
   rfalse;
];
! No specific request
! From "Epistemology" by Eric Eve
! Carry out opening a container ( this is the mark items as seen on opening a container rule ):
[ R_740 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ( (actor==player) && ((noun ofclass K5_container))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_740, 740);
      ! phrase 1
      ! [1: repeat with item running through things that are enclosed by the noun begin]
       for (t_0=Prop_63(0), t_1=Prop_63(t_0): t_0: t_0=t_1, t_1=Prop_63(t_1))  {
         ! phrase 2
         ! [2: if the item is unseen and the item is visible , now the item is seen]
          if (((((Adj_89_t1_v65(t_0))))) && ((((Adj_3_t1_v65(t_0)))))) {  (Adj_88_t2_v65(t_0));   }
         ! phrase 3
         ! [3: end repeat]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_740, 740, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Opening (B187_report_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor opening ( this is the reveal any newly visible interior rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor opening ( this is the standard report opening rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor opening ( this is the reveal any newly visible interior rule ):
[ R_215 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_215, 215);
      ! phrase 1
      ! [1: if the actor is the player and the noun is an opaque container and the first thing held by the noun is not nothing and the noun does not enclose the actor , stop the action with library message opening action number 4 for the noun]
       if ((((actor == player))) && ((((noun ofclass K5_container) && ((Adj_72_t1_v65(noun))))) && ((((~~(( (child(noun))  == nothing))))) && (((~~((IndirectlyContains(noun,actor))))))))) {  return GL__M(##Open,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_215, 215, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor opening ( this is the standard report opening rule ):
[ R_216 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_216, 216);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message opening action number 5 for the noun]
          GL__M(##Open,5,noun); 
         ! phrase 3
         ! [3: otherwise if the player can see the actor]
          } else if (((TestVisibility(player,actor)))) { 
         ! phrase 4
         ! [4: issue actor-based library message opening action number 6 for the noun]
          AGL__M(##Open,6,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message opening action number 7 for the noun]
          AGL__M(##Open,7,noun); 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_216, 216, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Closing (B188_check_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor closing ( this is the can't close unless openable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor closing ( this is the can't close what's already closed rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor closing ( this is the can't close unless openable rule ):
[ R_217 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_217, 217);
      ! phrase 1
      ! [1: if the noun provides the property openable and the noun is openable , continue the action]
       if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_76_t1_v65(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message closing action number 1 for the noun]
       return GL__M(##Close,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_217, 217, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor closing ( this is the can't close what's already closed rule ):
[ R_218 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_218, 218);
      ! phrase 1
      ! [1: if the noun is closed , stop the action with library message closing action number 2 for the noun]
       if ((((Adj_75_t1_v65(noun))))) {  return GL__M(##Close,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_218, 218, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Closing (B189_carry_out_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor closing ( this is the standard closing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor closing ( this is the standard closing rule ):
[ R_219 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_219, 219);
      ! phrase 1
      ! [1: now the noun is closed]
       (Adj_75_t2_v65(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_219, 219, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Closing (B190_report_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor closing ( this is the standard report closing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor closing ( this is the standard report closing rule ):
[ R_220 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_220, 220);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message closing action number 3 for the noun]
          GL__M(##Close,3,noun); 
         ! phrase 3
         ! [3: otherwise if the player can see the actor]
          } else if (((TestVisibility(player,actor)))) { 
         ! phrase 4
         ! [4: issue actor-based library message closing action number 4 for the noun]
          AGL__M(##Close,4,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message closing action number 5 for the noun]
          AGL__M(##Close,5,noun); 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_220, 220, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Wearing (B191_check_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor wearing ( this is the can't wear what's not clothing rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor wearing ( this is the can't wear what's not held rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor wearing ( this is the can't wear what's already worn rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's not clothing rule ):
[ R_221 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_221, 221);
      ! phrase 1
      ! [1: if the noun is not a thing or the noun is not wearable , stop the action with library message wearing action number 1 for the noun]
       if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_62_t1_v65(noun)))))))) {  return GL__M(##Wear,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_221, 221, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's not held rule ):
[ R_222 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_222, 222);
      ! phrase 1
      ! [1: if the holder of the noun is not the actor , stop the action with library message wearing action number 2 for the noun]
       if (((~~(( (HolderOf(noun))  == actor))))) {  return GL__M(##Wear,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_222, 222, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's already worn rule ):
[ R_223 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_223, 223);
      ! phrase 1
      ! [1: if the actor is wearing the noun , stop the action with library message wearing action number 3 for the noun]
       if (((actor == WearerOf(noun)))) {  return GL__M(##Wear,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_223, 223, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Wearing (B192_carry_out_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor wearing ( this is the standard wearing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor wearing ( this is the standard wearing rule ):
[ R_224 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_224, 224);
      ! phrase 1
      ! [1: now the actor wears the noun]
       WearObject(noun,actor); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_224, 224, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Wearing (B193_report_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor wearing ( this is the standard report wearing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor wearing ( this is the standard report wearing rule ):
[ R_225 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_225, 225);
      ! phrase 1
      ! [1: if the actor is the player , issue library message wearing action number 4 for the noun]
       if (((actor == player))) {  GL__M(##Wear,4,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message wearing action number 5 for the noun]
       else {  AGL__M(##Wear,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_225, 225, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking off (B194_check_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor taking off ( this is the can't take off what's not worn rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor taking off ( this is the can't take off what's not worn rule ):
[ R_226 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_226, 226);
      ! phrase 1
      ! [1: if the actor is not wearing the noun , stop the action with library message taking off action number 1 for the noun]
       if (((~~((actor == WearerOf(noun)))))) {  return GL__M(##Disrobe,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_226, 226, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking off (B195_carry_out_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking off ( this is the standard taking off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor taking off ( this is the standard taking off rule ):
[ R_227 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_227, 227);
      ! phrase 1
      ! [1: now the actor carries the noun]
       MoveObject(noun,actor); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_227, 227, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking off (B196_report_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking off ( this is the standard report taking off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor taking off ( this is the standard report taking off rule ):
[ R_228 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_228, 228);
      ! phrase 1
      ! [1: if the actor is the player , issue library message taking off action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Disrobe,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message taking off action number 3 for the noun]
       else {  AGL__M(##Disrobe,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_228, 228, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Giving it to (B197_check_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor giving something to ( this is the can't give what you haven't got rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor giving something to ( this is the can't give to yourself rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor giving something to ( this is the can't give to a non-person rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor giving something to ( this is the can't give clothes being worn rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor giving something to ( this is the block giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give what you haven't got rule ):
[ R_229 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_229, 229);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message giving it to action number 1 for the noun]
       if (((~~((actor ==  (HolderOf(noun)) ))))) {  return GL__M(##Give,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_229, 229, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give to yourself rule ):
[ R_230 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_230, 230);
      ! phrase 1
      ! [1: if the actor is the second noun , stop the action with library message giving it to action number 2 for the noun]
       if (((actor == second))) {  return GL__M(##Give,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_230, 230, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give to a non-person rule ):
[ R_231 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_231, 231);
      ! phrase 1
      ! [1: if the second noun is not a person , stop the action with library message giving it to action number 4 for the second noun]
       if (((~~((second ofclass K8_person))))) {  return GL__M(##Give,4,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_231, 231, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give clothes being worn rule ):
[ R_232 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_232, 232);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_232, 232, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the block giving rule ):
[ R_233 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_233, 233);
      ! phrase 1
      ! [1: stop the action with library message giving it to action number 3 for the second noun]
       return GL__M(##Give,3,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_233, 233, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Giving it to (B198_carry_out_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor giving something to ( this is the standard giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor giving something to ( this is the standard giving rule ):
[ R_234 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_234, 234);
      ! phrase 1
      ! [1: move the noun to the second noun]
       MoveObject(noun, second, 0, false); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_234, 234, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Giving it to (B199_report_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor giving something to ( this is the standard report giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor giving something to ( this is the standard report giving rule ):
[ R_235 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_235, 235);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message giving it to action number 5 for the noun]
          GL__M(##Give,5,noun); 
         ! phrase 3
         ! [3: otherwise if the second noun is the player]
          } else if (((second == player))) { 
         ! phrase 4
         ! [4: issue actor-based library message giving it to action number 6 for the noun]
          AGL__M(##Give,6,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message giving it to action number 7 for the noun]
          AGL__M(##Give,7,noun); 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_235, 235, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Showing it to (B200_check_showing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor showing something to ( this is the can't show what you haven't got rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor showing something to ( this is the block showing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor showing something to ( this is the can't show what you haven't got rule ):
[ R_236 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_236, 236);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message showing it to action number 1 for the noun]
       if (((~~((actor ==  (HolderOf(noun)) ))))) {  return GL__M(##Show,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_236, 236, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
[ R_237 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_237, 237);
      ! phrase 1
      ! [1: if the actor is the second noun , convert to the examining action on the noun]
       if (((actor == second))) {  return GVS_Convert(##Examine,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_237, 237, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor showing something to ( this is the block showing rule ):
[ R_238 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_238, 238);
      ! phrase 1
      ! [1: stop the action with library message showing it to action number 2 for the second noun]
       return GL__M(##Show,2,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_238, 238, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking (B203_check_waking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking ( this is the block waking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waking ( this is the block waking rule ):
[ R_239 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_239, 239);
      ! phrase 1
      ! [1: stop the action with library message waking action number 1 for the noun]
       return GL__M(##WakeOther,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_239, 239, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Throwing it at (B206_check_throwing_it_at)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor throwing something at ( this is the block throwing at rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
[ R_240 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_240, 240);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_240, 240, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
[ R_241 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_241, 241);
      ! phrase 1
      ! [1: if the second noun is not a person , stop the action with library message throwing it at action number 1 for the second noun]
       if (((~~((second ofclass K8_person))))) {  return GL__M(##ThrowAt,1,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_241, 241, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor throwing something at ( this is the block throwing at rule ):
[ R_242 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_242, 242);
      ! phrase 1
      ! [1: stop the action with library message throwing it at action number 2 for the noun]
       return GL__M(##ThrowAt,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_242, 242, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Attacking (B209_check_attacking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor attacking ( this is the block attacking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor attacking ( this is the block attacking rule ):
[ R_243 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_243, 243);
      ! phrase 1
      ! [1: stop the action with library message attacking action number 1 for the noun]
       return GL__M(##Attack,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_243, 243, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Kissing (B212_check_kissing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor kissing ( this is the kissing yourself rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor kissing ( this is the block kissing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor kissing ( this is the kissing yourself rule ):
[ R_244 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_244, 244);
      ! phrase 1
      ! [1: if the noun is the actor , stop the action with library message touching action number 3 for the noun]
       if (((noun == actor))) {  return GL__M(##Touch,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_244, 244, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor kissing ( this is the block kissing rule ):
[ R_245 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_245, 245);
      ! phrase 1
      ! [1: stop the action with library message kissing action number 1 for the noun]
       return GL__M(##Kiss,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_245, 245, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Answering it that (B217_report_answering_it_tha)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor answering something that ( this is the block answering rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor answering something that ( this is the block answering rule ):
[ R_246 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_246, 246);
      ! phrase 1
      ! [1: stop the action with library message answering it that action number 1 for the noun]
       return GL__M(##Answer,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_246, 246, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Telling it about (B218_check_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor telling something about ( this is the telling yourself rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor telling something about ( this is the telling yourself rule ):
[ R_247 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_247, 247);
      ! phrase 1
      ! [1: if the actor is the noun , stop the action with library message telling it about action number 1 for the noun]
       if (((actor == noun))) {  return GL__M(##Tell,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_247, 247, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Telling it about (B220_report_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor telling something about ( this is the block telling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor telling something about ( this is the block telling rule ):
[ R_248 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_248, 248);
      ! phrase 1
      ! [1: stop the action with library message telling it about action number 2 for the noun]
       return GL__M(##Tell,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_248, 248, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Asking it about (B223_report_asking_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor asking something about ( this is the block asking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor asking something about ( this is the block asking rule ):
[ R_249 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_249, 249);
      ! phrase 1
      ! [1: stop the action with library message asking it about action number 1 for the noun]
       return GL__M(##Ask,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_249, 249, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Asking it for (B224_check_asking_it_for)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor asking something for ( this is the asking yourself for something rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor asking something for ( this is the translate asking for to giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor asking something for ( this is the asking yourself for something rule ):
[ R_250 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_250, 250);
      ! phrase 1
      ! [1: if the actor is the noun and the actor is the player , try taking inventory instead]
       if ((((actor == noun))) && (((actor == player)))) {  TryAction(0, player, ##Inv, 0, 0);;   rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_250, 250, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor asking something for ( this is the translate asking for to giving rule ):
[ R_251 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_251, 251);
      ! phrase 1
      ! [1: convert to request of the noun to perform giving it to action with the second noun and the actor]
       TryAction(true, noun, ##Give, second, actor); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_251, 251, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waiting (B229_report_waiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waiting ( this is the standard report waiting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor waiting ( this is the standard report waiting rule ):
[ R_252 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_252, 252);
      ! phrase 1
      ! [1: if the actor is the player , stop the action with library message waiting action number 1 for the actor]
       if (((actor == player))) {  return GL__M(##Wait,1,actor);   }
      ! phrase 2
      ! [2: issue actor-based library message waiting action number 2]
       AGL__M(##Wait,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_252, 252, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Touching (B232_report_touching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report an actor touching ( this is the report touching yourself rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report an actor touching ( this is the report touching other people rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Report an actor touching ( this is the report touching things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor touching ( this is the report touching yourself rule ):
[ R_253 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_253, 253);
      ! phrase 1
      ! [1: if the noun is the actor begin]
       if (((noun == actor)))  {
         ! phrase 2
         ! [2: if the actor is the player , issue library message touching action number 3 for the noun]
          if (((actor == player))) {  GL__M(##Touch,3,noun);   }
         ! phrase 3
         ! [3: otherwise issue actor-based library message touching action number 4]
          else {  AGL__M(##Touch,4,noun);   }
         ! phrase 4
         ! [4: stop the action]
          rtrue; 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_253, 253, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor touching ( this is the report touching other people rule ):
[ R_254 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_254, 254);
      ! phrase 1
      ! [1: if the noun is a person begin]
       if (((noun ofclass K8_person)))  {
         ! phrase 2
         ! [2: if the actor is the player begin]
          if (((actor == player)))  {
            ! phrase 3
            ! [3: issue library message touching action number 1 for the noun]
             GL__M(##Touch,1,noun); 
            ! phrase 4
            ! [4: otherwise if the noun is the player]
             } else if (((noun == player))) { 
            ! phrase 5
            ! [5: issue actor-based library message touching action number 5]
             AGL__M(##Touch,5,noun); 
            ! phrase 6
            ! [6: otherwise]
            } else {

            ! phrase 7
            ! [7: issue actor-based library message touching action number 6 for the noun]
             AGL__M(##Touch,6,noun); 
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: stop the action]
          rtrue; 
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_254, 254, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor touching ( this is the report touching things rule ):
[ R_255 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_255, 255);
      ! phrase 1
      ! [1: if the actor is the player , issue library message touching action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Touch,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message touching action number 6 for the noun]
       else {  AGL__M(##Touch,6,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_255, 255, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving (B233_check_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving ( this is the can't wave what's not held rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waving ( this is the can't wave what's not held rule ):
[ R_256 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_256, 256);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message waving action number 1 for the noun]
       if (((~~((actor ==  (HolderOf(noun)) ))))) {  return GL__M(##Wave,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_256, 256, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waving (B235_report_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waving ( this is the report waving things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor waving ( this is the report waving things rule ):
[ R_257 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_257, 257);
      ! phrase 1
      ! [1: if the actor is the player , issue library message waving action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Wave,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message waving action number 3 for the noun]
       else {  AGL__M(##Wave,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_257, 257, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pulling (B236_check_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor pulling ( this is the can't pull scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor pulling ( this is the can't pull people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
[ R_258 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_258, 258);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message pulling action number 1 for the noun]
       if ((((Adj_59_t1_v65(noun))))) {  return GL__M(##Pull,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_258, 258, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pulling ( this is the can't pull scenery rule ):
[ R_259 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_259, 259);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message pulling action number 2 for the noun]
       if ((((Adj_61_t1_v65(noun))))) {  return GL__M(##Pull,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_259, 259, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pulling ( this is the can't pull people rule ):
[ R_260 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_260, 260);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message pulling action number 4 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Pull,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_260, 260, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pulling (B238_report_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pulling ( this is the report pulling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor pulling ( this is the report pulling rule ):
[ R_261 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_261, 261);
      ! phrase 1
      ! [1: if the actor is the player , issue library message pulling action number 3 for the noun]
       if (((actor == player))) {  GL__M(##Pull,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message pulling action number 5 for the noun]
       else {  AGL__M(##Pull,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_261, 261, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing (B239_check_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor pushing something ( this is the can't push scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor pushing something ( this is the can't push people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
[ R_262 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_262, 262);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message pushing action number 1 for the noun]
       if ((((Adj_59_t1_v65(noun))))) {  return GL__M(##Push,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_262, 262, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something ( this is the can't push scenery rule ):
[ R_263 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_263, 263);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message pushing action number 2 for the noun]
       if ((((Adj_61_t1_v65(noun))))) {  return GL__M(##Push,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_263, 263, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something ( this is the can't push people rule ):
[ R_264 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_264, 264);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message pushing action number 4 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Push,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_264, 264, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pushing (B241_report_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pushing something ( this is the report pushing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor pushing something ( this is the report pushing rule ):
[ R_265 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_265, 265);
      ! phrase 1
      ! [1: if the actor is the player , issue library message pushing action number 3 for the noun]
       if (((actor == player))) {  GL__M(##Push,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message pushing action number 6 for the noun]
       else {  AGL__M(##Push,6,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_265, 265, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Turning (B242_check_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor turning ( this is the can't turn what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor turning ( this is the can't turn scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor turning ( this is the can't turn people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor turning ( this is the can't turn what's fixed in place rule ):
[ R_266 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_266, 266);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message turning action number 1 for the noun]
       if ((((Adj_59_t1_v65(noun))))) {  return GL__M(##Turn,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_266, 266, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor turning ( this is the can't turn scenery rule ):
[ R_267 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_267, 267);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message turning action number 2 for the noun]
       if ((((Adj_61_t1_v65(noun))))) {  return GL__M(##Turn,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_267, 267, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor turning ( this is the can't turn people rule ):
[ R_268 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_268, 268);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message turning action number 4 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Turn,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_268, 268, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Turning (B244_report_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor turning ( this is the report turning rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor turning ( this is the report turning rule ):
[ R_269 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_269, 269);
      ! phrase 1
      ! [1: if the actor is the player , issue library message turning action number 3 for the noun]
       if (((actor == player))) {  GL__M(##Turn,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message turning action number 7 for the noun]
       else {  AGL__M(##Turn,7,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_269, 269, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing it to (B245_check_pushing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor pushing something to ( this is the can't push unpushable things rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor pushing something to ( this is the can't push to non-directions rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor pushing something to ( this is the can't push vertically rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor pushing something to ( this is the standard pushing in directions rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor pushing something to ( this is the block pushing in directions rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the can't push unpushable things rule ):
[ R_270 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_270, 270);
      ! phrase 1
      ! [1: if the noun is not pushable between rooms , stop the action with library message pushing it to action number 1 for the noun]
       if (((~~(((Adj_63_t1_v65(noun))))))) {  return GL__M(##PushDir,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_270, 270, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the can't push to non-directions rule ):
[ R_271 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_271, 271);
      ! phrase 1
      ! [1: if the second noun is not a direction , stop the action with library message pushing it to action number 2 for the noun]
       if (((~~((second ofclass K3_direction))))) {  return GL__M(##PushDir,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_271, 271, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the can't push vertically rule ):
[ R_272 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_272, 272);
      ! phrase 1
      ! [1: if the second noun is up or the second noun is down , stop the action with library message pushing it to action number 3 for the noun]
       if ((((second == O18_up))) || (((second == O19_down)))) {  return GL__M(##PushDir,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_272, 272, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the standard pushing in directions rule ):
[ R_273 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_273, 273);
      ! phrase 1
      ! [1: convert to special going-with-push action]
       ConvertToGoingWithPush(); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_273, 273, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the block pushing in directions rule ):
[ R_274 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_274, 274);
      ! phrase 1
      ! [1: stop the action with library message pushing it to action number 1 for the noun]
       return GL__M(##PushDir,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_274, 274, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Squeezing (B248_check_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
[ R_275 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_275, 275);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message squeezing action number 1 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Squeeze,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_275, 275, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Squeezing (B250_report_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor squeezing ( this is the report squeezing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor squeezing ( this is the report squeezing rule ):
[ R_276 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_276, 276);
      ! phrase 1
      ! [1: if the actor is the player , issue library message squeezing action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Squeeze,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message squeezing action number 3 for the noun]
       else {  AGL__M(##Squeeze,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_276, 276, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying yes (B251_check_saying_yes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying yes ( this is the block saying yes rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor saying yes ( this is the block saying yes rule ):
[ R_277 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_277, 277);
      ! phrase 1
      ! [1: stop the action with library message saying yes action number 1]
       return GL__M(##Yes,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_277, 277, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying no (B254_check_saying_no)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying no ( this is the block saying no rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor saying no ( this is the block saying no rule ):
[ R_278 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_278, 278);
      ! phrase 1
      ! [1: stop the action with library message saying no action number 1]
       return GL__M(##No,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_278, 278, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Burning (B257_check_burning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor burning ( this is the block burning rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor burning ( this is the block burning rule ):
[ R_279 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_279, 279);
      ! phrase 1
      ! [1: stop the action with library message burning action number 1]
       return GL__M(##Burn,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_279, 279, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking up (B260_check_waking_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking up ( this is the block waking up rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waking up ( this is the block waking up rule ):
[ R_280 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_280, 280);
      ! phrase 1
      ! [1: stop the action with library message waking up action number 1]
       return GL__M(##Wake,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_280, 280, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Thinking (B263_check_thinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor thinking ( this is the block thinking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor thinking ( this is the block thinking rule ):
[ R_281 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_281, 281);
      ! phrase 1
      ! [1: stop the action with library message thinking action number 1]
       return GL__M(##Think,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_281, 281, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Smelling (B266_check_smelling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor smelling ( this is the block smelling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor smelling ( this is the block smelling rule ):
[ R_282 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_282, 282);
      ! phrase 1
      ! [1: stop the action with library message smelling action number 1 for the noun]
       return GL__M(##Smell,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_282, 282, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Listening to (B269_check_listening_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor listening ( this is the block listening rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor listening ( this is the block listening rule ):
[ R_283 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_283, 283);
      ! phrase 1
      ! [1: stop the action with library message listening to action number 1 for the noun]
       return GL__M(##Listen,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_283, 283, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tasting (B272_check_tasting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tasting ( this is the block tasting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor tasting ( this is the block tasting rule ):
[ R_284 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_284, 284);
      ! phrase 1
      ! [1: stop the action with library message tasting action number 1 for the noun]
       return GL__M(##Taste,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_284, 284, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Cutting (B275_check_cutting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor cutting ( this is the block cutting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor cutting ( this is the block cutting rule ):
[ R_285 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_285, 285);
      ! phrase 1
      ! [1: stop the action with library message cutting action number 1 for the noun]
       return GL__M(##Cut,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_285, 285, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Jumping (B278_check_jumping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor jumping ( this is the block jumping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor jumping ( this is the block jumping rule ):
[ R_286 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_286, 286);
      ! phrase 1
      ! [1: stop the action with library message jumping action number 1]
       return GL__M(##Jump,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_286, 286, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tying it to (B281_check_tying_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tying something to ( this is the block tying rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor tying something to ( this is the block tying rule ):
[ R_287 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_287, 287);
      ! phrase 1
      ! [1: stop the action with library message tying it to action number 1 for the noun]
       return GL__M(##Tie,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_287, 287, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Drinking (B284_check_drinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor drinking ( this is the block drinking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor drinking ( this is the block drinking rule ):
[ R_288 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_288, 288);
      ! phrase 1
      ! [1: stop the action with library message drinking action number 1 for the noun]
       return GL__M(##Drink,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_288, 288, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying sorry (B287_check_saying_sorry)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying sorry ( this is the block saying sorry rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor saying sorry ( this is the block saying sorry rule ):
[ R_289 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_289, 289);
      ! phrase 1
      ! [1: stop the action with library message saying sorry action number 1]
       return GL__M(##Sorry,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_289, 289, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swearing obscenely (B290_check_swearing_obscenel)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swearing obscenely ( this is the block swearing obscenely rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor swearing obscenely ( this is the block swearing obscenely rule ):
[ R_290 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_290, 290);
      ! phrase 1
      ! [1: stop the action with library message swearing obscenely action number 1]
       return GL__M(##Strong,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_290, 290, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swearing mildly (B293_check_swearing_mildly)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swearing mildly ( this is the block swearing mildly rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor swearing mildly ( this is the block swearing mildly rule ):
[ R_291 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_291, 291);
      ! phrase 1
      ! [1: stop the action with library message swearing mildly action number 1]
       return GL__M(##Mild,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_291, 291, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swinging (B296_check_swinging)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swinging ( this is the block swinging rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor swinging ( this is the block swinging rule ):
[ R_292 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_292, 292);
      ! phrase 1
      ! [1: stop the action with library message swinging action number 1 for the noun]
       return GL__M(##Swing,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_292, 292, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Rubbing (B299_check_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor rubbing ( this is the block rubbing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor rubbing ( this is the block rubbing rule ):
[ R_293 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_293, 293);
      ! phrase 1
      ! [1: stop the action with library message rubbing action number 1 for the noun]
       return GL__M(##Rub,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_293, 293, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Setting it to (B302_check_setting_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor setting something to ( this is the block setting it to rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor setting something to ( this is the block setting it to rule ):
[ R_294 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_294, 294);
      ! phrase 1
      ! [1: stop the action with library message setting it to action number 1 for the noun]
       return GL__M(##SetTo,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_294, 294, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving hands (B305_check_waving_hands)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving hands ( this is the block waving hands rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waving hands ( this is the block waving hands rule ):
[ R_295 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_295, 295);
      ! phrase 1
      ! [1: stop the action with library message waving hands action number 1]
       return GL__M(##WaveHands,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_295, 295, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Buying (B308_check_buying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor buying ( this is the block buying rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor buying ( this is the block buying rule ):
[ R_296 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_296, 296);
      ! phrase 1
      ! [1: stop the action with library message buying action number 1 for the noun]
       return GL__M(##Buy,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_296, 296, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Singing (B311_check_singing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor singing ( this is the block singing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor singing ( this is the block singing rule ):
[ R_297 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_297, 297);
      ! phrase 1
      ! [1: stop the action with library message singing action number 1]
       return GL__M(##Sing,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_297, 297, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Climbing (B314_check_climbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor climbing ( this is the block climbing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor climbing ( this is the block climbing rule ):
[ R_298 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_298, 298);
      ! phrase 1
      ! [1: stop the action with library message climbing action number 1 for the noun]
       return GL__M(##Climb,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_298, 298, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Sleeping (B317_check_sleeping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor sleeping ( this is the block sleeping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor sleeping ( this is the block sleeping rule ):
[ R_299 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_299, 299);
      ! phrase 1
      ! [1: stop the action with library message sleeping action number 1]
       return GL__M(##Sleep,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_299, 299, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Requesting epistemic status of (B367_report_requesting_epist)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report requesting epistemic status of:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Epistemology" by Eric Eve
! Report requesting epistemic status of:
[ R_744 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_744, 744);
      ! phrase 1
      ! [1: say ~[noun] - [if seen]seen[otherwise]unseen[end if] / [if familiar]familiar[otherwise]unfamiliar[end if] / [if known]known[otherwise]unknown[end if].~]
      say__p=1;ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_480; 
	if (~~(((((Adj_88_t1_v65(self))))))) jump L_Say322;
		ParaContent();  print (PrintText) SC_481; 
	jump L_SayX290; .L_Say322;
		ParaContent();  print (PrintText) SC_482; 
	.L_Say323; .L_SayX290;
		ParaContent();  print (PrintText) SC_483; 
	if (~~(((((Adj_90_t1_v65(self))))))) jump L_Say324;
		ParaContent();  print (PrintText) SC_484; 
	jump L_SayX291; .L_Say324;
		ParaContent();  print (PrintText) SC_485; 
	.L_Say325; .L_SayX291;
		ParaContent();  print (PrintText) SC_483; 
	if (~~(((((Adj_31_t1_v65(self))))))) jump L_Say326;
		ParaContent();  print (PrintText) SC_486; 
	jump L_SayX292; .L_Say326;
		ParaContent();  print (PrintText) SC_487; 
	.L_Say327; .L_SayX292;
		ParaContent();  print (PrintText) SC_77;  new_line; .L_Say328; .L_SayX293;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_744, 744, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Quizzing it about (B374_check_quizzing_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check quizzing someone about something unknown ( this is the block asking about something unknown rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Check quizzing someone about something unknown ( this is the block asking about something unknown rule ):
[ R_781 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing) && ((Adj_32_t1_v65(second))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_781, 781);
      ! phrase 1
      ! [1: abide by the block asking rule]
       if (ProcessRulebook(R_249)) rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_781, 781, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Quizzing it about (B376_report_quizzing_it_abou)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report quizzing someone about something ( this is the block quizzing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Report quizzing someone about something ( this is the block quizzing rule ):
[ R_746 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_746, 746);
      ! phrase 1
      ! [1: say ~There is no reply.~]
      say__p=1;ParaContent();  print (PrintText) SC_488;  new_line; .L_Say329; .L_SayX294;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_746, 746, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Informing it about (B377_check_informing_it_abou)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check informing someone about something unknown ( this is the block telling about something unknown rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Check informing someone about something unknown ( this is the block telling about something unknown rule ):
[ R_782 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing) && ((Adj_32_t1_v65(second))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_782, 782);
      ! phrase 1
      ! [1: abide by the block telling rule]
       if (ProcessRulebook(R_248)) rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_782, 782, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Informing it about (B379_report_informing_it_abo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report informing someone about something ( this is the block informing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Report informing someone about something ( this is the block informing rule ):
[ R_745 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_745, 745);
      ! phrase 1
      ! [1: say ~There is no reply.~]
      say__p=1;ParaContent();  print (PrintText) SC_488;  new_line; .L_Say330; .L_SayX295;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_745, 745, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying hello to (B392_check_saying_hello_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check saying hello to a person when the noun is the current interlocutor ( this is the can't greet current interlocutor rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Check saying hello to a person when the noun is the current interlocutor ( this is the can't greet current interlocutor rule ):
[ R_756 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && (((noun == (Global_Vars-->9))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_756, 756);
      ! phrase 1
      ! [1: if the noun is the player , say ~Talking to yourself is unrewarding.~ instead]
       if (((noun == player))) { say__p=1;ParaContent();  print (PrintText) SC_489;  new_line; .L_Say331; .L_SayX296;  rtrue; }
      ! phrase 2
      ! [2: say ~You are already talking to [the noun].~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_490; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_77;  new_line; rtrue; .L_Say332; .L_SayX297; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_756, 756, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Saying hello to (B393_carry_out_saying_hello_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! carry out saying hello to someone when suggest-on-greeting is true and greeting type is explicit ( this is the display topic suggestions on explicit greeting rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/3 ! Carry out saying hello to a person ( this is the note current interlocutor when greeted rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Carry out saying hello to a person ( called the conversant ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! carry out saying hello to someone when suggest-on-greeting is true and greeting type is explicit ( this is the display topic suggestions on explicit greeting rule ):
[ R_843 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && (((((Global_Vars-->16) == 1))) && ((((Global_Vars-->10) == Q23_explicit))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_843, 843);
      ! phrase 1
      ! [1: the topic list displays in 0 turns from now]
       SetTimedEvent(R_844, 0+1, 0); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_843, 843, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Carry out saying hello to a person ( this is the note current interlocutor when greeted rule ):
[ R_757 ;
   if ( (actor==player) && ((noun ofclass K8_person))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_757, 757);
      ! phrase 1
      ! [1: now the current interlocutor is the noun]
       (Global_Vars-->9) = noun; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_757, 757, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Carry out saying hello to a person ( called the conversant ):
[ R_851 
    t_0 ! Local variable e.g. 'conversant' = object
    ;
   if ( (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K8_person))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_851, 851);
      ! phrase 1
      ! [1: now every thing held by the conversant is familiar]
       Prop_64(,t_0); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_851, 851, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Saying hello to (B394_report_saying_hello_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report saying hello to someone when the greeting type is explicit ( this is the default greeting rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Report saying hello to something that is not a person ( this is the can't greet inanimate objects rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Report saying hello to someone when the greeting type is explicit ( this is the default greeting rule ):
[ R_759 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && ((((Global_Vars-->10) == Q23_explicit)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_759, 759);
      ! phrase 1
      ! [1: say ~You say hello to [the noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_491; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_77;  new_line; .L_Say333; .L_SayX298;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_759, 759, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Report saying hello to something that is not a person ( this is the can't greet inanimate objects rule ):
[ R_758 ;
   if ( (actor==player) && ((noun ofclass K2_thing) && (~~((noun ofclass K8_person))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_758, 758);
      ! phrase 1
      ! [1: say ~[The noun] do[if the noun is not plural-named and the noun is not the player]es[end if] not respond.~]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_492; 
	if (~~(((((~~(((Adj_45_t1_v65(noun))))))) && (((~~((noun == player)))))))) jump L_Say334;
		ParaContent();  print (PrintText) SC_493; 
	.L_Say334; .L_SayX299;
		ParaContent();  print (PrintText) SC_494;  new_line; .L_Say335; .L_SayX300;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_758, 758, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Hailing (B395_check_hailing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check hailing ( this is the check what's being hailed rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Check hailing ( this is the check what's being hailed rule ):
[ R_761 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_761, 761);
      ! phrase 1
      ! [1: if the current interlocutor is a visible person , say ~You are already talking to [the current interlocutor].~ instead]
       if ((((Global_Vars-->9) ofclass K8_person) && ((Adj_3_t1_v65((Global_Vars-->9)))))) { say__p=1;ParaContent();  print (PrintText) SC_490; ParaContent();  print (the) (Global_Vars-->9); ParaContent();  print (PrintText) SC_77;  new_line; .L_Say336; .L_SayX301;  rtrue; }
      ! phrase 2
      ! [2: now the noun is a random visible person who is not the player]
       noun =  (Prop_65()) ; 
      ! phrase 3
      ! [3: if the noun is a person and the noun is not yourself and the noun is not the player , say ~(addressing [the noun])~]
       if ((((noun ofclass K8_person))) && ((((~~((noun == selfobj))))) && (((~~((noun == player))))))) { say__p=1;ParaContent();  print (PrintText) SC_118; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_104;  .L_Say337; .L_SayX302;  }
      ! phrase 4
      ! [4: otherwise say ~There's no one here but you.~ instead]
       else { say__p=1;ParaContent();  print (PrintText) SC_495;  new_line; .L_Say338; .L_SayX303;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_761, 761, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Hailing (B396_carry_out_hailing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out hailing ( this is the standard hailing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Carry out hailing ( this is the standard hailing rule ):
[ R_762 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_762, 762);
      ! phrase 1
      ! [1: try saying hello to the noun]
       TryAction(0, player, ##A89_saying_hello_to, noun, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_762, 762, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Leavetaking (B398_check_leavetaking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check leavetaking when the current interlocutor is not a visible person ( this is the don't allow saying goodbye to no-one rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Check leavetaking when the current interlocutor is not a visible person ( this is the don't allow saying goodbye to no-one rule ):
[ R_768 ;
   if (actor == player) {
   if ((((((~~(((Global_Vars-->9) ofclass K8_person) && ((Adj_3_t1_v65((Global_Vars-->9))))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_768, 768);
      ! phrase 1
      ! [1: say ~You're not talking to anyone.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_119;  new_line; rtrue; .L_Say339; .L_SayX304; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_768, 768, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Leavetaking (B399_carry_out_leavetaking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out someone trying leavetaking ( this is the convert npc leavetaking to player leavetaking rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out leavetaking ( this is the standard leavetaking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Carry out someone trying leavetaking ( this is the convert npc leavetaking to player leavetaking rule ):
[ R_771 ;
   if ( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_771, 771);
      ! phrase 1
      ! [1: try saying goodbye to the person asked]
       TryAction(0, player, ##A92_saying_goodbye_to, actor, 0);; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_771, 771, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Carry out leavetaking ( this is the standard leavetaking rule ):
[ R_769 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_769, 769);
      ! phrase 1
      ! [1: try saying goodbye to the current interlocutor]
       TryAction(0, player, ##A92_saying_goodbye_to, (Global_Vars-->9), 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_769, 769, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying goodbye to (B401_check_saying_goodbye_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check saying goodbye to something when the noun is not the current interlocutor ( this is the can't say goodbye to someone you're not talking to rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Check saying goodbye to something when the noun is not the current interlocutor ( this is the can't say goodbye to someone you're not talking to rule ):
[ R_766 ;
   if ( (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((~~((noun == (Global_Vars-->9))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_766, 766);
      ! phrase 1
      ! [1: say ~You're not talking to [the noun].~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_496; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_77;  new_line; rtrue; .L_Say340; .L_SayX305; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_766, 766, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Saying goodbye to (B402_carry_out_saying_goodby)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out saying goodbye to a person ( called the conversant ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/2 ! Carry out saying goodbye to something ( this is the reset interlocutor on saying goodbye rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Carry out saying goodbye to a person ( called the conversant ):
[ R_852 
    t_0 ! Local variable e.g. 'conversant' = object
    ;
   if ( (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K8_person))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_852, 852);
      ! phrase 1
      ! [1: now every thing held by the conversant is unfamiliar]
       Prop_66(,t_0); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_852, 852, true);
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Carry out saying goodbye to something ( this is the reset interlocutor on saying goodbye rule ):
[ R_767 ;
   if ( (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_767, 767);
      ! phrase 1
      ! [1: reset the interlocutor]
      (PHR_765_r3 ());
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_767, 767, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Saying goodbye to (B403_report_saying_goodbye_t)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report saying goodbye to someone when the farewell type is explicit ( this is the default saying goodbye rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Report saying goodbye to someone when the farewell type is explicit ( this is the default saying goodbye rule ):
[ R_772 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && ((((Global_Vars-->11) == Q23_explicit)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_772, 772);
      ! phrase 1
      ! [1: say ~You say goodbye to [the noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_497; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_77;  new_line; .L_Say341; .L_SayX306;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_772, 772, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: suggestion list construction (B404_suggestion_list_constru)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! The first suggestion list construction rule ( this is the use the current interlocutor's suggestion lists rule ):
! --- now the last-placed rules ---
! Rule 2/3 ! The last suggestion list construction rule ( this is the exclude unknown items from suggestions rule ):
!   === which is equally specific with ===
! Rule 3/3 ! The last suggestion list construction rule ( this is the refer to current interlocutor as him-herself in suggestions rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! The first suggestion list construction rule ( this is the use the current interlocutor's suggestion lists rule ):
[ R_837 ;
      ! phrase 1
      ! [1: now sugg-list-other is the other-suggestions of the current interlocutor]
       BlkValueCopy((Global_Vars-->15), GProperty(OBJECT_TY, (Global_Vars-->9),p15_other_suggestions)); 
      ! phrase 2
      ! [2: now sugg-list-ask is the ask-suggestions of the current interlocutor]
       BlkValueCopy((Global_Vars-->13), GProperty(OBJECT_TY, (Global_Vars-->9),p13_ask_suggestions)); 
      ! phrase 3
      ! [3: now sugg-list-tell is the tell-suggestions of the current interlocutor]
       BlkValueCopy((Global_Vars-->14), GProperty(OBJECT_TY, (Global_Vars-->9),p14_tell_suggestions)); 
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! The last suggestion list construction rule ( this is the exclude unknown items from suggestions rule ):
[ R_838 ;blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 2;
    blockv_stack-->(blockv_sp++) = R_SHELL_3(blockv_sp-2);
    blockv_sp = blockv_sp - 3;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+2);
];
[ R_SHELL_3 I7BASPL 
    t_0 ! Local variable e.g. 'u-list' = list of objects
    ;
      ! phrase 1
      ! [1: let u-list be the list of unknown things]
       t_0 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_0,  LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+1)), Prop_67, OBJECT_TY) ); 
      ! phrase 2
      ! [2: remove u-list from sugg-list-ask , if present]
       LIST_OF_TY_Remove_List((Global_Vars-->13), t_0, 1); 
      ! phrase 3
      ! [3: remove u-list from sugg-list-tell , if present]
       LIST_OF_TY_Remove_List((Global_Vars-->14), t_0, 1); 
      ! phrase 4
      ! [4: if the number of entries in sugg-list-other > 0 begin]
       if ((( LIST_OF_TY_GetLength((Global_Vars-->15))  > 0)))  {
         ! phrase 5
         ! [5: remove u-list from sugg-list-other , if present]
          LIST_OF_TY_Remove_List((Global_Vars-->15), t_0, 1); 
         ! phrase 6
         ! [6: sort sugg-list-other in seqno order]
          LIST_OF_TY_Sort((Global_Vars-->15), 1, p16_seqno, 0); 
         ! phrase 7
         ! [7: end if]
         }

   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! The last suggestion list construction rule ( this is the refer to current interlocutor as him-herself in suggestions rule ):
[ R_839 ;
      ! phrase 1
      ! [1: if the current interlocutor is listed in sugg-list-ask begin]
       if (( (LIST_OF_TY_FindItem((Global_Vars-->13), (Global_Vars-->9))) ))  {
         ! phrase 2
         ! [2: remove the current interlocutor from sugg-list-ask]
          LIST_OF_TY_RemoveValue((Global_Vars-->13), (Global_Vars-->9), 0); 
         ! phrase 3
         ! [3: add self-suggestion at entry 1 in sugg-list-ask]
          LIST_OF_TY_InsertItem((Global_Vars-->13), O34_self_suggestion, 1, 1, 0); 
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: if the current interlocutor is listed in sugg-list-tell begin]
       if (( (LIST_OF_TY_FindItem((Global_Vars-->14), (Global_Vars-->9))) ))  {
         ! phrase 6
         ! [6: remove the current interlocutor from sugg-list-tell]
          LIST_OF_TY_RemoveValue((Global_Vars-->14), (Global_Vars-->9), 0); 
         ! phrase 7
         ! [7: add self-suggestion at entry 1 in sugg-list-tell]
          LIST_OF_TY_InsertItem((Global_Vars-->14), O34_self_suggestion, 1, 1, 0); 
         ! phrase 8
         ! [8: end if]
         }

   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Listing suggested topics (B405_check_listing_suggested)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check listing suggested topics when the current interlocutor is not a person:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Check listing suggested topics when the current interlocutor is not a person:
[ R_840 ;
   if (actor == player) {
   if ((((((~~(((Global_Vars-->9) ofclass K8_person)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_840, 840);
      ! phrase 1
      ! [1: say ~You aren't talking to anyone right now.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_498;  new_line; rtrue; .L_Say342; .L_SayX307; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_840, 840, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Listing suggested topics (B406_carry_out_listing_sugge)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out listing suggested topics:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! Carry out listing suggested topics:
[ R_842 ;blockv_stack-->(blockv_sp+6) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+5) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+4) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+3) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 7;
    blockv_stack-->(blockv_sp++) = R_SHELL_4(blockv_sp-7);
    blockv_sp = blockv_sp - 8;
    BlkFree(blockv_stack-->(blockv_sp+6));
    BlkFree(blockv_stack-->(blockv_sp+5));
    BlkFree(blockv_stack-->(blockv_sp+4));
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+7);
];
[ R_SHELL_4 I7BASPL 
    t_0 ! Local variable e.g. 'ask-suggs' = number
    t_1 ! Local variable e.g. 'tell-suggs' = number
    t_2 ! Local variable e.g. 'other-suggs' = number
    t_3 ! Local variable e.g. 'sugg-rep' = indexed text
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_842, 842);
      ! phrase 1
      ! [1: consider the suggestion list construction rules]
       ProcessRulebook(404); 
      ! phrase 2
      ! [2: let ask-suggs be the number of entries in sugg-list-ask]
       t_0 =  LIST_OF_TY_GetLength((Global_Vars-->13)) ; 
      ! phrase 3
      ! [3: let tell-suggs be the number of entries in sugg-list-tell]
       t_1 =  LIST_OF_TY_GetLength((Global_Vars-->14)) ; 
      ! phrase 4
      ! [4: let other-suggs be the number of entries in sugg-list-other]
       t_2 =  LIST_OF_TY_GetLength((Global_Vars-->15)) ; 
      ! phrase 5
      ! [5: if ask-suggs + tell-suggs + other-suggs is 0 begin]
       if ((( (t_0+ (t_1+t_2) )  == 0)))  {
         ! phrase 6
         ! [6: say ~[nothing specific]~]
         say__p=1;ParaContent(); (PHR_841_r36 ()); .L_Say343; .L_SayX308;
         ! phrase 7
         ! [7: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 8
         ! [8: end if]
         }

      ! phrase 9
      ! [9: let sugg-rep be an indexed text]
       t_3 = (blockv_stack-->(I7BASPL+0)); 
      ! phrase 10
      ! [10: say ~[if topic-request is implicit]([end if]You could ~]
      say__p=1;
	if (~~(((((Global_Vars-->17) == Q22_implicit))))) jump L_Say344;
		ParaContent();  print (PrintText) SC_499; 
	.L_Say344; .L_SayX309;
		ParaContent();  print (PrintText) SC_500;  .L_Say345; .L_SayX310;
      ! phrase 11
      ! [11: if other-suggs > 0 begin]
       if (((t_2 > 0)))  {
         ! phrase 12
         ! [12: let sugg-rep be ~[sugg-list-other]~]
          BlkValueCast(t_3, INDEXED_TEXT_TY, TEXT_TY, ((LocalParking-->0=t_0)*0+(LocalParking-->1=t_1)*0+(LocalParking-->2=t_2)*0+(LocalParking-->3=t_3)*0+text_routine_58)); 
         ! phrase 13
         ! [13: replace the regular expression ~@{5C}band@{5C}b~ in sugg-rep with ~or~]
          IT_Replace_RE(REGEXP_BLOB, t_3, BlkValueCast((blockv_stack-->(I7BASPL+1)),INDEXED_TEXT_TY,TEXT_TY,SC_501),
		BlkValueCast((blockv_stack-->(I7BASPL+2)),INDEXED_TEXT_TY,TEXT_TY,SC_502), 0); 
         ! phrase 14
         ! [14: say ~[sugg-rep][if tell-suggs + ask-suggs > 0]; or [end if]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_3; 
	if (~~(((( (t_1+t_0)  > 0))))) jump L_Say346;
		ParaContent();  print (PrintText) SC_503; 
	.L_Say346; .L_SayX311;
		 .L_Say347; .L_SayX312;
         ! phrase 15
         ! [15: end if]
         }

      ! phrase 16
      ! [16: if ask-suggs > 0 begin]
       if (((t_0 > 0)))  {
         ! phrase 17
         ! [17: let sugg-rep be ~[sugg-list-ask with definite articles]~]
          BlkValueCast(t_3, INDEXED_TEXT_TY, TEXT_TY, ((LocalParking-->0=t_0)*0+(LocalParking-->1=t_1)*0+(LocalParking-->2=t_2)*0+(LocalParking-->3=t_3)*0+text_routine_59)); 
         ! phrase 18
         ! [18: replace the regular expression ~@{5C}band@{5C}b~ in sugg-rep with ~or~]
          IT_Replace_RE(REGEXP_BLOB, t_3, BlkValueCast((blockv_stack-->(I7BASPL+3)),INDEXED_TEXT_TY,TEXT_TY,SC_501),
		BlkValueCast((blockv_stack-->(I7BASPL+4)),INDEXED_TEXT_TY,TEXT_TY,SC_502), 0); 
         ! phrase 19
         ! [19: say ~ask [it-them of the current interlocutor] about [sugg-rep][if tell-suggs > 0]; or [end if]~]
         say__p=1;ParaContent();  print (PrintText) SC_504; ParaContent(); (Resolver_11((Global_Vars-->9),"source", 476));ParaContent();  print (PrintText) SC_505; ParaContent();  print (INDEXED_TEXT_TY_Say) t_3; 
	if (~~((((t_1 > 0))))) jump L_Say348;
		ParaContent();  print (PrintText) SC_503; 
	.L_Say348; .L_SayX313;
		 .L_Say349; .L_SayX314;
         ! phrase 20
         ! [20: end if]
         }

      ! phrase 21
      ! [21: if tell-suggs > 0 begin]
       if (((t_1 > 0)))  {
         ! phrase 22
         ! [22: let sugg-rep be ~[sugg-list-tell with definite articles]~]
          BlkValueCast(t_3, INDEXED_TEXT_TY, TEXT_TY, ((LocalParking-->0=t_0)*0+(LocalParking-->1=t_1)*0+(LocalParking-->2=t_2)*0+(LocalParking-->3=t_3)*0+text_routine_60)); 
         ! phrase 23
         ! [23: replace the regular expression ~@{5C}band@{5C}b~ in sugg-rep with ~or~]
          IT_Replace_RE(REGEXP_BLOB, t_3, BlkValueCast((blockv_stack-->(I7BASPL+5)),INDEXED_TEXT_TY,TEXT_TY,SC_501),
		BlkValueCast((blockv_stack-->(I7BASPL+6)),INDEXED_TEXT_TY,TEXT_TY,SC_502), 0); 
         ! phrase 24
         ! [24: say ~tell [it-them of the current interlocutor] about [sugg-rep]~]
         say__p=1;ParaContent();  print (PrintText) SC_506; ParaContent(); (Resolver_11((Global_Vars-->9),"source", 481));ParaContent();  print (PrintText) SC_505; ParaContent();  print (INDEXED_TEXT_TY_Say) t_3;  .L_Say350; .L_SayX315;
         ! phrase 25
         ! [25: end if]
         }

      ! phrase 26
      ! [26: say ~[if topic-request is implicit].)[paragraph break][otherwise].[end if]~]
      say__p=1;
	if (~~(((((Global_Vars-->17) == Q22_implicit))))) jump L_Say351;
		ParaContent();  print (PrintText) SC_507; ParaContent();  DivideParagraphPoint(); new_line; 
	jump L_SayX316; .L_Say351;
		ParaContent();  print (PrintText) SC_77;  new_line;
	.L_Say352; .L_SayX316;
		 .L_Say353; .L_SayX317;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_842, 842, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Standing (B408_check_standing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor standing ( this is the check holder for standing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Modified Exit" by Emily Short
! Check an actor standing ( this is the check holder for standing rule ):
[ R_865 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_865, 865);
      ! phrase 1
      ! [1: if the holder of the actor is a room begin]
       if ((( (HolderOf(actor))  ofclass K1_room)))  {
         ! phrase 2
         ! [2: if the actor is the player , say ~You're already up.~]
          if (((actor == player))) { say__p=1;ParaContent();  print (PrintText) SC_508;  new_line; .L_Say354; .L_SayX318;  }
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_865, 865, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Standing (B409_carry_out_standing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor standing ( this is the convert standing to getting off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Modified Exit" by Emily Short
! Carry out an actor standing ( this is the convert standing to getting off rule ):
[ R_866 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_866, 866);
      ! phrase 1
      ! [1: try the person asked getting off the holder of the person asked]
       TryAction(0, actor, ##GetOff,  (HolderOf(actor)) , 0);; 
      ! phrase 2
      ! [2: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_866, 866, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Retreating (B412_carry_out_retreating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out retreating ( this is the small kindnesses carry out retreating rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Carry out retreating ( this is the small kindnesses carry out retreating rule ):
[ R_871 
    t_0 ! Local variable e.g. 'way' = object
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_871, 871);
      ! phrase 1
      ! [1: let way be the best route from the location to the small kindnesses former location , using even locked doors]
       t_0 =  MapRouteTo(real_location,(Global_Vars-->20),0,2) ; 
      ! phrase 2
      ! [2: if way is a direction , try going way]
       if (((t_0 ofclass K3_direction))) {  TryAction(0, player, ##Go, t_0, 0);;   }
      ! phrase 3
      ! [3: otherwise say ~You can't see an open way back.~]
       else { say__p=1;ParaContent();  print (PrintText) SC_509;  new_line; .L_Say355; .L_SayX319;  }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_871, 871, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Using (B415_carry_out_using)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out using:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Carry out using:
[ R_880 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_880, 880);
      ! phrase 1
      ! [1: say ~You'll have to try a more specific verb than use.~]
      say__p=1;ParaContent();  print (PrintText) SC_510;  new_line; .L_Say356; .L_SayX320;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_880, 880, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Deciding whether to allow undo (B418_for_deciding_whether_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for deciding whether to allow undo:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for deciding whether to allow undo:
[ R_919 ;
      ! phrase 1
      ! [1: if undo is prevented , say ~Yeah, you wish you could unsmoke all the cigs you've inhaled. Life doesn't work like that.~]
       if (((PHR_915_r38 ()))) { say__p=1;ParaContent();  print (PrintText) SC_511;  new_line; .L_Say357; .L_SayX321;  }
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Brooding (B423_check_brooding)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check brooding when noun is not a memory:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check brooding when noun is not a memory:
[ R_933 ;
   if (actor == player) {
   if ((((((~~((noun ofclass K43_memory)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_933, 933);
      ! phrase 1
      ! [1: instead say ~Eh. You couldn't really get into a good brood about that when it's this damn cold.~]
      say__p=1;ParaContent();  print (PrintText) SC_512;  new_line; rtrue; .L_Say358; .L_SayX322; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_933, 933, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Brooding (B424_carry_out_brooding)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out brooding:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out brooding:
[ R_934 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_934, 934);
      ! phrase 1
      ! [1: say ~[description of noun][line break]~]
      say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(OBJECT_TY, self=noun,description); @pull self; ParaContent();  new_line;  .L_Say359; .L_SayX323;
      ! phrase 2
      ! [2: now the noun is retrieved]
       (Adj_96_t2_v65(noun)); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_934, 934, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Smoking (B426_check_smoking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check smoking when count of pack of cigarettes is 0:
!   === which is equally specific with ===
! Rule 2/3 ! Check smoking when noun is not pack of cigarettes:
!   === which is equally specific with ===
! Rule 3/3 ! Check smoking when lighter is not held:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check smoking when count of pack of cigarettes is 0:
[ R_967 ;
   if (actor == player) {
   if ((((((GProperty(OBJECT_TY, O39_pack_of_cigarettes,p17_count) == 0)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_967, 967);
      ! phrase 1
      ! [1: instead say ~You're out of cigarettes.~]
      say__p=1;ParaContent();  print (PrintText) SC_513;  new_line; rtrue; .L_Say360; .L_SayX324; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_967, 967, true);
   rfalse;
];
! No specific request
! Check smoking when noun is not pack of cigarettes:
[ R_969 ;
   if (actor == player) {
   if ((((((~~((noun == O39_pack_of_cigarettes)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_969, 969);
      ! phrase 1
      ! [1: instead say ~Sounds like something your high school buddies would try.~]
      say__p=1;ParaContent();  print (PrintText) SC_514;  new_line; rtrue; .L_Say361; .L_SayX325; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_969, 969, true);
   rfalse;
];
! No specific request
! Check smoking when lighter is not held:
[ R_970 ;
   if (actor == player) {
   if ((((((~~(((Adj_2_t1_v65(O38_lighter)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_970, 970);
      ! phrase 1
      ! [1: instead say ~You pat your pockets, but can't seem to find your lighter.~]
      say__p=1;ParaContent();  print (PrintText) SC_515;  new_line; rtrue; .L_Say362; .L_SayX326; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_970, 970, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Smoking (B427_carry_out_smoking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out smoking:
!   === which is equally specific with ===
! Rule 2/2 ! Carry out smoking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out smoking:
[ R_918 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_918, 918);
      ! phrase 1
      ! [1: prevent undo]
      (PHR_913_r11 ());
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_918, 918, true);
   rfalse;
];
! No specific request
! Carry out smoking:
[ R_968 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_968, 968);
      ! phrase 1
      ! [1: decrease count of pack of cigarettes by 1]
       WriteGProperty(OBJECT_TY, O39_pack_of_cigarettes,p17_count,GProperty(OBJECT_TY, O39_pack_of_cigarettes,p17_count) - 1); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_968, 968, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Smoking (B428_report_smoking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! First report smoking:
! --- now the mid-placed rules ---
! Rule 2/7 ! Report smoking:
!   === which is equally specific with ===
! Rule 3/7 ! Report smoking:
!   === which is equally specific with ===
! Rule 4/7 ! Report smoking:
!   === which is equally specific with ===
! Rule 5/7 ! Report smoking:
!   === which is equally specific with ===
! Rule 6/7 ! Report smoking:
! --- now the last-placed rules ---
! Rule 7/7 ! Last report smoking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! First report smoking:
[ R_973 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_973, 973);
      ! phrase 1
      ! [1: say ~You pull out a cigarette and flick it into life. Thoughts tumble through your head.~]
      say__p=1;ParaContent();  print (PrintText) SC_516;  new_line; .L_Say363; .L_SayX327;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_973, 973, true);
   rfalse;
];
! No specific request
! Report smoking:
[ R_974 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_974, 974);
      ! phrase 1
      ! [1: say ~Well, you're still stuck here. [run paragraph on]~]
      say__p=1;ParaContent();  print (PrintText) SC_517; ParaContent();  RunParagraphOn();  .L_Say364; .L_SayX328;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_974, 974, true);
   rfalse;
];
! No specific request
! Report smoking:
[ R_975 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_975, 975);
      ! phrase 1
      ! [1: say ~[if location is lit brightly]You've finally lit the place up a little[otherwise if location is lit by headlights]It's dark outside the beam of your headlights[otherwise if location is lit by flashlight]It's pitch black outside the beam of your flashlight[otherwise]It's darker than you can remember it ever being[end if]. [run paragraph on]~]
      say__p=1;
	if (~~(((((Adj_37_t1_v65(real_location))))))) jump L_Say365;
		ParaContent();  print (PrintText) SC_518; ParaContent(); 
	jump L_SayX329; .L_Say365; if (~~(((((Adj_38_t1_v65(real_location))))))) jump L_Say366;
		ParaContent();  print (PrintText) SC_519; ParaContent(); 
	jump L_SayX329; .L_Say366; if (~~(((((Adj_39_t1_v65(real_location))))))) jump L_Say367;
		ParaContent();  print (PrintText) SC_520; 
	jump L_SayX329; .L_Say367;
		ParaContent();  print (PrintText) SC_521; 
	.L_Say368; .L_SayX329;
		ParaContent();  print (PrintText) SC_140; ParaContent();  RunParagraphOn();  .L_Say369; .L_SayX330;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_975, 975, true);
   rfalse;
];
! No specific request
! Report smoking:
[ R_976 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_976, 976);
      ! phrase 1
      ! [1: if the player holds a talent , say ~Some weird shit went down in the desert, but you do feel like you have more [list of talents held by player]. [run paragraph on]~]
       if ((Prop_68())) { say__p=1;ParaContent();  print (PrintText) SC_522; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K78_talent) && (player == HolderOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+NOARTICLE_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_140; ParaContent();  RunParagraphOn();  .L_Say370; .L_SayX331;  }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_976, 976, true);
   rfalse;
];
! No specific request
! Report smoking:
[ R_977 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_977, 977);
      ! phrase 1
      ! [1: if there is an in progress plan , say ~You've found [the list of handled things which are required by a plan], but [if the number of in progress plans is 2]you can't see how they're going to be helpful together[otherwise]you still need something else if you plan on [a random in progress plan][end if]. [run paragraph on]~]
       if ((Prop_69())) { say__p=1;ParaContent();  print (PrintText) SC_523; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && ((Adj_64_t1_v65(subst__v))) && ((subst__v.p79_objective) ofclass K72_plan)))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+DEFART_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_524; 
	if (~~(((( (Prop_70())  == 2))))) jump L_Say371;
		ParaContent();  print (PrintText) SC_525; 
	jump L_SayX332; .L_Say371;
		ParaContent();  print (PrintText) SC_526; ParaContent();  print (a)  (Prop_71()) ; 
	.L_Say372; .L_SayX332;
		ParaContent();  print (PrintText) SC_140; ParaContent();  RunParagraphOn();  .L_Say373; .L_SayX333;  }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_977, 977, true);
   rfalse;
];
! No specific request
! Report smoking:
[ R_978 
    t_0 ! Local variable e.g. 'hint' = text
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_978, 978);
      ! phrase 1
      ! [1: let hint be best course of action]
       t_0 = (PHR_980_r39 ()); 
      ! phrase 2
      ! [2: if best course of action is not ~~ , say ~Maybe [hint]. [run paragraph on]~]
       if (((~~(((PHR_980_r39 ()) == EMPTY_TEXT_VALUE))))) { say__p=1;ParaContent();  print (PrintText) SC_527; ParaContent();  print (PrintText) t_0; ParaContent();  print (PrintText) SC_140; ParaContent();  RunParagraphOn();  .L_Say374; .L_SayX334;  }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_978, 978, true);
   rfalse;
];
! No specific request
! Last report smoking:
[ R_979 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_979, 979);
      ! phrase 1
      ! [1: say ~[paragraph break]And you still haven't quit smoking. [if count of pack of cigarettes is 0]That was your last cigarette, too[otherwise]You've got [count of pack of cigarettes in words] cig[s] left[end if].~]
      say__p=1;ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_528; 
	if (~~((((GProperty(OBJECT_TY, O39_pack_of_cigarettes,p17_count) == 0))))) jump L_Say375;
		ParaContent();  print (PrintText) SC_529; 
	jump L_SayX335; .L_Say375;
		ParaContent();  print (PrintText) SC_530; ParaContent(); @push self;  print (number) say__n=(GProperty(OBJECT_TY, self=O39_pack_of_cigarettes,p17_count)); @pull self; ParaContent();  print (PrintText) SC_531; ParaContent();  STextSubstitution(); ParaContent();  print (PrintText) SC_532; 
	.L_Say376; .L_SayX335;
		ParaContent();  print (PrintText) SC_77;  new_line; .L_Say377; .L_SayX336;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_979, 979, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tuning it to (B429_check_tuning_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check tuning when the noun does not provide a frequency tuned to:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 2/5 ! Check tuning when the frequency understood is less than the minimum frequency of the noun:
!   === which is equally specific with ===
! Rule 3/5 ! Check tuning when the frequency understood is greater than the maximum frequency of the noun:
!   === which is equally specific with ===
! Rule 4/5 ! Check tuning when the frequency understood is the frequency tuned to of the noun:
!   === which is equally specific with ===
! Rule 5/5 ! Check tuning when the radio is switched off:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check tuning when the noun does not provide a frequency tuned to:
[ R_1009 ;
   if ( (actor==player) && (self=actor,true) && (((~~((WhetherProvides(noun, false, p18_frequency_tuned_to))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1009, 1009);
      ! phrase 1
      ! [1: instead say ~You can't tune that.~]
      say__p=1;ParaContent();  print (PrintText) SC_533;  new_line; rtrue; .L_Say378; .L_SayX337; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1009, 1009, true);
   rfalse;
];
! No specific request
! Check tuning when the frequency understood is less than the minimum frequency of the noun:
[ R_1010 ;
   if ( (actor==player) && (self=actor,true) && (((parsed_number < GProperty(OBJECT_TY, noun,p20_minimum_frequency))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1010, 1010);
      ! phrase 1
      ! [1: instead say ~[The noun] doesn't go any lower than [the minimum frequency of the noun].~]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_534; ParaContent(); @push self;  print (T45_frequency) GProperty(OBJECT_TY, self=noun,p20_minimum_frequency); @pull self; ParaContent();  print (PrintText) SC_77;  new_line; rtrue; .L_Say379; .L_SayX338; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1010, 1010, true);
   rfalse;
];
! No specific request
! Check tuning when the frequency understood is greater than the maximum frequency of the noun:
[ R_1011 ;
   if ( (actor==player) && (self=actor,true) && (((parsed_number > GProperty(OBJECT_TY, noun,p19_maximum_frequency))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1011, 1011);
      ! phrase 1
      ! [1: instead say ~[The noun] doesn't go any higher than [the maximum frequency of the noun].~]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_535; ParaContent(); @push self;  print (T45_frequency) GProperty(OBJECT_TY, self=noun,p19_maximum_frequency); @pull self; ParaContent();  print (PrintText) SC_77;  new_line; rtrue; .L_Say380; .L_SayX339; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1011, 1011, true);
   rfalse;
];
! No specific request
! Check tuning when the frequency understood is the frequency tuned to of the noun:
[ R_1012 ;
   if ( (actor==player) && (self=actor,true) && (((parsed_number == GProperty(OBJECT_TY, noun,p18_frequency_tuned_to))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1012, 1012);
      ! phrase 1
      ! [1: instead say ~[The noun] is already tuned to that frequency.~]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_536;  new_line; rtrue; .L_Say381; .L_SayX340; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1012, 1012, true);
   rfalse;
];
! No specific request
! Check tuning when the radio is switched off:
[ R_1013 ;
   if ( (actor==player) && (self=actor,true) && ((((Adj_85_t1_v65(O118_emergency_radio)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1013, 1013);
      ! phrase 1
      ! [1: instead say ~Not much point when it's not turned on.~]
      say__p=1;ParaContent();  print (PrintText) SC_537;  new_line; rtrue; .L_Say382; .L_SayX341; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1013, 1013, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Tuning it to (B430_carry_out_tuning_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out tuning:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out tuning:
[ R_1014 ;
   if ( (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1014, 1014);
      ! phrase 1
      ! [1: now the frequency tuned to of the noun is the frequency understood]
       WriteGProperty(OBJECT_TY, noun,p18_frequency_tuned_to,parsed_number); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1014, 1014, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Tuning it to (B431_report_tuning_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report tuning:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report tuning:
[ R_1015 ;
   if ( (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1015, 1015);
      ! phrase 1
      ! [1: say ~You tune [the radio] to [the frequency tuned to of the radio][if the frequency tuned to of the radio is the emergency frequency], and the static resolves into a clear signal[otherwise if the frequency tuned to of the radio was the emergency frequency], and the voice dissolves into static[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_538; ParaContent();  print (the) O118_emergency_radio; ParaContent();  print (PrintText) SC_539; ParaContent(); @push self;  print (T45_frequency) GProperty(OBJECT_TY, self=O118_emergency_radio,p18_frequency_tuned_to); @pull self; 
	if (~~((((GProperty(OBJECT_TY, O118_emergency_radio,p18_frequency_tuned_to) == (Global_Vars-->27)))))) jump L_Say383;
		ParaContent();  print (PrintText) SC_540; ParaContent(); 
	jump L_SayX342; .L_Say383; if (~~((TestSinglePastState(1, 2, false, 1)))) jump L_Say384;
		ParaContent();  print (PrintText) SC_541; 
	.L_Say384; .L_SayX342;
		ParaContent();  print (PrintText) SC_77;  new_line; .L_Say385; .L_SayX343;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1015, 1015, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Coarse tuning (B433_carry_out_coarse_tuning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out coarse tuning:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out coarse tuning:
[ R_1008 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1008, 1008);
      ! phrase 1
      ! [1: try tuning the noun to the frequency with integer part number understood decimal part 0]
       TryAction(0, player, ##A99_tuning_it_to, noun,  (10*parsed_number+0) );; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1008, 1008, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Trading (B435_check_trading)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8 ! Check trading when the trader needs more memories during Sand-dancer's offer:
!   >>> I - Number of aspects constrained >>>
! Rule 2/8 ! Check trading when the trader is not a spirit animal:
!   === which is equally specific with ===
! Rule 3/8 ! Check trading when the noun is not a memory:
!   === which is equally specific with ===
! Rule 4/8 ! Check trading when the second noun is not a talent:
!   === which is equally specific with ===
! Rule 5/8 ! Check trading when the second noun is held:
!   === which is equally specific with ===
! Rule 6/8 ! Check trading when the noun is not in emotional baggage:
!   === which is equally specific with ===
! Rule 7/8 ! Check trading when trader needs more memories:
!   === which is equally specific with ===
! Rule 8/8 ! Check trading when the noun is not a memory and the trader is the rabbit:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check trading when the trader needs more memories during Sand-dancer's offer:
[ R_1231 ;
   if (scene_status-->10 == 1) { ! Runs only during scene
   if (actor == player) {
   if (((((Resolver_12((MStack-->MstVO(20101,0)),"source", 1401)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1231, 1231);
      ! phrase 1
      ! [1: move the noun to the trader]
       MoveObject(noun, (MStack-->MstVO(20101,0)), 0, false); 
      ! phrase 2
      ! [2: say ~He flicks out his tongue and pulls [the noun] from [one of]your head[or]your heart[or]your gut[or]your palm[or]your core[or]your soul[in random order], swallowing it whole. '[one of]A good start,' he says, 'but you must trade more.'[or]Yes,' he says, 'but more.'[or]More,' he says.[or]Still more,' he says.[or]I must have more,' he says.[or]Give me more,' he says.[stopping]~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_542; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_543; ParaContent();  I7_ST_say_one_of-->15 =
	i7_soo_shu(I7_ST_say_one_of-->15, 6);
	switch((I7_ST_say_one_of-->15)%(6+1)-1) {
		0: ParaContent();  print (PrintText) SC_544; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_545; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_546; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_547; ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_548; ParaContent();  @nop; 5: ParaContent();  print (PrintText) SC_549; ParaContent();  } ParaContent();  print (PrintText) SC_550; ParaContent();  I7_ST_say_one_of-->16 =
	i7_soo_stop(I7_ST_say_one_of-->16, 6);
	switch((I7_ST_say_one_of-->16)%(6+1)-1) {
		0: ParaContent();  print (PrintText) SC_551;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_552;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_553;  new_line;ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_554;  new_line;ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_555;  new_line;ParaContent();  @nop; 5: ParaContent();  print (PrintText) SC_556;  new_line;ParaContent();  }  rtrue; .L_Say386; .L_SayX344; rtrue;
   } ! Runs only during scene
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1231, 1231, true);
   rfalse;
];
! No specific request
! Check trading when the trader is not a spirit animal:
[ R_1099 ;
   if (actor == player) {
   if ((((((~~(((MStack-->MstVO(20101,0)) ofclass K165_spirit_animal)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1099, 1099);
      ! phrase 1
      ! [1: instead say ~There's no one here to trade with.~]
      say__p=1;ParaContent();  print (PrintText) SC_557;  new_line; rtrue; .L_Say387; .L_SayX345; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1099, 1099, true);
   rfalse;
];
! No specific request
! Check trading when the noun is not a memory:
[ R_1100 ;
   if (actor == player) {
   if ((((((~~((noun ofclass K43_memory)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1100, 1100);
      ! phrase 1
      ! [1: instead say ~'I'm only interested in trading memories,' [the trader] says.~]
      say__p=1;ParaContent();  print (PrintText) SC_558; ParaContent();  print (the) (MStack-->MstVO(20101,0)); ParaContent();  print (PrintText) SC_559;  new_line; rtrue; .L_Say388; .L_SayX346; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1100, 1100, true);
   rfalse;
];
! No specific request
! Check trading when the second noun is not a talent:
[ R_1101 ;
   if (actor == player) {
   if ((((((~~((second ofclass K78_talent)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1101, 1101);
      ! phrase 1
      ! [1: instead say ~'I only have talents to offer you,' says [the trader], '[list of visible not held talents].'~]
      say__p=1;ParaContent();  print (PrintText) SC_560; ParaContent();  print (the) (MStack-->MstVO(20101,0)); ParaContent();  print (PrintText) SC_561; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K78_talent) && ((Adj_3_t1_v65(subst__v))) && (~~((Adj_2_t1_v65(subst__v))))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+NOARTICLE_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_251;  new_line; rtrue; .L_Say389; .L_SayX347; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1101, 1101, true);
   rfalse;
];
! No specific request
! Check trading when the second noun is held:
[ R_1102 ;
   if (actor == player) {
   if (((((((Adj_2_t1_v65(second)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1102, 1102);
      ! phrase 1
      ! [1: instead say ~You've already got the talent of [second noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_562; ParaContent();  print (PrintShortName) second; ParaContent();  print (PrintText) SC_77;  new_line; rtrue; .L_Say390; .L_SayX348; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1102, 1102, true);
   rfalse;
];
! No specific request
! Check trading when the noun is not in emotional baggage:
[ R_1103 ;
   if (actor == player) {
   if ((((((~~((O45_emotional_baggage == ContainerOf(noun))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1103, 1103);
      ! phrase 1
      ! [1: instead say ~You've already traded away that memory.~]
      say__p=1;ParaContent();  print (PrintText) SC_563;  new_line; rtrue; .L_Say391; .L_SayX349; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1103, 1103, true);
   rfalse;
];
! No specific request
! Check trading when trader needs more memories:
[ R_1104 ;
   if (actor == player) {
   if (((((Resolver_12((MStack-->MstVO(20101,0)),"source", 929)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1104, 1104);
      ! phrase 1
      ! [1: move the noun to the trader]
       MoveObject(noun, (MStack-->MstVO(20101,0)), 0, false); 
      ! phrase 2
      ! [2: instead say ~[The trader] touches your fingertips and pulls [the noun] through your nerve endings. 'Good,' he says, 'I'll take that, although it's not enough to complete the trade.'[paragraph break]Somewhere inside you, things are shifting, moving, growing.~]
      say__p=1;ParaContent();  print (The) (MStack-->MstVO(20101,0)); ParaContent();  print (PrintText) SC_564; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_565; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_566;  new_line; rtrue; .L_Say392; .L_SayX350; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1104, 1104, true);
   rfalse;
];
! No specific request
! Check trading when the noun is not a memory and the trader is the rabbit:
[ R_1154 ;
   if (actor == player) {
   if (((((((~~((noun ofclass K43_memory))))) && ((((MStack-->MstVO(20101,0)) == O166_rabbit))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1154, 1154);
      ! phrase 1
      ! [1: instead say ~'No, no, I don't want that,' says the rabbit, twitching its nose indignantly. 'For a talent like this, you ought to put up something real. Something you care about.'[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_567; ParaContent();  new_line;  rtrue; .L_Say393; .L_SayX351; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1154, 1154, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Trading (B436_carry_out_trading)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out trading:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out trading:
[ R_1106 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1106, 1106);
      ! phrase 1
      ! [1: now the noun is held by the trader]
       MoveObject(noun,(MStack-->MstVO(20101,0))); 
      ! phrase 2
      ! [2: now the second noun is held by the player]
       MoveObject(second,player); 
      ! phrase 3
      ! [3: repeat with item running through visible not held talents begin]
       for (t_0=Prop_72(0), t_1=Prop_72(t_0): t_0: t_0=t_1, t_1=Prop_72(t_1))  {
                  ! phrase 4
         ! [4: now item is off-stage]
          (Adj_9_t3_v65(t_0)); 
         ! phrase 5
         ! [5: end repeat]
         }

         } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1106, 1106, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Trading (B437_report_trading)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! First report trading:
! --- now the mid-placed rules ---
! Rule 2/4 ! Report trading when Rabbit is visible:
!   === which is equally specific with ===
! Rule 3/4 ! Report trading when Coyote is visible:
!   === which is equally specific with ===
! Rule 4/4 ! Report trading when Sand-dancer is visible:
! ----------------------------------------------------------------------------------------------------
! No specific request
! First report trading:
[ R_1107 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1107, 1107);
      ! phrase 1
      ! [1: say ~[The trader] nods. 'Yes,' he says, 'a fair trade.' And something happens inside you as he says it. [The noun] shifts and wriggles and fades away and it's still there, but now it's shifted, become something else. And yeah, it kinda does feel like you could call it [the second noun]. Cool.~]
      say__p=1;ParaContent();  print (The) (MStack-->MstVO(20101,0)); ParaContent();  print (PrintText) SC_568; ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_569; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_570;  new_line; .L_Say394; .L_SayX352;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1107, 1107, true);
   rfalse;
];
! No specific request
! Report trading when Rabbit is visible:
[ R_1155 ;
   if (actor == player) {
   if (((((((Adj_3_t1_v65(O166_rabbit)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1155, 1155);
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: now more coming is familiar]
       (Adj_90_t2_v65(O198_more_coming)); 
      ! phrase 3
      ! [3: try quizzing the rabbit about more coming]
       TryAction(0, player, ##A83_quizzing_it_about, O166_rabbit, O198_more_coming);; 
      ! phrase 4
      ! [4: stop the action]
       rtrue; 
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1155, 1155, true);
   rfalse;
];
! No specific request
! Report trading when Coyote is visible:
[ R_1195 ;
   if (actor == player) {
   if (((((((Adj_3_t1_v65(O167_coyote)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1195, 1195);
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: now more coming is familiar]
       (Adj_90_t2_v65(O198_more_coming)); 
      ! phrase 3
      ! [3: try quizzing coyote about more coming]
       TryAction(0, player, ##A83_quizzing_it_about, O167_coyote, O198_more_coming);; 
      ! phrase 4
      ! [4: stop the action]
       rtrue; 
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1195, 1195, true);
   rfalse;
];
! No specific request
! Report trading when Sand-dancer is visible:
[ R_1232 ;
   if (actor == player) {
   if (((((((Adj_3_t1_v65(O168_sand_dancer)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1232, 1232);
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: say ~'The choice is made,' he rumbles, 'your path is set. Goodbye, Nakaibito.' And he turns and dives into the sand. The lizards twist and writhe and follow him.[paragraph break]And then, just as quiet settles, another huge rumble shakes the ground, and, almost like an afterthought, the building breaches the sand and rises to the surface.~]
      say__p=1;ParaContent();  print (PrintText) SC_571; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_572;  new_line; .L_Say395; .L_SayX353;
      ! phrase 3
      ! [3: now sand-dancer is off-stage]
       (Adj_9_t3_v65(O168_sand_dancer)); 
      ! phrase 4
      ! [4: now thousands of lizards are off-stage]
       (Adj_9_t3_v65(O206_thousands_of_lizards)); 
      ! phrase 5
      ! [5: reset the interlocutor]
      (PHR_765_r3 ());
      ! phrase 6
      ! [6: move player to crumbling concrete]
       MoveObject(player, O68_crumbling_concrete, 0, false); 
      ! phrase 7
      ! [7: stop the action]
       rtrue; 
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1232, 1232, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Rainstorm begins (B440_when_rainstorm_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Rainstorm begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Rainstorm begins:
[ R_1119 ;
      ! phrase 1
      ! [1: now the rain is in around the tower]
       MoveObject(O180_rain,O87_around_the_tower); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Rainstorm ends (B441_when_rainstorm_ends)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Rainstorm ends:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Rainstorm ends:
[ R_1121 ;
      ! phrase 1
      ! [1: now the rain is off-stage]
       (Adj_9_t3_v65(O180_rain)); 
      ! phrase 2
      ! [2: say ~The rain's dying down, the sounds of the storm fading, water sinking into the thirsty sand leaving only the smell of [sage] behind.~]
      say__p=1;ParaContent();  print (PrintText) SC_573; ParaContent();  print (PrintShortName) O64_sage; ParaContent();  print (PrintText) SC_574;  new_line; .L_Say396; .L_SayX354;
      ! phrase 3
      ! [3: now sage is in around the tower]
       MoveObject(O64_sage,O87_around_the_tower); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Pursuit begins (B442_when_pursuit_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Pursuit begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Pursuit begins:
[ R_1129 
    t_0 ! Local variable e.g. 'desert connection' = object
    ;
      ! phrase 1
      ! [1: let desert connection be an object]
       t_0 = nothing; 
      ! phrase 2
      ! [2: if location is the open desert begin]
       if (((real_location == O149_open_desert)))  {
         ! phrase 3
         ! [3: now desert connection is the bunny's path]
          t_0 = (PHR_1135_r33 ()); 
         ! phrase 4
         ! [4: otherwise if location is weed-strewn rust]
          } else if (((real_location == O88_weed_strewn_rust))) { 
         ! phrase 5
         ! [5: now desert connection is east]
          t_0 = O16_east; 
         ! phrase 6
         ! [6: otherwise]
         } else {

         ! phrase 7
         ! [7: now desert connection is west]
          t_0 = O17_west; 
         ! phrase 8
         ! [8: end if]
         }

      ! phrase 9
      ! [9: now path of darting shadow is desert connection]
       WriteGProperty(OBJECT_TY, O181_darting_shadow,p22_path,t_0); 
      ! phrase 10
      ! [10: move darting shadow to location]
       MoveObject(O181_darting_shadow, real_location, 0, false); 
      ! phrase 11
      ! [11: if darting shadow is visible , say ~[one of]Out of the corner of your eye you spot a glimpse of something moving in the darkness, off in the desert to the [path of darting shadow][or]You see that weird movement again, out in the shadows to the [path of darting shadow][stopping].~]
       if ((((Adj_3_t1_v65(O181_darting_shadow))))) { say__p=1;ParaContent();  I7_ST_say_one_of-->17 =
	i7_soo_stop(I7_ST_say_one_of-->17, 2);
	switch((I7_ST_say_one_of-->17)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_575; ParaContent(); @push self;  print (PrintShortName) GProperty(OBJECT_TY, self=O181_darting_shadow,p22_path); @pull self; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_576; ParaContent(); @push self;  print (PrintShortName) GProperty(OBJECT_TY, self=O181_darting_shadow,p22_path); @pull self; ParaContent();  } ParaContent();  print (PrintText) SC_77;  new_line; .L_Say397; .L_SayX355;  }
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Pursuit ends (B443_when_pursuit_ends)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Pursuit ends:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Pursuit ends:
[ R_1134 ;
      ! phrase 1
      ! [1: now times followed of darting shadow is 0]
       WriteGProperty(OBJECT_TY, O181_darting_shadow,p23_times_followed,0); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Rabbit's Offer begins (B444_when_rabbit_s_offer_beg)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Rabbit's Offer begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Rabbit's Offer begins:
[ R_1136 ;
      ! phrase 1
      ! [1: rabbit's conversation starts in 1 turn from now]
       SetTimedEvent(R_1137, 1+1, 0); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Temptation begins (B446_when_temptation_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Temptation begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Temptation begins:
[ R_1158 ;
      ! phrase 1
      ! [1: say ~You stop in mid-stride as your eyes flick to the horizon. Way out in the desert, silhouetted on a rise, a [distant figure] stands. As you watch he raises a hand and waves.~]
      say__p=1;ParaContent();  print (PrintText) SC_577; ParaContent();  print (PrintShortName) O200_distant_figure; ParaContent();  print (PrintText) SC_578;  new_line; .L_Say398; .L_SayX356;
      ! phrase 2
      ! [2: move distant figure to around the tower]
       MoveObject(O200_distant_figure, O87_around_the_tower, 0, false); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Temptation ends (B447_when_temptation_ends)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Temptation ends:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Temptation ends:
[ R_1162 ;
      ! phrase 1
      ! [1: now the distant figure is off-stage]
       (Adj_9_t3_v65(O200_distant_figure)); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Chase begins (B448_when_chase_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Chase begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Chase begins:
[ R_1165 ;
      ! phrase 1
      ! [1: move snarling shadows to open desert]
       MoveObject(O201_snarling_shadows, O149_open_desert, 0, false); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Chase ends (B449_when_chase_ends)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Chase ends:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Chase ends:
[ R_1166 ;
      ! phrase 1
      ! [1: now snarling shadows are off-stage]
       (Adj_9_t3_v65(O201_snarling_shadows)); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Fight begins (B450_when_fight_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Fight begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Fight begins:
[ R_1169 ;
      ! phrase 1
      ! [1: now circle of snarling coyotes is in location]
       MoveObject(O202_circle_of_snarling_coyo,real_location); 
      ! phrase 2
      ! [2: say ~It's over. They've caught you. They surround you, circling, growling, looking for weakness, moving in for the kill.~]
      say__p=1;ParaContent();  print (PrintText) SC_579;  new_line; .L_Say399; .L_SayX357;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Fight ends (B451_when_fight_ends)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Fight ends:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Fight ends:
[ R_1175 ;
      ! phrase 1
      ! [1: now circle of snarling coyotes is off-stage]
       (Adj_9_t3_v65(O202_circle_of_snarling_coyo)); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Coyote's Offer begins (B452_when_coyote_s_offer_beg)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! When Coyote's Offer begins:
!   === which is equally specific with ===
! Rule 2/2 ! When Coyote's Offer begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Coyote's Offer begins:
[ R_1176 ;
      ! phrase 1
      ! [1: move the coyote to open desert]
       MoveObject(O167_coyote, O149_open_desert, 0, false); 
      ! phrase 2
      ! [2: coyote's conversation starts in 1 turn from now]
       SetTimedEvent(R_1177, 1+1, 0); 
   rfalse;
];
! No specific request
! When Coyote's Offer begins:
[ R_1179 ;
      ! phrase 1
      ! [1: now flashlight is switched off]
       (Adj_85_t2_v65(O71_flashlight)); 
      ! phrase 2
      ! [2: now coyote is lit]
       (Adj_55_t2_v65(O167_coyote)); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Sand-dancer's Offer begins (B456_when_sand_dancer_s_offe)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Sand-dancer's Offer begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Sand-dancer's Offer begins:
[ R_1210 ;
      ! phrase 1
      ! [1: now sand-dancer is in location]
       MoveObject(O168_sand_dancer,real_location); 
      ! phrase 2
      ! [2: now thousands of lizards are in location]
       MoveObject(O206_thousands_of_lizards,real_location); 
      ! phrase 3
      ! [3: now sand-dancer holds advice]
       MoveObject(O203_advice,O168_sand_dancer); 
      ! phrase 4
      ! [4: sand-dancer's conversation starts in 1 turn from now]
       SetTimedEvent(R_1212, 1+1, 0); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Fight ends in cowardice (B458_when_fight_ends_in_cowa)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Fight ends in cowardice:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Fight ends in cowardice:
[ R_1172 ;
      ! phrase 1
      ! [1: say ~It's over. The coyotes dive in for the kill, jaws snapping, and you cower in fear.^^But then one of them flicks his head and bares his teeth, and the others pull back. He's not bigger or stronger or anything but there's something about him that's different. He takes the littlest step forward and the others scatter, mangy shadows slinking away into the desert and then you're left alone with the leader, the alpha coyote.~]
      say__p=1;ParaContent();  print (PrintText) SC_580;  new_line; .L_Say400; .L_SayX358;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------
! Definitions of displaced and unbooked rules

! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take what you're inside rule ):
[ R_94 
    t_0 ! Local variable e.g. 'local ceiling' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_94, 94);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: if the local ceiling is the noun , stop the action with library message taking action number 4 for the noun]
       if (((t_0 == noun))) {  return GL__M(##Take,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_94, 94, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't go through undescribed doors rule ):
[ R_140 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_140, 140);
      ! phrase 1
      ! [1: if the door gone through is not nothing and the door gone through is undescribed , stop the action with library message going action number 2 for the room gone from]
       if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_66_t1_v65((MStack-->MstVO(20007,2)))))))) {  return GL__M(##Go,2,(MStack-->MstVO(20007,0)));   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_140, 140, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the convert exit into go out rule ):
[ R_160 
    t_0 ! Local variable e.g. 'local room' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_160, 160);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
       t_0 =  LocationOf(actor) ; 
      ! phrase 2
      ! [2: if the container exited from is the local room begin]
       if ((((MStack-->MstVO(20009,0)) == t_0)))  {
         ! phrase 3
         ! [3: if the room-or-door outside from the local room is not nothing , convert to the going action on the outside]
          if (((~~(((Resolver_10(out_obj,t_0,"source", 2185)) == nothing))))) {  return GVS_Convert(##Go,out_obj,0);   }
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_160, 160, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor exiting ( this is the describe room emerged into rule ):
[ R_166 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_166, 166);
      ! phrase 1
      ! [1: if the actor is the player , produce a room description with going spacing conventions]
       if (((actor == player))) {  LookAfterGoing();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_166, 166, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor getting off ( this is the can't get off things rule ):
[ R_167 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_167, 167);
      ! phrase 1
      ! [1: if the actor is on the noun , continue the action]
       if (((noun == SupporterOf(actor)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is carried by the noun , continue the action]
       if (((noun == CarrierOf(actor)))) {  rfalse;   }
      ! phrase 3
      ! [3: stop the action with library message getting off action number 1 for the noun]
       return GL__M(##GetOff,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_167, 167, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor getting off ( this is the describe room stood up into rule ):
[ R_170 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_170, 170);
      ! phrase 1
      ! [1: if the actor is the player , produce a room description with going spacing conventions]
       if (((actor == player))) {  LookAfterGoing();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_170, 170, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out looking ( this is the room description body text rule ):
[ R_173 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_173, 173);
      ! phrase 1
      ! [1: if the visibility level count is 0 begin]
       if ((((MStack-->MstVO(20011,2)) == 0)))  {
         ! phrase 2
         ! [2: if set to abbreviated room descriptions , continue the action]
          if (( (lookmode == 3) )) {  rfalse;   }
         ! phrase 3
         ! [3: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and darkness witnessed is true , continue the action]
          if ((( (lookmode == 1) )) && (((((MStack-->MstVO(20011,1)) == 1))) && ((((Global_Vars-->0) == 1))))) {  rfalse;   }
         ! phrase 4
         ! [4: begin the printing the description of a dark room activity]
          BeginActivity(V9_printing_the_description_); 
         ! phrase 5
         ! [5: if handling the printing the description of a dark room activity , issue miscellaneous library message number 17]
          if (( (~~(ForActivity(V9_printing_the_description_))) )) {  GL__M(##Miscellany,17);   }
         ! phrase 6
         ! [6: end the printing the description of a dark room activity]
          EndActivity(V9_printing_the_description_); 
         ! phrase 7
         ! [7: otherwise if the visibility ceiling is the location]
          } else if ((((MStack-->MstVO(20011,3)) == real_location))) { 
         ! phrase 8
         ! [8: if set to abbreviated room descriptions , continue the action]
          if (( (lookmode == 3) )) {  rfalse;   }
         ! phrase 9
         ! [9: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and the location is visited , continue the action]
          if ((( (lookmode == 1) )) && (((((MStack-->MstVO(20011,1)) == 1))) && ((((Adj_53_t1_v65(real_location))))))) {  rfalse;   }
         ! phrase 10
         ! [10: print the location's description]
          PrintOrRun(location, description); 
         ! phrase 11
         ! [11: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_173, 173, true);
   rfalse;
];
! No specific request
! From "Modified Exit" by Emily Short
! This is the implicit exiting rule:
[ R_863 
    t_0 ! Local variable e.g. 'chaise' = object
    ;
      ! phrase 1
      ! [1: let the chaise be the holder of the person asked]
       t_0 =  (HolderOf(actor)) ; 
      ! phrase 2
      ! [2: if the person asked is the player and the sequential action option is not active begin]
       if ((((actor == player))) && (((~~(((Adj_22_t1_v74(23))))))))  {
         ! phrase 3
         ! [3: say ~(first getting [if the chaise is a supporter]off[otherwise]out of[end if] [the chaise])[command clarification break]~]
         say__p=1;ParaContent();  print (PrintText) SC_581; 
	if (~~((((t_0 ofclass K6_supporter))))) jump L_Say401;
		ParaContent();  print (PrintText) SC_582; 
	jump L_SayX359; .L_Say401;
		ParaContent();  print (PrintText) SC_583; 
	.L_Say402; .L_SayX359;
		ParaContent();  print (PrintText) SC_166; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_104; ParaContent();  CommandClarificationBreak();  .L_Say403; .L_SayX360;
         ! phrase 4
         ! [4: silently try the person asked exiting]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Exit, 0, 0);; @pull keep_silent; 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: try the person asked exiting]
          TryAction(0, actor, ##Exit, 0, 0);; 
         ! phrase 7
         ! [7: end if]
         }

   rfalse;
];
! No specific request
! From "Modified Exit" by Emily Short
! This is the new convert exit into go out rule:
[ R_864 
    t_0 ! Local variable e.g. 'local room' = object
    ;
      ! phrase 1
      ! [1: let the local room be the location of the actor]
       t_0 =  LocationOf(actor) ; 
      ! phrase 2
      ! [2: if the container exited from is the local room , convert to the going action on the outside]
       if ((((MStack-->MstVO(20009,0)) == t_0))) {  return GVS_Convert(##Go,out_obj,0);   }
   rfalse;
];
! No specific request
! From "Default Messages" by David Fisher
! This is the print library message rule:
[ R_889 
    t_0 ! Local variable e.g. 'n1' = number
    t_1 ! Local variable e.g. 'n2' = number
    t_2 ! Local variable e.g. 'mid' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let n1 be 1]
       t_0 = 1; 
      ! phrase 2
      ! [2: let n2 be the number of rows in the table of library messages]
       t_1 =  TableRows(T3_library_messages) ; 
      ! phrase 3
      ! [3: change libmsg_printed to 0]
       (Global_Vars-->22) = 0; 
      ! phrase 4
      ! [4: while n1 <= n2 begin]
       while (((t_0 <= t_1)))  {
         ! phrase 5
         ! [5: let mid be n1 plus n2]
          t_2 =  (t_0+t_1) ; 
         ! phrase 6
         ! [6: change mid to mid divided by 2]
          t_2 =  (IntegerDivide(t_2,2)) ; 
         ! phrase 7
         ! [7: choose row mid in the table of library messages]
          ct_0 = T3_library_messages; ct_1 = t_2; 
         ! phrase 8
         ! [8: if the message id entry is library-message-id begin]
          if (((TableLookUpEntry(ct_0,107,ct_1) == (Global_Vars-->21))))  {
            ! phrase 9
            ! [9: if the message text entry is not ~@@126~ begin]
             if (((~~((TableLookUpEntry(ct_0,108,ct_1) == SC_69)))))  {
               ! phrase 10
               ! [10: if library message debug is on , say ~{[library-message-id] - custom}[line break]~]
                if ((((Adj_94_t1_v65(O35_library_message_debug))))) { say__p=1;ParaContent();  print (PrintText) SC_584; ParaContent();  print (T44_library_message_id) (Global_Vars-->21); ParaContent();  print (PrintText) SC_585; ParaContent();  new_line;  .L_Say404; .L_SayX361;  }
               ! phrase 11
               ! [11: say the message text entry]
               say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,108,ct_1);  .L_Say405; .L_SayX362;
               ! phrase 12
               ! [12: change libmsg_printed to 1]
                (Global_Vars-->22) = 1; 
               ! phrase 13
               ! [13: otherwise]
               } else {

               ! phrase 14
               ! [14: if library message debug is on , say ~{[library-message-id]}[line break]~]
                if ((((Adj_94_t1_v65(O35_library_message_debug))))) { say__p=1;ParaContent();  print (PrintText) SC_584; ParaContent();  print (T44_library_message_id) (Global_Vars-->21); ParaContent();  print (PrintText) SC_586; ParaContent();  new_line;  .L_Say406; .L_SayX363;  }
               ! phrase 15
               ! [15: end if]
               }

            ! phrase 16
            ! [16: change n1 to n2 + 1]
             t_0 =  (t_1+1) ; 
            ! phrase 17
            ! [17: end if]
            }

         ! phrase 18
         ! [18: if the message id entry < library-message-id , change n1 to mid plus 1]
          if (((TableLookUpEntry(ct_0,107,ct_1) < (Global_Vars-->21)))) {  t_0 =  (t_2+1) ;   }
         ! phrase 19
         ! [19: if the message id entry > library-message-id , change n2 to mid minus 1]
          if (((TableLookUpEntry(ct_0,107,ct_1) > (Global_Vars-->21)))) {  t_1 =  (t_2-1) ;   }
         ! phrase 20
         ! [20: end while]
         }

   rfalse;
];
! No specific request
! From "Default Messages" by David Fisher
! This is the custom_internal_i6 reveal any newly visible exterior rule:
[ R_905 ;
      ! phrase 1
      ! [1: display libmsg <reveal any newly visible exterior initial text> / the fake_newly_visible_exterior rule]
      (PHR_904_r42 (Q236_libmsg__reveal_any_newl,R_906));
      ! phrase 2
      ! [2: if there is no newly visible exterior begin]
       if (( WriteListFrom(child(lm_o), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT) == 0 ))  {
         ! phrase 3
         ! [3: display libmsg <no newly visible exterior> / the fake_newly_visible_exterior_nothing rule]
         (PHR_904_r42 (Q237_libmsg__no_newly_visibl,R_907));
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~.~]
         say__p=1;ParaContent();  print (PrintText) SC_77;  new_line; .L_Say407; .L_SayX364;
         ! phrase 6
         ! [6: end if]
         }

   rfalse;
];
! No specific request
! From "Default Messages" by David Fisher
! This is the fake_newly_visible_exterior rule:
[ R_906 ;
      ! phrase 1
      ! [1: say ~You open [the main object], revealing [run paragraph on]~]
      say__p=1;ParaContent();  print (PrintText) SC_587; ParaContent();  print (the) (Global_Vars-->23); ParaContent();  print (PrintText) SC_588; ParaContent();  RunParagraphOn();  .L_Say408; .L_SayX365;
   rfalse;
];
! No specific request
! From "Default Messages" by David Fisher
! This is the fake_newly_visible_exterior_nothing rule:
[ R_907 ;
      ! phrase 1
      ! [1: say ~nothing.~]
      say__p=1;ParaContent();  print (PrintText) SC_589;  new_line; .L_Say409; .L_SayX366;
   rfalse;
];
! No specific request
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! At the time when the topic list displays:
[ R_844 ;
      ! phrase 1
      ! [1: show the topic suggestions implicitly]
      (PHR_845_r43 ());
   rfalse;
];
! No specific request
! At the time when Rabbit's conversation starts:
[ R_1137 ;
      ! phrase 1
      ! [1: try quizzing the rabbit about introduction]
       TryAction(0, player, ##A83_quizzing_it_about, O166_rabbit, O184_introduction);; 
      ! phrase 2
      ! [2: try listing suggested topics]
       TryAction(0, player, ##A93_listing_suggested_topics, 0, 0);; 
   rfalse;
];
! No specific request
! At the time when Coyote's conversation starts:
[ R_1177 ;
      ! phrase 1
      ! [1: try quizzing the coyote about introduction]
       TryAction(0, player, ##A83_quizzing_it_about, O167_coyote, O184_introduction);; 
      ! phrase 2
      ! [2: now coyote holds down to business]
       MoveObject(O190_down_to_business,O167_coyote); 
      ! phrase 3
      ! [3: try listing suggested topics]
       TryAction(0, player, ##A93_listing_suggested_topics, 0, 0);; 
   rfalse;
];
! No specific request
! At the time when Sand-dancer's conversation starts:
[ R_1212 ;
      ! phrase 1
      ! [1: try quizzing sand-dancer about introduction]
       TryAction(0, player, ##A83_quizzing_it_about, O168_sand_dancer, O184_introduction);; 
      ! phrase 2
      ! [2: try listing suggested topics]
       TryAction(0, player, ##A93_listing_suggested_topics, 0, 0);; 
   rfalse;
];
! Definitions of adjectives

! No specific request
! From the Standard Rules
! Definition:
[ R_0 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_1 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_2 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_3 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_4 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_5 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_6 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_7 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_37 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_38 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_39 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_40 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_41 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_42 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_43 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_44 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_45 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_46 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_47 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_48 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_49 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_50 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_51 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_52 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_53 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_54 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_55 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_56 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_84 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Epistemology" by Eric Eve
! Definition:
[ R_742 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Epistemology" by Eric Eve
! Definition:
[ R_743 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Definition:
[ R_874 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Definition:
[ R_876 
    t_0 ! Call parameter 'it' = object
    ;
      ! phrase 1
      ! [1: if it provides the property switched on , yes]
       if (((WhetherProvides(t_0, true, on)))) {  rtrue;   }
   rfalse;
];
! No specific request
! Definition:
[ R_928 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_940 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_941 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_942 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_943 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_949 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_951 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_952 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_1081 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_1204 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_1205 
    t_0 ! Call parameter 'it' = object
    ;
      ! phrase 1
      ! [1: if it is the player , no]
       if (((t_0 == player))) {  rfalse;   }
      ! phrase 2
      ! [2: if it is a window , no]
       if (((t_0 ofclass K119_window))) {  rfalse;   }
      ! phrase 3
      ! [3: if it is a door , no]
       if (((t_0 ofclass K4_door))) {  rfalse;   }
      ! phrase 4
      ! [4: if it is scenery , no]
       if ((((Adj_61_t1_v65(t_0))))) {  rfalse;   }
      ! phrase 5
      ! [5: if it is enclosed by player , no]
       if (((IndirectlyContains(player,t_0)))) {  rfalse;   }
      ! phrase 6
      ! [6: yes]
       rtrue; 
   rfalse;
];
[ Adj_0_t1_v65 ! meaning of "worn"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((player == WearerOf(t_0)))));
    rfalse;
];

[ Adj_1_t1_v65 ! meaning of "carried"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((player == CarrierOf(t_0)))));
    rfalse;
];

[ Adj_2_t1_v65 ! meaning of "held"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((player == HolderOf(t_0)))));
    rfalse;
];

[ Adj_3_t1_v65 ! meaning of "visible"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((TestVisibility(player,t_0)))));
    rfalse;
];

[ Adj_4_t1_v65 ! meaning of "invisible"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (~~(((((TestVisibility(player,t_0)))))));
    rfalse;
];

[ Adj_5_t1_v65 ! meaning of "touchable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((TestTouchability(player,t_0)))));
    rfalse;
];

[ Adj_6_t1_v65 ! meaning of "untouchable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (~~(((((TestTouchability(player,t_0)))))));
    rfalse;
];

[ Adj_7_t1_v65 ! meaning of "concealed"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((TestConcealment( (HolderOf(t_0)) ,t_0)))));
    rfalse;
];

[ Adj_8_t1_v65 ! meaning of "unconcealed"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (~~(((((TestConcealment( (HolderOf(t_0)) ,t_0)))))));
    rfalse;
];

[ Adj_9_t1_v65 ! meaning of "on-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, -1)));
    rfalse;
];

[ Adj_10_t1_v65 ! meaning of "off-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return (~~(((OnStage(t_0, -1)))));
    rfalse;
];

[ Adj_11_t1_v65 ! meaning of "adjacent"

    t_0 ! Call parameter 'it' = room
    ;
  if (t_0 ofclass K1_room) return ((((TestAdjacency(real_location,t_0)))));
    rfalse;
];

[ Adj_12_t1_v66 ! meaning of "even"

    t_0 ! Call parameter 'it' = number
    ;
return (((( (IntegerRemainder(t_0,2))  == 0))));
    rfalse;
];

[ Adj_13_t1_v66 ! meaning of "odd"

    t_0 ! Call parameter 'it' = number
    ;
return (~~((((( (IntegerRemainder(t_0,2))  == 0))))));
    rfalse;
];

[ Adj_14_t1_v66 ! meaning of "positive"

    t_0 ! Call parameter 'it' = number
    ;
return ((((t_0 > 0))));
    rfalse;
];

[ Adj_15_t1_v66 ! meaning of "negative"

    t_0 ! Call parameter 'it' = number
    ;
return ((((t_0 < 0))));
    rfalse;
];

[ Adj_16_t1_v68 ! meaning of "empty"

    t_0 ! Call parameter 'it' = text
    ;
return ((((t_0 == EMPTY_TEXT_VALUE))));
    rfalse;
];

[ Adj_16_t1_v69 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((INDEXED_TEXT_TY_Empty(t_0)));
    rfalse;
];

[ Adj_16_t1_v72 ! meaning of "empty"

    t_0 ! Call parameter 'it' = table name
    ;
return (((( TableFilledRows(t_0)  == 0))));
    rfalse;
];

[ Adj_16_t1_v82 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RulebookEmpty(t_0)));
    rfalse;
];

[ Adj_16_t1_v83 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((ActivityEmpty(t_0)));
    rfalse;
];

[ Adj_16_t1_v78 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((LIST_OF_TY_Empty(t_0)));
    rfalse;
];

[ Adj_16_t1_v80 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, -1)));
    rfalse;
];

[ Adj_17_t1_v68 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = text
    ;
return (~~(((((t_0 == EMPTY_TEXT_VALUE))))));
    rfalse;
];

[ Adj_17_t1_v69 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((INDEXED_TEXT_TY_Empty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v72 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = table name
    ;
return (~~((((( TableFilledRows(t_0)  == 0))))));
    rfalse;
];

[ Adj_17_t1_v82 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((RulebookEmpty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v83 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((ActivityEmpty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v78 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((LIST_OF_TY_Empty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v80 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((RELATION_TY_Empty(t_0, -1)))));
    rfalse;
];

[ Adj_18_t1_v94 ! meaning of "happening"

    t_0 ! Call parameter 'it' = scene
    ;
return ((scene_status-->(t_0-1)==1));
    rfalse;
];

[ Adj_19_t1_v72 ! meaning of "full"

    t_0 ! Call parameter 'it' = table name
    ;
return (((( TableBlankRows(t_0)  == 0))));
    rfalse;
];

[ Adj_20_t1_v72 ! meaning of "non-full"

    t_0 ! Call parameter 'it' = table name
    ;
return (~~((((( TableBlankRows(t_0)  == 0))))));
    rfalse;
];

[ Adj_21_t1_v83 ! meaning of "going on"

    t_0 ! Call parameter 'it' = number
    ;
return ((TestActivity(t_0)));
    rfalse;
];

[ Adj_22_t1_v74 ! meaning of "active"

    t_0 ! Call parameter 'it' = number
    ;
return ((TestUseOption(t_0)));
    rfalse;
];

[ Adj_23_t1_v74 ! meaning of "inactive"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((TestUseOption(t_0)))));
    rfalse;
];

[ Adj_24_t1_v80 ! meaning of "equivalence"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_EquivalenceAdjective(t_0, -1)));
    rfalse;
];

[ Adj_25_t1_v80 ! meaning of "symmetric"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_SymmetricAdjective(t_0, -1)));
    rfalse;
];

[ Adj_26_t1_v80 ! meaning of "one-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToOAdjective(t_0, -1)));
    rfalse;
];

[ Adj_27_t1_v80 ! meaning of "one-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToVAdjective(t_0, -1)));
    rfalse;
];

[ Adj_28_t1_v80 ! meaning of "various-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToOAdjective(t_0, -1)));
    rfalse;
];

[ Adj_29_t1_v80 ! meaning of "various-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToVAdjective(t_0, -1)));
    rfalse;
];

[ Adj_30_t1_v65 ! meaning of "locale-supportable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (((((~~(((Adj_61_t1_v65(t_0))))))) && ((((~~(((Adj_69_t1_v65(t_0))))))) && (((~~(((Adj_66_t1_v65(t_0))))))))));
    rfalse;
];

[ Adj_31_t1_v65 ! meaning of "known"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((((Adj_90_t1_v65(t_0))))) || ((((Adj_88_t1_v65(t_0)))))));
    rfalse;
];

[ Adj_32_t1_v65 ! meaning of "unknown"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((~~(((Adj_31_t1_v65(t_0))))))));
    rfalse;
];

[ Adj_33_t1_v65 ! meaning of "viable"

    t_0 ! Call parameter 'it' = direction
    ;
  if (t_0 ofclass K3_direction) return (((((Resolver_13(t_0,real_location,"source", 69)) ofclass K1_room))));
      if (t_0 ofclass K3_direction) return (((((Resolver_13(t_0,real_location,"source", 1285)) ofclass K1_room))));
    rfalse;
];

[ Adj_34_t1_v65 ! meaning of "switchable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((R_876(t_0)));
    rfalse;
];

[ Adj_35_t1_v65 ! meaning of "charged"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (((((t_0.p78_suggested_memory) ofclass K43_memory) && (O44_subconscious == ContainerOf((t_0.p78_suggested_memory))))));
    rfalse;
];

[ Adj_36_t1_v65 ! meaning of "within range of headlights"

    t_0 ! Call parameter 'it' = room
    ;
  if (t_0 ofclass K1_room) return (((((t_0 == O66_middle_of_nowhere))) || ((((t_0 == O67_backtracking))) || ((((t_0 == O68_crumbling_concrete))) || (((t_0 == O70_base_of_the_tower)))))));
    rfalse;
];

[ Adj_37_t1_v65 ! meaning of "lit brightly"

    t_0 ! Call parameter 'it' = room
    ;
  if (t_0 ofclass K1_room) return (((((TestRegionalContainment(t_0,O164_tower_vicinity)))) && ((((Adj_84_t1_v65(O131_emergency_lights)))))));
    rfalse;
];

[ Adj_38_t1_v65 ! meaning of "lit by headlights"

    t_0 ! Call parameter 'it' = room
    ;
  if (t_0 ofclass K1_room) return (((((~~(((Adj_37_t1_v65(t_0))))))) && (((((Adj_36_t1_v65(t_0))))) && ((((Adj_84_t1_v65(O95_headlights))))))));
    rfalse;
];

[ Adj_39_t1_v65 ! meaning of "lit by flashlight"

    t_0 ! Call parameter 'it' = room
    ;
  if (t_0 ofclass K1_room) return (((((~~(((Adj_37_t1_v65(t_0))))))) && ((((~~(((Adj_38_t1_v65(t_0))))))) && ((((IndirectlyContains(t_0,O71_flashlight)))) && ((((Adj_84_t1_v65(O71_flashlight)))))))));
    rfalse;
];

[ Adj_40_t1_v65 ! meaning of "brighter"

    t_0 ! Call parameter 'it' = direction
    ;
  if (t_0 ofclass K3_direction) return ((((((Adj_33_t1_v65(t_0))))) && ((((Adj_51_t1_v65((Resolver_13(t_0,real_location,"source", 271)))))))));
    rfalse;
];

[ Adj_41_t1_v65 ! meaning of "in progress"

    t_0 ! Call parameter 'it' = plan
    ;
  if (t_0 ofclass K72_plan) return (((Prop_73(,t_0))));
    rfalse;
];

[ Adj_42_t1_v65 ! meaning of "complete"

    t_0 ! Call parameter 'it' = plan
    ;
  if (t_0 ofclass K72_plan) return (((Prop_74(,t_0))));
    rfalse;
];

[ Adj_43_t1_v65 ! meaning of "cardinal"

    t_0 ! Call parameter 'it' = direction
    ;
  if (t_0 ofclass K3_direction) return (((((~~((t_0 == O18_up))))) && ((((~~((t_0 == O19_down))))) && ((((~~((t_0 == out_obj))))) && (((~~((t_0 == in_obj)))))))));
    rfalse;
];

[ Adj_44_t1_v65 ! meaning of "detrital"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((R_1205(t_0)));
    rfalse;
];

[ Adj_45_t1_v65 ! meaning of "plural-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, pluralname));
    rfalse;
];

[ Adj_46_t1_v65 ! meaning of "singular-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, pluralname) == false);
    rfalse;
];

[ Adj_47_t1_v65 ! meaning of "proper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, proper));
    rfalse;
];

[ Adj_48_t1_v65 ! meaning of "improper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, proper) == false);
    rfalse;
];

[ Adj_49_t1_v65 ! meaning of "privately-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, privately_named));
    rfalse;
];

[ Adj_50_t1_v65 ! meaning of "publically-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, privately_named) == false);
    rfalse;
];

[ Adj_51_t1_v65 ! meaning of "lighted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_52_t1_v65 ! meaning of "dark"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];

[ Adj_53_t1_v65 ! meaning of "visited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, visited));
    rfalse;
];

[ Adj_54_t1_v65 ! meaning of "unvisited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, visited) == false);
    rfalse;
];

[ Adj_55_t1_v65 ! meaning of "lit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_56_t1_v65 ! meaning of "unlit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];

[ Adj_57_t1_v65 ! meaning of "edible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, edible));
    rfalse;
];

[ Adj_58_t1_v65 ! meaning of "inedible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, edible) == false);
    rfalse;
];

[ Adj_59_t1_v65 ! meaning of "fixed in place"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, static));
    rfalse;
];

[ Adj_60_t1_v65 ! meaning of "portable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, static) == false);
    rfalse;
];

[ Adj_61_t1_v65 ! meaning of "scenery"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, scenery));
    rfalse;
];

[ Adj_62_t1_v65 ! meaning of "wearable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, clothing));
    rfalse;
];

[ Adj_63_t1_v65 ! meaning of "pushable between rooms"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, pushable));
    rfalse;
];

[ Adj_64_t1_v65 ! meaning of "handled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, moved));
    rfalse;
];

[ Adj_65_t1_v65 ! meaning of "described"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, concealed) == false);
    rfalse;
];

[ Adj_66_t1_v65 ! meaning of "undescribed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, concealed));
    rfalse;
];

[ Adj_67_t1_v65 ! meaning of "marked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, workflag));
    rfalse;
];

[ Adj_68_t1_v65 ! meaning of "unmarked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, workflag) == false);
    rfalse;
];

[ Adj_69_t1_v65 ! meaning of "mentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mentioned));
    rfalse;
];

[ Adj_70_t1_v65 ! meaning of "unmentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mentioned) == false);
    rfalse;
];

[ Adj_71_t1_v65 ! meaning of "enterable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, enterable));
    rfalse;
];

[ Adj_72_t1_v65 ! meaning of "opaque"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, transparent) == false);
    rfalse;
];

[ Adj_73_t1_v65 ! meaning of "transparent"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, transparent));
    rfalse;
];

[ Adj_74_t1_v65 ! meaning of "open"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, open));
    rfalse;
];

[ Adj_75_t1_v65 ! meaning of "closed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, open) == false);
    rfalse;
];

[ Adj_76_t1_v65 ! meaning of "openable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, openable));
    rfalse;
];

[ Adj_77_t1_v65 ! meaning of "unopenable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, openable) == false);
    rfalse;
];

[ Adj_78_t1_v65 ! meaning of "lockable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, lockable));
    rfalse;
];

[ Adj_79_t1_v65 ! meaning of "locked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, locked));
    rfalse;
];

[ Adj_80_t1_v65 ! meaning of "unlocked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, locked) == false);
    rfalse;
];

[ Adj_81_t1_v65 ! meaning of "female"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, female));
    rfalse;
];

[ Adj_82_t1_v65 ! meaning of "male"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, female) == false);
    rfalse;
];

[ Adj_83_t1_v65 ! meaning of "neuter"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, neuter));
    rfalse;
];

[ Adj_84_t1_v65 ! meaning of "switched on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, on));
    rfalse;
];

[ Adj_85_t1_v65 ! meaning of "switched off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, on) == false);
    rfalse;
];

[ Adj_86_t1_v94 ! meaning of "recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p65_recurring));
    rfalse;
];

[ Adj_87_t1_v94 ! meaning of "non-recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p65_recurring) == false);
    rfalse;
];

[ Adj_88_t1_v65 ! meaning of "seen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p67_seen));
    rfalse;
];

[ Adj_89_t1_v65 ! meaning of "unseen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p67_seen) == false);
    rfalse;
];

[ Adj_90_t1_v65 ! meaning of "familiar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p69_familiar));
    rfalse;
];

[ Adj_91_t1_v65 ! meaning of "unfamiliar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p69_familiar) == false);
    rfalse;
];

[ Adj_92_t1_v65 ! meaning of "ambiguously plural"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p71_ambiguously_plural));
    rfalse;
];

[ Adj_93_t1_v65 ! meaning of "ordinarily enumerated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p71_ambiguously_plural) == false);
    rfalse;
];

[ Adj_94_t1_v65 ! meaning of "on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p74_on));
    rfalse;
];

[ Adj_95_t1_v65 ! meaning of "off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p74_on) == false);
    rfalse;
];

[ Adj_96_t1_v65 ! meaning of "retrieved"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p76_retrieved));
    rfalse;
];

[ Adj_97_t1_v65 ! meaning of "buried"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p76_retrieved) == false);
    rfalse;
];

[ Adj_98_t1_v65 ! meaning of "noted as useful"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p80_noted_as_useful));
    rfalse;
];

[ Adj_99_t1_v65 ! meaning of "hefty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p81_hefty));
    rfalse;
];

[ Adj_100_t1_v65 ! meaning of "dim"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p82_dim));
    rfalse;
];

[ Adj_101_t1_v65 ! meaning of "bright"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p82_dim) == false);
    rfalse;
];

[ Adj_102_t1_v65 ! meaning of "placed correctly"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p84_placed_correctly));
    rfalse;
];

[ Adj_103_t1_v94 ! meaning of "dramatic"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p85_dramatic));
    rfalse;
];

[ Adj_104_t1_v65 ! meaning of "named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p86_named));
    rfalse;
];

[ Adj_105_t1_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, worn));
    rfalse;
];

[ Adj_106_t1_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];

[ Adj_107_t1_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];

[ Adj_108_t1_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, absent));
    rfalse;
];

[ Adj_9_t2_v65 ! meaning of "on-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];

[ Adj_10_t2_v65 ! meaning of "off-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];

[ Adj_16_t2_v80 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];

[ Adj_17_t2_v80 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];

[ Adj_24_t2_v80 ! meaning of "equivalence"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_EquivalenceAdjective(t_0, true)));
    rfalse;
];

[ Adj_25_t2_v80 ! meaning of "symmetric"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_SymmetricAdjective(t_0, true)));
    rfalse;
];

[ Adj_26_t2_v80 ! meaning of "one-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToOAdjective(t_0, true)));
    rfalse;
];

[ Adj_27_t2_v80 ! meaning of "one-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToVAdjective(t_0, true)));
    rfalse;
];

[ Adj_28_t2_v80 ! meaning of "various-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToOAdjective(t_0, true)));
    rfalse;
];

[ Adj_29_t2_v80 ! meaning of "various-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToVAdjective(t_0, true)));
    rfalse;
];

[ Adj_45_t2_v65 ! meaning of "plural-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];

[ Adj_46_t2_v65 ! meaning of "singular-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];

[ Adj_47_t2_v65 ! meaning of "proper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];

[ Adj_48_t2_v65 ! meaning of "improper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];

[ Adj_49_t2_v65 ! meaning of "privately-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];

[ Adj_50_t2_v65 ! meaning of "publically-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];

[ Adj_51_t2_v65 ! meaning of "lighted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_52_t2_v65 ! meaning of "dark"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_53_t2_v65 ! meaning of "visited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];

[ Adj_54_t2_v65 ! meaning of "unvisited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];

[ Adj_55_t2_v65 ! meaning of "lit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_56_t2_v65 ! meaning of "unlit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_57_t2_v65 ! meaning of "edible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];

[ Adj_58_t2_v65 ! meaning of "inedible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];

[ Adj_59_t2_v65 ! meaning of "fixed in place"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];

[ Adj_60_t2_v65 ! meaning of "portable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];

[ Adj_61_t2_v65 ! meaning of "scenery"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, scenery));
    rfalse;
];

[ Adj_62_t2_v65 ! meaning of "wearable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, clothing));
    rfalse;
];

[ Adj_63_t2_v65 ! meaning of "pushable between rooms"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pushable));
    rfalse;
];

[ Adj_64_t2_v65 ! meaning of "handled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, moved));
    rfalse;
];

[ Adj_65_t2_v65 ! meaning of "described"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];

[ Adj_66_t2_v65 ! meaning of "undescribed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];

[ Adj_67_t2_v65 ! meaning of "marked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];

[ Adj_68_t2_v65 ! meaning of "unmarked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];

[ Adj_69_t2_v65 ! meaning of "mentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];

[ Adj_70_t2_v65 ! meaning of "unmentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];

[ Adj_71_t2_v65 ! meaning of "enterable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, enterable));
    rfalse;
];

[ Adj_72_t2_v65 ! meaning of "opaque"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];

[ Adj_73_t2_v65 ! meaning of "transparent"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];

[ Adj_74_t2_v65 ! meaning of "open"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];

[ Adj_75_t2_v65 ! meaning of "closed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];

[ Adj_76_t2_v65 ! meaning of "openable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];

[ Adj_77_t2_v65 ! meaning of "unopenable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];

[ Adj_78_t2_v65 ! meaning of "lockable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, lockable));
    rfalse;
];

[ Adj_79_t2_v65 ! meaning of "locked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];

[ Adj_80_t2_v65 ! meaning of "unlocked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];

[ Adj_81_t2_v65 ! meaning of "female"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female));
    rfalse;
];

[ Adj_82_t2_v65 ! meaning of "male"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female, true));
    rfalse;
];

[ Adj_83_t2_v65 ! meaning of "neuter"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, neuter));
    rfalse;
];

[ Adj_84_t2_v65 ! meaning of "switched on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];

[ Adj_85_t2_v65 ! meaning of "switched off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];

[ Adj_86_t2_v94 ! meaning of "recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p65_recurring, true));
    rfalse;
];

[ Adj_87_t2_v94 ! meaning of "non-recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p65_recurring));
    rfalse;
];

[ Adj_88_t2_v65 ! meaning of "seen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p67_seen));
    rfalse;
];

[ Adj_89_t2_v65 ! meaning of "unseen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p67_seen, true));
    rfalse;
];

[ Adj_90_t2_v65 ! meaning of "familiar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_familiar));
    rfalse;
];

[ Adj_91_t2_v65 ! meaning of "unfamiliar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_familiar, true));
    rfalse;
];

[ Adj_92_t2_v65 ! meaning of "ambiguously plural"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p71_ambiguously_plural));
    rfalse;
];

[ Adj_93_t2_v65 ! meaning of "ordinarily enumerated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p71_ambiguously_plural, true));
    rfalse;
];

[ Adj_94_t2_v65 ! meaning of "on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p74_on));
    rfalse;
];

[ Adj_95_t2_v65 ! meaning of "off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p74_on, true));
    rfalse;
];

[ Adj_96_t2_v65 ! meaning of "retrieved"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p76_retrieved));
    rfalse;
];

[ Adj_97_t2_v65 ! meaning of "buried"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p76_retrieved, true));
    rfalse;
];

[ Adj_98_t2_v65 ! meaning of "noted as useful"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p80_noted_as_useful));
    rfalse;
];

[ Adj_99_t2_v65 ! meaning of "hefty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p81_hefty));
    rfalse;
];

[ Adj_100_t2_v65 ! meaning of "dim"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p82_dim));
    rfalse;
];

[ Adj_101_t2_v65 ! meaning of "bright"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p82_dim, true));
    rfalse;
];

[ Adj_102_t2_v65 ! meaning of "placed correctly"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p84_placed_correctly));
    rfalse;
];

[ Adj_103_t2_v94 ! meaning of "dramatic"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p85_dramatic, true));
    rfalse;
];

[ Adj_104_t2_v65 ! meaning of "named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p86_named));
    rfalse;
];

[ Adj_105_t2_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, worn));
    rfalse;
];

[ Adj_106_t2_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];

[ Adj_107_t2_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];

[ Adj_108_t2_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, absent));
    rfalse;
];

[ Adj_9_t3_v65 ! meaning of "on-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];

[ Adj_10_t3_v65 ! meaning of "off-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];

[ Adj_16_t3_v80 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];

[ Adj_17_t3_v80 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];

[ Adj_24_t3_v80 ! meaning of "equivalence"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_EquivalenceAdjective(t_0, false)));
    rfalse;
];

[ Adj_25_t3_v80 ! meaning of "symmetric"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_SymmetricAdjective(t_0, false)));
    rfalse;
];

[ Adj_26_t3_v80 ! meaning of "one-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToOAdjective(t_0, false)));
    rfalse;
];

[ Adj_27_t3_v80 ! meaning of "one-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToVAdjective(t_0, false)));
    rfalse;
];

[ Adj_28_t3_v80 ! meaning of "various-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToOAdjective(t_0, false)));
    rfalse;
];

[ Adj_29_t3_v80 ! meaning of "various-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToVAdjective(t_0, false)));
    rfalse;
];

[ Adj_45_t3_v65 ! meaning of "plural-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];

[ Adj_46_t3_v65 ! meaning of "singular-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];

[ Adj_47_t3_v65 ! meaning of "proper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];

[ Adj_48_t3_v65 ! meaning of "improper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];

[ Adj_49_t3_v65 ! meaning of "privately-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];

[ Adj_50_t3_v65 ! meaning of "publically-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];

[ Adj_51_t3_v65 ! meaning of "lighted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_52_t3_v65 ! meaning of "dark"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_53_t3_v65 ! meaning of "visited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];

[ Adj_54_t3_v65 ! meaning of "unvisited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];

[ Adj_55_t3_v65 ! meaning of "lit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_56_t3_v65 ! meaning of "unlit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_57_t3_v65 ! meaning of "edible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];

[ Adj_58_t3_v65 ! meaning of "inedible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];

[ Adj_59_t3_v65 ! meaning of "fixed in place"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];

[ Adj_60_t3_v65 ! meaning of "portable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];

[ Adj_61_t3_v65 ! meaning of "scenery"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, scenery, true));
    rfalse;
];

[ Adj_62_t3_v65 ! meaning of "wearable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, clothing, true));
    rfalse;
];

[ Adj_63_t3_v65 ! meaning of "pushable between rooms"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pushable, true));
    rfalse;
];

[ Adj_64_t3_v65 ! meaning of "handled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, moved, true));
    rfalse;
];

[ Adj_65_t3_v65 ! meaning of "described"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];

[ Adj_66_t3_v65 ! meaning of "undescribed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];

[ Adj_67_t3_v65 ! meaning of "marked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];

[ Adj_68_t3_v65 ! meaning of "unmarked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];

[ Adj_69_t3_v65 ! meaning of "mentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];

[ Adj_70_t3_v65 ! meaning of "unmentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];

[ Adj_71_t3_v65 ! meaning of "enterable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, enterable, true));
    rfalse;
];

[ Adj_72_t3_v65 ! meaning of "opaque"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];

[ Adj_73_t3_v65 ! meaning of "transparent"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];

[ Adj_74_t3_v65 ! meaning of "open"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];

[ Adj_75_t3_v65 ! meaning of "closed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];

[ Adj_76_t3_v65 ! meaning of "openable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];

[ Adj_77_t3_v65 ! meaning of "unopenable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];

[ Adj_78_t3_v65 ! meaning of "lockable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, lockable, true));
    rfalse;
];

[ Adj_79_t3_v65 ! meaning of "locked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];

[ Adj_80_t3_v65 ! meaning of "unlocked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];

[ Adj_81_t3_v65 ! meaning of "female"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female, true));
    rfalse;
];

[ Adj_82_t3_v65 ! meaning of "male"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female));
    rfalse;
];

[ Adj_83_t3_v65 ! meaning of "neuter"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, neuter, true));
    rfalse;
];

[ Adj_84_t3_v65 ! meaning of "switched on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];

[ Adj_85_t3_v65 ! meaning of "switched off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];

[ Adj_86_t3_v94 ! meaning of "recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p65_recurring));
    rfalse;
];

[ Adj_87_t3_v94 ! meaning of "non-recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p65_recurring, true));
    rfalse;
];

[ Adj_88_t3_v65 ! meaning of "seen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p67_seen, true));
    rfalse;
];

[ Adj_89_t3_v65 ! meaning of "unseen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p67_seen));
    rfalse;
];

[ Adj_90_t3_v65 ! meaning of "familiar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_familiar, true));
    rfalse;
];

[ Adj_91_t3_v65 ! meaning of "unfamiliar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_familiar));
    rfalse;
];

[ Adj_92_t3_v65 ! meaning of "ambiguously plural"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p71_ambiguously_plural, true));
    rfalse;
];

[ Adj_93_t3_v65 ! meaning of "ordinarily enumerated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p71_ambiguously_plural));
    rfalse;
];

[ Adj_94_t3_v65 ! meaning of "on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p74_on, true));
    rfalse;
];

[ Adj_95_t3_v65 ! meaning of "off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p74_on));
    rfalse;
];

[ Adj_96_t3_v65 ! meaning of "retrieved"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p76_retrieved, true));
    rfalse;
];

[ Adj_97_t3_v65 ! meaning of "buried"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p76_retrieved));
    rfalse;
];

[ Adj_98_t3_v65 ! meaning of "noted as useful"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p80_noted_as_useful, true));
    rfalse;
];

[ Adj_99_t3_v65 ! meaning of "hefty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p81_hefty, true));
    rfalse;
];

[ Adj_100_t3_v65 ! meaning of "dim"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p82_dim, true));
    rfalse;
];

[ Adj_101_t3_v65 ! meaning of "bright"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p82_dim));
    rfalse;
];

[ Adj_102_t3_v65 ! meaning of "placed correctly"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p84_placed_correctly, true));
    rfalse;
];

[ Adj_103_t3_v94 ! meaning of "dramatic"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p85_dramatic));
    rfalse;
];

[ Adj_104_t3_v65 ! meaning of "named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p86_named, true));
    rfalse;
];

[ Adj_105_t3_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, worn, true));
    rfalse;
];

[ Adj_106_t3_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_room, true));
    rfalse;
];

[ Adj_107_t3_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing, true));
    rfalse;
];

[ Adj_108_t3_v65 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, absent, true));
    rfalse;
];



Array TimedEventsTable table 0 0 0 0 0 0 0 0 0 0;

Array TimedEventTimesTable table 0 0 0 0 0 0 0 0 0 0;



Array rulebooks_array --> B0_procedural B1_startup B2_turn_sequence B3_shutdown B4_scene_changing B5_when_play_begins B6_when_play_ends B7_when_scene_begins B8_when_scene_ends B9_every_turn B10_action_processing B11_setting_action_variables B12_specific_action_processi B13_player_s_action_awarenes B14_accessibility B15_reaching_inside B16_reaching_outside B17_visibility B18_persuasion B19_unsuccessful_attempt_by B20_before B21_instead B22_check B23_carry_out B24_after B25_report B26_does_the_player_mean B27_when_entire_game_begins B28_when_entire_game_ends B29_before_printing_the_name B30_for_printing_the_name B31_after_printing_the_name B32_before_printing_the_plur B33_for_printing_the_plural_ B34_after_printing_the_plura B35_before_printing_a_number B36_for_printing_a_number B37_after_printing_a_number B38_before_printing_room_des B39_for_printing_room_descri B40_after_printing_room_desc B41_before_listing_contents B42_for_listing_contents B43_after_listing_contents B44_before_grouping_together B45_for_grouping_together B46_after_grouping_together B47_before_writing_a_paragra B48_for_writing_a_paragraph_ B49_after_writing_a_paragrap B50_before_listing_nondescri B51_for_listing_nondescript_ B52_after_listing_nondescrip B53_before_printing_the_name B54_for_printing_the_name_of B55_after_printing_the_name_ B56_before_printing_the_desc B57_for_printing_the_descrip B58_after_printing_the_descr B59_before_printing_the_anno B60_for_printing_the_announc B61_after_printing_the_annou B62_before_printing_the_anno B63_for_printing_the_announc B64_after_printing_the_annou B65_before_printing_a_refusa B66_for_printing_a_refusal_t B67_after_printing_a_refusal B68_before_constructing_the_ B69_for_constructing_the_sta B70_after_constructing_the_s B71_before_printing_the_bann B72_for_printing_the_banner_ B73_after_printing_the_banne B74_before_reading_a_command B75_for_reading_a_command B76_after_reading_a_command B77_before_deciding_the_scop B78_for_deciding_the_scope B79_after_deciding_the_scope B80_before_deciding_the_conc B81_for_deciding_the_conceal B82_after_deciding_the_conce B83_before_deciding_whether_ B84_for_deciding_whether_all B85_after_deciding_whether_a B86_before_clarifying_the_pa B87_for_clarifying_the_parse B88_after_clarifying_the_par B89_before_asking_which_do_y B90_for_asking_which_do_you_ B91_after_asking_which_do_yo B92_before_printing_a_parser B93_for_printing_a_parser_er B94_after_printing_a_parser_ B95_before_supplying_a_missi B96_for_supplying_a_missing_ B97_after_supplying_a_missin B98_before_supplying_a_missi B99_for_supplying_a_missing_ B100_after_supplying_a_missi B101_before_implicitly_takin B102_for_implicitly_taking B103_after_implicitly_taking B104_before_starting_the_vir B105_for_starting_the_virtua B106_after_starting_the_virt B107_before_amusing_a_victor B108_for_amusing_a_victoriou B109_after_amusing_a_victori B110_before_printing_the_pla B111_for_printing_the_player B112_after_printing_the_play B113_before_handling_the_fin B114_for_handling_the_final_ B115_after_handling_the_fina B116_before_printing_the_loc B117_for_printing_the_locale B118_after_printing_the_loca B119_before_choosing_notable B120_for_choosing_notable_lo B121_after_choosing_notable_ B122_before_printing_a_local B123_for_printing_a_locale_p B124_after_printing_a_locale B125_check_taking_inventory B126_carry_out_taking_invent B127_report_taking_inventory B128_check_taking B129_carry_out_taking B130_report_taking B131_check_removing_it_from B132_carry_out_removing_it_f B133_report_removing_it_from B134_check_dropping B135_carry_out_dropping B136_report_dropping B137_check_putting_it_on B138_carry_out_putting_it_on B139_report_putting_it_on B140_check_inserting_it_into B141_carry_out_inserting_it_ B142_report_inserting_it_int B143_check_eating B144_carry_out_eating B145_report_eating B146_check_going B147_carry_out_going B148_report_going B149_check_entering B150_carry_out_entering B151_report_entering B152_check_exiting B153_carry_out_exiting B154_report_exiting B155_check_getting_off B156_carry_out_getting_off B157_report_getting_off B158_check_looking B159_carry_out_looking B160_report_looking B161_check_examining B162_carry_out_examining B163_report_examining B164_check_looking_under B165_carry_out_looking_under B166_report_looking_under B167_check_searching B168_carry_out_searching B169_report_searching B170_check_consulting_it_abo B171_carry_out_consulting_it B172_report_consulting_it_ab B173_check_locking_it_with B174_carry_out_locking_it_wi B175_report_locking_it_with B176_check_unlocking_it_with B177_carry_out_unlocking_it_ B178_report_unlocking_it_wit B179_check_switching_on B180_carry_out_switching_on B181_report_switching_on B182_check_switching_off B183_carry_out_switching_off B184_report_switching_off B185_check_opening B186_carry_out_opening B187_report_opening B188_check_closing B189_carry_out_closing B190_report_closing B191_check_wearing B192_carry_out_wearing B193_report_wearing B194_check_taking_off B195_carry_out_taking_off B196_report_taking_off B197_check_giving_it_to B198_carry_out_giving_it_to B199_report_giving_it_to B200_check_showing_it_to B201_carry_out_showing_it_to B202_report_showing_it_to B203_check_waking B204_carry_out_waking B205_report_waking B206_check_throwing_it_at B207_carry_out_throwing_it_a B208_report_throwing_it_at B209_check_attacking B210_carry_out_attacking B211_report_attacking B212_check_kissing B213_carry_out_kissing B214_report_kissing B215_check_answering_it_that B216_carry_out_answering_it_ B217_report_answering_it_tha B218_check_telling_it_about B219_carry_out_telling_it_ab B220_report_telling_it_about B221_check_asking_it_about B222_carry_out_asking_it_abo B223_report_asking_it_about B224_check_asking_it_for B225_carry_out_asking_it_for B226_report_asking_it_for B227_check_waiting B228_carry_out_waiting B229_report_waiting B230_check_touching B231_carry_out_touching B232_report_touching B233_check_waving B234_carry_out_waving B235_report_waving B236_check_pulling B237_carry_out_pulling B238_report_pulling B239_check_pushing B240_carry_out_pushing B241_report_pushing B242_check_turning B243_carry_out_turning B244_report_turning B245_check_pushing_it_to B246_carry_out_pushing_it_to B247_report_pushing_it_to B248_check_squeezing B249_carry_out_squeezing B250_report_squeezing B251_check_saying_yes B252_carry_out_saying_yes B253_report_saying_yes B254_check_saying_no B255_carry_out_saying_no B256_report_saying_no B257_check_burning B258_carry_out_burning B259_report_burning B260_check_waking_up B261_carry_out_waking_up B262_report_waking_up B263_check_thinking B264_carry_out_thinking B265_report_thinking B266_check_smelling B267_carry_out_smelling B268_report_smelling B269_check_listening_to B270_carry_out_listening_to B271_report_listening_to B272_check_tasting B273_carry_out_tasting B274_report_tasting B275_check_cutting B276_carry_out_cutting B277_report_cutting B278_check_jumping B279_carry_out_jumping B280_report_jumping B281_check_tying_it_to B282_carry_out_tying_it_to B283_report_tying_it_to B284_check_drinking B285_carry_out_drinking B286_report_drinking B287_check_saying_sorry B288_carry_out_saying_sorry B289_report_saying_sorry B290_check_swearing_obscenel B291_carry_out_swearing_obsc B292_report_swearing_obscene B293_check_swearing_mildly B294_carry_out_swearing_mild B295_report_swearing_mildly B296_check_swinging B297_carry_out_swinging B298_report_swinging B299_check_rubbing B300_carry_out_rubbing B301_report_rubbing B302_check_setting_it_to B303_carry_out_setting_it_to B304_report_setting_it_to B305_check_waving_hands B306_carry_out_waving_hands B307_report_waving_hands B308_check_buying B309_carry_out_buying B310_report_buying B311_check_singing B312_carry_out_singing B313_report_singing B314_check_climbing B315_carry_out_climbing B316_report_climbing B317_check_sleeping B318_carry_out_sleeping B319_report_sleeping B320_check_quitting_the_game B321_carry_out_quitting_the_ B322_report_quitting_the_gam B323_check_saving_the_game B324_carry_out_saving_the_ga B325_report_saving_the_game B326_check_restoring_the_gam B327_carry_out_restoring_the B328_report_restoring_the_ga B329_check_restarting_the_ga B330_carry_out_restarting_th B331_report_restarting_the_g B332_check_verifying_the_sto B333_carry_out_verifying_the B334_report_verifying_the_st B335_check_switching_the_sto B336_carry_out_switching_the B337_report_switching_the_st B338_check_switching_the_sto B339_carry_out_switching_the B340_report_switching_the_st B341_check_requesting_the_st B342_carry_out_requesting_th B343_report_requesting_the_s B344_check_requesting_the_sc B345_carry_out_requesting_th B346_report_requesting_the_s B347_check_preferring_abbrev B348_carry_out_preferring_ab B349_report_preferring_abbre B350_check_preferring_unabbr B351_carry_out_preferring_un B352_report_preferring_unabb B353_check_preferring_someti B354_carry_out_preferring_so B355_report_preferring_somet B356_check_switching_score_n B357_carry_out_switching_sco B358_report_switching_score_ B359_check_switching_score_n B360_carry_out_switching_sco B361_report_switching_score_ B362_check_requesting_the_pr B363_carry_out_requesting_th B364_report_requesting_the_p B365_check_requesting_episte B366_carry_out_requesting_ep B367_report_requesting_epist B368_check_requesting_it_for B369_carry_out_requesting_it B370_report_requesting_it_fo B371_check_imploring_it_for B372_carry_out_imploring_it_ B373_report_imploring_it_for B374_check_quizzing_it_about B375_carry_out_quizzing_it_a B376_report_quizzing_it_abou B377_check_informing_it_abou B378_carry_out_informing_it_ B379_report_informing_it_abo B380_check_implicit_quizzing B381_carry_out_implicit_quiz B382_report_implicit_quizzin B383_check_implicit_informin B384_carry_out_implicit_info B385_report_implicit_informi B386_check_implicit_requesti B387_carry_out_implicit_requ B388_report_implicit_request B389_check_implicit_implorin B390_carry_out_implicit_impl B391_report_implicit_implori B392_check_saying_hello_to B393_carry_out_saying_hello_ B394_report_saying_hello_to B395_check_hailing B396_carry_out_hailing B397_report_hailing B398_check_leavetaking B399_carry_out_leavetaking B400_report_leavetaking B401_check_saying_goodbye_to B402_carry_out_saying_goodby B403_report_saying_goodbye_t B404_suggestion_list_constru B405_check_listing_suggested B406_carry_out_listing_sugge B407_report_listing_suggeste B408_check_standing B409_carry_out_standing B410_report_standing B411_check_retreating B412_carry_out_retreating B413_report_retreating B414_check_using B415_carry_out_using B416_report_using B417_before_deciding_whether B418_for_deciding_whether_to B419_after_deciding_whether_ B420_before_deciding_whether B421_for_deciding_whether_th B422_after_deciding_whether_ B423_check_brooding B424_carry_out_brooding B425_report_brooding B426_check_smoking B427_carry_out_smoking B428_report_smoking B429_check_tuning_it_to B430_carry_out_tuning_it_to B431_report_tuning_it_to B432_check_coarse_tuning B433_carry_out_coarse_tuning B434_report_coarse_tuning B435_check_trading B436_carry_out_trading B437_report_trading B438_when_sinister_voices_be B439_when_sinister_voices_en B440_when_rainstorm_begins B441_when_rainstorm_ends B442_when_pursuit_begins B443_when_pursuit_ends B444_when_rabbit_s_offer_beg B445_when_rabbit_s_offer_end B446_when_temptation_begins B447_when_temptation_ends B448_when_chase_begins B449_when_chase_ends B450_when_fight_begins B451_when_fight_ends B452_when_coyote_s_offer_beg B453_when_coyote_s_offer_end B454_when_sand_dancer_s_arri B455_when_sand_dancer_s_arri B456_when_sand_dancer_s_offe B457_when_sand_dancer_s_offe B458_when_fight_ends_in_cowa B459_when_fight_ends_in_brav 0;

Constant B0_procedural = EMPTY_RULEBOOK;
Array B1_startup --> INITIALISE_MEMORY_R VIRTUAL_MACHINE_STARTUP_R SEED_RANDOM_NUMBER_GENERATOR_R UPDATE_CHRONOLOGICAL_RECORDS_R POSITION_PLAYER_IN_MODEL_R R_8 R_9 R_10 R_11 R_12 NULL; ! 10 rule(s)
Array B2_turn_sequence --> PARSE_COMMAND_R GENERATE_ACTION_R R_14 R_13 TIMED_EVENTS_R ADVANCE_TIME_R UPDATE_CHRONOLOGICAL_RECORDS_R R_15 ADJUST_LIGHT_R NOTE_OBJECT_ACQUISITIONS_R R_16 NULL; ! 11 rule(s)
Array B3_shutdown --> R_17 RESURRECT_PLAYER_IF_ASKED_R R_18 ASK_FINAL_QUESTION_R NULL; ! 4 rule(s)
Array B4_scene_changing --> DetectSceneChange NULL; ! 1 rule(s)
Array B5_when_play_begins --> R_764 R_885 R_910 R_922 R_927 NULL; ! 5 rule(s)
Constant B6_when_play_ends = EMPTY_RULEBOOK;
Array B7_when_scene_begins --> R_57 NULL; ! 1 rule(s)
Constant B8_when_scene_ends = EMPTY_RULEBOOK;
Array B9_every_turn --> R_1112 R_1120 R_849 R_911 R_929 R_953 R_955 R_956 R_1090 R_1170 R_1161 R_1164 R_1199 R_774 R_917 R_825 NULL; ! 16 rule(s)
Array B10_action_processing --> R_20 R_19 R_21 BASIC_VISIBILITY_R BASIC_ACCESSIBILITY_R CARRYING_REQUIREMENTS_R R_22 REQUESTED_ACTIONS_REQUIRE_R CARRY_OUT_REQUESTED_ACTIONS_R DESCEND_TO_SPECIFIC_ACTION_R R_23 NULL; ! 11 rule(s)
Array B11_setting_action_variables --> R_137 R_171 R_159 R_1098 NULL; ! 4 rule(s)
Array B12_specific_action_processi --> WORK_OUT_DETAILS_OF_SPECIFIC_R R_24 R_25 R_26 R_27 R_28 R_29 R_30 NULL; ! 8 rule(s)
Array B13_player_s_action_awarenes --> R_31 R_32 R_33 R_34 NULL; ! 4 rule(s)
Array B14_accessibility --> ACCESS_THROUGH_BARRIERS_R NULL; ! 1 rule(s)
Array B15_reaching_inside --> R_1059 R_983 CANT_REACH_INSIDE_ROOMS_R CANT_REACH_INSIDE_CLOSED_R NULL; ! 4 rule(s)
Array B16_reaching_outside --> CANT_REACH_OUTSIDE_CLOSED_R NULL; ! 1 rule(s)
Array B17_visibility --> R_35 NULL; ! 1 rule(s)
Array B18_persuasion --> R_763 R_770 NULL; ! 2 rule(s)
Constant B19_unsuccessful_attempt_by = EMPTY_RULEBOOK;
Array B20_before --> (-2) ##SwitchOn R_1041 ##Go 2 R_998 R_1082 ##Take R_939 ##Enter R_990 ##Go R_1209 ##A90_hailing R_760 (-2) R_754 ##Go 3 R_872 R_1080 R_1085 ##Answer 3 R_778 R_779 R_780 ##Show R_881 ##A89_saying_hello_to R_1118 ##Eat R_878 ##Wear R_879 ##Yes R_775 ##No R_776 ##Sorry R_777 (-2) 4 R_748 R_753 R_747 R_1207 ##A89_saying_hello_to R_912 ##A98_smoking 2 R_971 R_972 ##Exit R_991 ##Go R_1131 ##A93_listing_suggested_topics R_855 NULL; ! 31 rule(s)
Array B21_instead --> (-2) ##Go 2 R_1064 R_1002 ##Examine R_1036 ##Go 2 R_1035 R_1124 ##A83_quizzing_it_about R_1217 ##ThrowAt 2 R_1174 R_1206 ##Push R_1069 ##Attack R_1055 ##Push R_1070 ##Take R_1052 ##Open R_982 ##Take 3 R_1032 R_1051 R_1053 ##Touch R_1058 ##LookUnder R_1078 ##SwitchOff R_1096 ##Examine R_1157 ##SwitchOn R_1180 ##Enter R_1000 (-2) R_1028 ##Go R_1133 ##Smell R_1122 ##Take 2 R_1030 R_1108 ##Drop R_1086 ##A98_smoking R_1183 ##Go 6 R_861 R_873 R_1063 R_1026 R_1027 R_1034 ##Unlock R_1054 ##Insert 3 R_1020 R_984 R_1033 ##Give R_1087 ##Consult 3 R_1004 R_1005 R_1006 ##ThrowAt 3 R_1019 R_1021 R_1022 ##Give R_1109 ##Insert R_964 ##Attack R_1056 ##Push R_1072 (-2) 8 R_1067 R_938 R_995 R_1073 R_1128 R_1149 R_1159 R_1167 ##A89_saying_hello_to R_857 ##Drop R_946 ##Burn 2 R_947 R_966 ##Take R_985 ##Attack R_987 ##Touch R_996 ##Take R_997 ##Enter R_1001 ##Take R_1003 ##Open R_1039 ##Enter R_1043 ##Take 2 R_1044 R_1049 ##Attack R_1057 ##Smell R_1074 ##LookUnder R_1077 ##Open R_1079 ##Kiss R_1089 ##Attack R_1117 ##Smell R_1123 ##Take R_1181 ##Drop R_1182 (-2) 12 R_950 R_992 R_1048 R_1050 R_1062 R_1068 R_1075 R_999 R_1007 R_1029 R_1088 R_1076 ##Attack R_1024 (-2) 2 R_1110 R_1084 ##Drop R_963 ##Attack R_1023 (-2) 4 R_1018 R_935 R_848 R_1198 ##Yes R_1145 ##No R_1146 ##Yes R_1185 ##No R_1186 ##Yes R_1222 ##No R_1223 ##Go 3 R_923 R_924 R_925 ##A97_brooding R_937 ##Jump R_1061 ##Go R_1171 ##A90_hailing R_1214 ##Listen R_1125 ##WaveHands R_1160 ##A97_brooding R_1168 ##Attack R_1173 ##A98_smoking 2 R_1184 R_1111 (-2) R_930 ##Go R_875 ##A85_implicit_quizzing R_749 ##A86_implicit_informing R_750 ##A87_implicit_requesting R_751 ##A88_implicit_imploring R_752 ##Yes R_846 ##No R_847 ##A90_hailing R_858 ##Wait R_931 ##Think R_936 NULL; ! 132 rule(s)
Constant B22_check = EMPTY_RULEBOOK;
Constant B23_carry_out = EMPTY_RULEBOOK;
Array B24_after --> (-2) ##A83_quizzing_it_about R_854 ##A84_informing_it_about R_853 ##Touch R_1037 ##Open R_1038 ##Take R_1040 ##Go R_1208 ##Take R_1220 ##A83_quizzing_it_about R_1091 ##A84_informing_it_about R_1092 ##A83_quizzing_it_about R_1093 ##A84_informing_it_about 2 R_1094 R_1095 ##A83_quizzing_it_about 3 R_1138 R_1139 R_1140 ##A84_informing_it_about R_1141 ##A83_quizzing_it_about 3 R_1142 R_1143 R_1144 ##A84_informing_it_about R_1147 ##A83_quizzing_it_about 3 R_1150 R_1151 R_1152 ##A84_informing_it_about R_1153 ##A83_quizzing_it_about 14 R_1156 R_1178 R_1189 R_1190 R_1191 R_1192 R_1193 R_1194 R_1196 R_1213 R_1215 R_1216 R_1218 R_1221 ##A84_informing_it_about R_1225 ##A83_quizzing_it_about 4 R_1226 R_1227 R_1228 R_1229 ##Open R_988 ##Close R_989 ##SwitchOn R_993 ##SwitchOff R_994 ##SwitchOn R_1017 ##Take R_1031 ##SwitchOn 2 R_1042 R_1046 ##SwitchOff R_1047 ##Wear R_1060 ##A93_listing_suggested_topics R_856 NULL; ! 54 rule(s)
Constant B25_report = EMPTY_RULEBOOK;
Array B26_does_the_player_mean --> R_36 R_926 NULL; ! 2 rule(s)
Constant B27_when_entire_game_begins = EMPTY_RULEBOOK;
Constant B28_when_entire_game_ends = EMPTY_RULEBOOK;
Array B29_before_printing_the_name --> R_959 R_960 R_961 R_58 NULL; ! 4 rule(s)
Array B30_for_printing_the_name --> R_957 R_958 STANDARD_NAME_PRINTING_R NULL; ! 3 rule(s)
Array B31_after_printing_the_name --> R_962 R_981 R_826 R_784 NULL; ! 4 rule(s)
Constant B32_before_printing_the_plur = EMPTY_RULEBOOK;
Array B33_for_printing_the_plural_ --> R_59 NULL; ! 1 rule(s)
Constant B34_after_printing_the_plura = EMPTY_RULEBOOK;
Constant B35_before_printing_a_number = EMPTY_RULEBOOK;
Array B36_for_printing_a_number --> R_60 NULL; ! 1 rule(s)
Constant B37_after_printing_a_number = EMPTY_RULEBOOK;
Constant B38_before_printing_room_des = EMPTY_RULEBOOK;
Constant B39_for_printing_room_descri = EMPTY_RULEBOOK;
Constant B40_after_printing_room_desc = EMPTY_RULEBOOK;
Array B41_before_listing_contents --> R_882 R_883 NULL; ! 2 rule(s)
Array B42_for_listing_contents --> STANDARD_CONTENTS_LISTING_R NULL; ! 1 rule(s)
Constant B43_after_listing_contents = EMPTY_RULEBOOK;
Array B44_before_grouping_together --> R_884 NULL; ! 1 rule(s)
Constant B45_for_grouping_together = EMPTY_RULEBOOK;
Constant B46_after_grouping_together = EMPTY_RULEBOOK;
Constant B47_before_writing_a_paragra = EMPTY_RULEBOOK;
Array B48_for_writing_a_paragraph_ --> R_1045 R_1066 NULL; ! 2 rule(s)
Constant B49_after_writing_a_paragrap = EMPTY_RULEBOOK;
Constant B50_before_listing_nondescri = EMPTY_RULEBOOK;
Constant B51_for_listing_nondescript_ = EMPTY_RULEBOOK;
Constant B52_after_listing_nondescrip = EMPTY_RULEBOOK;
Constant B53_before_printing_the_name = EMPTY_RULEBOOK;
Constant B54_for_printing_the_name_of = EMPTY_RULEBOOK;
Constant B55_after_printing_the_name_ = EMPTY_RULEBOOK;
Constant B56_before_printing_the_desc = EMPTY_RULEBOOK;
Constant B57_for_printing_the_descrip = EMPTY_RULEBOOK;
Constant B58_after_printing_the_descr = EMPTY_RULEBOOK;
Constant B59_before_printing_the_anno = EMPTY_RULEBOOK;
Constant B60_for_printing_the_announc = EMPTY_RULEBOOK;
Constant B61_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B62_before_printing_the_anno = EMPTY_RULEBOOK;
Array B63_for_printing_the_announc --> R_61 NULL; ! 1 rule(s)
Constant B64_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B65_before_printing_a_refusa = EMPTY_RULEBOOK;
Constant B66_for_printing_a_refusal_t = EMPTY_RULEBOOK;
Constant B67_after_printing_a_refusal = EMPTY_RULEBOOK;
Constant B68_before_constructing_the_ = EMPTY_RULEBOOK;
Constant B69_for_constructing_the_sta = EMPTY_RULEBOOK;
Constant B70_after_constructing_the_s = EMPTY_RULEBOOK;
Constant B71_before_printing_the_bann = EMPTY_RULEBOOK;
Array B72_for_printing_the_banner_ --> R_920 NULL; ! 1 rule(s)
Array B73_after_printing_the_banne --> R_921 NULL; ! 1 rule(s)
Constant B74_before_reading_a_command = EMPTY_RULEBOOK;
Constant B75_for_reading_a_command = EMPTY_RULEBOOK;
Array B76_after_reading_a_command --> R_916 NULL; ! 1 rule(s)
Constant B77_before_deciding_the_scop = EMPTY_RULEBOOK;
Constant B78_for_deciding_the_scope = EMPTY_RULEBOOK;
Array B79_after_deciding_the_scope --> R_877 NULL; ! 1 rule(s)
Constant B80_before_deciding_the_conc = EMPTY_RULEBOOK;
Constant B81_for_deciding_the_conceal = EMPTY_RULEBOOK;
Constant B82_after_deciding_the_conce = EMPTY_RULEBOOK;
Constant B83_before_deciding_whether_ = EMPTY_RULEBOOK;
Array B84_for_deciding_whether_all --> R_62 R_64 R_63 NULL; ! 3 rule(s)
Constant B85_after_deciding_whether_a = EMPTY_RULEBOOK;
Constant B86_before_clarifying_the_pa = EMPTY_RULEBOOK;
Constant B87_for_clarifying_the_parse = EMPTY_RULEBOOK;
Constant B88_after_clarifying_the_par = EMPTY_RULEBOOK;
Constant B89_before_asking_which_do_y = EMPTY_RULEBOOK;
Constant B90_for_asking_which_do_you_ = EMPTY_RULEBOOK;
Constant B91_after_asking_which_do_yo = EMPTY_RULEBOOK;
Constant B92_before_printing_a_parser = EMPTY_RULEBOOK;
Constant B93_for_printing_a_parser_er = EMPTY_RULEBOOK;
Constant B94_after_printing_a_parser_ = EMPTY_RULEBOOK;
Constant B95_before_supplying_a_missi = EMPTY_RULEBOOK;
Array B96_for_supplying_a_missing_ --> R_65 R_66 R_67 R_965 R_148 NULL; ! 5 rule(s)
Constant B97_after_supplying_a_missin = EMPTY_RULEBOOK;
Constant B98_before_supplying_a_missi = EMPTY_RULEBOOK;
Constant B99_for_supplying_a_missing_ = EMPTY_RULEBOOK;
Constant B100_after_supplying_a_missi = EMPTY_RULEBOOK;
Constant B101_before_implicitly_takin = EMPTY_RULEBOOK;
Constant B102_for_implicitly_taking = EMPTY_RULEBOOK;
Constant B103_after_implicitly_taking = EMPTY_RULEBOOK;
Constant B104_before_starting_the_vir = EMPTY_RULEBOOK;
Array B105_for_starting_the_virtua --> ENABLE_GLULX_ACCEL_R NULL; ! 1 rule(s)
Constant B106_after_starting_the_virt = EMPTY_RULEBOOK;
Constant B107_before_amusing_a_victor = EMPTY_RULEBOOK;
Constant B108_for_amusing_a_victoriou = EMPTY_RULEBOOK;
Constant B109_after_amusing_a_victori = EMPTY_RULEBOOK;
Constant B110_before_printing_the_pla = EMPTY_RULEBOOK;
Array B111_for_printing_the_player --> PRINT_OBITUARY_HEADLINE_R PRINT_FINAL_SCORE_R DISPLAY_FINAL_STATUS_LINE_R NULL; ! 3 rule(s)
Constant B112_after_printing_the_play = EMPTY_RULEBOOK;
Array B113_before_handling_the_fin --> R_69 R_68 READ_FINAL_ANSWER_R NULL; ! 3 rule(s)
Array B114_for_handling_the_final_ --> R_70 NULL; ! 1 rule(s)
Constant B115_after_handling_the_fina = EMPTY_RULEBOOK;
Array B116_before_printing_the_loc --> R_73 R_74 NULL; ! 2 rule(s)
Array B117_for_printing_the_locale --> R_75 R_76 NULL; ! 2 rule(s)
Constant B118_after_printing_the_loca = EMPTY_RULEBOOK;
Constant B119_before_choosing_notable = EMPTY_RULEBOOK;
Array B120_for_choosing_notable_lo --> R_77 NULL; ! 1 rule(s)
Constant B121_after_choosing_notable_ = EMPTY_RULEBOOK;
Constant B122_before_printing_a_local = EMPTY_RULEBOOK;
Array B123_for_printing_a_locale_p --> R_78 R_79 R_80 R_81 R_82 R_83 R_85 NULL; ! 7 rule(s)
Constant B124_after_printing_a_locale = EMPTY_RULEBOOK;
Constant B125_check_taking_inventory = EMPTY_RULEBOOK;
Array B126_carry_out_taking_invent --> R_86 R_87 NULL; ! 2 rule(s)
Array B127_report_taking_inventory --> R_88 NULL; ! 1 rule(s)
Array B128_check_taking --> R_89 R_90 R_91 R_92 R_93 R_95 R_96 R_97 R_98 R_99 R_100 R_860 NULL; ! 12 rule(s)
Array B129_carry_out_taking --> R_101 NULL; ! 1 rule(s)
Array B130_report_taking --> R_102 NULL; ! 1 rule(s)
Array B131_check_removing_it_from --> R_91 R_103 R_104 R_105 NULL; ! 4 rule(s)
Constant B132_carry_out_removing_it_f = EMPTY_RULEBOOK;
Constant B133_report_removing_it_from = EMPTY_RULEBOOK;
Array B134_check_dropping --> R_106 R_107 R_108 R_109 R_110 NULL; ! 5 rule(s)
Array B135_carry_out_dropping --> R_111 NULL; ! 1 rule(s)
Array B136_report_dropping --> R_112 NULL; ! 1 rule(s)
Array B137_check_putting_it_on --> R_113 R_114 R_115 R_116 R_117 R_118 R_119 NULL; ! 7 rule(s)
Array B138_carry_out_putting_it_on --> R_120 NULL; ! 1 rule(s)
Array B139_report_putting_it_on --> R_121 R_122 NULL; ! 2 rule(s)
Array B140_check_inserting_it_into --> R_123 R_124 R_125 R_126 R_127 R_128 R_129 NULL; ! 7 rule(s)
Array B141_carry_out_inserting_it_ --> R_130 NULL; ! 1 rule(s)
Array B142_report_inserting_it_int --> R_131 R_132 NULL; ! 2 rule(s)
Array B143_check_eating --> R_133 R_134 NULL; ! 2 rule(s)
Array B144_carry_out_eating --> R_135 NULL; ! 1 rule(s)
Array B145_report_eating --> R_136 NULL; ! 1 rule(s)
Array B146_check_going --> R_862 R_138 R_139 R_141 R_142 R_143 NULL; ! 6 rule(s)
Array B147_carry_out_going --> R_773 R_870 R_1132 R_1163 R_144 R_145 R_146 NULL; ! 7 rule(s)
Array B148_report_going --> R_1065 R_1071 R_1126 R_1083 R_1025 R_1200 R_147 NULL; ! 7 rule(s)
Array B149_check_entering --> R_149 R_150 R_151 R_152 R_153 R_154 R_155 NULL; ! 7 rule(s)
Array B150_carry_out_entering --> R_156 NULL; ! 1 rule(s)
Array B151_report_entering --> R_157 R_158 NULL; ! 2 rule(s)
Array B152_check_exiting --> R_869 R_161 R_162 R_163 NULL; ! 4 rule(s)
Array B153_carry_out_exiting --> R_164 NULL; ! 1 rule(s)
Array B154_report_exiting --> R_165 R_867 NULL; ! 2 rule(s)
Array B155_check_getting_off --> R_859 NULL; ! 1 rule(s)
Array B156_carry_out_getting_off --> R_168 NULL; ! 1 rule(s)
Array B157_report_getting_off --> R_169 R_868 NULL; ! 2 rule(s)
Constant B158_check_looking = EMPTY_RULEBOOK;
Array B159_carry_out_looking --> R_172 R_1201 R_174 R_175 R_739 R_1203 NULL; ! 6 rule(s)
Array B160_report_looking --> R_176 NULL; ! 1 rule(s)
Constant B161_check_examining = EMPTY_RULEBOOK;
Array B162_carry_out_examining --> R_741 R_177 R_178 R_179 R_180 R_181 R_182 NULL; ! 7 rule(s)
Array B163_report_examining --> R_183 NULL; ! 1 rule(s)
Constant B164_check_looking_under = EMPTY_RULEBOOK;
Array B165_carry_out_looking_under --> R_184 NULL; ! 1 rule(s)
Array B166_report_looking_under --> R_185 NULL; ! 1 rule(s)
Array B167_check_searching --> R_186 R_187 NULL; ! 2 rule(s)
Constant B168_carry_out_searching = EMPTY_RULEBOOK;
Array B169_report_searching --> R_188 R_189 R_190 NULL; ! 3 rule(s)
Constant B170_check_consulting_it_abo = EMPTY_RULEBOOK;
Constant B171_carry_out_consulting_it = EMPTY_RULEBOOK;
Array B172_report_consulting_it_ab --> R_191 NULL; ! 1 rule(s)
Array B173_check_locking_it_with --> R_192 R_193 R_194 R_195 NULL; ! 4 rule(s)
Array B174_carry_out_locking_it_wi --> R_196 NULL; ! 1 rule(s)
Array B175_report_locking_it_with --> R_197 NULL; ! 1 rule(s)
Array B176_check_unlocking_it_with --> R_198 R_199 R_200 NULL; ! 3 rule(s)
Array B177_carry_out_unlocking_it_ --> R_201 NULL; ! 1 rule(s)
Array B178_report_unlocking_it_wit --> R_202 NULL; ! 1 rule(s)
Array B179_check_switching_on --> R_1016 R_203 R_204 NULL; ! 3 rule(s)
Array B180_carry_out_switching_on --> R_944 R_205 NULL; ! 2 rule(s)
Array B181_report_switching_on --> R_206 NULL; ! 1 rule(s)
Array B182_check_switching_off --> R_207 R_208 NULL; ! 2 rule(s)
Array B183_carry_out_switching_off --> R_945 R_209 NULL; ! 2 rule(s)
Array B184_report_switching_off --> R_210 NULL; ! 1 rule(s)
Array B185_check_opening --> R_211 R_212 R_213 NULL; ! 3 rule(s)
Array B186_carry_out_opening --> R_214 R_740 NULL; ! 2 rule(s)
Array B187_report_opening --> R_215 R_216 NULL; ! 2 rule(s)
Array B188_check_closing --> R_217 R_218 NULL; ! 2 rule(s)
Array B189_carry_out_closing --> R_219 NULL; ! 1 rule(s)
Array B190_report_closing --> R_220 NULL; ! 1 rule(s)
Array B191_check_wearing --> R_221 R_222 R_223 NULL; ! 3 rule(s)
Array B192_carry_out_wearing --> R_224 NULL; ! 1 rule(s)
Array B193_report_wearing --> R_225 NULL; ! 1 rule(s)
Array B194_check_taking_off --> R_226 NULL; ! 1 rule(s)
Array B195_carry_out_taking_off --> R_227 NULL; ! 1 rule(s)
Array B196_report_taking_off --> R_228 NULL; ! 1 rule(s)
Array B197_check_giving_it_to --> R_229 R_230 R_231 R_232 R_233 NULL; ! 5 rule(s)
Array B198_carry_out_giving_it_to --> R_234 NULL; ! 1 rule(s)
Array B199_report_giving_it_to --> R_235 NULL; ! 1 rule(s)
Array B200_check_showing_it_to --> R_236 R_237 R_238 NULL; ! 3 rule(s)
Constant B201_carry_out_showing_it_to = EMPTY_RULEBOOK;
Constant B202_report_showing_it_to = EMPTY_RULEBOOK;
Array B203_check_waking --> R_239 NULL; ! 1 rule(s)
Constant B204_carry_out_waking = EMPTY_RULEBOOK;
Constant B205_report_waking = EMPTY_RULEBOOK;
Array B206_check_throwing_it_at --> R_240 R_241 R_242 NULL; ! 3 rule(s)
Constant B207_carry_out_throwing_it_a = EMPTY_RULEBOOK;
Constant B208_report_throwing_it_at = EMPTY_RULEBOOK;
Array B209_check_attacking --> R_243 NULL; ! 1 rule(s)
Constant B210_carry_out_attacking = EMPTY_RULEBOOK;
Constant B211_report_attacking = EMPTY_RULEBOOK;
Array B212_check_kissing --> R_244 R_245 NULL; ! 2 rule(s)
Constant B213_carry_out_kissing = EMPTY_RULEBOOK;
Constant B214_report_kissing = EMPTY_RULEBOOK;
Constant B215_check_answering_it_that = EMPTY_RULEBOOK;
Constant B216_carry_out_answering_it_ = EMPTY_RULEBOOK;
Array B217_report_answering_it_tha --> R_246 NULL; ! 1 rule(s)
Array B218_check_telling_it_about --> R_247 NULL; ! 1 rule(s)
Constant B219_carry_out_telling_it_ab = EMPTY_RULEBOOK;
Array B220_report_telling_it_about --> R_248 NULL; ! 1 rule(s)
Constant B221_check_asking_it_about = EMPTY_RULEBOOK;
Constant B222_carry_out_asking_it_abo = EMPTY_RULEBOOK;
Array B223_report_asking_it_about --> R_249 NULL; ! 1 rule(s)
Array B224_check_asking_it_for --> R_250 R_251 NULL; ! 2 rule(s)
Constant B225_carry_out_asking_it_for = EMPTY_RULEBOOK;
Constant B226_report_asking_it_for = EMPTY_RULEBOOK;
Constant B227_check_waiting = EMPTY_RULEBOOK;
Constant B228_carry_out_waiting = EMPTY_RULEBOOK;
Array B229_report_waiting --> R_252 NULL; ! 1 rule(s)
Constant B230_check_touching = EMPTY_RULEBOOK;
Constant B231_carry_out_touching = EMPTY_RULEBOOK;
Array B232_report_touching --> R_253 R_254 R_255 NULL; ! 3 rule(s)
Array B233_check_waving --> R_256 NULL; ! 1 rule(s)
Constant B234_carry_out_waving = EMPTY_RULEBOOK;
Array B235_report_waving --> R_257 NULL; ! 1 rule(s)
Array B236_check_pulling --> R_258 R_259 R_260 NULL; ! 3 rule(s)
Constant B237_carry_out_pulling = EMPTY_RULEBOOK;
Array B238_report_pulling --> R_261 NULL; ! 1 rule(s)
Array B239_check_pushing --> R_262 R_263 R_264 NULL; ! 3 rule(s)
Constant B240_carry_out_pushing = EMPTY_RULEBOOK;
Array B241_report_pushing --> R_265 NULL; ! 1 rule(s)
Array B242_check_turning --> R_266 R_267 R_268 NULL; ! 3 rule(s)
Constant B243_carry_out_turning = EMPTY_RULEBOOK;
Array B244_report_turning --> R_269 NULL; ! 1 rule(s)
Array B245_check_pushing_it_to --> R_270 R_271 R_272 R_273 R_274 NULL; ! 5 rule(s)
Constant B246_carry_out_pushing_it_to = EMPTY_RULEBOOK;
Constant B247_report_pushing_it_to = EMPTY_RULEBOOK;
Array B248_check_squeezing --> R_275 NULL; ! 1 rule(s)
Constant B249_carry_out_squeezing = EMPTY_RULEBOOK;
Array B250_report_squeezing --> R_276 NULL; ! 1 rule(s)
Array B251_check_saying_yes --> R_277 NULL; ! 1 rule(s)
Constant B252_carry_out_saying_yes = EMPTY_RULEBOOK;
Constant B253_report_saying_yes = EMPTY_RULEBOOK;
Array B254_check_saying_no --> R_278 NULL; ! 1 rule(s)
Constant B255_carry_out_saying_no = EMPTY_RULEBOOK;
Constant B256_report_saying_no = EMPTY_RULEBOOK;
Array B257_check_burning --> R_279 NULL; ! 1 rule(s)
Constant B258_carry_out_burning = EMPTY_RULEBOOK;
Constant B259_report_burning = EMPTY_RULEBOOK;
Array B260_check_waking_up --> R_280 NULL; ! 1 rule(s)
Constant B261_carry_out_waking_up = EMPTY_RULEBOOK;
Constant B262_report_waking_up = EMPTY_RULEBOOK;
Array B263_check_thinking --> R_281 NULL; ! 1 rule(s)
Constant B264_carry_out_thinking = EMPTY_RULEBOOK;
Constant B265_report_thinking = EMPTY_RULEBOOK;
Array B266_check_smelling --> R_282 NULL; ! 1 rule(s)
Constant B267_carry_out_smelling = EMPTY_RULEBOOK;
Constant B268_report_smelling = EMPTY_RULEBOOK;
Array B269_check_listening_to --> R_283 NULL; ! 1 rule(s)
Constant B270_carry_out_listening_to = EMPTY_RULEBOOK;
Constant B271_report_listening_to = EMPTY_RULEBOOK;
Array B272_check_tasting --> R_284 NULL; ! 1 rule(s)
Constant B273_carry_out_tasting = EMPTY_RULEBOOK;
Constant B274_report_tasting = EMPTY_RULEBOOK;
Array B275_check_cutting --> R_285 NULL; ! 1 rule(s)
Constant B276_carry_out_cutting = EMPTY_RULEBOOK;
Constant B277_report_cutting = EMPTY_RULEBOOK;
Array B278_check_jumping --> R_286 NULL; ! 1 rule(s)
Constant B279_carry_out_jumping = EMPTY_RULEBOOK;
Constant B280_report_jumping = EMPTY_RULEBOOK;
Array B281_check_tying_it_to --> R_287 NULL; ! 1 rule(s)
Constant B282_carry_out_tying_it_to = EMPTY_RULEBOOK;
Constant B283_report_tying_it_to = EMPTY_RULEBOOK;
Array B284_check_drinking --> R_288 NULL; ! 1 rule(s)
Constant B285_carry_out_drinking = EMPTY_RULEBOOK;
Constant B286_report_drinking = EMPTY_RULEBOOK;
Array B287_check_saying_sorry --> R_289 NULL; ! 1 rule(s)
Constant B288_carry_out_saying_sorry = EMPTY_RULEBOOK;
Constant B289_report_saying_sorry = EMPTY_RULEBOOK;
Array B290_check_swearing_obscenel --> R_290 NULL; ! 1 rule(s)
Constant B291_carry_out_swearing_obsc = EMPTY_RULEBOOK;
Constant B292_report_swearing_obscene = EMPTY_RULEBOOK;
Array B293_check_swearing_mildly --> R_291 NULL; ! 1 rule(s)
Constant B294_carry_out_swearing_mild = EMPTY_RULEBOOK;
Constant B295_report_swearing_mildly = EMPTY_RULEBOOK;
Array B296_check_swinging --> R_292 NULL; ! 1 rule(s)
Constant B297_carry_out_swinging = EMPTY_RULEBOOK;
Constant B298_report_swinging = EMPTY_RULEBOOK;
Array B299_check_rubbing --> R_293 NULL; ! 1 rule(s)
Constant B300_carry_out_rubbing = EMPTY_RULEBOOK;
Constant B301_report_rubbing = EMPTY_RULEBOOK;
Array B302_check_setting_it_to --> R_294 NULL; ! 1 rule(s)
Constant B303_carry_out_setting_it_to = EMPTY_RULEBOOK;
Constant B304_report_setting_it_to = EMPTY_RULEBOOK;
Array B305_check_waving_hands --> R_295 NULL; ! 1 rule(s)
Constant B306_carry_out_waving_hands = EMPTY_RULEBOOK;
Constant B307_report_waving_hands = EMPTY_RULEBOOK;
Array B308_check_buying --> R_296 NULL; ! 1 rule(s)
Constant B309_carry_out_buying = EMPTY_RULEBOOK;
Constant B310_report_buying = EMPTY_RULEBOOK;
Array B311_check_singing --> R_297 NULL; ! 1 rule(s)
Constant B312_carry_out_singing = EMPTY_RULEBOOK;
Constant B313_report_singing = EMPTY_RULEBOOK;
Array B314_check_climbing --> R_298 NULL; ! 1 rule(s)
Constant B315_carry_out_climbing = EMPTY_RULEBOOK;
Constant B316_report_climbing = EMPTY_RULEBOOK;
Array B317_check_sleeping --> R_299 NULL; ! 1 rule(s)
Constant B318_carry_out_sleeping = EMPTY_RULEBOOK;
Constant B319_report_sleeping = EMPTY_RULEBOOK;
Constant B320_check_quitting_the_game = EMPTY_RULEBOOK;
Array B321_carry_out_quitting_the_ --> QUIT_THE_GAME_R NULL; ! 1 rule(s)
Constant B322_report_quitting_the_gam = EMPTY_RULEBOOK;
Constant B323_check_saving_the_game = EMPTY_RULEBOOK;
Array B324_carry_out_saving_the_ga --> SAVE_THE_GAME_R NULL; ! 1 rule(s)
Constant B325_report_saving_the_game = EMPTY_RULEBOOK;
Constant B326_check_restoring_the_gam = EMPTY_RULEBOOK;
Array B327_carry_out_restoring_the --> RESTORE_THE_GAME_R NULL; ! 1 rule(s)
Constant B328_report_restoring_the_ga = EMPTY_RULEBOOK;
Constant B329_check_restarting_the_ga = EMPTY_RULEBOOK;
Array B330_carry_out_restarting_th --> RESTART_THE_GAME_R NULL; ! 1 rule(s)
Constant B331_report_restarting_the_g = EMPTY_RULEBOOK;
Constant B332_check_verifying_the_sto = EMPTY_RULEBOOK;
Array B333_carry_out_verifying_the --> VERIFY_THE_STORY_FILE_R NULL; ! 1 rule(s)
Constant B334_report_verifying_the_st = EMPTY_RULEBOOK;
Constant B335_check_switching_the_sto = EMPTY_RULEBOOK;
Array B336_carry_out_switching_the --> SWITCH_TRANSCRIPT_ON_R NULL; ! 1 rule(s)
Constant B337_report_switching_the_st = EMPTY_RULEBOOK;
Constant B338_check_switching_the_sto = EMPTY_RULEBOOK;
Array B339_carry_out_switching_the --> SWITCH_TRANSCRIPT_OFF_R NULL; ! 1 rule(s)
Constant B340_report_switching_the_st = EMPTY_RULEBOOK;
Constant B341_check_requesting_the_st = EMPTY_RULEBOOK;
Array B342_carry_out_requesting_th --> ANNOUNCE_STORY_FILE_VERSION_R NULL; ! 1 rule(s)
Constant B343_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B344_check_requesting_the_sc = EMPTY_RULEBOOK;
Array B345_carry_out_requesting_th --> ANNOUNCE_SCORE_R NULL; ! 1 rule(s)
Constant B346_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B347_check_preferring_abbrev = EMPTY_RULEBOOK;
Array B348_carry_out_preferring_ab --> PREFER_ABBREVIATED_R NULL; ! 1 rule(s)
Array B349_report_preferring_abbre --> REP_PREFER_ABBREVIATED_R NULL; ! 1 rule(s)
Constant B350_check_preferring_unabbr = EMPTY_RULEBOOK;
Array B351_carry_out_preferring_un --> PREFER_UNABBREVIATED_R NULL; ! 1 rule(s)
Array B352_report_preferring_unabb --> REP_PREFER_UNABBREVIATED_R NULL; ! 1 rule(s)
Constant B353_check_preferring_someti = EMPTY_RULEBOOK;
Array B354_carry_out_preferring_so --> PREFER_SOMETIMES_ABBREVIATED_R NULL; ! 1 rule(s)
Array B355_report_preferring_somet --> REP_PREFER_SOMETIMES_ABBR_R NULL; ! 1 rule(s)
Constant B356_check_switching_score_n = EMPTY_RULEBOOK;
Array B357_carry_out_switching_sco --> SWITCH_SCORE_NOTIFY_ON_R NULL; ! 1 rule(s)
Array B358_report_switching_score_ --> REP_SWITCH_NOTIFY_ON_R NULL; ! 1 rule(s)
Constant B359_check_switching_score_n = EMPTY_RULEBOOK;
Array B360_carry_out_switching_sco --> SWITCH_SCORE_NOTIFY_OFF_R NULL; ! 1 rule(s)
Array B361_report_switching_score_ --> REP_SWITCH_NOTIFY_OFF_R NULL; ! 1 rule(s)
Constant B362_check_requesting_the_pr = EMPTY_RULEBOOK;
Array B363_carry_out_requesting_th --> ANNOUNCE_PRONOUN_MEANINGS_R NULL; ! 1 rule(s)
Constant B364_report_requesting_the_p = EMPTY_RULEBOOK;
Constant B365_check_requesting_episte = EMPTY_RULEBOOK;
Constant B366_carry_out_requesting_ep = EMPTY_RULEBOOK;
Array B367_report_requesting_epist --> R_744 NULL; ! 1 rule(s)
Constant B368_check_requesting_it_for = EMPTY_RULEBOOK;
Constant B369_carry_out_requesting_it = EMPTY_RULEBOOK;
Constant B370_report_requesting_it_fo = EMPTY_RULEBOOK;
Constant B371_check_imploring_it_for = EMPTY_RULEBOOK;
Constant B372_carry_out_imploring_it_ = EMPTY_RULEBOOK;
Constant B373_report_imploring_it_for = EMPTY_RULEBOOK;
Array B374_check_quizzing_it_about --> R_781 NULL; ! 1 rule(s)
Constant B375_carry_out_quizzing_it_a = EMPTY_RULEBOOK;
Array B376_report_quizzing_it_abou --> R_746 NULL; ! 1 rule(s)
Array B377_check_informing_it_abou --> R_782 NULL; ! 1 rule(s)
Constant B378_carry_out_informing_it_ = EMPTY_RULEBOOK;
Array B379_report_informing_it_abo --> R_745 NULL; ! 1 rule(s)
Constant B380_check_implicit_quizzing = EMPTY_RULEBOOK;
Constant B381_carry_out_implicit_quiz = EMPTY_RULEBOOK;
Constant B382_report_implicit_quizzin = EMPTY_RULEBOOK;
Constant B383_check_implicit_informin = EMPTY_RULEBOOK;
Constant B384_carry_out_implicit_info = EMPTY_RULEBOOK;
Constant B385_report_implicit_informi = EMPTY_RULEBOOK;
Constant B386_check_implicit_requesti = EMPTY_RULEBOOK;
Constant B387_carry_out_implicit_requ = EMPTY_RULEBOOK;
Constant B388_report_implicit_request = EMPTY_RULEBOOK;
Constant B389_check_implicit_implorin = EMPTY_RULEBOOK;
Constant B390_carry_out_implicit_impl = EMPTY_RULEBOOK;
Constant B391_report_implicit_implori = EMPTY_RULEBOOK;
Array B392_check_saying_hello_to --> R_756 NULL; ! 1 rule(s)
Array B393_carry_out_saying_hello_ --> R_843 R_757 R_851 NULL; ! 3 rule(s)
Array B394_report_saying_hello_to --> R_759 R_758 NULL; ! 2 rule(s)
Array B395_check_hailing --> R_761 NULL; ! 1 rule(s)
Array B396_carry_out_hailing --> R_762 NULL; ! 1 rule(s)
Constant B397_report_hailing = EMPTY_RULEBOOK;
Array B398_check_leavetaking --> R_768 NULL; ! 1 rule(s)
Array B399_carry_out_leavetaking --> R_771 R_769 NULL; ! 2 rule(s)
Constant B400_report_leavetaking = EMPTY_RULEBOOK;
Array B401_check_saying_goodbye_to --> R_766 NULL; ! 1 rule(s)
Array B402_carry_out_saying_goodby --> R_852 R_767 NULL; ! 2 rule(s)
Array B403_report_saying_goodbye_t --> R_772 NULL; ! 1 rule(s)
Array B404_suggestion_list_constru --> R_837 R_838 R_839 NULL; ! 3 rule(s)
Array B405_check_listing_suggested --> R_840 NULL; ! 1 rule(s)
Array B406_carry_out_listing_sugge --> R_842 NULL; ! 1 rule(s)
Constant B407_report_listing_suggeste = EMPTY_RULEBOOK;
Array B408_check_standing --> R_865 NULL; ! 1 rule(s)
Array B409_carry_out_standing --> R_866 NULL; ! 1 rule(s)
Constant B410_report_standing = EMPTY_RULEBOOK;
Constant B411_check_retreating = EMPTY_RULEBOOK;
Array B412_carry_out_retreating --> R_871 NULL; ! 1 rule(s)
Constant B413_report_retreating = EMPTY_RULEBOOK;
Constant B414_check_using = EMPTY_RULEBOOK;
Array B415_carry_out_using --> R_880 NULL; ! 1 rule(s)
Constant B416_report_using = EMPTY_RULEBOOK;
Constant B417_before_deciding_whether = EMPTY_RULEBOOK;
Array B418_for_deciding_whether_to --> R_919 NULL; ! 1 rule(s)
Constant B419_after_deciding_whether_ = EMPTY_RULEBOOK;
Constant B420_before_deciding_whether = EMPTY_RULEBOOK;
Constant B421_for_deciding_whether_th = EMPTY_RULEBOOK;
Constant B422_after_deciding_whether_ = EMPTY_RULEBOOK;
Array B423_check_brooding --> R_933 NULL; ! 1 rule(s)
Array B424_carry_out_brooding --> R_934 NULL; ! 1 rule(s)
Constant B425_report_brooding = EMPTY_RULEBOOK;
Array B426_check_smoking --> R_967 R_969 R_970 NULL; ! 3 rule(s)
Array B427_carry_out_smoking --> R_918 R_968 NULL; ! 2 rule(s)
Array B428_report_smoking --> R_973 R_974 R_975 R_976 R_977 R_978 R_979 NULL; ! 7 rule(s)
Array B429_check_tuning_it_to --> R_1009 R_1010 R_1011 R_1012 R_1013 NULL; ! 5 rule(s)
Array B430_carry_out_tuning_it_to --> R_1014 NULL; ! 1 rule(s)
Array B431_report_tuning_it_to --> R_1015 NULL; ! 1 rule(s)
Constant B432_check_coarse_tuning = EMPTY_RULEBOOK;
Array B433_carry_out_coarse_tuning --> R_1008 NULL; ! 1 rule(s)
Constant B434_report_coarse_tuning = EMPTY_RULEBOOK;
Array B435_check_trading --> R_1231 R_1099 R_1100 R_1101 R_1102 R_1103 R_1104 R_1154 NULL; ! 8 rule(s)
Array B436_carry_out_trading --> R_1106 NULL; ! 1 rule(s)
Array B437_report_trading --> R_1107 R_1155 R_1195 R_1232 NULL; ! 4 rule(s)
Constant B438_when_sinister_voices_be = EMPTY_RULEBOOK;
Constant B439_when_sinister_voices_en = EMPTY_RULEBOOK;
Array B440_when_rainstorm_begins --> R_1119 NULL; ! 1 rule(s)
Array B441_when_rainstorm_ends --> R_1121 NULL; ! 1 rule(s)
Array B442_when_pursuit_begins --> R_1129 NULL; ! 1 rule(s)
Array B443_when_pursuit_ends --> R_1134 NULL; ! 1 rule(s)
Array B444_when_rabbit_s_offer_beg --> R_1136 NULL; ! 1 rule(s)
Constant B445_when_rabbit_s_offer_end = EMPTY_RULEBOOK;
Array B446_when_temptation_begins --> R_1158 NULL; ! 1 rule(s)
Array B447_when_temptation_ends --> R_1162 NULL; ! 1 rule(s)
Array B448_when_chase_begins --> R_1165 NULL; ! 1 rule(s)
Array B449_when_chase_ends --> R_1166 NULL; ! 1 rule(s)
Array B450_when_fight_begins --> R_1169 NULL; ! 1 rule(s)
Array B451_when_fight_ends --> R_1175 NULL; ! 1 rule(s)
Array B452_when_coyote_s_offer_beg --> R_1176 R_1179 NULL; ! 2 rule(s)
Constant B453_when_coyote_s_offer_end = EMPTY_RULEBOOK;
Constant B454_when_sand_dancer_s_arri = EMPTY_RULEBOOK;
Constant B455_when_sand_dancer_s_arri = EMPTY_RULEBOOK;
Array B456_when_sand_dancer_s_offe --> R_1210 NULL; ! 1 rule(s)
Constant B457_when_sand_dancer_s_offe = EMPTY_RULEBOOK;
Array B458_when_fight_ends_in_cowa --> R_1172 NULL; ! 1 rule(s)
Constant B459_when_fight_ends_in_brav = EMPTY_RULEBOOK;

Constant BR_0 = R_8;
Constant BR_1 = R_9;
Constant BR_2 = R_10;
Constant BR_3 = R_11;
Constant BR_4 = R_12;
Constant BR_5 = R_13;
Constant BR_6 = R_16;
Constant BR_7 = R_17;
Constant BR_8 = R_18;
Constant BR_9 = R_19;
Constant BR_10 = R_20;
Constant BR_11 = R_21;
Constant BR_12 = R_22;
Constant BR_13 = R_23;
Constant BR_14 = R_24;
Constant BR_15 = R_25;
Constant BR_16 = R_26;
Constant BR_17 = R_27;
Constant BR_18 = R_28;
Constant BR_19 = R_29;
Constant BR_20 = R_31;
Constant BR_21 = R_32;
Constant BR_22 = R_33;
Constant BR_23 = R_34;
Constant BR_24 = R_35;
Constant BR_25 = R_36;
Constant BR_26 = R_57;
Constant BR_27 = R_58;
Constant BR_28 = R_59;
Constant BR_29 = R_60;
Constant BR_30 = R_61;
Constant BR_31 = R_62;
Constant BR_32 = R_63;
Constant BR_33 = R_64;
Constant BR_34 = R_65;
Constant BR_35 = R_66;
Constant BR_36 = R_67;
Constant BR_37 = R_68;
Constant BR_38 = R_69;
Constant BR_39 = R_70;
Constant BR_40 = R_73;
Constant BR_41 = R_74;
Constant BR_42 = R_75;
Constant BR_43 = R_76;
Constant BR_44 = R_77;
Constant BR_45 = R_78;
Constant BR_46 = R_79;
Constant BR_47 = R_80;
Constant BR_48 = R_81;
Constant BR_49 = R_82;
Constant BR_50 = R_83;
Constant BR_51 = R_85;
Constant BR_52 = R_86;
Constant BR_53 = R_87;
Constant BR_54 = R_88;
Constant BR_55 = R_89;
Constant BR_56 = R_90;
Constant BR_57 = R_91;
Constant BR_58 = R_92;
Constant BR_59 = R_93;
Constant BR_60 = R_94;
Constant BR_61 = R_95;
Constant BR_62 = R_96;
Constant BR_63 = R_97;
Constant BR_64 = R_98;
Constant BR_65 = R_99;
Constant BR_66 = R_100;
Constant BR_67 = R_101;
Constant BR_68 = R_102;
Constant BR_69 = R_103;
Constant BR_70 = R_104;
Constant BR_71 = R_105;
Constant BR_72 = R_106;
Constant BR_73 = R_107;
Constant BR_74 = R_108;
Constant BR_75 = R_109;
Constant BR_76 = R_110;
Constant BR_77 = R_111;
Constant BR_78 = R_112;
Constant BR_79 = R_113;
Constant BR_80 = R_114;
Constant BR_81 = R_115;
Constant BR_82 = R_116;
Constant BR_83 = R_117;
Constant BR_84 = R_118;
Constant BR_85 = R_119;
Constant BR_86 = R_120;
Constant BR_87 = R_121;
Constant BR_88 = R_122;
Constant BR_89 = R_123;
Constant BR_90 = R_124;
Constant BR_91 = R_125;
Constant BR_92 = R_126;
Constant BR_93 = R_127;
Constant BR_94 = R_128;
Constant BR_95 = R_129;
Constant BR_96 = R_130;
Constant BR_97 = R_131;
Constant BR_98 = R_132;
Constant BR_99 = R_133;
Constant BR_100 = R_134;
Constant BR_101 = R_135;
Constant BR_102 = R_136;
Constant BR_103 = R_137;
Constant BR_104 = R_138;
Constant BR_105 = R_139;
Constant BR_106 = R_140;
Constant BR_107 = R_141;
Constant BR_108 = R_142;
Constant BR_109 = R_143;
Constant BR_110 = R_144;
Constant BR_111 = R_145;
Constant BR_112 = R_146;
Constant BR_113 = R_147;
Constant BR_114 = R_148;
Constant BR_115 = R_149;
Constant BR_116 = R_150;
Constant BR_117 = R_151;
Constant BR_118 = R_152;
Constant BR_119 = R_153;
Constant BR_120 = R_154;
Constant BR_121 = R_155;
Constant BR_122 = R_156;
Constant BR_123 = R_157;
Constant BR_124 = R_158;
Constant BR_125 = R_160;
Constant BR_126 = R_161;
Constant BR_127 = R_162;
Constant BR_128 = R_163;
Constant BR_129 = R_164;
Constant BR_130 = R_165;
Constant BR_131 = R_166;
Constant BR_132 = R_167;
Constant BR_133 = R_168;
Constant BR_134 = R_169;
Constant BR_135 = R_170;
Constant BR_136 = R_171;
Constant BR_137 = R_172;
Constant BR_138 = R_173;
Constant BR_139 = R_174;
Constant BR_140 = R_175;
Constant BR_141 = R_176;
Constant BR_142 = R_177;
Constant BR_143 = R_178;
Constant BR_144 = R_179;
Constant BR_145 = R_180;
Constant BR_146 = R_181;
Constant BR_147 = R_182;
Constant BR_148 = R_183;
Constant BR_149 = R_184;
Constant BR_150 = R_185;
Constant BR_151 = R_186;
Constant BR_152 = R_187;
Constant BR_153 = R_188;
Constant BR_154 = R_189;
Constant BR_155 = R_190;
Constant BR_156 = R_191;
Constant BR_157 = R_192;
Constant BR_158 = R_193;
Constant BR_159 = R_194;
Constant BR_160 = R_195;
Constant BR_161 = R_196;
Constant BR_162 = R_197;
Constant BR_163 = R_198;
Constant BR_164 = R_199;
Constant BR_165 = R_200;
Constant BR_166 = R_201;
Constant BR_167 = R_202;
Constant BR_168 = R_203;
Constant BR_169 = R_204;
Constant BR_170 = R_205;
Constant BR_171 = R_206;
Constant BR_172 = R_207;
Constant BR_173 = R_208;
Constant BR_174 = R_209;
Constant BR_175 = R_210;
Constant BR_176 = R_211;
Constant BR_177 = R_212;
Constant BR_178 = R_213;
Constant BR_179 = R_214;
Constant BR_180 = R_215;
Constant BR_181 = R_216;
Constant BR_182 = R_217;
Constant BR_183 = R_218;
Constant BR_184 = R_219;
Constant BR_185 = R_220;
Constant BR_186 = R_221;
Constant BR_187 = R_222;
Constant BR_188 = R_223;
Constant BR_189 = R_224;
Constant BR_190 = R_225;
Constant BR_191 = R_226;
Constant BR_192 = R_227;
Constant BR_193 = R_228;
Constant BR_194 = R_229;
Constant BR_195 = R_230;
Constant BR_196 = R_231;
Constant BR_197 = R_232;
Constant BR_198 = R_233;
Constant BR_199 = R_234;
Constant BR_200 = R_235;
Constant BR_201 = R_236;
Constant BR_202 = R_237;
Constant BR_203 = R_238;
Constant BR_204 = R_239;
Constant BR_205 = R_240;
Constant BR_206 = R_241;
Constant BR_207 = R_242;
Constant BR_208 = R_243;
Constant BR_209 = R_244;
Constant BR_210 = R_245;
Constant BR_211 = R_246;
Constant BR_212 = R_247;
Constant BR_213 = R_248;
Constant BR_214 = R_249;
Constant BR_215 = R_250;
Constant BR_216 = R_251;
Constant BR_217 = R_252;
Constant BR_218 = R_253;
Constant BR_219 = R_254;
Constant BR_220 = R_255;
Constant BR_221 = R_256;
Constant BR_222 = R_257;
Constant BR_223 = R_258;
Constant BR_224 = R_259;
Constant BR_225 = R_260;
Constant BR_226 = R_261;
Constant BR_227 = R_262;
Constant BR_228 = R_263;
Constant BR_229 = R_264;
Constant BR_230 = R_265;
Constant BR_231 = R_266;
Constant BR_232 = R_267;
Constant BR_233 = R_268;
Constant BR_234 = R_269;
Constant BR_235 = R_270;
Constant BR_236 = R_271;
Constant BR_237 = R_272;
Constant BR_238 = R_273;
Constant BR_239 = R_274;
Constant BR_240 = R_275;
Constant BR_241 = R_276;
Constant BR_242 = R_277;
Constant BR_243 = R_278;
Constant BR_244 = R_279;
Constant BR_245 = R_280;
Constant BR_246 = R_281;
Constant BR_247 = R_282;
Constant BR_248 = R_283;
Constant BR_249 = R_284;
Constant BR_250 = R_285;
Constant BR_251 = R_286;
Constant BR_252 = R_287;
Constant BR_253 = R_288;
Constant BR_254 = R_289;
Constant BR_255 = R_290;
Constant BR_256 = R_291;
Constant BR_257 = R_292;
Constant BR_258 = R_293;
Constant BR_259 = R_294;
Constant BR_260 = R_295;
Constant BR_261 = R_296;
Constant BR_262 = R_297;
Constant BR_263 = R_298;
Constant BR_264 = R_299;
Constant BR_265 = R_739;
Constant BR_266 = R_740;
Constant BR_267 = R_741;
Constant BR_268 = R_745;
Constant BR_269 = R_746;
Constant BR_270 = R_747;
Constant BR_271 = R_748;
Constant BR_272 = R_753;
Constant BR_273 = R_754;
Constant BR_274 = R_756;
Constant BR_275 = R_757;
Constant BR_276 = R_758;
Constant BR_277 = R_759;
Constant BR_278 = R_760;
Constant BR_279 = R_761;
Constant BR_280 = R_762;
Constant BR_281 = R_763;
Constant BR_282 = R_766;
Constant BR_283 = R_767;
Constant BR_284 = R_768;
Constant BR_285 = R_769;
Constant BR_286 = R_770;
Constant BR_287 = R_771;
Constant BR_288 = R_772;
Constant BR_289 = R_773;
Constant BR_290 = R_774;
Constant BR_291 = R_775;
Constant BR_292 = R_776;
Constant BR_293 = R_777;
Constant BR_294 = R_778;
Constant BR_295 = R_779;
Constant BR_296 = R_780;
Constant BR_297 = R_781;
Constant BR_298 = R_782;
Constant BR_299 = R_837;
Constant BR_300 = R_838;
Constant BR_301 = R_839;
Constant BR_302 = R_843;
Constant BR_303 = R_859;
Constant BR_304 = R_860;
Constant BR_305 = R_861;
Constant BR_306 = R_862;
Constant BR_307 = R_863;
Constant BR_308 = R_864;
Constant BR_309 = R_865;
Constant BR_310 = R_866;
Constant BR_311 = R_867;
Constant BR_312 = R_868;
Constant BR_313 = R_869;
Constant BR_314 = R_870;
Constant BR_315 = R_871;
Constant BR_316 = R_872;
Constant BR_317 = R_873;
Constant BR_318 = R_875;
Constant BR_319 = R_877;
Constant BR_320 = R_878;
Constant BR_321 = R_879;
Constant BR_322 = R_889;
Constant BR_323 = R_905;
Constant BR_324 = R_906;
Constant BR_325 = R_907;
Constant BR_326 = R_916;
Constant BR_327 = R_917;
Constant BR_328 = R_1201;
Constant BR_329 = R_1203;
Constant BR_1163 = R_8;
Constant BR_1169 = R_9;
Constant BR_1170 = R_10;
Constant BR_1171 = R_11;
Constant BR_1172 = R_12;
Constant BR_1180 = R_16;
Constant BR_1181 = R_17;
Constant BR_1183 = R_18;
Constant BR_1186 = R_21;
Constant BR_1187 = R_19;
Constant BR_1188 = R_20;
Constant BR_1192 = R_22;
Constant BR_1196 = R_23;
Constant BR_1202 = R_35;
Constant BR_1204 = R_59;
Constant BR_1205 = R_60;
Constant BR_1207 = R_61;
Constant BR_1212 = R_69;
Constant BR_1213 = R_68;
Constant BR_1215 = R_70;
Constant BR_1216 = R_91;
Constant BR_1217 = R_148;
Constant BR_1238 = R_740;
Constant BR_1239 = R_760;
Constant BR_1240 = R_773;
Constant BR_1241 = R_859;
Constant BR_1242 = R_864;
Constant BR_1243 = R_867;
Constant BR_1244 = R_868;
Constant BR_1245 = R_869;
Constant BR_1246 = R_1201;
Constant BR_1247 = R_1203;



[ DetectSceneChange 
    chs sc ch ! Used for scene searches
    ;
if (scene_status-->0 == 1) {
        if ((( (deadflag~=0) ))) {
            ch++;
            if (debug_scenes) print "[Scene 'Entire Game' ends]^";
            if (GProperty(94, 1, p65_recurring)) scene_status-->0 = 0; else scene_status-->0 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 1);
            ProcessRulebook(28);
            scene_ended-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|2;
            scene_latest_ending-->0 = 1;
            jump CScene;
        }
    }
    if (scene_status-->0 == 0) {
        if ((( (deadflag==0) ))) {
            ch++;
            if (debug_scenes) print "[Scene 'Entire Game' begins]^";
            scene_status-->0 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 1);
            ProcessRulebook(27);
            scene_started-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|1;
            scene_latest_ending-->0 = 0;
            jump CScene;
        }
    }
    if (scene_status-->1 == 1) {
    }
    if (scene_status-->1 == 0) {
    }
    if (scene_status-->2 == 1) {
        if (((TestSinglePastState(0, 3, false, 5)) && (((((Adj_53_t1_v65(O143_control_center))))) && ((((~~((real_location == O89_roof))))) && (( (GenerateRandomNumber(1, 4) <= 1) )))))) {
            ch++;
            if (debug_scenes) print "[Scene 'Rainstorm' ends]^";
            if (GProperty(94, 3, p65_recurring)) scene_status-->2 = 0; else scene_status-->2 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 3);
            ProcessRulebook(441);
            scene_ended-->2 = the_time;
            scene_endings-->2 = (scene_endings-->2)|2;
            scene_latest_ending-->2 = 1;
            jump CScene;
        }
    }
    if (scene_status-->2 == 0) {
    }
    if (scene_status-->3 == 1) {
        if ((((~~(((Adj_3_t1_v65(O181_darting_shadow)))))))) {
            ch++;
            if (debug_scenes) print "[Scene 'Pursuit' ends]^";
            if (GProperty(94, 4, p65_recurring)) scene_status-->3 = 0; else scene_status-->3 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 4);
            ProcessRulebook(443);
            scene_ended-->3 = the_time;
            scene_endings-->3 = (scene_endings-->3)|2;
            scene_latest_ending-->3 = 1;
            jump CScene;
        }
    }
    if (scene_status-->3 == 0) {
        if (((((player == HolderOf(O71_flashlight)))) && (((((Adj_84_t1_v65(O131_emergency_lights))))) && ((( (scene_endings-->(Q342_rabbit_s_offer-1) == 0) )) && ((TestSinglePastState(0, 4, false, 5)) && (((PHR_1127_r95 ())))))))) {
            ch++;
            if (debug_scenes) print "[Scene 'Pursuit' begins]^";
            scene_status-->3 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 4);
            ProcessRulebook(442);
            scene_started-->3 = the_time;
            scene_endings-->3 = (scene_endings-->3)|1;
            scene_latest_ending-->3 = 0;
            jump CScene;
        }
    }
    if (scene_status-->4 == 1) {
        if ((((~~((real_location == O182_burrow)))))) {
            ch++;
            if (debug_scenes) print "[Scene 'Rabbit's Offer' ends]^";
            if (GProperty(94, 5, p65_recurring)) scene_status-->4 = 0; else scene_status-->4 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 5);
            ProcessRulebook(445);
            scene_ended-->4 = the_time;
            scene_endings-->4 = (scene_endings-->4)|2;
            scene_latest_ending-->4 = 1;
            if (scene_status-->1 == 0) {
                if (debug_scenes) print "[Scene 'Sinister Voices' begins]^";
                scene_status-->1 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 2);
                ProcessRulebook(438);
                scene_started-->1 = the_time;
                scene_endings-->1 = (scene_endings-->1)|1;
                scene_latest_ending-->1 = 0;
            }
            if (scene_status-->2 == 0) {
                if (debug_scenes) print "[Scene 'Rainstorm' begins]^";
                scene_status-->2 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 3);
                ProcessRulebook(440);
                scene_started-->2 = the_time;
                scene_endings-->2 = (scene_endings-->2)|1;
                scene_latest_ending-->2 = 0;
            }
            jump CScene;
        }
    }
    if (scene_status-->4 == 0) {
        if ((((real_location == O182_burrow)))) {
            ch++;
            if (debug_scenes) print "[Scene 'Rabbit's Offer' begins]^";
            scene_status-->4 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 5);
            ProcessRulebook(444);
            scene_started-->4 = the_time;
            scene_endings-->4 = (scene_endings-->4)|1;
            scene_latest_ending-->4 = 0;
            jump CScene;
        }
    }
    if (scene_status-->5 == 1) {
        if ((((real_location == O149_open_desert)))) {
            ch++;
            if (debug_scenes) print "[Scene 'Temptation' ends]^";
            if (GProperty(94, 6, p65_recurring)) scene_status-->5 = 0; else scene_status-->5 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 6);
            ProcessRulebook(447);
            scene_ended-->5 = the_time;
            scene_endings-->5 = (scene_endings-->5)|2;
            scene_latest_ending-->5 = 1;
            if (scene_status-->6 == 0) {
                if (debug_scenes) print "[Scene 'Chase' begins]^";
                scene_status-->6 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 7);
                ProcessRulebook(448);
                scene_started-->6 = the_time;
                scene_endings-->6 = (scene_endings-->6)|1;
                scene_latest_ending-->6 = 0;
            }
            jump CScene;
        }
    }
    if (scene_status-->5 == 0) {
        if (((( (scene_endings-->(Q340_rainstorm-1) > 1) )) && (((((Adj_53_t1_v65(O143_control_center))))) && ((((~~((TestRegionalContainment(real_location,O112_office_interior)))))) && ((((~~((real_location == O89_roof))))) && (((~~((real_location == O143_control_center)))))))))) {
            ch++;
            if (debug_scenes) print "[Scene 'Temptation' begins]^";
            scene_status-->5 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 6);
            ProcessRulebook(446);
            scene_started-->5 = the_time;
            scene_endings-->5 = (scene_endings-->5)|1;
            scene_latest_ending-->5 = 0;
            jump CScene;
        }
    }
    if (scene_status-->6 == 1) {
        if ((TestSinglePastState(0, 5, false, 2) == 6 )) {
            ch++;
            if (debug_scenes) print "[Scene 'Chase' ends]^";
            if (GProperty(94, 7, p65_recurring)) scene_status-->6 = 0; else scene_status-->6 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 7);
            ProcessRulebook(449);
            scene_ended-->6 = the_time;
            scene_endings-->6 = (scene_endings-->6)|2;
            scene_latest_ending-->6 = 1;
            if (scene_status-->7 == 0) {
                if (debug_scenes) print "[Scene 'Fight' begins]^";
                scene_status-->7 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 8);
                ProcessRulebook(450);
                scene_started-->7 = the_time;
                scene_endings-->7 = (scene_endings-->7)|1;
                scene_latest_ending-->7 = 0;
            }
            jump CScene;
        }
    }
    if (scene_status-->6 == 0) {
    }
    if (scene_status-->7 == 1) {
        if (((action ==##Attack) &&  (actor==player))) {
            ch++;
            if (debug_scenes) print "[Scene 'Fight' ends]^";
            if (GProperty(94, 8, p65_recurring)) scene_status-->7 = 0; else scene_status-->7 = 2; 
            scene_ended-->7 = the_time;
            scene_endings-->7 = (scene_endings-->7)|2;
            scene_latest_ending-->7 = 1;
            if (debug_scenes) print "[Scene 'Fight' ends in bravery]^";
            if (GProperty(94, 8, p65_recurring)) scene_status-->7 = 0; else scene_status-->7 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 8);
            ProcessRulebook(459);
            scene_ended-->7 = the_time;
            scene_endings-->7 = (scene_endings-->7)|8;
            scene_latest_ending-->7 = 3;
            ProcessRulebook(WHEN_SCENE_ENDS_RB, 8);
            ProcessRulebook(451);
            if (scene_status-->8 == 0) {
                if (debug_scenes) print "[Scene 'Coyote's Offer' begins]^";
                scene_status-->8 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 9);
                ProcessRulebook(452);
                scene_started-->8 = the_time;
                scene_endings-->8 = (scene_endings-->8)|1;
                scene_latest_ending-->8 = 0;
            }
            jump CScene;
        }
        if ((TestSinglePastState(0, 6, false, 2) == 6 )) {
            ch++;
            if (debug_scenes) print "[Scene 'Fight' ends]^";
            if (GProperty(94, 8, p65_recurring)) scene_status-->7 = 0; else scene_status-->7 = 2; 
            scene_ended-->7 = the_time;
            scene_endings-->7 = (scene_endings-->7)|2;
            scene_latest_ending-->7 = 1;
            if (debug_scenes) print "[Scene 'Fight' ends in cowardice]^";
            if (GProperty(94, 8, p65_recurring)) scene_status-->7 = 0; else scene_status-->7 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 8);
            ProcessRulebook(458);
            scene_ended-->7 = the_time;
            scene_endings-->7 = (scene_endings-->7)|4;
            scene_latest_ending-->7 = 2;
            ProcessRulebook(WHEN_SCENE_ENDS_RB, 8);
            ProcessRulebook(451);
            if (scene_status-->8 == 0) {
                if (debug_scenes) print "[Scene 'Coyote's Offer' begins]^";
                scene_status-->8 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 9);
                ProcessRulebook(452);
                scene_started-->8 = the_time;
                scene_endings-->8 = (scene_endings-->8)|1;
                scene_latest_ending-->8 = 0;
            }
            jump CScene;
        }
    }
    if (scene_status-->7 == 0) {
    }
    if (scene_status-->8 == 1) {
        if ((((~~((real_location == O149_open_desert)))))) {
            ch++;
            if (debug_scenes) print "[Scene 'Coyote's Offer' ends]^";
            if (GProperty(94, 9, p65_recurring)) scene_status-->8 = 0; else scene_status-->8 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 9);
            ProcessRulebook(453);
            scene_ended-->8 = the_time;
            scene_endings-->8 = (scene_endings-->8)|2;
            scene_latest_ending-->8 = 1;
            jump CScene;
        }
    }
    if (scene_status-->8 == 0) {
    }
    if (scene_status-->9 == 1) {
        if ((((real_location == O89_roof)))) {
            ch++;
            if (debug_scenes) print "[Scene 'Sand-dancer's Arrival' ends]^";
            if (GProperty(94, 10, p65_recurring)) scene_status-->9 = 0; else scene_status-->9 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 10);
            ProcessRulebook(455);
            scene_ended-->9 = the_time;
            scene_endings-->9 = (scene_endings-->9)|2;
            scene_latest_ending-->9 = 1;
            if (scene_status-->10 == 0) {
                if (debug_scenes) print "[Scene 'Sand-dancer's Offer' begins]^";
                scene_status-->10 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 11);
                ProcessRulebook(456);
                scene_started-->10 = the_time;
                scene_endings-->10 = (scene_endings-->10)|1;
                scene_latest_ending-->10 = 0;
            }
            jump CScene;
        }
    }
    if (scene_status-->9 == 0) {
        if (((((PHR_1197_r17 ()))) && (((((Global_Vars-->32) == 1))) && (~~(((PHR_932_r14 ()))))))) {
            ch++;
            if (debug_scenes) print "[Scene 'Sand-dancer's Arrival' begins]^";
            scene_status-->9 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 10);
            ProcessRulebook(454);
            scene_started-->9 = the_time;
            scene_endings-->9 = (scene_endings-->9)|1;
            scene_latest_ending-->9 = 0;
            if (scene_status-->1 == 1) {
                if (debug_scenes) print "[Scene 'Sinister Voices' ends]^";
                if (GProperty(94, 2, p65_recurring)) scene_status-->1 = 0; else scene_status-->1 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 2);
                ProcessRulebook(439);
                scene_ended-->1 = the_time;
                scene_endings-->1 = (scene_endings-->1)|2;
                scene_latest_ending-->1 = 1;
            }
            jump CScene;
        }
    }
    if (scene_status-->10 == 1) {
    }
    if (scene_status-->10 == 0) {
    }
    .CScene;
    if (chs>10) ">--> The scene change machinery is stuck.";

    if (ch>0) DetectSceneChange(++chs);

    rfalse;
];

#IFDEF DEBUG;
[ ShowSceneStatus chs sc ch;
    if (scene_status-->0 == 1) {
        print "Scene 'Entire Game' playing (for ", the_time-(scene_started-->0), " mins now)^";
    } else {
        if (scene_latest_ending-->0 > 0) {
            print "Scene 'Entire Game' ended ";
            print "^";
        }
    }
    if (scene_status-->1 == 1) {
        print "Scene 'Sinister Voices' playing (for ", the_time-(scene_started-->1), " mins now)^";
    } else {
        if (scene_latest_ending-->1 > 0) {
            print "Scene 'Sinister Voices' ended ";
            print "^";
        }
    }
    if (scene_status-->2 == 1) {
        print "Scene 'Rainstorm' playing (for ", the_time-(scene_started-->2), " mins now)^";
    } else {
        if (scene_latest_ending-->2 > 0) {
            print "Scene 'Rainstorm' ended ";
            print "^";
        }
    }
    if (scene_status-->3 == 1) {
        print "Scene 'Pursuit' playing (for ", the_time-(scene_started-->3), " mins now)^";
    } else {
        if (scene_latest_ending-->3 > 0) {
            print "Scene 'Pursuit' ended ";
            print "^";
        }
    }
    if (scene_status-->4 == 1) {
        print "Scene 'Rabbit's Offer' playing (for ", the_time-(scene_started-->4), " mins now)^";
    } else {
        if (scene_latest_ending-->4 > 0) {
            print "Scene 'Rabbit's Offer' ended ";
            print "^";
        }
    }
    if (scene_status-->5 == 1) {
        print "Scene 'Temptation' playing (for ", the_time-(scene_started-->5), " mins now)^";
    } else {
        if (scene_latest_ending-->5 > 0) {
            print "Scene 'Temptation' ended ";
            print "^";
        }
    }
    if (scene_status-->6 == 1) {
        print "Scene 'Chase' playing (for ", the_time-(scene_started-->6), " mins now)^";
    } else {
        if (scene_latest_ending-->6 > 0) {
            print "Scene 'Chase' ended ";
            print "^";
        }
    }
    if (scene_status-->7 == 1) {
        print "Scene 'Fight' playing (for ", the_time-(scene_started-->7), " mins now)^";
    } else {
        if (scene_latest_ending-->7 > 0) {
            print "Scene 'Fight' ended ";
            switch(scene_latest_ending-->7) {
                2: print "in cowardice";
                3: print "in bravery";
            }
            print "^";
        }
    }
    if (scene_status-->8 == 1) {
        print "Scene 'Coyote's Offer' playing (for ", the_time-(scene_started-->8), " mins now)^";
    } else {
        if (scene_latest_ending-->8 > 0) {
            print "Scene 'Coyote's Offer' ended ";
            print "^";
        }
    }
    if (scene_status-->9 == 1) {
        print "Scene 'Sand-dancer's Arrival' playing (for ", the_time-(scene_started-->9), " mins now)^";
    } else {
        if (scene_latest_ending-->9 > 0) {
            print "Scene 'Sand-dancer's Arrival' ended ";
            print "^";
        }
    }
    if (scene_status-->10 == 1) {
        print "Scene 'Sand-dancer's Offer' playing (for ", the_time-(scene_started-->10), " mins now)^";
    } else {
        if (scene_latest_ending-->10 > 0) {
            print "Scene 'Sand-dancer's Offer' ended ";
            print "^";
        }
    }
];


#ENDIF;



Constant AD_ACTION = 0; ! The I6 action number (0 to 4095)
Constant AD_REQUIREMENTS = 1; ! Such as requiring light; a bitmap, see below
Constant AD_NOUN_KOV = 2; ! Kind of value of the first noun
Constant AD_SECOND_KOV = 3; ! Kind of value of the second noun
Constant AD_VARIABLES_CREATOR = 4; ! Routine to initialise variables owned
Constant AD_VARIABLES_ID = 5; ! Frame ID for variables owned by action

Constant AD_RECORD_SIZE = 6;

[ FindAction fa t;
	if (fa == -1) fa = action;
	t = 1;
	while (t <= ActionData-->0) {
		if (fa == ActionData-->t) return t;
		t = t + AD_RECORD_SIZE;
	}
	rfalse;
];

[ ActionNumberIndexed i;
	if ((i>=0) && (i < AD_RECORDS)) return ActionData-->(i*AD_RECORD_SIZE + AD_ACTION + 1);
	return 0;
];

Constant TOUCH_NOUN_ABIT   = $$00000001;
Constant TOUCH_SECOND_ABIT = $$00000010;
Constant LIGHT_ABIT        = $$00000100;
Constant NEED_NOUN_ABIT    = $$00001000;
Constant NEED_SECOND_ABIT  = $$00010000;
Constant OUT_OF_WORLD_ABIT = $$00100000;
Constant CARRY_NOUN_ABIT   = $$01000000;
Constant CARRY_SECOND_ABIT = $$10000000;

[ NeedToCarryNoun;       return TestActionMask(CARRY_NOUN_ABIT); ];
[ NeedToCarrySecondNoun; return TestActionMask(CARRY_SECOND_ABIT); ];
[ NeedToTouchNoun;       return TestActionMask(TOUCH_NOUN_ABIT); ];
[ NeedToTouchSecondNoun; return TestActionMask(TOUCH_SECOND_ABIT); ];
[ NeedLightForAction;    return TestActionMask(LIGHT_ABIT); ];

[ TestActionMask match mask at; 
	at = FindAction(-1); 
	if (at == 0) rfalse; 
	mask = ActionData-->(at+AD_REQUIREMENTS); 
	if (mask & match) rtrue; 
	rfalse; 
];

[ TryAction req by ac n s stora smeta tbits saved_command text_of_command;
	if (stora) return STORED_ACTION_TY_New(ac, n, s, by, req, stora);
	tbits = req & (16+32);
	req = req & 1;
	@push actor; @push act_requester; @push inp1; @push inp2;
	@push parsed_number; smeta = meta;
	actor = by; if (req) act_requester = player; else act_requester = 0;

	by = FindAction(ac);
	if (by) {
		if (ActionData-->(by+AD_NOUN_KOV) == OBJECT_TY) inp1 = n;
		else { inp1 = 1; parsed_number = n; }
		if (ActionData-->(by+AD_SECOND_KOV) == OBJECT_TY) inp2 = s;
		else { inp2 = 1; parsed_number = s; }
		if (((ActionData-->(by+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(by+AD_SECOND_KOV) == UNDERSTANDING_TY)) && (tbits)) {
			saved_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(players_command, SNIPPET_TY, saved_command);
			text_of_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(parsed_number, TEXT_TY, text_of_command);
			SetPlayersCommand(text_of_command);
			if (tbits == 16) {
				n = players_command; inp1 = 1; parsed_number = players_command;
			} else {
				s = players_command; inp2 = 1; parsed_number = players_command;
			}
			BlkFree(text_of_command);
			@push consult_from; @push consult_words;
			consult_from = 1; consult_words = parsed_number - 100;
		}
	}

	BeginAction(ac, n, s, 0, true);

	if (saved_command) {
		@pull consult_words; @pull consult_from;
		SetPlayersCommand(saved_command);
		BlkFree(saved_command);
	}

	meta = smeta; @pull parsed_number;
	@pull inp2; @pull inp1; @pull act_requester; @pull actor;
	TrackActions(true, smeta);
];

[ R_Process a i j;
	@push inp1; @push inp2;
    inp1 = i; inp2 = j; BeginAction(a, i, j);
    @pull inp2; @pull inp1;
];

Global converted_action_outcome = -1;
[ GVS_Convert ac n s;
	converted_action_outcome = BeginAction(ac, n, s);
	rtrue;
];

[ ConvertToGoingWithPush i oldrm newrm infl;
	i=noun;
	if (IndirectlyContains(noun, actor) == false) { move i to actor; infl = true; }
	move_pushing = i;
	oldrm = LocationOf(noun);
	BeginAction(##Go, second);
	newrm = LocationOf(actor);
	move_pushing = nothing; move i to newrm;
	if (newrm ~= oldrm) {
		if (IndirectlyContains(i, player)) TryAction(0, player, ##Look, 0, 0);
		RulebookSucceeds();
	} else RulebookFails();
];

[ ImplicitTake obj ks;
	if (actor == player) L__M(##Miscellany, 69, obj);
	else L__M(##Miscellany, 68, obj);
	ClearParagraphing();
	@push keep_silent; keep_silent = true;
	if (act_requester) TryAction(true, actor, ##Take, obj, nothing);
	else TryAction(false, actor, ##Take, obj, nothing);
	@pull keep_silent;
	if (obj in actor) rtrue;
	rfalse;
];

[ LookAfterGoing;
	GoingLookBreak();
	AbbreviatedRoomDescription();
];

[ AbbreviatedRoomDescription  prior_action pos frame_id;
	prior_action = action; 

	action = ##Look;
	pos = FindAction(##Look);
	if ((pos) && (ActionData-->(pos+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(pos+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);
		ProcessRulebook(SETTING_ACTION_VARIABLES_RB);
		(MStack-->MstVO(frame_id, 0)) = prior_action; ! "room-describing action"
		(MStack-->MstVO(frame_id, 1)) = true; ! "abbreviated form allowed"
	}
	LookSub(); ! The I6 verb routine for "looking"
	if (frame_id) Mstack_Destroy_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);

	action = prior_action;
];

[ BeginAction a n s moi notrack  rv;
	ChronologyPoint();

	@push action; @push noun; @push second; @push self; @push multiple_object_item;

	action = a; noun = n; second = s; self = noun; multiple_object_item = moi;
	if (action < 4096) rv = ActionPrimitive();

	@pull multiple_object_item; @pull self; @pull second; @pull noun; @pull action;
	
	if (notrack == false) TrackActions(true, meta);
	return rv;
];

[ ActionPrimitive  rv p1 p2 p3 p4 p5 frame_id;
	MStack_CreateRBVars(ACTION_PROCESSING_RB);

	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	reason_the_action_failed = 0;

	frame_id = -1;
	p1 = FindAction(action);
	if ((p1) && (ActionData-->(p1+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(p1+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	if (ActionVariablesNotTypeSafe()) {
		if (frame_id ~= -1)
			Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
		MStack_DestroyRBVars(ACTION_PROCESSING_RB);
		return;
	}

	ProcessRulebook(SETTING_ACTION_VARIABLES_RB);

	#IFDEF DEBUG;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; p1=actor; p2=act_requester; p3=action; p4=noun; p5=second;
		DB_Action(p1,p2,p3,p4,p5);
		print "]^"; ClearParagraphing();
	}
	++debug_rule_nesting;
	#ENDIF;
	TrackActions(false, meta);
	BeginFollowRulebook();
	if ((meta) && (actor ~= player)) { L__M(##Miscellany, 74, actor); rv = RS_FAILS; }
	else if (meta) { DESCEND_TO_SPECIFIC_ACTION_R(); rv = RulebookOutcome(); }
	else { ProcessRulebook(ACTION_PROCESSING_RB); rv = RulebookOutcome(); }
	#IFDEF DEBUG;
	--debug_rule_nesting;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; DB_Action(p1,p2,p3,p4,p5); print " - ";
		switch (rv) {
			RS_SUCCEEDS: print "succeeded";
			RS_FAILS: print "failed";
				#IFNDEF MEMORY_ECONOMY;
				if (reason_the_action_failed)
					print " the ",
						(RulePrintingRule) reason_the_action_failed;
			    #ENDIF;
			default: print "ended without result";
		}
		print "]^"; say__p = 1;
		SetRulebookOutcome(rv); ! In case disturbed by printing activities
	}
	#ENDIF;
	if (rv == RS_SUCCEEDS) UpdateActionBitmap();
	EndFollowRulebook();
	if (frame_id ~= -1) {
		p1 = FindAction(action);
		Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	MStack_DestroyRBVars(ACTION_PROCESSING_RB);
	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	if (rv == RS_SUCCEEDS) rtrue;
	rfalse;
];

[ ActionVariablesNotTypeSafe mask noun_kova second_kova at;
	at = FindAction(-1); if (at == 0) rfalse; ! For any I6-defined actions

	noun_kova = ActionData-->(at+AD_NOUN_KOV);
	second_kova = ActionData-->(at+AD_SECOND_KOV);

	!print "at = ", at, " nst = ", noun_kova, "^";
	!print "consult_from = ", consult_from, " consult_words = ", consult_from, "^";
	!print "inp1 = ", inp1, " noun = ", noun, "^";
	!print "inp2 = ", inp2, " second = ", second, "^";
	!print "sst = ", second_kova, "^";

	if (noun_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    if (inp1 ~= 1) { inp2 = inp1; second = noun; }
	    parsed_number = 100*consult_from + consult_words;
	    inp1 = 1; noun = parsed_number;
	}
	if (second_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    parsed_number = 100*consult_from + consult_words;
	    inp2 = 1; second = parsed_number;
	}

	mask = ActionData-->(at+AD_REQUIREMENTS);
	if (mask & OUT_OF_WORLD_ABIT) { meta = 1; rfalse; }

	if (inp1 == 1) {
	    if (noun_kova == OBJECT_TY) {
	        return L__M(##Miscellany, 61); }
	} else {
	    if (noun_kova ~= OBJECT_TY) {
	        return L__M(##Miscellany, 62); }
	    if ((mask & NEED_NOUN_ABIT) && (noun == nothing)) {
	    	@push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_NOUN_ACT);
	        @pull act_requester;
	        if (noun == nothing) {
	        	if (say__p) rtrue;
	        	return L__M(##Miscellany, 59);
	    	}
	    }
	    if (((mask & NEED_NOUN_ABIT) == 0) && (noun ~= nothing)) {
	        return L__M(##Miscellany, 60); }
	}

	if (inp2 == 1) {
	    if (second_kova == OBJECT_TY) {
	        return L__M(##Miscellany, 63); }
	} else {
	    if (second_kova ~= OBJECT_TY) {
	        return L__M(##Miscellany, 64); }
	    if ((mask & NEED_SECOND_ABIT) && (second == nothing)) {
	        @push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_SECOND_ACT);
	        @pull act_requester;
	        if (second == nothing) {
	        	if (say__p) rtrue;
	        	return L__M(##Miscellany, 65);
	        }
	    }
	    if (((mask & NEED_SECOND_ABIT) == 0) && (second ~= nothing)) {
	        return L__M(##Miscellany, 66); }
	}

	rfalse;
];

[ BASIC_VISIBILITY_R;
	if (act_requester) rfalse;
	if ((NeedLightForAction()) &&
		(actor == player) &&
		(ProcessRulebook(VISIBLE_RB)) &&
		(RulebookSucceeded())) {
		BeginActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		if (ForActivity(REFUSAL_TO_ACT_IN_DARK_ACT)==false) L__M(##Miscellany, 17);
		EndActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		reason_the_action_failed = BASIC_VISIBILITY_R;
		RulebookFails();
		rtrue;
	}
	rfalse;
];

[ BASIC_ACCESSIBILITY_R mask at;
	if (act_requester) rfalse;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if (noun ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			if (actor~=player) rtrue;
			return L__M(##Miscellany, 67);
		}
		if (ObjectIsUntouchable(noun, (actor~=player), FALSE, actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if (second ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			if (actor~=player) rtrue;
			return L__M(##Miscellany, 67);
		}
		if (ObjectIsUntouchable(second, (actor~=player), FALSE, actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}
	rfalse;
];

[ CARRYING_REQUIREMENTS_R mask at;
	
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if ((mask & CARRY_NOUN_ABIT) && (noun notin actor)) {
			BeginActivity(IMPLICITLY_TAKING_ACT, noun);
            if (ForActivity(IMPLICITLY_TAKING_ACT, noun)==false)
            	ImplicitTake(noun);
            EndActivity(IMPLICITLY_TAKING_ACT, noun);
            !if (act_requester) rfalse;
			if (noun notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if ((mask & CARRY_SECOND_ABIT) && (second notin actor)) {
			BeginActivity(IMPLICITLY_TAKING_ACT, second);
            if (ForActivity(IMPLICITLY_TAKING_ACT, second)==false)
            	ImplicitTake(second);
            EndActivity(IMPLICITLY_TAKING_ACT, second);
            !if (act_requester) rfalse;
			if (second notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}
	rfalse;
];

[ REQUESTED_ACTIONS_REQUIRE_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push say__p;
		say__p = 0;
		rv = ProcessRulebook(PERSUADE_RB);
		if (RulebookSucceeded() == false) {
			if ((deadflag == false) && (say__p == FALSE)) L__M(##Miscellany, 72, actor);
			ActRulebookFails(rv); rtrue;
		}
		@pull say__p;
	}
	rfalse;
];

[ CARRY_OUT_REQUESTED_ACTIONS_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push act_requester; act_requester = nothing;
		rv = BeginAction(action, noun, second);
		if (((meta) || (rv == false)) && (deadflag == false)) {
			if (ProcessRulebook(UNSUCCESSFUL_ATTEMPT_RB) == false) L__M(##Miscellany, 58);
		}
		@pull act_requester;
		ActRulebookSucceeds();
		rtrue;
	}
	rfalse;
];

Array Details_of_Specific_Action-->5;

[ GenericVerbSub ch co re vis rv;
	@push converted_action_outcome;
	converted_action_outcome = -1;

	Details_of_Specific_Action-->0 = true;
	if (meta) Details_of_Specific_Action-->0 = false;
	Details_of_Specific_Action-->1 = keep_silent;
	Details_of_Specific_Action-->2 = ch; ! Check rules for the action
	Details_of_Specific_Action-->3 = co; ! Carry out rules for the action
	Details_of_Specific_Action-->4 = re; ! Report rules for the action

	ProcessRulebook(SPECIFIC_ACTION_PROCESSING_RB, 0, true);
	if ((RulebookFailed()) && (converted_action_outcome == 1)) ActRulebookSucceeds();

	@pull converted_action_outcome;
	rtrue;
];

[ WORK_OUT_DETAILS_OF_SPECIFIC_R;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 0) = Details_of_Specific_Action-->0;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 1) = Details_of_Specific_Action-->1;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 2) = Details_of_Specific_Action-->2;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 3) = Details_of_Specific_Action-->3;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 4) = Details_of_Specific_Action-->4;
	rfalse;
];

[ TestActionBitmap obj act i j k bitmap;
	if (obj == nothing) bitmap = ActionHappened;
	else {
		if (~~(obj provides action_bitmap)) rfalse;
		bitmap = obj.&action_bitmap;
	}
	if (act == -1) return (((bitmap->0) & 1) ~= 0); 
	for (i=0, k=2; i<ActionCount; i++) {
		if (act == ActionCoding-->i) {
			return (((bitmap->j) & k) ~= 0);
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
	rfalse;
];

[ UpdateActionBitmap;
	SetActionBitmap(noun, action);
	if (action == ##Go) SetActionBitmap(location, ##Enter);
];

[ SetActionBitmap obj act i j k bitmap;
	for (i=0, k=2; i<ActionCount; i++) {
		if (act == ActionCoding-->i) {
			if (obj provides action_bitmap) {
				bitmap = obj.&action_bitmap;
				bitmap->0 = (bitmap->0) | 1;
				bitmap->j = (bitmap->j) | k;
			}
			ActionHappened->0 = (ActionHappened->0) | 1;
			ActionHappened->j = (ActionHappened->j) | k;
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
];

[ SayActionName act; DB_Action(0, 0, act, 0, 0, 2); ];

[ DA_Name n; if (n ofclass K3_direction) print (name) n; else print (the) n; ];
[ DA_Topic x a b c d i cf cw;
	cw = x%100; cf = x/100;
	print "~";
	for (a=cf:d<cw:d++,a++) {
		wn = a; b = WordAddress(a); c = WordLength(a);
		for (i=b:i<b+c:i++) {
			print (char) 0->i;
		}
		if (d<cw-1) print " ";
	}
	print "~";
];
[ DA_Number n; print n; ];
[ DA_TruthState n; if (n==0) print "false"; else print "true"; ];
[ DB_Action ac acr act n s for_say t at l j v c clc;
	if ((for_say == 0) && (debug_rule_nesting > 0))
		print "(", debug_rule_nesting, ") ";
	if ((ac ~= player) && (for_say ~= 2)) {
		if (acr) print "asking ", (the) ac, " to try ";
		else print (the) ac, " ";
	}
	DB_Action_Details(act, n, s, for_say);
	if ((keep_silent) && (for_say == 0)) print " - silently";
];

Constant MAX_NESTED_ACTIVITIES = 20;
Global activities_sp = 0;
Array activities_stack --> MAX_NESTED_ACTIVITIES;
Array activity_parameters_stack --> MAX_NESTED_ACTIVITIES;

Global inhibit_flag = 0;
Global saved_debug_rules = 0;
[ FixInhibitFlag n act inhibit_rule_debugging;
	for (n=0:n<activities_sp:n++) {
		act = activities_stack-->n;
		if (act == PRINTING_THE_NAME_ACT or PRINTING_THE_PLURAL_NAME_ACT or
			PRINTING_ROOM_DESC_DETAILS_ACT or LISTING_CONTENTS_ACT or
			GROUPING_TOGETHER_ACT) inhibit_rule_debugging = true;
	}
	if ((inhibit_flag == false) && (inhibit_rule_debugging)) {
		saved_debug_rules = debug_rules;
		debug_rules = 0;
	}
	if ((inhibit_flag) && (inhibit_rule_debugging == false)) {
		debug_rules = saved_debug_rules;
	}
	inhibit_flag = inhibit_rule_debugging;
];

[ TestActivity A desc val i;
	for (i=0:i<activities_sp:i++)
		if (activities_stack-->i == A) {
			if (desc) {
				if ((desc)(activity_parameters_stack-->i)) rtrue;
			} else if (val) {
				if (val == activity_parameters_stack-->i) rtrue;
			} else rtrue;
		}
	rfalse;
];

[ ActivityEmpty A x;
	x = Activity_before_rulebooks-->A;
	if (((rulebooks_array-->x)-->0) ~= NULL) rfalse;
	x = Activity_for_rulebooks-->A;
	if (((rulebooks_array-->x)-->0) ~= NULL) rfalse;
	x = Activity_after_rulebooks-->A;
	if (((rulebooks_array-->x)-->0) ~= NULL) rfalse;
	rtrue;
];

[ RulebookEmpty rb;
	if (((rulebooks_array-->rb)-->0) ~= NULL) rfalse;
	rtrue;
];

[ ProcessActivityRulebook rulebook parameter  rv;
	@push self;
	if (parameter) self = parameter;
	rv = ProcessRulebook(rulebook, parameter, true);
	@pull self;
	if (rv) rtrue;
	rfalse;
];

[ CarryOutActivity A o rv;
	BeginActivity(A, o);
	rv = ForActivity(A, o);
	EndActivity(A, o);
	return rv;
];

[ BeginActivity A o x;
	if (activities_sp == MAX_NESTED_ACTIVITIES) return RunTimeProblem(RTP_TOOMANYACTS);
	activity_parameters_stack-->activities_sp = o;
	activities_stack-->(activities_sp++) = A;
	FixInhibitFlag();
	MStack_CreateAVVars(A);
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_before_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];

[ ForActivity A o x;
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_for_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];

[ EndActivity A o rv x;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
		rv = ProcessActivityRulebook(Activity_after_rulebooks-->A, o);
		if (Activity_atb_rulebooks->A) action = x;
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return rv;
	}
	return RunTimeProblem(RTP_CANTABANDON);
];

[ AbandonActivity A o;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return;
	}
	return RunTimeProblem(RTP_CANTEND);
];

Array ResourceUsageFlags ->
	(1+0+5);

[ DisplayFigure resource_ID one_time;
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	print "^"; VM_Picture(resource_ID); print "^";
];

[ PlaySound resource_ID one_time;
	if (resource_ID == 0) return; ! The "silence" non-sound effect
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	VM_SoundEffect(resource_ID);
];

#IFDEF PLUGIN_FILES;

Constant AUXF_MAGIC = 0; ! First word holds a safety constant
Constant AUXF_MAGIC_VALUE = 16339; ! Should be first word of any valid file structure
Constant AUXF_STATUS = 1; ! One of the following:
	Constant AUXF_STATUS_IS_CLOSED = 1; ! Currently closed, or perhaps doesn't exist
	Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
	Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
	Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2; ! False for text files (I7 default), true for binary
Constant AUXF_STREAM = 3; ! Stream for an open file (meaningless otherwise)
Constant AUXF_FILENAME = 4; ! Packed address of constant string
Constant AUXF_IFID_OF_OWNER = 5; ! UUID_ARRAY if owned by this project, or
	! string array of IFID of owner wrapped in //...//, or NULL to leave open

Constant NO_EXTERNAL_FILES 0;
Array TableOfExternalFiles --> 0 0;


[ FileIO_Error extf err_text  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) {
		print "^*** Error on unknown file: ", (string) err_text, " ***^";
	} else {
		struc = TableOfExternalFiles-->extf;
		print "^*** Error on file '",
			(string) struc-->AUXF_FILENAME, "': ",
			(string) err_text, " ***^";
	}
	RunTimeProblem(RTP_FILEIOERROR);
	return 0;
];

#IFDEF TARGET_GLULX;

[ FileIO_Exists extf  fref struc rv usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	rv = glk_fileref_does_file_exist(fref);
	glk_fileref_destroy(fref);
	return rv;
];

[ FileIO_Ready extf  struc fref usage str ch;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		rfalse;
	}
	str = glk_stream_open_file(fref, filemode_Read, 0);
	ch = glk_get_char_stream(str);
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
	if (ch ~= '*') rfalse;
	rtrue;
];

[ FileIO_MarkReady extf readiness  struc fref str ch usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only existing files can be marked");
	}
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only closed files can be marked");
	}
	str = glk_stream_open_file(fref, filemode_ReadWrite, 0);
	glk_stream_set_position(str, 0, 0); ! seek start
	if (readiness) ch = '*'; else ch = '-';
	glk_put_char_stream(str, ch); ! mark as complete
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
];

[ FileIO_Open extf write_flag append_flag
	struc fref str mode ix ch not_this_ifid owner force_header usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED)
		return FileIO_Error(extf, "tried to open a file already open");
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (write_flag) {
		if (append_flag) {
			mode = filemode_WriteAppend;
			if (glk_fileref_does_file_exist(fref) == false)
				force_header = true;
		}
		else mode = filemode_Write;
	} else {
		mode = filemode_Read;
		if (glk_fileref_does_file_exist(fref) == false) {
			glk_fileref_destroy(fref);
			return FileIO_Error(extf, "tried to open a file which does not exist");
		}
	}
	str = glk_stream_open_file(fref, mode, 0);
	glk_fileref_destroy(fref);
	if (str == 0) return FileIO_Error(extf, "tried to open a file but failed");
	struc-->AUXF_STREAM = str;
	if (write_flag) {
		if (append_flag)
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_APPEND;
		else
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_WRITE;
		glk_stream_set_current(str);
		if ((append_flag == FALSE) || (force_header)) {
			print "- ";
			for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
			print " ", (string) struc-->AUXF_FILENAME, "^";
		}
	} else {
		struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_READ;
		ch = FileIO_GetC(extf);
		if (ch ~= '-' or '*') { jump BadFile; }
		if (ch == '-')
			return FileIO_Error(extf, "tried to open a file which was incomplete");
		ch = FileIO_GetC(extf);
		if (ch ~= ' ') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		owner = struc-->AUXF_IFID_OF_OWNER;
		ix = 3;
		if (owner == UUID_ARRAY) ix = 8;
		if (owner ~= NULL) {
			for (: ix <= owner->0: ix++) {
				ch = FileIO_GetC(extf);
				if (ch == -1) { jump BadFile; }
				if (ch ~= owner->ix) not_this_ifid = true;
				if (ch == ' ') break;
			}
			if (not_this_ifid == false) {
				ch = FileIO_GetC(extf);
				if (ch ~= ' ') { jump BadFile; }
			}
		}
		while (ch ~= -1) {
			ch = FileIO_GetC(extf);
			if (ch == 10 or 13) break;
		}
		if (not_this_ifid) {
			struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
			glk_stream_close(str, 0);
			return FileIO_Error(extf,
				"tried to open a file owned by another project");
		}
	}
	return struc-->AUXF_STREAM;
	.BadFile;
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
	glk_stream_close(str, 0);
	return FileIO_Error(extf, "tried to open a file which seems to be malformed");
];

[ FileIO_Close extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_READ or
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf, "tried to close a file which is not open");
	if ((struc-->AUXF_BINARY == false) &&
		(struc-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
		glk_set_window(gg_mainwin);
	}
	if (struc-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND) {
		glk_stream_set_position(struc-->AUXF_STREAM, 0, 0); ! seek start
		glk_put_char_stream(struc-->AUXF_STREAM, '*'); ! mark as complete
	}
	glk_stream_close(struc-->AUXF_STREAM, 0);
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
];

[ FileIO_GetC extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_OPEN_FOR_READ) return -1;
	return glk_get_char_stream(struc-->AUXF_STREAM);
];

[ FileIO_PutC extf char  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf,
			"tried to write to a file which is not open for writing");
	return glk_put_char_stream(struc-->AUXF_STREAM, char);
];

[ FileIO_PrintLine extf ch  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	for (::) {
		ch = FileIO_GetC(extf);
		if (ch == -1) rfalse;
		if (ch == 10 or 13) { print "^"; rtrue; }
		print (char) ch;
	}
];

[ FileIO_PrintContents extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "printing text will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	while (FileIO_PrintLine(extf)) ;
	FileIO_Close(extf);
	rtrue;
];

[ FileIO_PutContents extf text append_flag  struc str ch;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing text will not work with binary files");
	str = FileIO_Open(extf, true, append_flag);
	if (str == 0) rfalse;
	@push say__p; @push say__pc;
	ClearParagraphing();
	PrintText(text);
	FileIO_Close(extf);
	@pull say__pc; @pull say__p;
	rfalse;
];

[ FileIO_PutTable extf tab rv  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write table to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing a table will not work with binary files");
	if (FileIO_Open(extf, true) == 0) rfalse;
	rv = TablePrint(tab);
	FileIO_Close(extf);
	if (rv) return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	rtrue;
];

[ FileIO_GetTable extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to read table from a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "reading a table will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	TableRead(tab, extf);
	FileIO_Close(extf);
	rtrue;
];

#IFNOT; ! TARGET_GLULX
[ FileIO_Exists extf; rfalse; ];
[ FileIO_Ready extf; rfalse; ];
[ FileIO_GetC extf; return -1; ];
[ FileIO_PutTable extf tab;
	return FileIO_Error(extf, "external files can only be used under Glulx");
];
[ FileIO_MarkReady extf status; FileIO_PutTable(extf); ];
[ FileIO_GetTable extf tab; FileIO_PutTable(extf); ];
[ FileIO_PrintContents extf; FileIO_PutTable(extf); ];
[ FileIO_PutContents extf; FileIO_PutTable(extf); ];
#ENDIF; ! TARGET_GLULX

#IFNOT; ! PLUGIN_FILES
[ FileIO_GetC extf; return -1; ];
#ENDIF; ! PLUGIN_FILES

Constant MAX_MSTACK_FRAME = 2 + 6;
Constant MSTACK_CAPACITY = 20;
Constant MSTACK_SIZE = MSTACK_CAPACITY*MAX_MSTACK_FRAME;

Array MStack --> MSTACK_SIZE;
Global MStack_Top = 0; ! Topmost word currently used

[ Mstack_Create_Frame creator id extent;
	if (creator == 0) rfalse;
	extent = creator.call(MStack_Top+2, 1);
	if (extent == 0) rfalse;
	if (MStack_Top + MAX_MSTACK_FRAME >= MSTACK_SIZE + 2) {
		RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);
		Mstack_Backtrace();
		rfalse;
	}
	MStack_Top++;
	MStack-->MStack_Top = id;
	MStack_Top++;
	MStack_Top = MStack_Top + extent;
	MStack-->MStack_Top = -(extent+2);
	rtrue;
];

[ Mstack_Destroy_Frame creator id pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) rfalse; ! Not found: do nothing
	MStack_Top = pos - 2; ! Clear mstack down to just below this frame
	if (creator) creator.call(pos, -1);
	rtrue;
];

Global MStack_Frame_Extent = 0;

[ Mstack_Seek_Frame id pos;
	pos = MStack_Top;
	while ((pos > 0) && (MStack-->pos ~= 0)) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		if (MStack-->(pos+1) == id) return pos+2;
	}
	MStack_Frame_Extent = 0;
	return 0; ! Not found
];

[ Mstack_Backtrace pos k;
	print "Mstack backtrace: size ", MStack_Top+1, " words^";
	pos = MStack_Top;
	while (MStack-->pos ~= 0) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		print "Block at ", pos+2,
			" owner ID ", MStack-->(pos+1), " size ", MStack_Frame_Extent, "^";
		for (k=0: k<MStack_Frame_Extent: k++) print MStack-->(pos+2+k), " ";
		print "^";
	}
];

[ MstVO id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		print "Variable unavailable for this action, activity or rulebook: ",
			"internal ID number ",
			id, "/", off, "^";
		rfalse;
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];

[ MstVON id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		return 0; ! word position 0 on the M-stack
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];

#IFNDEF MEMORY_ECONOMY;
Array rulebook_var_creators --> 0 0 0 0 0 0 0 0 0 0 RBSTVC_10 0 RBSTVC_12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#ENDIF;
[  RBSTVC_10 pos state;
    if (state == 1) {
        MStack-->pos = selfobj; pos++;
    } else {
        pos++;
    }
    return 1;
];
[  RBSTVC_12 pos state;
    if (state == 1) {
        MStack-->pos = false; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = false; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 6;
];


[ MStack_CreateRBVars rb cr;
#IFDEF MEMORY_ECONOMY;
switch (rb) {
10: cr = RBSTVC_10;
12: cr = RBSTVC_12;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#ENDIF;

	if (cr == 0) return;
	Mstack_Create_Frame(cr, rb);
];

[ MStack_DestroyRBVars rb cr;
#IFDEF MEMORY_ECONOMY;
switch (rb) {
10: cr = RBSTVC_10;
12: cr = RBSTVC_12;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#ENDIF;

	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, rb);
];

Array activity_var_creators --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;


[ MStack_CreateAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Create_Frame(cr, av + 10000);
];

[ MStack_DestroyAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, av + 10000);
];


[ Perform_Undo;
	#ifdef PREVENT_UNDO; L__M(##Miscellany, 70); return; #endif;
	if (turns == 1) { L__M(##Miscellany, 11); return; }
	if (undo_flag == 0) { L__M(##Miscellany, 6); return; }
	if (undo_flag == 1) { L__M(##Miscellany, 7); return; }
	if (~~AllowUndo()) return;
	if (VM_Undo() == 0) L__M(##Miscellany, 7);
];
[ ANNOUNCE_SCORE_R;
	if (actor ~= player) rfalse;
	#ifdef NO_SCORING; L__M(##Score, 2);
	#ifnot; GL__M(##Score); PrintRank();
	#endif;
];

[ SWITCH_SCORE_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#ifdef NO_SCORING; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=1; #endif;
];

[ REP_SWITCH_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#ifndef NO_SCORING; GL__M(##NotifyOn); #endif;
];

[ SWITCH_SCORE_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#ifdef NO_SCORING; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=0; #endif;
];

[ REP_SWITCH_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#ifndef NO_SCORING; GL__M(##NotifyOff); #endif;
];

[ PREFER_SOMETIMES_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=1;
]; ! Brief

[ REP_PREFER_SOMETIMES_ABBR_R;
	if (actor ~= player) rfalse;
	print (string) Story; GL__M(##LMode1);
]; ! Brief

[ PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=2;
]; ! Verbose

[ REP_PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (string) Story; GL__M(##LMode2);
]; ! Verbose

[ PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=3;
]; ! Superbrief

[ REP_PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (string) Story; GL__M(##LMode3);
]; ! Superbrief

[ ANNOUNCE_PRONOUN_MEANINGS_R x y c d;
	if (actor ~= player) rfalse;
	GL__M(##Pronouns, 1);

	c = (LanguagePronouns-->0)/3;
	if (player ~= selfobj) c++;

	if (c==0) return GL__M(##Pronouns, 4);

	for (x = 1, d = 0 : x <= LanguagePronouns-->0: x = x+3) {
		print "~", (address) LanguagePronouns-->x, "~ ";
		y = LanguagePronouns-->(x+2);
		if (y == NULL) GL__M(##Pronouns, 3);
		else { GL__M(##Pronouns, 2); print (the) y; }
		d++;
		if (d < c-1) print ", ";
		if (d == c-1) print (string) LISTAND__TX;
	}
	if (player ~= selfobj) {
		print "~", (address) ME1__WD, "~ "; GL__M(##Pronouns, 2);
		c = player; player = selfobj;
		print (the) c; player = c;
	}
	".";
];

!Constant TRACE_I7_SPACING;

[ ClearParagraphing;
	say__p = 0; say__pc = 0;
];

[ DivideParagraphPoint;
	#ifdef TRACE_I7_SPACING; print "[DPP", say__p, say__pc, "]"; #endif;
	if (say__p) {
		new_line; say__p = 0; say__pc = say__pc | PARA_COMPLETED;
		if (say__pc & PARA_PROMPTSKIP) say__pc = say__pc - PARA_PROMPTSKIP;
		if (say__pc & PARA_SUPPRESSPROMPTSKIP) say__pc = say__pc - PARA_SUPPRESSPROMPTSKIP;
	}
	#ifdef TRACE_I7_SPACING; print "[-->", say__p, say__pc, "]"; #endif;
	say__pc = say__pc | PARA_CONTENTEXPECTED;
];

[ ParaContent;
	if (say__pc & PARA_CONTENTEXPECTED) {
		say__pc = say__pc - PARA_CONTENTEXPECTED;
		say__p = 1;
	}
];

[ GoingLookBreak;
	if (say__pc & PARA_COMPLETED == 0) new_line;
	ClearParagraphing();
];

[ CommandClarificationBreak;
	new_line;
	ClearParagraphing();
];

[ RunParagraphOn;
	#ifdef TRACE_I7_SPACING; print "[RPO", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
	say__pc = say__pc | PARA_SUPPRESSPROMPTSKIP;
];

[ SpecialLookSpacingBreak;
	#ifdef TRACE_I7_SPACING; print "[SLS", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
];

[ EnsureBreakBeforePrompt;
	if ((say__p) ||
		((say__pc & PARA_PROMPTSKIP) && ((say__pc & PARA_SUPPRESSPROMPTSKIP)==0)))
		new_line;
	ClearParagraphing();
];

[ PrintSingleParagraph matter;
	say__p = 1;
	say__pc = say__pc | PARA_NORULEBOOKBREAKS;
	PrintText(matter);
	DivideParagraphPoint();
	say__pc = 0;
];

[ STextSubstitution;
	if (say__n ~= 1) print "s";
];

[ PrintPrompt i;
	style roman;
	EnsureBreakBeforePrompt();
	PrintText( (Global_Vars-->1) );
	ClearBoxedText();
	ClearParagraphing();
	enable_rte = true;
];

Global pending_boxed_quotation; ! a routine to overlay the quotation on screen

[ DisplayBoxedQuotation Q;
	pending_boxed_quotation = Q;
];

[ ClearBoxedText i;
	if (pending_boxed_quotation) {
		for (i=0: Runtime_Quotations_Displayed-->i: i++)
			if (Runtime_Quotations_Displayed-->i == pending_boxed_quotation) {
				pending_boxed_quotation = 0;
				return;
			}
		Runtime_Quotations_Displayed-->i = pending_boxed_quotation;

		ClearParagraphing();
		pending_boxed_quotation();
		ClearParagraphing();

		pending_boxed_quotation = 0;
	}
];

[ NotifyTheScore;
#Ifndef NO_SCORING;
	if (notify_mode == 1) {
		DivideParagraphPoint();
		VM_Style(NOTE_VMSTY);
		print "["; L__M(##Miscellany, 50, score-last_score); print ".]^";
		VM_Style(NORMAL_VMSTY);
	}
#Endif;
];

#Ifdef TARGET_ZCODE;
#Iftrue (#version_number == 6);
[ DrawStatusLine; Z6_DrawStatusLine(); ];
#Endif;
#Endif;

#Ifndef DrawStatusLine;
[ DrawStatusLine width posb;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(1); VM_MoveCursorInStatusLine(1, 1); 
	if (statuswin_current) {
		width = VM_ScreenWidth(); posb = width-15;
		spaces width;
		ClearParagraphing();
		if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
			VM_MoveCursorInStatusLine(1, 2);
			switch(metaclass(left_hand_status_line)) {
				String: print (string) left_hand_status_line;
				Routine: left_hand_status_line();
			}
			VM_MoveCursorInStatusLine(1, posb);
			switch(metaclass(right_hand_status_line)) {
				String: print (string) right_hand_status_line;
				Routine: right_hand_status_line();
			}
		}
		VM_MoveCursorInStatusLine(1, 1); VM_MainWindow();
	}
	ClearParagraphing();
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;

[ SL_Score_Moves;
	if (not_yet_in_play) return;
	#ifdef NO_SCORING; print sline2; #ifnot; print sline1, "/", sline2; #endif;
];

[ SL_Location;
	if (not_yet_in_play) return;
	if (location == thedark) {
		BeginActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
		if (ForActivity(PRINTING_NAME_OF_DARK_ROOM_ACT) == false)
 			L__M(##Miscellany, 71);
		EndActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
	} else {
		FindVisibilityLevels();
		if (visibility_ceiling == location) print (name) location;
		else print (The) visibility_ceiling;
	}
];

[ Banner;
   BeginActivity(PRINTING_BANNER_TEXT_ACT);
   if (ForActivity(PRINTING_BANNER_TEXT_ACT) == false) {
	   	VM_Style(HEADER_VMSTY);
		print (string) Story;
		VM_Style(NORMAL_VMSTY);
		new_line;
		print (string) Headline;
		#ifdef Story_Author;
		print " by ", (string) Story_Author;
		#endif; ! Story_Author
		new_line;
		VM_Describe_Release();
		print " / Inform 7 build ", (string) NI_BUILD_COUNT, " ";
		print "(I6/v"; inversion;
		print " lib ", (string) LibRelease, ") ";
		#Ifdef STRICT_MODE;
		print "S";
		#Endif; ! STRICT_MODE
		#Ifdef DEBUG;
		print "D";
		#Endif; ! DEBUG
		new_line;
    }
    EndActivity(PRINTING_BANNER_TEXT_ACT);
];

[ DecimalNumber num; print num; ];

[ EnglishNumber n; LanguageNumber(n); ];

[ PrintText x;
	if (x ofclass String) print (string) x;
	if (x ofclass Routine) (x)();
];
[ I7_String x; PrintText(x); ]; ! An alternative name now used only by extensions

[ PrintOrRun obj prop no_break  routine_return_value;
	!print "(", obj, ".", prop, ";", say__p, say__pc, ")";
	if (prop == 0) {
		print (name) prop; routine_return_value = true;
	} else {
		switch (metaclass(obj.prop)) {
			nothing:
				routine_return_value = false;
			String:
				if (obj.prop == EMPTY_TEXT_VALUE) break;
				print (string) obj.prop; !if (no_break == false) new_line;
				routine_return_value = true;
			Routine:
				routine_return_value = RunRoutines(obj, prop);
				!print "[", routine_return_value, "]";
		}
	}
	
	if (routine_return_value) {
		say__p = 1;
		if (no_break == false) {
			new_line;
			!print "(DP->", say__p, say__pc, ")";
			DivideParagraphPoint();
			!print "(to", say__p, say__pc, ")";
		}
	}

	!print "(-->", say__p, say__pc, ")";
	return routine_return_value;
];

Array StorageForShortName buffer 250;

[ CPrintOrRun obj prop  v length i;
    if ((obj ofclass String or Routine) || (prop == 0))
        VM_PrintToBuffer (StorageForShortName, 160, obj);
    else {
    	if (obj.prop == NULL) rfalse;
        if (metaclass(obj.prop) == Routine or String)
            VM_PrintToBuffer(StorageForShortName, 160, obj, prop);
        else return RunTimeError(2, obj, prop);
	}

    length = StorageForShortName-->0;

    StorageForShortName->WORDSIZE = VM_LowerToUpperCase(StorageForShortName->WORDSIZE);
    for (i=WORDSIZE: i<length+WORDSIZE: i++) print (char) StorageForShortName->i;
    if (i>WORDSIZE) say__p = 1;

    return;
];

[ Cap str nocaps;
    if (nocaps) print (string) str;
    else CPrintOrRun(str, 0);
];

[ PSN__ o;
    if (o == 0) { print (string) NOTHING__TX; rtrue; }
    switch (metaclass(o)) {
		Routine:  print "<routine ", o, ">"; rtrue;
		String:   print "<string ~", (string) o, "~>"; rtrue;
		nothing:  print "<illegal object number ", o, ">"; rtrue;
    }
    CarryOutActivity(PRINTING_THE_NAME_ACT, o);
];

Global caps_mode = false;

[ STANDARD_NAME_PRINTING_R obj;
	obj = parameter_object;
    if (obj == 0) {
    	print (string) NOTHING__TX; return;
    }
    switch (metaclass(obj)) {
		Routine:  print "<routine ", obj, ">"; return;
		String:   print "<string ~", (string) obj, "~>"; return;
		nothing:  print "<illegal object number ", obj, ">"; return;
    }
    if (obj == player) { 
   	    if (indef_mode == NULL && caps_mode) print (string) YOU__TX;
   	    else print (string) YOURSELF__TX;
   	    return;
   	}
    #Ifdef LanguagePrintShortName;
    if (LanguagePrintShortName(obj)) return;
    #Endif; ! LanguagePrintShortName
    if (indef_mode && obj.&short_name_indef ~= 0 &&
    	PrintOrRun(obj, short_name_indef, true) ~= 0) return;
    if (caps_mode &&
    	obj.&cap_short_name ~= 0 && PrintOrRun(obj, cap_short_name, true) ~= 0) {
    	caps_mode = false;
    	return;
    }
    if (obj.&short_name ~= 0 && PrintOrRun(obj, short_name, true) ~= 0) return;
    print (object) obj;
];

Global short_name_case;

[ PrefaceByArticle obj acode pluralise capitalise  i artform findout artval;
    if (obj provides articles) {
        artval=(obj.&articles)-->(acode+short_name_case*LanguageCases);
        if (capitalise)
            print (Cap) artval, " ";
        else
            print (string) artval, " ";
        if (pluralise) return;
        print (PSN__) obj; return;
    }

    i = GetGNAOfObject(obj);
    if (pluralise) {
        if (i < 3 || (i >= 6 && i < 9)) i = i + 3;
    }
    i = LanguageGNAsToArticles-->i;

    artform = LanguageArticles
        + 3*WORDSIZE*LanguageContractionForms*(short_name_case + i*LanguageCases);

    #Iftrue (LanguageContractionForms == 2);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 3);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 4);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    if (artform-->(acode+6) ~= artform-->(acode+9)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms > 4);
    findout = true;
    #Endif; ! LanguageContractionForms

    #Ifdef TARGET_ZCODE;
    if (standard_interpreter ~= 0 && findout) {
        StorageForShortName-->0 = 160;
        @output_stream 3 StorageForShortName;
        if (pluralise) print (number) pluralise; else print (PSN__) obj;
        @output_stream -3;
        acode = acode + 3*LanguageContraction(StorageForShortName + 2);
    }
    #Ifnot; ! TARGET_GLULX
    if (findout) {
        if (pluralise)
            Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);
        else
            Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);
        acode = acode + 3*LanguageContraction(StorageForShortName);
    }
    #Endif; ! TARGET_

    Cap (artform-->acode, ~~capitalise); ! print article
    if (pluralise) return;
    print (PSN__) obj;
];

[ IndefArt obj i;
	if (obj == 0) { print (string) NOTHING__TX; rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) { indef_mode = NULL; print (PSN__) obj; indef_mode = i; return; }
    if ((obj provides article) && (obj.article ~= EMPTY_TEXT_VALUE)) {
        PrintOrRun(obj, article, true); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2); indef_mode = i;
];

[ CIndefArt obj i;
	if (obj == 0) { CPrintOrRun(NOTHING__TX, 0); rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) {
    	indef_mode = NULL;
		caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((obj provides article) && (obj.article ~= EMPTY_TEXT_VALUE)) {
        CPrintOrRun(obj, article); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2, 0, 1); indef_mode = i;
];

[ DefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 1); indef_mode = i;
];

[ CDefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((obj ofclass Object) && (obj has proper || obj == player)) {
    	indef_mode = NULL;
    	caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 0); indef_mode = i;
];

[ PrintShortName obj i;
    i = indef_mode; indef_mode = NULL;
    PSN__(obj); indef_mode = i;
];

[ I7_SOO_PAR oldval count; if (count <= 1) return count; return random(count); ];
[ I7_SOO_RAN oldval count v; if (count <= 1) return count;
	v = oldval; while (v == oldval) v = random(count); return v; ];
[ I7_SOO_STI oldval count v; if (oldval) return oldval; return I7_SOO_PAR(oldval, count); ];
[ I7_SOO_CYC oldval count; oldval++; if (oldval > count) oldval = 1; return oldval; ];
[ I7_SOO_STOP oldval count; oldval++; if (oldval > count) oldval = count; return oldval; ];
[ I7_SOO_TAP oldval count tn rn c; if (count <= 1) return count; tn = count*(count+1)/2;
	rn = random(tn); for (c=1:c<=count:c++) { rn = rn - c; if (rn<=0) return (count-c+1); } ];
[ I7_SOO_TRAN oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_RAN(oldval%(count+1), count); ];
[ I7_SOO_TPAR oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_PAR(oldval%(count+1), count); ];

Array I7_SOO_SHUF->32;

[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
	base = count+1;
	v = oldval%base; oldval = oldval/base; ct = oldval%base; sd = oldval/base;
	if (count > 32) return I7_SOO_PAR(oldval, count);
	if (count <= 1) v = count;
	else {
		!print "^In v=", v, " ct=", ct, " sd=", sd, "^";
		cc = base*base;
		scope = MAX_POSITIVE_NUMBER/cc - cc - base;
		if (scope%2==0) scope--;
		if (scope<0) scope = -scope;
		!print "Scope = ", scope, "^";
		if (sd == 0) { sd = random(scope); ct=0; }
		for (i=0:i<count:i++) I7_SOO_SHUF->i = i;
		ssd = sd;
		for (i=0:i<count-1:i++) {
			j = (sd)%(count-i)+i; sd = (sd*31973)+17; if (sd<0) sd=-sd;
			s = I7_SOO_SHUF->j; I7_SOO_SHUF->j = I7_SOO_SHUF->i; I7_SOO_SHUF->i = s;
		}
		!for (i=0:i<count:i++) print I7_SOO_SHUF->i, " "; print "^";
		v = (I7_SOO_SHUF->ct)+1;
		ct++; if (ct >= count) { ct = 0; ssd = 0; }
	}
	!print "Out v=", v, " ct=", ct, " ssd=", sd, "^";
	!print "Return ", v + ct*base + ssd*base*base, "^";
	return v + ct*base + ssd*base*base;
];

Constant RR_NAME     		4;
Constant RR_PERMISSIONS		5;
Constant RR_STORAGE			6;
Constant RR_KIND			7;
Constant RR_HANDLER			8;
Constant RR_DESCRIPTION		9;

Constant VALENCY_MASK = RELS_EQUIVALENCE+RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;
[ RELATION_TY_EquivalenceAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & RELS_EQUIVALENCE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		perms = perms + RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC == 0) perms = perms + RELS_SYMMETRIC;
	}
	if ((set == false) && (state)) {
		perms = perms - RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to an equivalence relation ***";		
];

[ RELATION_TY_SymmetricAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & RELS_SYMMETRIC) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) perms = perms + RELS_SYMMETRIC;
	if ((set == false) && (state)) perms = perms - RELS_SYMMETRIC;
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a symmetric relation ***";		
];

[ RELATION_TY_OToOAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE+RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-one relation ***";		
];

[ RELATION_TY_OToVAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-various relation ***";		
];

[ RELATION_TY_VToOAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-one relation ***";		
];

[ RELATION_TY_VToVAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == 0) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-various relation ***";		
];

[ Relation_Now1to1 obj1 relation_property obj2 ol; ! Assert 1-1 true
	if (obj2) objectloop (ol provides relation_property)
		if (ol.relation_property == obj2) ol.relation_property = nothing;
	if (obj1) obj1.relation_property = obj2;
];

[ Relation_NowN1toV obj1 relation_property obj2; ! Assert 1-1 false
	if ((obj1) && (obj1.relation_property == obj2)) obj1.relation_property = nothing;
];

[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N; ! Assert 1-1 true
	if (obj2) {
		N = KOVDomainSize(KOV);
		for (ol=1: ol<=N: ol++)
			if (GProperty(KOV, ol, relation_property) == obj2)
				WriteGProperty(KOV, ol, relation_property, 0);
	}
	if (obj1) WriteGProperty(KOV, obj1, relation_property, obj2);
];

[ Relation_NowN1toVV obj1 obj2 KOV relation_property; ! Assert 1-1 false
	if ((obj1) && (GProperty(KOV, obj1, relation_property) == obj2))
		WriteGProperty(KOV, obj1, relation_property, 0);
];

[ Relation_NowS1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 true
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property)) {
		if (obj1.relation_property) { (obj1.relation_property).relation_property = 0; }
		if (obj2.relation_property) { (obj2.relation_property).relation_property = 0; }
		obj1.relation_property = obj2; obj2.relation_property = obj1;
	}
];

[ Relation_NowSN1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 false
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property) &&
		(obj1.relation_property == obj2)) {
		obj1.relation_property = 0; obj2.relation_property = 0;
	}
];

[ Relation_NowS1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 true
	if (GProperty(KOV, obj1, relation_property))
		WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);
	if (GProperty(KOV, obj2, relation_property)) 
		WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);
	WriteGProperty(KOV, obj1, relation_property, obj2);
	WriteGProperty(KOV, obj2, relation_property, obj1);
];

[ Relation_NowSN1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 false
	if (GProperty(KOV, obj1, relation_property) == obj2) {
		WriteGProperty(KOV, obj1, relation_property, 0);
		WriteGProperty(KOV, obj2, relation_property, 0);
	}
];

Constant VTOVS_LEFT_INDEX_PROP = 0;
Constant VTOVS_RIGHT_INDEX_PROP = 1;
Constant VTOVS_LEFT_DOMAIN_SIZE = 2;
Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;
Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;
Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;
Constant VTOVS_CACHE_BROKEN = 6;
Constant VTOVS_CACHE = 7;

[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowVtoV(obj2, relation, obj1, false); }
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	vtov_structure-->pr = (vtov_structure-->pr) | i1;
];

[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowNVtoV(obj2, relation, obj1, false); }
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) vtov_structure-->pr = vtov_structure-->pr - i1;
];

[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	if (sym && (obj2 > obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else { RunTimeProblem(RTP_IMPREL, obj1, relation); rfalse; }
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else { RunTimeProblem(RTP_IMPREL, obj2, relation); rfalse; }
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) rtrue; rfalse;
];

[ Relation_NowEquiv obj1 relation_property obj2 big little;
	big = obj1.relation_property; little = obj2.relation_property;
	if (big == little) return;
	if (big < little) { little = obj1.relation_property; big = obj2.relation_property; }
	objectloop (obj1 provides relation_property)
		if (obj1.relation_property == big) obj1.relation_property = little;
];

[ Relation_NowNEquiv obj1 relation_property obj2 old new;
	old = obj1.relation_property; new = obj2.relation_property;
	if (old ~= new) return;
	new = 0;
	objectloop (obj2 provides relation_property)
		if (obj2.relation_property > new) new = obj2.relation_property;
	new++;
	obj1.relation_property = new;
];

[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;
	big = GProperty(KOV, obj1, relation_property);
	little = GProperty(KOV, obj2, relation_property);
	if (big == little) return;
	if (big < little) {
		little = GProperty(KOV, obj1, relation_property);
		big = GProperty(KOV, obj2, relation_property);
	}
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) == big)
			WriteGProperty(KOV, i, relation_property, little);
];

[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;
	old = GProperty(KOV, obj1, relation_property); 
	new = GProperty(KOV, obj2, relation_property);
	if (old ~= new) return;
	new = 0;
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) > new)
			new = GProperty(KOV, i, relation_property);
	new++;
	WriteGProperty(KOV, obj1, relation_property, new);
];

[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	proutine1 = vtov_structure-->VTOVS_LEFT_PRINTING_ROUTINE;
	proutine2 = vtov_structure-->VTOVS_RIGHT_PRINTING_ROUTINE;
 
	if (pr && pr2) {
		objectloop (obj1 provides pr)
		  objectloop (obj2 provides pr2) {
				if (sym && obj2 > obj1) continue;
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1;
					if (sym) print "  <=>  "; else print "  >=>  ";
					print (the) obj2, "^";
				}
		  }
		return;
	}
	if (pr && (pr2==0)) {
		objectloop (obj1 provides pr)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1, "  >=>  ";
					(proutine2).call(obj2);
					print "^";
				}
		  }
		return;
	}
	if ((pr==0) && (pr2)) {
		for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  objectloop (obj2 provides pr2) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ";
					(proutine1).call(obj1);
					print "  >=>  ", (the) obj2, "^";
				}
		  }
		return;
	}
	for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++)
			if (Relation_TestVtoV(obj1, relation, obj2)) {
				if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
				print "  ";
				(proutine1).call(obj1);
				print "  >=>  ";
				(proutine2).call(obj2);
				print "^";
		  }
];

[ Relation_ShowOtoO relation sym x relation_property t N obj1 obj2;
	relation_property = relation-->RR_STORAGE;
	t = KindBaseTerm(relation-->RR_KIND, 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property) {
			obj2 = obj1.relation_property;
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
			print "  ", (The) obj1;
			if (sym) print "  ==  "; else print "  >=>  ";
			print (the) obj2, "^";
		}
	} else {
		for (obj1=1: obj1<=N: obj1++) {
			obj2 = GProperty(t, obj1, relation_property);
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
			print "  ";
			PrintKindValuePair(t, obj1);
			if (sym) print "  ==  "; else print "  >=>  ";
			PrintKindValuePair(t, obj2);
			print "^";
		}
	}
];

[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;
	relation_property = relation-->RR_STORAGE;
	t1 = KindBaseTerm(relation-->RR_KIND, 0); ! Kind of left term
	t2 = KindBaseTerm(relation-->RR_KIND, 1); ! Kind of right term
	if (t2 == OBJECT_TY) {
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  "; PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		}
	} else {
		N2 = KOVDomainSize(t2);
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ";
					PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		}
	}
];

[ RSE_Flip KOV v relation_property x;
	x = GProperty(KOV, v, relation_property); x = -x;
	WriteGProperty(KOV, v, relation_property, x);
];
[ RSE_Set KOV v relation_property;
	if (GProperty(KOV, v, relation_property) < 0) rtrue; rfalse;
];
[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;
	print (string) relation-->RR_DESCRIPTION, ":^";
	relation_property = relation-->RR_STORAGE;
	t = KindBaseTerm(relation-->RR_KIND, 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property)
			obj1.relation_property = -(obj1.relation_property);
		objectloop (obj1 provides relation_property) {
			if (obj1.relation_property < 0) {
				v = obj1.relation_property; c = 0;
				objectloop (obj2 has workflag2) give obj2 ~workflag2;
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property == v) {
						give obj2 workflag2;
						obj2.relation_property = -v;
						c++;
					}
				}
				if (c>1) {
					somegroups = true;
					print "  { ";
					WriteListOfMarkedObjects(ENGLISH_BIT);
					print " }^";
				} else obj1.relation_property = v;
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0; objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0) { c++; give obj1 workflag2; }
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c < 4) { WriteListOfMarkedObjects(ENGLISH_BIT); print " in"; }
		else print c;
		if (c == 1) print " a";
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0)
				obj1.relation_property = -(obj1.relation_property);
	} else {
		! A slower method, since we have less efficient storage:
		for (obj1 = 1: obj1 <= N: obj1++)
			RSE_Flip(t, obj1, relation_property);
		for (obj1 = 1: obj1 <= N: obj1++) {
			if (RSE_Set(t, obj1, relation_property)) {
				v = GProperty(t, obj1, relation_property);
				c = 0;
				for (obj2 = 1: obj2 <= N: obj2++)
					if (GProperty(t, obj2, relation_property) == v)
						c++;
				if (c>1) {
					somegroups = true;
					print "  {";
					d = 0;
					for (obj2 = 1: obj2 <= N: obj2++) {
						if (GProperty(t, obj2, relation_property) == v) {
							print " "; PrintKindValuePair(t, obj2);
							if (d < c-1) print ","; print " ";
							RSE_Flip(t, obj2, relation_property);
							d++;
						}
					}
					print "}^";
				} else WriteGProperty(t, obj1, relation_property, v);
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0;
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property)) c++;
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c == 1) print "a"; else print c;
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property))
				RSE_Flip(t, obj1, relation_property);
	}
];

#ifndef FAST_ROUTE_FINDING;
#ifndef SLOW_ROUTE_FINDING;
#ifdef TARGET_GLULX;
Constant FAST_ROUTE_FINDING;
#ifnot;
Constant SLOW_ROUTE_FINDING;
#endif;
#endif;
#endif;

Constant NUM_DOORS = 4;
Constant NUM_ROOMS = 13;

Array DoorRoutingViable -> NUM_DOORS+1;

Global map_has_changed = true;
Global last_filter; Global last_use_doors;

[ SignalMapChange; map_has_changed = true; ];

[ MapRouteTo from to filter use_doors count  oy oyi ds;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	if ((filter) && (filter(from) == 0)) return nothing;
	if ((filter) && (filter(to) == 0)) return nothing;
	if ((last_filter ~= filter) || (last_use_doors ~= use_doors)) map_has_changed = true;
	oyi = 0;
	objectloop (oy has mark_as_room) {
		if ((filter == 0) || (filter(oy))) {
			if (oy.room_index == -1) map_has_changed = true;
			oy.room_index = oyi++;
		} else {
			if (oy.room_index >= 0) map_has_changed = true;
			oy.room_index = -1;
		}
	}
	oyi = 0;
	objectloop (oy ofclass K4_door) {
		ds = false;
		if ((use_doors & 2) ||
			(oy has open) || ((oy has openable) && (oy hasnt locked))) ds = true;
		if (DoorRoutingViable->oyi ~= ds) map_has_changed = true;
		DoorRoutingViable->oyi = ds;
		oyi++;
	}
	if (map_has_changed) {
		#ifdef FAST_ROUTE_FINDING; ComputeFWMatrix(filter, use_doors); #endif;
		map_has_changed = false; last_filter = filter; last_use_doors = use_doors;
	}
	#ifdef FAST_ROUTE_FINDING;
	if (count) return FastCountRouteTo(from, to, filter, use_doors);
	return FastRouteTo(from, to, filter, use_doors);
	#ifnot;
	if (count) return SlowCountRouteTo(from, to, filter, use_doors);
	return SlowRouteTo(from, to, filter, use_doors);
	#endif;
];

#ifdef FAST_ROUTE_FINDING;
Array FWMatrix --> NUM_ROOMS*NUM_ROOMS;

[ FastRouteTo from to filter use_doors diri i dir oy;
	if (from == to) return nothing;
	i = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (i == 0) return nothing;
	diri = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))%No_Directions;
	i=0; objectloop (dir ofclass K3_direction) {
		if (i == diri) return dir;
		i++;
	}
	return nothing;
];

[ FastCountRouteTo from to filter use_doors  k;
	if (from == to) return 0;
	k = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (k == 0) return -1;
	return k;
];

[ ComputeFWMatrix filter use_doors  oy ox oj axy ayj axj dir diri nd row;
	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0)
			FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = 0;

	objectloop (oy has mark_as_room) if (oy.room_index >= 0) {
		row = (oy.IK_1)*No_Directions;
		for (diri=0: diri<No_Directions: diri++) {
			ox = Map_Storage-->(row+diri);
			if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
				FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
				continue;
			}
			if (use_doors && (ox ofclass K4_door) &&
				((use_doors & 2) || (DoorRoutingViable->(ox.IK_4)))) {
				@push location; location = oy;
				ox = ox.door_to();
				@pull location;
				if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
					FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
					continue;
				}
			}
		}	
	}

	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0) {
			axy = (FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))/No_Directions;
			if (axy > 0)
				objectloop (oj has mark_as_room) if (oj.room_index >= 0) {
					ayj = (FWMatrix-->(oy.room_index*NUM_ROOMS + oj.room_index))/No_Directions;
					if (ayj > 0) {
						!print "Is it faster to go from ", (name) ox, " to ",
						!   (name) oj, " via ", (name) oy, "?^";
						axj = (FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index))/
							No_Directions;
						if ((axj == 0) || (axy + ayj < axj)) {
							!print "Yes^";
							FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index) =
								(axy + ayj)*No_Directions +
								(FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))%
									No_Directions;
						}
					}
				}
		}
];
#ENDIF;

#ifndef FAST_ROUTE_FINDING;
[ SlowRouteTo from to filter use_doors  obj dir in_direction progressed sl through_door;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	objectloop (obj has mark_as_room) obj.vector = 0;
	to.vector = 1;
	!print "Routing from ", (the) from, " to ", (the) to, "^";
	while (true) {
		progressed = false;
		!print "Pass begins^";
		objectloop (obj has mark_as_room)
			if ((filter == 0) || (filter(obj)))
				if (obj.vector == 0)
					objectloop (dir ofclass K3_direction) {
						in_direction = Map_Storage-->((obj.IK_1)*No_Directions + dir.IK_3);
						if (in_direction == nothing) continue;
						!print (the) obj, " > ", (the) dir, " > ", (the) in_direction, "^";
						if ((in_direction)
							&& (in_direction has mark_as_room)
							&& (in_direction.vector > 0)
							&& ((filter == 0) || (filter(in_direction)))) {
							obj.vector = dir | WORD_HIGHBIT;
							!print "* ", (the) obj, " vector is ", (the) dir, "^";
							progressed = true;
							continue;
						}
						if (use_doors && (in_direction ofclass K4_door) &&
							((use_doors & 2) ||
							 (in_direction has open) ||
							 ((in_direction has openable) && (in_direction hasnt locked)))) {
							sl = location; location = obj;
							through_door = in_direction.door_to();
							location = sl;
							!print "Through door is ", (the) through_door, "^";
							if ((through_door)
								&& (through_door has mark_as_room)
								&& (through_door.vector > 0)
								&& ((filter == 0) || (filter(through_door)))) {
								obj.vector = dir | WORD_HIGHBIT;
								!print "* ", (the) obj, " vector is ", (the) dir, "^";
								progressed = true;
								continue;
							}
						}
					}
		objectloop (obj has mark_as_room) obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) return from.vector;
		if (progressed == false) return from.vector;
	}
];

[ SlowCountRouteTo from to filter use_doors obj i;
	if (from == nothing) return -1;
	if (to == nothing) return -1;
	if (from == to) return 0;
	if (from has mark_as_room && to has mark_as_room) {
		obj = MapRouteTo(from,to,filter,use_doors);
		if (obj == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<NUM_ROOMS)) { i++; obj = MapConnection(obj,obj.vector); }
		return i;
	}
	return -1;
];
#ENDIF;

Constant MAX_ROUTE_LENGTH = 216 + 32;

[ RelationRouteTo relation from to count  handler;
	if (count) {
		if (from == nothing) return -1;
		if (to == nothing) return -1;
		if (relation == 0) return -1;
	} else {
		if (from == nothing) return nothing;
		if (to == nothing) return nothing;
		if (relation == 0) return nothing;
	}
	if (from == to) return nothing;
	if (((relation-->RR_PERMISSIONS) & RELS_ROUTE_FIND) == 0) {
		RunTimeProblem(RTP_ROUTELESS);
		return nothing;
	}
	if (relation-->RR_STORAGE == 0) return nothing;
	handler = relation-->RR_HANDLER;
	if (count) return handler(relation, RELS_ROUTE_FIND_COUNT, from, to);
	return handler(relation, RELS_ROUTE_FIND, from, to);
];

[ RelFollowVector rv from to  obj i;
	if (rv == nothing) return -1;
	i = 0; obj = from;
	while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
	return i;
];

[ OtoVRelRouteTo relation_property from to previous;
	while ((to) && (to provides relation_property) && (to.relation_property)) {
		previous = to.relation_property;
		previous.vector = to;
		if (previous == from) return to;
		to = previous;
	}
	return nothing;
];

[ VtoORelRouteTo relation_property from to next  start;
	start = from;
	while ((from) && (from provides relation_property) && (from.relation_property)) {
		next = from.relation_property;
		from.vector = next;
		if (from == to) return start.vector;
		from = next;
	}
	return nothing;
];

[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;
	vtov_structure = relation-->RR_STORAGE;
	if (vtov_structure-->VTOVS_CACHE)
		return FastVtoVRelRouteTo(relation, from, to, count);
	left_ix = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	objectloop (obj ofclass Object && obj provides vector) obj.vector = 0;
	to.vector = 1;
	while (true) {
		progressed = false;
		objectloop (obj ofclass Object && obj provides left_ix)
			if (obj.vector == 0) {
				objectloop (obj2 ofclass Object && obj2 provides pr2 && obj2.vector > 0) {
					if (Relation_TestVtoV(obj, relation, obj2)) {
						obj.vector = obj2 | WORD_HIGHBIT;
						progressed = true;
						continue;
					}
				}
			}
		objectloop (obj ofclass Object && obj provides left_ix)
			obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) break;
		if (progressed == false) break;
	}
	if (count) {
		if (from.vector == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
		return i;
	}
	return from.vector;
];

[ FastVtoVRelRouteTo relation from to count
	domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;
	domainsize = relation-->RR_STORAGE-->2; ! Number of left instances
	left_ix = relation-->RR_STORAGE-->VTOVS_LEFT_INDEX_PROP;
	if ((from provides left_ix) && (to provides left_ix)) {
		if (domainsize < 256) {
			cache = relation-->RR_STORAGE-->VTOVS_CACHE;
			cache2 = cache + domainsize*domainsize;
			if (relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN == true) {
				relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 1;
							cache2->offset = ox.left_ix;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 0;
							cache2->offset = 255;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache->offset = (axy + ayj);
										cache2->offset = cache2->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			oy = cache2->((from.left_ix)*domainsize + (to.left_ix));
			if (oy < 255)
				objectloop (ox provides left_ix)
					if (ox.left_ix == oy) return oy;
			return nothing;
		} else {
			cache = relation-->RR_STORAGE-->VTOVS_CACHE;
			cache2 = cache + WORDSIZE*domainsize*domainsize;
			if (relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN == true) {
				relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 1;
							cache2-->offset = ox;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 0;
							cache2-->offset = nothing;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache-->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache-->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache-->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache-->offset = (axy + ayj);
										cache2-->offset = cache2-->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache-->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			return cache2-->((from.left_ix)*domainsize + (to.left_ix));
		}
	}
	if (count) return -1;
	return nothing;
];

[ IterateRelations callback;
	callback(Rel_Record_63);
    callback(Rel_Record_65);
    callback(Rel_Record_67);
    callback(Rel_Record_69);

];

[ RunTimeProblem n par1 par2 par3 ln   i c;
	if (enable_rte == false) return;
	enable_rte = false;
	print "^*** Run-time problem P", n;
	if (ln) print " (at paragraph ", ln, " in the source text)";
	print ": ";
	switch(n) {
		RTP_BACKDROP:
			print "Tried to move ", (the) par1, " (a backdrop) to ", (the) par2,
				", which is not a region.^";
		RTP_CANTCHANGE:
			print "Tried to change player to ", (the) par1,
				", which is not a player-character.^";
		RTP_NOEXIT:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it didn't seem to have such an exit to change.^";
		RTP_EXITDOOR:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it led to a door, not a room.^";
		RTP_IMPREL:
			print "Tried to access an inappropriate relation for ", (the) par1,
				", violating '", (string) par2-->RR_DESCRIPTION, "'.^";
		RTP_RULESTACK:
			print "Too many procedural rules acting all at once.^";
		RTP_TOOMANYRULEBOOKS:
			print "Too many rulebooks in simultaneous use.^";
		RTP_TOOMANYEVENTS:
			print "Too many timed events are going on at once.^";
		RTP_BADPROPERTY:
			print "Tried to access non-existent property for ", (the) par1, ".^";
		RTP_UNPROVIDED:
			print "Since ", (the) par1, " is not allowed the property ~",
					(string) par2, "~, it is against the rules to try to use it.^";
		RTP_UNSET:
			print "Although ", (the) par1, " is allowed to have the property ~",
				(string) par2, "~, no value was ever given, so it can't now be used.^";
		RTP_TOOMANYACTS:
			print "Too many activities are going on at once.^";
		RTP_CANTABANDON:
			print "Tried to abandon an activity which wasn't going on.^";
		RTP_CANTEND:
			print "Tried to end an activity which wasn't going on.^";
		RTP_CANTMOVENOTHING:
			print "You can't move nothing.^";
		RTP_CANTREMOVENOTHING:
			print "You can't remove nothing from play.^";
		RTP_DIVZERO:
			print "You can't divide by zero.^";
		RTP_BADVALUEPROPERTY:
			print "Tried to access property for a value which didn't fit: ",
				"if this were a number it would be ", par1, ".^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) par1, " (not a backdrop) to ", (the) par2,
				", which is a region.^";
		RTP_TABLE_NOCOL:
			print "Attempt to look up a non-existent column in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOCORR:
			print "Attempt to look up a non-existent correspondence in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROW:
			print "Attempt to look up a non-existent row in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOENTRY:
			print "Attempt to look up a non-existent entry at column ", par2,
				", row ", par3, " of the table '", (PrintTableName) par1, "'.^";
		RTP_TABLE_NOTABLE:
			print "Attempt to blank out a row from a non-existent table (value ",
				par1, ").^";
		RTP_TABLE_NOMOREBLANKS:
			print "Attempt to choose a blank row in a table with none left: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROWS:
			print "Attempt to choose a random row in an entirely blank table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTRUNTHROUGH:
			print "Attempt to repeat through a table in a tricky column order: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSORT:
			print "Attempt to sort a table whose ordering must remain fixed: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSAVE:
			print "Attempt to save a table to a file whose data is unstable: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_WONTFIT:
			print "File being read has too many rows or columns to fit into table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_BADFILE:
			print "File being read is not a previously saved table: table '",
				(PrintTableName) par1, "'.^";
		RTP_NOTINAROOM:
			print "Attempt to test if the current location is '",
				(the) par1, "', which is not a room or region.^";
		RTP_BADTOPIC:
			print "Attempt to see if a snippet of text matches something which
				is not a topic.^";
		RTP_ROUTELESS:
			print "Attempt to find route or count steps through an implicit
				relation.^";
		RTP_PROPOFNOTHING:
			print "Attempt to use a property of the 'nothing' non-object.^";
		RTP_DECIDEONWRONGKIND:
			print "Attempt to 'decide on V' where V is the wrong kind of object.^";
		RTP_DECIDEONNOTHING:
			print "Attempt to 'decide on nothing'.^";
		RTP_LOWLEVELERROR:
			print "Low level error.^";
		RTP_DONTIGNORETURNSEQUENCE:
			print "Attempt to ignore the turn sequence rules.^";
		RTP_SAYINVALIDSNIPPET:
			print "Attempt to say a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_SPLICEINVALIDSNIPPET:
			print "Attempt to splice a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_INCLUDEINVALIDSNIPPET:
			print "Attempt to match a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_LISTWRITERMEMORY:
			print "The list-writer has run out of memory.^";
		RTP_CANTREMOVEPLAYER:
			print "Attempt to remove the player from play.^";
		RTP_CANTREMOVEDOORS:
			print "Attempt to remove a door from play.^";
		RTP_CANTCHANGEOFFSTAGE:
			print "Attempt to change the player to a person off-stage.^";
		RTP_MSTACKMEMORY:
			print "The memory stack is exhausted.^";
		RTP_TYPECHECK:
			print "Phrase applied to an incompatible kind of value.^";
		RTP_FILEIOERROR:
			print "Error handling external file.^";
		RTP_HEAPERROR:
			print "Memory allocation proved impossible.^";
		RTP_LISTRANGEERROR:
			print "Attempt to use list item which does not exist.^";
		RTP_REGEXPSYNTAXERROR:
			print "Syntax error in regular expression.^";
		RTP_NOGLULXUNICODE:
			print "This interpreter does not support Unicode.^";
		RTP_BACKDROPONLY:
			print "Only backdrops can be moved to multiple places.^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) par1, " (not a thing) to ", (the) par2,
				", but only things can move around.^";
		RTP_SCENEHASNTSTARTED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't started, so you can't ask when it did.^";
		RTP_SCENEHASNTENDED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't ended, so you can't ask when it did.^";
		RTP_NEGATIVEROOT:
			print "You can't take the square root of a negative number.^";
		RTP_CANTITERATE:
			print "You can't implicitly repeat through the values of this kind: ",
				"a problem arising from a description which started out here - ~",
				(string) par1, "~.^";
		}
	print "^";
];

Constant MAX_TIMERS = 0;
[ RunTimeError n p1 p2;
    #Ifdef DEBUG;
    print "** Library error ", n, " (", p1, ",", p2, ") **^** ";
    switch (n) {
      1:    print "preposition not found (this should not occur)";
      2:    print "Property value not routine or string: ~", (property) p2, "~ of ~", (name) p1,
                  "~ (", p1, ")";
      3:    print "Entry in property list not routine or string: ~", (property) p2, "~ list of ~",
                  (name) p1, "~ (", p1, ")";
      4:    print "Too many timers/daemons are active simultaneously.
                  The limit is the library constant MAX_TIMERS (currently ",
                  MAX_TIMERS, ") and should be increased";
      5:    print "Object ~", (name) p1, "~ has no ~time_left~ property";
      7:    print "The object ~", (name) p1, "~ can only be used as a player object if it has
                  the ~number~ property";
      8:    print "Attempt to take random entry from an empty table array";
      9:    print p1, " is not a valid direction property number";
      10:   print "The player-object is outside the object tree";
      11:   print "The room ~", (name) p1, "~ has no ~description~ property";
      12:   print "Tried to set a non-existent pronoun using SetPronoun";
      13:   print "A 'topic' token can only be followed by a preposition";
      default: print "(unexplained)";
    }
    print " **^";
    #Ifnot;
    print "** Library error ", n, " (", p1, ",", p2, ") **^";
    #Endif; ! DEBUG
    RunTimeProblem(RTP_LOWLEVELERROR);
];

[ ArgumentTypeFailed file line arg;
	RunTimeProblem(RTP_TYPECHECK, 0, 0, 0, line);
];

[ CheckKindReturned V K;
	if (V ofclass K) return V;
	if (v == nothing) RunTimeProblem(RTP_DECIDEONNOTHING);
	else RunTimeProblem(RTP_DECIDEONWRONGKIND);
	return V;
];

[ WhetherProvides obj either_or p issue_rtp  off i textual a l;
	if (metaclass(obj) ~= Object) rfalse;
	if (p<0) p = ~p;
	if (either_or) {
		if (p < FBNA_PROP_NUMBER) off = attributed_property_offsets-->p;
		else off = valued_property_offsets-->p;
	} else off = valued_property_offsets-->p;
	if (off<0) {
		if (issue_rtp) RunTimeProblem(RTP_BADPROPERTY, obj);
		rfalse;
	}
	textual = property_metadata-->off; off++;
	
	if (ScanPropertyMetadata(obj, off)) jump PermissionFound;
	if (obj provides IK_0) {
		l = obj.IK_0;
		while (l > 0) {
			a = l*2;
			if (ScanPropertyMetadata(KindHierarchy-->a, off)) jump PermissionFound;
			l = KindHierarchy-->(a+1);
		}
	}
	if (issue_rtp) RunTimeProblem(RTP_UNPROVIDED, obj, textual);
	rfalse;

	.PermissionFound;
		if (either_or) rtrue;
		if (obj provides p) rtrue;
		if (issue_rtp) RunTimeProblem(RTP_UNSET, obj, textual);
		rfalse;
];

[ ScanPropertyMetadata obj off i;
	for (i=off: property_metadata-->i >= 0: i++)
		if (obj == property_metadata-->i) rtrue;
	rfalse;
];

[ GetEitherOrProperty o p;
	if (o == nothing) rfalse;
	if (p<0) p = ~p;
	if (WhetherProvides(o, true, p, false)) {
		if (p<FBNA_PROP_NUMBER) { if (o has p) rtrue; rfalse; }
		if ((o provides p) && (o.p)) rtrue;
	}
	rfalse;
];

[ SetEitherOrProperty o p negate adj;
	if (p<0) { p = ~p; negate = ~negate; }
	if (adj) {
		(adj)(o);
	} else if (WhetherProvides(o, true, p, true)) {
		if (negate) {
			if (p<FBNA_PROP_NUMBER) give o ~p; else o.p = false;
		} else {
			if (p<FBNA_PROP_NUMBER) give o p; else o.p = true;
		}
	}
];

[ GProperty K V pr obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (obj provides pr) {
		if (K == OBJECT_TY) {
			if (pr == door_to) return obj.pr();
			if (WhetherProvides(V, false, pr, true)) return obj.pr;
			rfalse;
		}
		if ((V < 1) || (V > obj.value_range)) {
			RunTimeProblem(RTP_BADVALUEPROPERTY); return 0; }
		return (obj.pr)-->(V+COL_HSIZE);
	}
    rfalse;
];

[ WriteGProperty K V pr val obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (K == OBJECT_TY) {
		if (WhetherProvides(V, false, pr, true)) obj.pr = val;
	} else {
		if ((V < 1) || (V > obj.value_range))
			return RunTimeProblem(RTP_BADVALUEPROPERTY);
		if (obj provides pr) { (obj.pr)-->(V+COL_HSIZE) = val; }
	}
];

[ PROPERTY_TY_Say v;
	print "property ", v;
];

Constant RULECHANGE_STACK_SIZE = 501;
Global rulechange_sp = 0;
Array rulechange_stack --> RULECHANGE_STACK_SIZE;

[ PushRuleChange usage rule1 rule2;
	if (rulechange_sp >= RULECHANGE_STACK_SIZE) return RunTimeProblem(RTP_RULESTACK);
	rulechange_stack-->rulechange_sp++ = usage;
	rulechange_stack-->rulechange_sp++ = rule1;
	rulechange_stack-->rulechange_sp++ = rule2;
];

Constant RS_FRAME       = -1;

Constant RS_DONOTRUN	= 1;
Constant RS_RUN			= 2;
Constant RS_MOVEBEFORE	= 3;
Constant RS_MOVEAFTER	= 4;
Constant RS_DONOTUSE	= 5;
Constant RS_USE			= 6;
Constant RS_SUBSTITUTE	= 7;

Constant RS_SUCCEEDS	= 8;
Constant RS_FAILS		= 9;
Constant RS_NEITHER		= 10;

Global rule_frames = 0; ! Number of frames currently in force
Constant MAX_SIMULTANEOUS_FRAMES = 20;

[ FollowRulebook rulebook parameter no_paragraph_skips  rv;
	@push self;
	if ((Protect_I7_Arrays-->0 ~= 16339) || (Protect_I7_Arrays-->1 ~= 12345)) {
		print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
		@quit;
	}
	if (parameter) self = parameter;
	if (rulebook ~= PROCEDURAL_RB) BeginFollowRulebook();
	rv = ProcessRulebook(rulebook, parameter, no_paragraph_skips);
	if (rulebook ~= PROCEDURAL_RB) EndFollowRulebook();
	@pull self;
	if (rv) rtrue;
	rfalse;
];

[ BeginFollowRulebook;
	PushRuleChange(RS_FRAME, RS_FRAME, RS_FRAME);
	rule_frames++;
	if (rule_frames == MAX_SIMULTANEOUS_FRAMES) {
		RunTimeProblem(RTP_TOOMANYRULEBOOKS);
		rule_frames = -1; ! For recovery: this terminates rulebook processing
		return;
	}
	ProcessRulebook(PROCEDURAL_RB, 0, true);
];

[ EndFollowRulebook r x y;
	if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) r = 1;
	else if (rulechange_stack-->rulechange_sp == RS_FAILS) r = 0;
	else r = -1;
	if (r ~= -1) {
		x = rulechange_stack-->(rulechange_sp+1);
		y = rulechange_stack-->(rulechange_sp+2);
	}
	rule_frames--;
	while (rulechange_sp > 0) {
		rulechange_sp = rulechange_sp - 3;
		if (rulechange_stack-->rulechange_sp == RS_FRAME) break;
	}
	if (rulechange_sp == 0) rule_frames = 0;
	if (r == 1) rulechange_stack-->rulechange_sp = RS_SUCCEEDS;
	else if (r == 0) rulechange_stack-->rulechange_sp = RS_FAILS;
	if (r ~= -1) {
		rulechange_stack-->(rulechange_sp+1) = x;
		rulechange_stack-->(rulechange_sp+2) = y;
	}
];

Constant RS_ACTIVE_BIT		= 1;
Constant RS_MOVED_BIT		= 2;
Constant RS_USERESULT_BIT	= 4;
Constant RS_ACTIVITY		= 8;
Constant RS_NOSKIPS			= 16;
Constant RS_AFFECTED_BIT	= 32;

Global process_rulebook_count; ! Depth of processing recursion
Global debugging_rules = false; ! Are we tracing rule invocations?

[ ProcessRulebook rulebook parameter bits rv
	x frame_base substituted_rule usage original_deadflag rbaddress ra acf gc ga;
	if (bits) bits = RS_ACTIVITY + RS_NOSKIPS;
	if (say__pc & PARA_NORULEBOOKBREAKS) bits = bits | RS_NOSKIPS;
	if (rule_frames<0) rfalse;
	if (parameter) parameter_object = parameter;
	for (x = rulechange_sp-3: x>=0: x = x - 3) {
		usage = rulechange_stack-->x;
		if (usage == RS_FRAME) { x=x+3; break; }
		if (rulechange_stack-->(x+1) == rulebook) {
			bits = bits | (RS_AFFECTED_BIT);
			if (usage == RS_MOVEBEFORE or RS_MOVEAFTER)
				bits = bits | (RS_MOVED_BIT);
		}
		if (rulechange_stack-->(x+2) == rulebook) {
			bits = bits | (RS_AFFECTED_BIT);
		}
	} if (x<0) x=0; frame_base = x;
	if ((bits & RS_MOVED_BIT) && (rv == false)) { rfalse; }
	! rv was a call parameter: it's no longer needed and is now reused
	bits = bits | (RS_ACTIVE_BIT + RS_USERESULT_BIT);
	substituted_rule = rulebook; rv = 0;
	if (bits & RS_AFFECTED_BIT)
		for (: x<rulechange_sp: x = x + 3) {
			usage = rulechange_stack-->x;
			if (rulechange_stack-->(x+1) == rulebook) {
				if (usage == RS_DONOTRUN) bits = bits & (~RS_ACTIVE_BIT);
				if (usage == RS_RUN) bits = bits | (RS_ACTIVE_BIT);
				if (usage == RS_DONOTUSE) bits = bits & (~RS_USERESULT_BIT);
				if (usage == RS_USE) bits = bits | (RS_USERESULT_BIT);
				if (usage == RS_SUBSTITUTE)
					substituted_rule = rulechange_stack-->(x+2);
			}
			if ((usage == RS_MOVEBEFORE) && (rulechange_stack-->(x+2) == rulebook)) {
				rv = ProcessRulebook(rulechange_stack-->(x+1),
					parameter, (bits & RS_ACTIVITY ~= 0), true);
				if (rv) return rv;
			}
		}
	if ((bits & RS_ACTIVE_BIT) == 0) rfalse;
	! We now reuse usage to keep the stack frame slimmer
	usage = debugging_rules;
	#ifndef MEMORY_ECONOMY;
	if (debugging_rules) DebugRulebooks(substituted_rule, parameter);
	#endif;
	! (A routine defined in the I7 code generator)
	process_rulebook_count = process_rulebook_count + debugging_rules;
	if ((substituted_rule >= 0) && (substituted_rule < NUMBER_RULEBOOKS_CREATED)) {
		rbaddress = rulebooks_array-->substituted_rule;
		ra = rbaddress-->0; x = 0; original_deadflag = deadflag;
		if (ra ~= NULL) {
			acf = (bits & RS_ACTIVITY ~= 0);
			if (substituted_rule ~= ACTION_PROCESSING_RB) MStack_CreateRBVars(substituted_rule);
			if (ra == (-2)) {
				for (x=1: original_deadflag == deadflag: x++) {
					ra = rbaddress-->x;
					if (ra == NULL) break;
					if (gc == 0) {
						ga = ra; x++; gc = rbaddress-->x;
						if ((gc<1) || (gc>31)) { gc = 1; x--; }
						x++; ra = rbaddress-->x;
					}
					gc--;
					if (ga ~= (-2) or action) continue;
					if ((rv = (ProcessRulebook(ra, parameter, acf)))
						&& (bits & RS_USERESULT_BIT)) jump NonNullResult;
				}
			} else {
				for (: original_deadflag == deadflag: x++) {
					ra = rbaddress-->x;
					if (ra == NULL) break;
					if ((rv = (ProcessRulebook(ra, parameter, acf)))
						&& (bits & RS_USERESULT_BIT)) jump NonNullResult;
				}
			}
			rv = 0;
			.NonNullResult;
			if (substituted_rule ~= ACTION_PROCESSING_RB) MStack_DestroyRBVars(substituted_rule);
		}
	} else {
		if ((say__p) && (bits & RS_NOSKIPS == 0)) DivideParagraphPoint();
		rv = indirect(substituted_rule);
		if (rv) rv = substituted_rule;
	}
	if (rv && (bits & RS_USERESULT_BIT)) {
		process_rulebook_count = process_rulebook_count - debugging_rules;
		if (process_rulebook_count < 0) process_rulebook_count = 0;
		#ifndef MEMORY_ECONOMY;
		if (debugging_rules) {
			spaces(2*process_rulebook_count);
	  	    if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS)
	  			print "[stopped: success]^";
	  	    if (rulechange_stack-->rulechange_sp == RS_FAILS)
	  			print "[stopped: fail]^";
		}
		#endif;
		debugging_rules = usage;
		return rv;
	}
	if (bits & RS_AFFECTED_BIT)
		for (x=rulechange_sp-3: x>=frame_base: x = x-3) {
			if ((rulechange_stack-->x == RS_MOVEAFTER) &&
				(rulechange_stack-->(x+2) == rulebook)) {
				rv = ProcessRulebook(rulechange_stack-->(x+1),
					parameter, (bits & RS_ACTIVITY ~= 0), true);
				if (rv) {
					process_rulebook_count--;
					debugging_rules = usage;
					return rv;
				}
			}
		}
	process_rulebook_count = process_rulebook_count - debugging_rules;
	rulechange_stack-->rulechange_sp = 0;
	debugging_rules = usage;
	rfalse;
];

[ ActRulebookSucceeds rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookSucceeds();
];

[ ActRulebookFails rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookFails();
];

[ RulebookSucceeds valueflag value;
	PushRuleChange(RS_SUCCEEDS, valueflag, value);
	rulechange_sp = rulechange_sp - 3;
];

[ RulebookFails valueflag value;
	PushRuleChange(RS_FAILS, valueflag, value);
	rulechange_sp = rulechange_sp - 3;
];

[ RuleHasNoOutcome;
	PushRuleChange(RS_NEITHER, 0, 0);
	rulechange_sp = rulechange_sp - 3;
];

[ SetRulebookOutcome a;
	rulechange_stack-->rulechange_sp = a;
];

[ RulebookOutcome a;
	a = rulechange_stack-->rulechange_sp;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) return a;
	return RS_NEITHER;
];

[ RulebookFailed;
	if (rulechange_stack-->rulechange_sp == RS_FAILS) rtrue; rfalse;
];

[ RulebookSucceeded;
	if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) rtrue; rfalse;
];

[ ResultOfRule RB V F K a;
	if (RB) ProcessRulebook(RB, V, F);
	a = rulechange_stack-->rulechange_sp;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) {
		a = rulechange_stack-->(rulechange_sp + 1);
		if (a) return rulechange_stack-->(rulechange_sp + 2);
	}
	if (K) return DefaultValueOfKOV(K);
	return 0;
];

Global DITS_said = false;
[ SuppressRule rule;
	if (rule == TURN_SEQUENCE_RB) {
		if (DITS_said == false) RunTimeProblem(RTP_DONTIGNORETURNSEQUENCE);
		DITS_said = true;
	} else PushRuleChange(RS_DONOTRUN, rule, 0);
];
[ ReinstateRule rule; PushRuleChange(RS_RUN, rule, 0); ];
[ DonotuseRule rule; PushRuleChange(RS_DONOTUSE, rule, 0); ];
[ UseRule rule; PushRuleChange(RS_USE, rule, 0); ];
[ SubstituteRule rule1 rule2; PushRuleChange(RS_SUBSTITUTE, rule2, rule1); ];
[ MoveRuleBefore rule1 rule2; PushRuleChange(RS_MOVEBEFORE, rule1, rule2); ];
[ MoveRuleAfter rule1 rule2; PushRuleChange(RS_MOVEAFTER, rule1, rule2); ];

#IFNDEF MEMORY_ECONOMY;
Array RulebookNames -->
    "Procedural rulebook" ! 0
    "Startup rulebook" ! 1
    "Turn sequence rulebook" ! 2
    "Shutdown rulebook" ! 3
    "Scene changing rulebook" ! 4
    "When play begins rulebook" ! 5
    "When play ends rulebook" ! 6
    "When scene begins rulebook" ! 7
    "When scene ends rulebook" ! 8
    "Every turn rulebook" ! 9
    "Action-processing rulebook" ! 10
    "Setting action variables rulebook" ! 11
    "specific action-processing rulebook" ! 12
    "player's action awareness rulebook" ! 13
    "Accessibility rulebook" ! 14
    "Reaching inside rulebook" ! 15
    "Reaching outside rulebook" ! 16
    "Visibility rulebook" ! 17
    "Persuasion rulebook" ! 18
    "Unsuccessful attempt by rulebook" ! 19
    "Before rulebook" ! 20
    "Instead rulebook" ! 21
    "Check rulebook" ! 22
    "Carry out rulebook" ! 23
    "After rulebook" ! 24
    "Report rulebook" ! 25
    "does the player mean rulebook" ! 26
    "when Entire Game begins rulebook" ! 27
    "when Entire Game ends rulebook" ! 28
    "before Printing the name rulebook" ! 29
    "for Printing the name rulebook" ! 30
    "after Printing the name rulebook" ! 31
    "before Printing the plural name rulebook" ! 32
    "for Printing the plural name rulebook" ! 33
    "after Printing the plural name rulebook" ! 34
    "before Printing a number rulebook" ! 35
    "for Printing a number rulebook" ! 36
    "after Printing a number rulebook" ! 37
    "before Printing room description details rulebook" ! 38
    "for Printing room description details rulebook" ! 39
    "after Printing room description details rulebook" ! 40
    "before Listing contents rulebook" ! 41
    "for Listing contents rulebook" ! 42
    "after Listing contents rulebook" ! 43
    "before Grouping together rulebook" ! 44
    "for Grouping together rulebook" ! 45
    "after Grouping together rulebook" ! 46
    "before Writing a paragraph about rulebook" ! 47
    "for Writing a paragraph about rulebook" ! 48
    "after Writing a paragraph about rulebook" ! 49
    "before Listing nondescript items rulebook" ! 50
    "for Listing nondescript items rulebook" ! 51
    "after Listing nondescript items rulebook" ! 52
    "before Printing the name of a dark room rulebook" ! 53
    "for Printing the name of a dark room rulebook" ! 54
    "after Printing the name of a dark room rulebook" ! 55
    "before Printing the description of a dark room rulebook" ! 56
    "for Printing the description of a dark room rulebook" ! 57
    "after Printing the description of a dark room rulebook" ! 58
    "before Printing the announcement of darkness rulebook" ! 59
    "for Printing the announcement of darkness rulebook" ! 60
    "after Printing the announcement of darkness rulebook" ! 61
    "before Printing the announcement of light rulebook" ! 62
    "for Printing the announcement of light rulebook" ! 63
    "after Printing the announcement of light rulebook" ! 64
    "before Printing a refusal to act in the dark rulebook" ! 65
    "for Printing a refusal to act in the dark rulebook" ! 66
    "after Printing a refusal to act in the dark rulebook" ! 67
    "before Constructing the status line rulebook" ! 68
    "for Constructing the status line rulebook" ! 69
    "after Constructing the status line rulebook" ! 70
    "before Printing the banner text rulebook" ! 71
    "for Printing the banner text rulebook" ! 72
    "after Printing the banner text rulebook" ! 73
    "before Reading a command rulebook" ! 74
    "for Reading a command rulebook" ! 75
    "after Reading a command rulebook" ! 76
    "before Deciding the scope rulebook" ! 77
    "for Deciding the scope rulebook" ! 78
    "after Deciding the scope rulebook" ! 79
    "before Deciding the concealed possessions rulebook" ! 80
    "for Deciding the concealed possessions rulebook" ! 81
    "after Deciding the concealed possessions rulebook" ! 82
    "before Deciding whether all includes rulebook" ! 83
    "for Deciding whether all includes rulebook" ! 84
    "after Deciding whether all includes rulebook" ! 85
    "before Clarifying the parser's choice rulebook" ! 86
    "for Clarifying the parser's choice rulebook" ! 87
    "after Clarifying the parser's choice rulebook" ! 88
    "before Asking which do you mean rulebook" ! 89
    "for Asking which do you mean rulebook" ! 90
    "after Asking which do you mean rulebook" ! 91
    "before Printing a parser error rulebook" ! 92
    "for Printing a parser error rulebook" ! 93
    "after Printing a parser error rulebook" ! 94
    "before Supplying a missing noun rulebook" ! 95
    "for Supplying a missing noun rulebook" ! 96
    "after Supplying a missing noun rulebook" ! 97
    "before Supplying a missing second noun rulebook" ! 98
    "for Supplying a missing second noun rulebook" ! 99
    "after Supplying a missing second noun rulebook" ! 100
    "before Implicitly taking rulebook" ! 101
    "for Implicitly taking rulebook" ! 102
    "after Implicitly taking rulebook" ! 103
    "before Starting the virtual machine rulebook" ! 104
    "for Starting the virtual machine rulebook" ! 105
    "after Starting the virtual machine rulebook" ! 106
    "before Amusing a victorious player rulebook" ! 107
    "for Amusing a victorious player rulebook" ! 108
    "after Amusing a victorious player rulebook" ! 109
    "before Printing the player's obituary rulebook" ! 110
    "for Printing the player's obituary rulebook" ! 111
    "after Printing the player's obituary rulebook" ! 112
    "before Handling the final question rulebook" ! 113
    "for Handling the final question rulebook" ! 114
    "after Handling the final question rulebook" ! 115
    "before Printing the locale description rulebook" ! 116
    "for Printing the locale description rulebook" ! 117
    "after Printing the locale description rulebook" ! 118
    "before Choosing notable locale objects rulebook" ! 119
    "for Choosing notable locale objects rulebook" ! 120
    "after Choosing notable locale objects rulebook" ! 121
    "before Printing a locale paragraph about rulebook" ! 122
    "for Printing a locale paragraph about rulebook" ! 123
    "after Printing a locale paragraph about rulebook" ! 124
    "check Taking inventory rulebook" ! 125
    "carry out Taking inventory rulebook" ! 126
    "report Taking inventory rulebook" ! 127
    "check Taking rulebook" ! 128
    "carry out Taking rulebook" ! 129
    "report Taking rulebook" ! 130
    "check Removing it from rulebook" ! 131
    "carry out Removing it from rulebook" ! 132
    "report Removing it from rulebook" ! 133
    "check Dropping rulebook" ! 134
    "carry out Dropping rulebook" ! 135
    "report Dropping rulebook" ! 136
    "check Putting it on rulebook" ! 137
    "carry out Putting it on rulebook" ! 138
    "report Putting it on rulebook" ! 139
    "check Inserting it into rulebook" ! 140
    "carry out Inserting it into rulebook" ! 141
    "report Inserting it into rulebook" ! 142
    "check Eating rulebook" ! 143
    "carry out Eating rulebook" ! 144
    "report Eating rulebook" ! 145
    "check Going rulebook" ! 146
    "carry out Going rulebook" ! 147
    "report Going rulebook" ! 148
    "check Entering rulebook" ! 149
    "carry out Entering rulebook" ! 150
    "report Entering rulebook" ! 151
    "check Exiting rulebook" ! 152
    "carry out Exiting rulebook" ! 153
    "report Exiting rulebook" ! 154
    "check Getting off rulebook" ! 155
    "carry out Getting off rulebook" ! 156
    "report Getting off rulebook" ! 157
    "check Looking rulebook" ! 158
    "carry out Looking rulebook" ! 159
    "report Looking rulebook" ! 160
    "check Examining rulebook" ! 161
    "carry out Examining rulebook" ! 162
    "report Examining rulebook" ! 163
    "check Looking under rulebook" ! 164
    "carry out Looking under rulebook" ! 165
    "report Looking under rulebook" ! 166
    "check Searching rulebook" ! 167
    "carry out Searching rulebook" ! 168
    "report Searching rulebook" ! 169
    "check Consulting it about rulebook" ! 170
    "carry out Consulting it about rulebook" ! 171
    "report Consulting it about rulebook" ! 172
    "check Locking it with rulebook" ! 173
    "carry out Locking it with rulebook" ! 174
    "report Locking it with rulebook" ! 175
    "check Unlocking it with rulebook" ! 176
    "carry out Unlocking it with rulebook" ! 177
    "report Unlocking it with rulebook" ! 178
    "check Switching on rulebook" ! 179
    "carry out Switching on rulebook" ! 180
    "report Switching on rulebook" ! 181
    "check Switching off rulebook" ! 182
    "carry out Switching off rulebook" ! 183
    "report Switching off rulebook" ! 184
    "check Opening rulebook" ! 185
    "carry out Opening rulebook" ! 186
    "report Opening rulebook" ! 187
    "check Closing rulebook" ! 188
    "carry out Closing rulebook" ! 189
    "report Closing rulebook" ! 190
    "check Wearing rulebook" ! 191
    "carry out Wearing rulebook" ! 192
    "report Wearing rulebook" ! 193
    "check Taking off rulebook" ! 194
    "carry out Taking off rulebook" ! 195
    "report Taking off rulebook" ! 196
    "check Giving it to rulebook" ! 197
    "carry out Giving it to rulebook" ! 198
    "report Giving it to rulebook" ! 199
    "check Showing it to rulebook" ! 200
    "carry out Showing it to rulebook" ! 201
    "report Showing it to rulebook" ! 202
    "check Waking rulebook" ! 203
    "carry out Waking rulebook" ! 204
    "report Waking rulebook" ! 205
    "check Throwing it at rulebook" ! 206
    "carry out Throwing it at rulebook" ! 207
    "report Throwing it at rulebook" ! 208
    "check Attacking rulebook" ! 209
    "carry out Attacking rulebook" ! 210
    "report Attacking rulebook" ! 211
    "check Kissing rulebook" ! 212
    "carry out Kissing rulebook" ! 213
    "report Kissing rulebook" ! 214
    "check Answering it that rulebook" ! 215
    "carry out Answering it that rulebook" ! 216
    "report Answering it that rulebook" ! 217
    "check Telling it about rulebook" ! 218
    "carry out Telling it about rulebook" ! 219
    "report Telling it about rulebook" ! 220
    "check Asking it about rulebook" ! 221
    "carry out Asking it about rulebook" ! 222
    "report Asking it about rulebook" ! 223
    "check Asking it for rulebook" ! 224
    "carry out Asking it for rulebook" ! 225
    "report Asking it for rulebook" ! 226
    "check Waiting rulebook" ! 227
    "carry out Waiting rulebook" ! 228
    "report Waiting rulebook" ! 229
    "check Touching rulebook" ! 230
    "carry out Touching rulebook" ! 231
    "report Touching rulebook" ! 232
    "check Waving rulebook" ! 233
    "carry out Waving rulebook" ! 234
    "report Waving rulebook" ! 235
    "check Pulling rulebook" ! 236
    "carry out Pulling rulebook" ! 237
    "report Pulling rulebook" ! 238
    "check Pushing rulebook" ! 239
    "carry out Pushing rulebook" ! 240
    "report Pushing rulebook" ! 241
    "check Turning rulebook" ! 242
    "carry out Turning rulebook" ! 243
    "report Turning rulebook" ! 244
    "check Pushing it to rulebook" ! 245
    "carry out Pushing it to rulebook" ! 246
    "report Pushing it to rulebook" ! 247
    "check Squeezing rulebook" ! 248
    "carry out Squeezing rulebook" ! 249
    "report Squeezing rulebook" ! 250
    "check Saying yes rulebook" ! 251
    "carry out Saying yes rulebook" ! 252
    "report Saying yes rulebook" ! 253
    "check Saying no rulebook" ! 254
    "carry out Saying no rulebook" ! 255
    "report Saying no rulebook" ! 256
    "check Burning rulebook" ! 257
    "carry out Burning rulebook" ! 258
    "report Burning rulebook" ! 259
    "check Waking up rulebook" ! 260
    "carry out Waking up rulebook" ! 261
    "report Waking up rulebook" ! 262
    "check Thinking rulebook" ! 263
    "carry out Thinking rulebook" ! 264
    "report Thinking rulebook" ! 265
    "check Smelling rulebook" ! 266
    "carry out Smelling rulebook" ! 267
    "report Smelling rulebook" ! 268
    "check Listening to rulebook" ! 269
    "carry out Listening to rulebook" ! 270
    "report Listening to rulebook" ! 271
    "check Tasting rulebook" ! 272
    "carry out Tasting rulebook" ! 273
    "report Tasting rulebook" ! 274
    "check Cutting rulebook" ! 275
    "carry out Cutting rulebook" ! 276
    "report Cutting rulebook" ! 277
    "check Jumping rulebook" ! 278
    "carry out Jumping rulebook" ! 279
    "report Jumping rulebook" ! 280
    "check Tying it to rulebook" ! 281
    "carry out Tying it to rulebook" ! 282
    "report Tying it to rulebook" ! 283
    "check Drinking rulebook" ! 284
    "carry out Drinking rulebook" ! 285
    "report Drinking rulebook" ! 286
    "check Saying sorry rulebook" ! 287
    "carry out Saying sorry rulebook" ! 288
    "report Saying sorry rulebook" ! 289
    "check Swearing obscenely rulebook" ! 290
    "carry out Swearing obscenely rulebook" ! 291
    "report Swearing obscenely rulebook" ! 292
    "check Swearing mildly rulebook" ! 293
    "carry out Swearing mildly rulebook" ! 294
    "report Swearing mildly rulebook" ! 295
    "check Swinging rulebook" ! 296
    "carry out Swinging rulebook" ! 297
    "report Swinging rulebook" ! 298
    "check Rubbing rulebook" ! 299
    "carry out Rubbing rulebook" ! 300
    "report Rubbing rulebook" ! 301
    "check Setting it to rulebook" ! 302
    "carry out Setting it to rulebook" ! 303
    "report Setting it to rulebook" ! 304
    "check Waving hands rulebook" ! 305
    "carry out Waving hands rulebook" ! 306
    "report Waving hands rulebook" ! 307
    "check Buying rulebook" ! 308
    "carry out Buying rulebook" ! 309
    "report Buying rulebook" ! 310
    "check Singing rulebook" ! 311
    "carry out Singing rulebook" ! 312
    "report Singing rulebook" ! 313
    "check Climbing rulebook" ! 314
    "carry out Climbing rulebook" ! 315
    "report Climbing rulebook" ! 316
    "check Sleeping rulebook" ! 317
    "carry out Sleeping rulebook" ! 318
    "report Sleeping rulebook" ! 319
    "check Quitting the game rulebook" ! 320
    "carry out Quitting the game rulebook" ! 321
    "report Quitting the game rulebook" ! 322
    "check Saving the game rulebook" ! 323
    "carry out Saving the game rulebook" ! 324
    "report Saving the game rulebook" ! 325
    "check Restoring the game rulebook" ! 326
    "carry out Restoring the game rulebook" ! 327
    "report Restoring the game rulebook" ! 328
    "check Restarting the game rulebook" ! 329
    "carry out Restarting the game rulebook" ! 330
    "report Restarting the game rulebook" ! 331
    "check Verifying the story file rulebook" ! 332
    "carry out Verifying the story file rulebook" ! 333
    "report Verifying the story file rulebook" ! 334
    "check Switching the story transcript on rulebook" ! 335
    "carry out Switching the story transcript on rulebook" ! 336
    "report Switching the story transcript on rulebook" ! 337
    "check Switching the story transcript off rulebook" ! 338
    "carry out Switching the story transcript off rulebook" ! 339
    "report Switching the story transcript off rulebook" ! 340
    "check Requesting the story file version rulebook" ! 341
    "carry out Requesting the story file version rulebook" ! 342
    "report Requesting the story file version rulebook" ! 343
    "check Requesting the score rulebook" ! 344
    "carry out Requesting the score rulebook" ! 345
    "report Requesting the score rulebook" ! 346
    "check Preferring abbreviated room descriptions rulebook" ! 347
    "carry out Preferring abbreviated room descriptions rulebook" ! 348
    "report Preferring abbreviated room descriptions rulebook" ! 349
    "check Preferring unabbreviated room descriptions rulebook" ! 350
    "carry out Preferring unabbreviated room descriptions rulebook" ! 351
    "report Preferring unabbreviated room descriptions rulebook" ! 352
    "check Preferring sometimes abbreviated room descriptions rulebook" ! 353
    "carry out Preferring sometimes abbreviated room descriptions rulebook" ! 354
    "report Preferring sometimes abbreviated room descriptions rulebook" ! 355
    "check Switching score notification on rulebook" ! 356
    "carry out Switching score notification on rulebook" ! 357
    "report Switching score notification on rulebook" ! 358
    "check Switching score notification off rulebook" ! 359
    "carry out Switching score notification off rulebook" ! 360
    "report Switching score notification off rulebook" ! 361
    "check Requesting the pronoun meanings rulebook" ! 362
    "carry out Requesting the pronoun meanings rulebook" ! 363
    "report Requesting the pronoun meanings rulebook" ! 364
    "check Requesting epistemic status of rulebook" ! 365
    "carry out Requesting epistemic status of rulebook" ! 366
    "report Requesting epistemic status of rulebook" ! 367
    "check Requesting it for rulebook" ! 368
    "carry out Requesting it for rulebook" ! 369
    "report Requesting it for rulebook" ! 370
    "check Imploring it for rulebook" ! 371
    "carry out Imploring it for rulebook" ! 372
    "report Imploring it for rulebook" ! 373
    "check Quizzing it about rulebook" ! 374
    "carry out Quizzing it about rulebook" ! 375
    "report Quizzing it about rulebook" ! 376
    "check Informing it about rulebook" ! 377
    "carry out Informing it about rulebook" ! 378
    "report Informing it about rulebook" ! 379
    "check implicit-quizzing rulebook" ! 380
    "carry out implicit-quizzing rulebook" ! 381
    "report implicit-quizzing rulebook" ! 382
    "check implicit-informing rulebook" ! 383
    "carry out implicit-informing rulebook" ! 384
    "report implicit-informing rulebook" ! 385
    "check implicit-requesting rulebook" ! 386
    "carry out implicit-requesting rulebook" ! 387
    "report implicit-requesting rulebook" ! 388
    "check implicit-imploring rulebook" ! 389
    "carry out implicit-imploring rulebook" ! 390
    "report implicit-imploring rulebook" ! 391
    "check Saying hello to rulebook" ! 392
    "carry out Saying hello to rulebook" ! 393
    "report Saying hello to rulebook" ! 394
    "check Hailing rulebook" ! 395
    "carry out Hailing rulebook" ! 396
    "report Hailing rulebook" ! 397
    "check Leavetaking rulebook" ! 398
    "carry out Leavetaking rulebook" ! 399
    "report Leavetaking rulebook" ! 400
    "check Saying goodbye to rulebook" ! 401
    "carry out Saying goodbye to rulebook" ! 402
    "report Saying goodbye to rulebook" ! 403
    "suggestion list construction rulebook" ! 404
    "check Listing suggested topics rulebook" ! 405
    "carry out Listing suggested topics rulebook" ! 406
    "report Listing suggested topics rulebook" ! 407
    "check Standing rulebook" ! 408
    "carry out Standing rulebook" ! 409
    "report Standing rulebook" ! 410
    "check Retreating rulebook" ! 411
    "carry out Retreating rulebook" ! 412
    "report Retreating rulebook" ! 413
    "check Using rulebook" ! 414
    "carry out Using rulebook" ! 415
    "report Using rulebook" ! 416
    "before Deciding whether to allow undo rulebook" ! 417
    "for Deciding whether to allow undo rulebook" ! 418
    "after Deciding whether to allow undo rulebook" ! 419
    "before Deciding whether the action prevents undo rulebook" ! 420
    "for Deciding whether the action prevents undo rulebook" ! 421
    "after Deciding whether the action prevents undo rulebook" ! 422
    "check Brooding rulebook" ! 423
    "carry out Brooding rulebook" ! 424
    "report Brooding rulebook" ! 425
    "check Smoking rulebook" ! 426
    "carry out Smoking rulebook" ! 427
    "report Smoking rulebook" ! 428
    "check Tuning it to rulebook" ! 429
    "carry out Tuning it to rulebook" ! 430
    "report Tuning it to rulebook" ! 431
    "check Coarse tuning rulebook" ! 432
    "carry out Coarse tuning rulebook" ! 433
    "report Coarse tuning rulebook" ! 434
    "check Trading rulebook" ! 435
    "carry out Trading rulebook" ! 436
    "report Trading rulebook" ! 437
    "when Sinister Voices begins rulebook" ! 438
    "when Sinister Voices ends rulebook" ! 439
    "when Rainstorm begins rulebook" ! 440
    "when Rainstorm ends rulebook" ! 441
    "when Pursuit begins rulebook" ! 442
    "when Pursuit ends rulebook" ! 443
    "when Rabbit's Offer begins rulebook" ! 444
    "when Rabbit's Offer ends rulebook" ! 445
    "when Temptation begins rulebook" ! 446
    "when Temptation ends rulebook" ! 447
    "when Chase begins rulebook" ! 448
    "when Chase ends rulebook" ! 449
    "when Fight begins rulebook" ! 450
    "when Fight ends rulebook" ! 451
    "when Coyote's Offer begins rulebook" ! 452
    "when Coyote's Offer ends rulebook" ! 453
    "when Sand-dancer's Arrival begins rulebook" ! 454
    "when Sand-dancer's Arrival ends rulebook" ! 455
    "when Sand-dancer's Offer begins rulebook" ! 456
    "when Sand-dancer's Offer ends rulebook" ! 457
    "when Fight ends in cowardice rulebook" ! 458
    "when Fight ends in bravery rulebook" ! 459
;


#ENDIF; ! MEMORY_ECONOMY

[ RulePrintingRule R p1;
#ifndef MEMORY_ECONOMY;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print (string) (RulebookNames-->R);
	} else {
		if (R == R_8) { print "start in the correct scenes rule"; return; } ! 0, case 1
		if (R == R_9) { print "when play begins stage rule"; return; } ! 1, case 1
		if (R == R_10) { print "fix baseline scoring rule"; return; } ! 2, case 1
		if (R == R_11) { print "display banner rule"; return; } ! 3, case 1
		if (R == R_12) { print "initial room description rule"; return; } ! 4, case 1
		if (R == R_13) { print "every turn stage rule"; return; } ! 5, case 1
		if (R == R_16) { print "notify score changes rule"; return; } ! 6, case 1
		if (R == R_17) { print "when play ends stage rule"; return; } ! 7, case 1
		if (R == R_18) { print "print player's obituary rule"; return; } ! 8, case 1
		if (R == R_19) { print "set pronouns from items from multiple object lists rule"; return; } ! 9, case 1
		if (R == R_20) { print "announce items from multiple object lists rule"; return; } ! 10, case 1
		if (R == R_21) { print "before stage rule"; return; } ! 11, case 1
		if (R == R_22) { print "instead stage rule"; return; } ! 12, case 1
		if (R == R_23) { print "end action-processing in success rule"; return; } ! 13, case 1
		if (R == R_24) { print "investigate player's awareness before action rule"; return; } ! 14, case 1
		if (R == R_25) { print "check stage rule"; return; } ! 15, case 1
		if (R == R_26) { print "carry out stage rule"; return; } ! 16, case 1
		if (R == R_27) { print "after stage rule"; return; } ! 17, case 1
		if (R == R_28) { print "investigate player's awareness after action rule"; return; } ! 18, case 1
		if (R == R_29) { print "report stage rule"; return; } ! 19, case 1
		if (R == R_31) { print "player aware of his own actions rule"; return; } ! 20, case 1
		if (R == R_32) { print "player aware of actions by visible actors rule"; return; } ! 21, case 1
		if (R == R_33) { print "player aware of actions on visible nouns rule"; return; } ! 22, case 1
		if (R == R_34) { print "player aware of actions on visible second nouns rule"; return; } ! 23, case 1
		if (R == R_35) { print "can't act in the dark rule"; return; } ! 24, case 1
		if (R == R_36) { print "very unlikely to mean taking what's already carried rule"; return; } ! 25, case 1
		if (R == R_57) { print "scene description text rule"; return; } ! 26, case 1
		if (R == R_58) { print "make named things mentioned rule"; return; } ! 27, case 1
		if (R == R_59) { print "standard printing the plural name rule"; return; } ! 28, case 1
		if (R == R_60) { print "standard printing a number of something rule"; return; } ! 29, case 1
		if (R == R_61) { print "look around once light available rule"; return; } ! 30, case 1
		if (R == R_62) { print "exclude scenery from take all rule"; return; } ! 31, case 1
		if (R == R_63) { print "exclude people from take all rule"; return; } ! 32, case 1
		if (R == R_64) { print "exclude fixed in place things from take all rule"; return; } ! 33, case 1
		if (R == R_65) { print "ambient odour rule"; return; } ! 34, case 1
		if (R == R_66) { print "ambient sound rule"; return; } ! 35, case 1
		if (R == R_67) { print "block vaguely going rule"; return; } ! 36, case 1
		if (R == R_68) { print "print the final prompt rule"; return; } ! 37, case 1
		if (R == R_69) { print "print the final question rule"; return; } ! 38, case 1
		if (R == R_70) { print "standard respond to final question rule"; return; } ! 39, case 1
		if (R == R_73) { print "initialise locale description rule"; return; } ! 40, case 1
		if (R == R_74) { print "find notable locale objects rule"; return; } ! 41, case 1
		if (R == R_75) { print "interesting locale paragraphs rule"; return; } ! 42, case 1
		if (R == R_76) { print "you-can-also-see rule"; return; } ! 43, case 1
		if (R == R_77) { print "standard notable locale objects rule"; return; } ! 44, case 1
		if (R == R_78) { print "don't mention player's supporter in room descriptions rule"; return; } ! 45, case 1
		if (R == R_79) { print "don't mention scenery in room descriptions rule"; return; } ! 46, case 1
		if (R == R_80) { print "don't mention undescribed items in room descriptions rule"; return; } ! 47, case 1
		if (R == R_81) { print "set pronouns from items in room descriptions rule"; return; } ! 48, case 1
		if (R == R_82) { print "offer items to writing a paragraph about rule"; return; } ! 49, case 1
		if (R == R_83) { print "use initial appearance in room descriptions rule"; return; } ! 50, case 1
		if (R == R_85) { print "describe what's on scenery supporters in room descriptions rule"; return; } ! 51, case 1
		if (R == R_86) { print "print empty inventory rule"; return; } ! 52, case 1
		if (R == R_87) { print "print standard inventory rule"; return; } ! 53, case 1
		if (R == R_88) { print "report other people taking inventory rule"; return; } ! 54, case 1
		if (R == R_89) { print "can't take yourself rule"; return; } ! 55, case 1
		if (R == R_90) { print "can't take other people rule"; return; } ! 56, case 1
		if (R == R_91) { print "can't take component parts rule"; return; } ! 57, case 1
		if (R == R_92) { print "can't take people's possessions rule"; return; } ! 58, case 1
		if (R == R_93) { print "can't take items out of play rule"; return; } ! 59, case 1
		if (R == R_94) { print "can't take what you're inside rule"; return; } ! 60, case 1
		if (R == R_95) { print "can't take what's already taken rule"; return; } ! 61, case 1
		if (R == R_96) { print "can't take scenery rule"; return; } ! 62, case 1
		if (R == R_97) { print "can only take things rule"; return; } ! 63, case 1
		if (R == R_98) { print "can't take what's fixed in place rule"; return; } ! 64, case 1
		if (R == R_99) { print "use player's holdall to avoid exceeding carrying capacity rule"; return; } ! 65, case 1
		if (R == R_100) { print "can't exceed carrying capacity rule"; return; } ! 66, case 1
		if (R == R_101) { print "standard taking rule"; return; } ! 67, case 1
		if (R == R_102) { print "standard report taking rule"; return; } ! 68, case 1
		if (R == R_103) { print "can't remove what's not inside rule"; return; } ! 69, case 1
		if (R == R_104) { print "can't remove from people rule"; return; } ! 70, case 1
		if (R == R_105) { print "convert remove to take rule"; return; } ! 71, case 1
		if (R == R_106) { print "can't drop yourself rule"; return; } ! 72, case 1
		if (R == R_107) { print "can't drop what's already dropped rule"; return; } ! 73, case 1
		if (R == R_108) { print "can't drop what's not held rule"; return; } ! 74, case 1
		if (R == R_109) { print "can't drop clothes being worn rule"; return; } ! 75, case 1
		if (R == R_110) { print "can't drop if this exceeds carrying capacity rule"; return; } ! 76, case 1
		if (R == R_111) { print "standard dropping rule"; return; } ! 77, case 1
		if (R == R_112) { print "standard report dropping rule"; return; } ! 78, case 1
		if (R == R_113) { print "convert put to drop where possible rule"; return; } ! 79, case 1
		if (R == R_114) { print "can't put what's not held rule"; return; } ! 80, case 1
		if (R == R_115) { print "can't put something on itself rule"; return; } ! 81, case 1
		if (R == R_116) { print "can't put onto what's not a supporter rule"; return; } ! 82, case 1
		if (R == R_117) { print "can't put onto something being carried rule"; return; } ! 83, case 1
		if (R == R_118) { print "can't put clothes being worn rule"; return; } ! 84, case 1
		if (R == R_119) { print "can't put if this exceeds carrying capacity rule"; return; } ! 85, case 1
		if (R == R_120) { print "standard putting rule"; return; } ! 86, case 1
		if (R == R_121) { print "concise report putting rule"; return; } ! 87, case 1
		if (R == R_122) { print "standard report putting rule"; return; } ! 88, case 1
		if (R == R_123) { print "convert insert to drop where possible rule"; return; } ! 89, case 1
		if (R == R_124) { print "can't insert what's not held rule"; return; } ! 90, case 1
		if (R == R_125) { print "can't insert something into itself rule"; return; } ! 91, case 1
		if (R == R_126) { print "can't insert into closed containers rule"; return; } ! 92, case 1
		if (R == R_127) { print "can't insert into what's not a container rule"; return; } ! 93, case 1
		if (R == R_128) { print "can't insert clothes being worn rule"; return; } ! 94, case 1
		if (R == R_129) { print "can't insert if this exceeds carrying capacity rule"; return; } ! 95, case 1
		if (R == R_130) { print "standard inserting rule"; return; } ! 96, case 1
		if (R == R_131) { print "concise report inserting rule"; return; } ! 97, case 1
		if (R == R_132) { print "standard report inserting rule"; return; } ! 98, case 1
		if (R == R_133) { print "can't eat unless edible rule"; return; } ! 99, case 1
		if (R == R_134) { print "can't eat clothing without removing it first rule"; return; } ! 100, case 1
		if (R == R_135) { print "standard eating rule"; return; } ! 101, case 1
		if (R == R_136) { print "standard report eating rule"; return; } ! 102, case 1
		if (R == R_137) { print "standard set going variables rule"; return; } ! 103, case 1
		if (R == R_138) { print "stand up before going rule"; return; } ! 104, case 1
		if (R == R_139) { print "can't travel in what's not a vehicle rule"; return; } ! 105, case 1
		if (R == R_140) { print "can't go through undescribed doors rule"; return; } ! 106, case 1
		if (R == R_141) { print "can't go through closed doors rule"; return; } ! 107, case 1
		if (R == R_142) { print "determine map connection rule"; return; } ! 108, case 1
		if (R == R_143) { print "can't go that way rule"; return; } ! 109, case 1
		if (R == R_144) { print "move player and vehicle rule"; return; } ! 110, case 1
		if (R == R_145) { print "move floating objects rule"; return; } ! 111, case 1
		if (R == R_146) { print "check light in new location rule"; return; } ! 112, case 1
		if (R == R_147) { print "describe room gone into rule"; return; } ! 113, case 1
		if (R == R_148) { print "find what to enter rule"; return; } ! 114, case 1
		if (R == R_149) { print "convert enter door into go rule"; return; } ! 115, case 1
		if (R == R_150) { print "convert enter compass direction into go rule"; return; } ! 116, case 1
		if (R == R_151) { print "can't enter what's already entered rule"; return; } ! 117, case 1
		if (R == R_152) { print "can't enter what's not enterable rule"; return; } ! 118, case 1
		if (R == R_153) { print "can't enter closed containers rule"; return; } ! 119, case 1
		if (R == R_154) { print "can't enter something carried rule"; return; } ! 120, case 1
		if (R == R_155) { print "implicitly pass through other barriers rule"; return; } ! 121, case 1
		if (R == R_156) { print "standard entering rule"; return; } ! 122, case 1
		if (R == R_157) { print "standard report entering rule"; return; } ! 123, case 1
		if (R == R_158) { print "describe contents entered into rule"; return; } ! 124, case 1
		if (R == R_160) { print "convert exit into go out rule"; return; } ! 125, case 1
		if (R == R_161) { print "can't exit when not inside anything rule"; return; } ! 126, case 1
		if (R == R_162) { print "can't exit closed containers rule"; return; } ! 127, case 1
		if (R == R_163) { print "convert exit into get off rule"; return; } ! 128, case 1
		if (R == R_164) { print "standard exiting rule"; return; } ! 129, case 1
		if (R == R_165) { print "standard report exiting rule"; return; } ! 130, case 1
		if (R == R_166) { print "describe room emerged into rule"; return; } ! 131, case 1
		if (R == R_167) { print "can't get off things rule"; return; } ! 132, case 1
		if (R == R_168) { print "standard getting off rule"; return; } ! 133, case 1
		if (R == R_169) { print "standard report getting off rule"; return; } ! 134, case 1
		if (R == R_170) { print "describe room stood up into rule"; return; } ! 135, case 1
		if (R == R_171) { print "determine visibility ceiling rule"; return; } ! 136, case 1
		if (R == R_172) { print "room description heading rule"; return; } ! 137, case 1
		if (R == R_173) { print "room description body text rule"; return; } ! 138, case 1
		if (R == R_174) { print "room description paragraphs about objects rule"; return; } ! 139, case 1
		if (R == R_175) { print "check new arrival rule"; return; } ! 140, case 1
		if (R == R_176) { print "other people looking rule"; return; } ! 141, case 1
		if (R == R_177) { print "standard examining rule"; return; } ! 142, case 1
		if (R == R_178) { print "examine directions rule"; return; } ! 143, case 1
		if (R == R_179) { print "examine containers rule"; return; } ! 144, case 1
		if (R == R_180) { print "examine supporters rule"; return; } ! 145, case 1
		if (R == R_181) { print "examine devices rule"; return; } ! 146, case 1
		if (R == R_182) { print "examine undescribed things rule"; return; } ! 147, case 1
		if (R == R_183) { print "report other people examining rule"; return; } ! 148, case 1
		if (R == R_184) { print "standard looking under rule"; return; } ! 149, case 1
		if (R == R_185) { print "report other people looking under rule"; return; } ! 150, case 1
		if (R == R_186) { print "can't search unless container or supporter rule"; return; } ! 151, case 1
		if (R == R_187) { print "can't search closed opaque containers rule"; return; } ! 152, case 1
		if (R == R_188) { print "standard search containers rule"; return; } ! 153, case 1
		if (R == R_189) { print "standard search supporters rule"; return; } ! 154, case 1
		if (R == R_190) { print "report other people searching rule"; return; } ! 155, case 1
		if (R == R_191) { print "block consulting rule"; return; } ! 156, case 1
		if (R == R_192) { print "can't lock without a lock rule"; return; } ! 157, case 1
		if (R == R_193) { print "can't lock what's already locked rule"; return; } ! 158, case 1
		if (R == R_194) { print "can't lock what's open rule"; return; } ! 159, case 1
		if (R == R_195) { print "can't lock without the correct key rule"; return; } ! 160, case 1
		if (R == R_196) { print "standard locking rule"; return; } ! 161, case 1
		if (R == R_197) { print "standard report locking rule"; return; } ! 162, case 1
		if (R == R_198) { print "can't unlock without a lock rule"; return; } ! 163, case 1
		if (R == R_199) { print "can't unlock what's already unlocked rule"; return; } ! 164, case 1
		if (R == R_200) { print "can't unlock without the correct key rule"; return; } ! 165, case 1
		if (R == R_201) { print "standard unlocking rule"; return; } ! 166, case 1
		if (R == R_202) { print "standard report unlocking rule"; return; } ! 167, case 1
		if (R == R_203) { print "can't switch on unless switchable rule"; return; } ! 168, case 1
		if (R == R_204) { print "can't switch on what's already on rule"; return; } ! 169, case 1
		if (R == R_205) { print "standard switching on rule"; return; } ! 170, case 1
		if (R == R_206) { print "standard report switching on rule"; return; } ! 171, case 1
		if (R == R_207) { print "can't switch off unless switchable rule"; return; } ! 172, case 1
		if (R == R_208) { print "can't switch off what's already off rule"; return; } ! 173, case 1
		if (R == R_209) { print "standard switching off rule"; return; } ! 174, case 1
		if (R == R_210) { print "standard report switching off rule"; return; } ! 175, case 1
		if (R == R_211) { print "can't open unless openable rule"; return; } ! 176, case 1
		if (R == R_212) { print "can't open what's locked rule"; return; } ! 177, case 1
		if (R == R_213) { print "can't open what's already open rule"; return; } ! 178, case 1
		if (R == R_214) { print "standard opening rule"; return; } ! 179, case 1
		if (R == R_215) { print "reveal any newly visible interior rule"; return; } ! 180, case 1
		if (R == R_216) { print "standard report opening rule"; return; } ! 181, case 1
		if (R == R_217) { print "can't close unless openable rule"; return; } ! 182, case 1
		if (R == R_218) { print "can't close what's already closed rule"; return; } ! 183, case 1
		if (R == R_219) { print "standard closing rule"; return; } ! 184, case 1
		if (R == R_220) { print "standard report closing rule"; return; } ! 185, case 1
		if (R == R_221) { print "can't wear what's not clothing rule"; return; } ! 186, case 1
		if (R == R_222) { print "can't wear what's not held rule"; return; } ! 187, case 1
		if (R == R_223) { print "can't wear what's already worn rule"; return; } ! 188, case 1
		if (R == R_224) { print "standard wearing rule"; return; } ! 189, case 1
		if (R == R_225) { print "standard report wearing rule"; return; } ! 190, case 1
		if (R == R_226) { print "can't take off what's not worn rule"; return; } ! 191, case 1
		if (R == R_227) { print "standard taking off rule"; return; } ! 192, case 1
		if (R == R_228) { print "standard report taking off rule"; return; } ! 193, case 1
		if (R == R_229) { print "can't give what you haven't got rule"; return; } ! 194, case 1
		if (R == R_230) { print "can't give to yourself rule"; return; } ! 195, case 1
		if (R == R_231) { print "can't give to a non-person rule"; return; } ! 196, case 1
		if (R == R_232) { print "can't give clothes being worn rule"; return; } ! 197, case 1
		if (R == R_233) { print "block giving rule"; return; } ! 198, case 1
		if (R == R_234) { print "standard giving rule"; return; } ! 199, case 1
		if (R == R_235) { print "standard report giving rule"; return; } ! 200, case 1
		if (R == R_236) { print "can't show what you haven't got rule"; return; } ! 201, case 1
		if (R == R_237) { print "convert show to yourself to examine rule"; return; } ! 202, case 1
		if (R == R_238) { print "block showing rule"; return; } ! 203, case 1
		if (R == R_239) { print "block waking rule"; return; } ! 204, case 1
		if (R == R_240) { print "implicitly remove thrown clothing rule"; return; } ! 205, case 1
		if (R == R_241) { print "futile to throw things at inanimate objects rule"; return; } ! 206, case 1
		if (R == R_242) { print "block throwing at rule"; return; } ! 207, case 1
		if (R == R_243) { print "block attacking rule"; return; } ! 208, case 1
		if (R == R_244) { print "kissing yourself rule"; return; } ! 209, case 1
		if (R == R_245) { print "block kissing rule"; return; } ! 210, case 1
		if (R == R_246) { print "block answering rule"; return; } ! 211, case 1
		if (R == R_247) { print "telling yourself rule"; return; } ! 212, case 1
		if (R == R_248) { print "block telling rule"; return; } ! 213, case 1
		if (R == R_249) { print "block asking rule"; return; } ! 214, case 1
		if (R == R_250) { print "asking yourself for something rule"; return; } ! 215, case 1
		if (R == R_251) { print "translate asking for to giving rule"; return; } ! 216, case 1
		if (R == R_252) { print "standard report waiting rule"; return; } ! 217, case 1
		if (R == R_253) { print "report touching yourself rule"; return; } ! 218, case 1
		if (R == R_254) { print "report touching other people rule"; return; } ! 219, case 1
		if (R == R_255) { print "report touching things rule"; return; } ! 220, case 1
		if (R == R_256) { print "can't wave what's not held rule"; return; } ! 221, case 1
		if (R == R_257) { print "report waving things rule"; return; } ! 222, case 1
		if (R == R_258) { print "can't pull what's fixed in place rule"; return; } ! 223, case 1
		if (R == R_259) { print "can't pull scenery rule"; return; } ! 224, case 1
		if (R == R_260) { print "can't pull people rule"; return; } ! 225, case 1
		if (R == R_261) { print "report pulling rule"; return; } ! 226, case 1
		if (R == R_262) { print "can't push what's fixed in place rule"; return; } ! 227, case 1
		if (R == R_263) { print "can't push scenery rule"; return; } ! 228, case 1
		if (R == R_264) { print "can't push people rule"; return; } ! 229, case 1
		if (R == R_265) { print "report pushing rule"; return; } ! 230, case 1
		if (R == R_266) { print "can't turn what's fixed in place rule"; return; } ! 231, case 1
		if (R == R_267) { print "can't turn scenery rule"; return; } ! 232, case 1
		if (R == R_268) { print "can't turn people rule"; return; } ! 233, case 1
		if (R == R_269) { print "report turning rule"; return; } ! 234, case 1
		if (R == R_270) { print "can't push unpushable things rule"; return; } ! 235, case 1
		if (R == R_271) { print "can't push to non-directions rule"; return; } ! 236, case 1
		if (R == R_272) { print "can't push vertically rule"; return; } ! 237, case 1
		if (R == R_273) { print "standard pushing in directions rule"; return; } ! 238, case 1
		if (R == R_274) { print "block pushing in directions rule"; return; } ! 239, case 1
		if (R == R_275) { print "innuendo about squeezing people rule"; return; } ! 240, case 1
		if (R == R_276) { print "report squeezing rule"; return; } ! 241, case 1
		if (R == R_277) { print "block saying yes rule"; return; } ! 242, case 1
		if (R == R_278) { print "block saying no rule"; return; } ! 243, case 1
		if (R == R_279) { print "block burning rule"; return; } ! 244, case 1
		if (R == R_280) { print "block waking up rule"; return; } ! 245, case 1
		if (R == R_281) { print "block thinking rule"; return; } ! 246, case 1
		if (R == R_282) { print "block smelling rule"; return; } ! 247, case 1
		if (R == R_283) { print "block listening rule"; return; } ! 248, case 1
		if (R == R_284) { print "block tasting rule"; return; } ! 249, case 1
		if (R == R_285) { print "block cutting rule"; return; } ! 250, case 1
		if (R == R_286) { print "block jumping rule"; return; } ! 251, case 1
		if (R == R_287) { print "block tying rule"; return; } ! 252, case 1
		if (R == R_288) { print "block drinking rule"; return; } ! 253, case 1
		if (R == R_289) { print "block saying sorry rule"; return; } ! 254, case 1
		if (R == R_290) { print "block swearing obscenely rule"; return; } ! 255, case 1
		if (R == R_291) { print "block swearing mildly rule"; return; } ! 256, case 1
		if (R == R_292) { print "block swinging rule"; return; } ! 257, case 1
		if (R == R_293) { print "block rubbing rule"; return; } ! 258, case 1
		if (R == R_294) { print "block setting it to rule"; return; } ! 259, case 1
		if (R == R_295) { print "block waving hands rule"; return; } ! 260, case 1
		if (R == R_296) { print "block buying rule"; return; } ! 261, case 1
		if (R == R_297) { print "block singing rule"; return; } ! 262, case 1
		if (R == R_298) { print "block climbing rule"; return; } ! 263, case 1
		if (R == R_299) { print "block sleeping rule"; return; } ! 264, case 1
		if (R == R_739) { print "mark items as seen when looking rule"; return; } ! 265, case 1
		if (R == R_740) { print "mark items as seen on opening a container rule"; return; } ! 266, case 1
		if (R == R_741) { print "mark items as seen on examining rule"; return; } ! 267, case 1
		if (R == R_745) { print "block informing rule"; return; } ! 268, case 1
		if (R == R_746) { print "block quizzing rule"; return; } ! 269, case 1
		if (R == R_747) { print "implicit-conversing needs current interlocutor rule"; return; } ! 270, case 1
		if (R == R_748) { print "can't converse with absent interlocutor rule"; return; } ! 271, case 1
		if (R == R_753) { print "greet a new interlocutor rule"; return; } ! 272, case 1
		if (R == R_754) { print "giving orders needs an interlocutor rule"; return; } ! 273, case 1
		if (R == R_756) { print "can't greet current interlocutor rule"; return; } ! 274, case 1
		if (R == R_757) { print "note current interlocutor when greeted rule"; return; } ! 275, case 1
		if (R == R_758) { print "can't greet inanimate objects rule"; return; } ! 276, case 1
		if (R == R_759) { print "default greeting rule"; return; } ! 277, case 1
		if (R == R_760) { print "change greeting command to greeting rule"; return; } ! 278, case 1
		if (R == R_761) { print "check what's being hailed rule"; return; } ! 279, case 1
		if (R == R_762) { print "standard hailing rule"; return; } ! 280, case 1
		if (R == R_763) { print "allow hailing rule"; return; } ! 281, case 1
		if (R == R_766) { print "can't say goodbye to someone you're not talking to rule"; return; } ! 282, case 1
		if (R == R_767) { print "reset interlocutor on saying goodbye rule"; return; } ! 283, case 1
		if (R == R_768) { print "don't allow saying goodbye to no-one rule"; return; } ! 284, case 1
		if (R == R_769) { print "standard leavetaking rule"; return; } ! 285, case 1
		if (R == R_770) { print "alllow leavetaking rule"; return; } ! 286, case 1
		if (R == R_771) { print "convert npc leavetaking to player leavetaking rule"; return; } ! 287, case 1
		if (R == R_772) { print "default saying goodbye rule"; return; } ! 288, case 1
		if (R == R_773) { print "say goodbye when moving rule"; return; } ! 289, case 1
		if (R == R_774) { print "reset protocol rule"; return; } ! 290, case 1
		if (R == R_775) { print "greet before saying yes rule"; return; } ! 291, case 1
		if (R == R_776) { print "greet before saying no rule"; return; } ! 292, case 1
		if (R == R_777) { print "greet before saying sorry rule"; return; } ! 293, case 1
		if (R == R_778) { print "change answering yes to saying yes rule"; return; } ! 294, case 1
		if (R == R_779) { print "change answering no to saying no rule"; return; } ! 295, case 1
		if (R == R_780) { print "change answering sorry to saying sorry rule"; return; } ! 296, case 1
		if (R == R_781) { print "block asking about something unknown rule"; return; } ! 297, case 1
		if (R == R_782) { print "block telling about something unknown rule"; return; } ! 298, case 1
		if (R == R_837) { print "use the current interlocutor's suggestion lists rule"; return; } ! 299, case 1
		if (R == R_838) { print "exclude unknown items from suggestions rule"; return; } ! 300, case 1
		if (R == R_839) { print "refer to current interlocutor as him-herself in suggestions rule"; return; } ! 301, case 1
		if (R == R_843) { print "display topic suggestions on explicit greeting rule"; return; } ! 302, case 1
		if (R == R_859) { print "new can't get off things rule"; return; } ! 303, case 1
		if (R == R_860) { print "clever can't take what you're inside rule"; return; } ! 304, case 1
		if (R == R_861) { print "no motion without purpose rule"; return; } ! 305, case 1
		if (R == R_862) { print "rising before departure rule"; return; } ! 306, case 1
		if (R == R_863) { print "implicit exiting rule"; return; } ! 307, case 1
		if (R == R_864) { print "new convert exit into go out rule"; return; } ! 308, case 1
		if (R == R_865) { print "check holder for standing rule"; return; } ! 309, case 1
		if (R == R_866) { print "convert standing to getting off rule"; return; } ! 310, case 1
		if (R == R_867) { print "new describe room emerged into rule"; return; } ! 311, case 1
		if (R == R_868) { print "new describe room stood up into rule"; return; } ! 312, case 1
		if (R == R_869) { print "small kindnesses exit leaves when there's only one way to go rule"; return; } ! 313, case 1
		if (R == R_870) { print "store small kindnesses former location rule"; return; } ! 314, case 1
		if (R == R_871) { print "small kindnesses carry out retreating rule"; return; } ! 315, case 1
		if (R == R_872) { print "small kindnesses automatically get out of containers before going rule"; return; } ! 316, case 1
		if (R == R_873) { print "small kindnesses don't get out of containers automatically when nowhere to go rule"; return; } ! 317, case 1
		if (R == R_875) { print "small kindnesses reporting on exits rule"; return; } ! 318, case 1
		if (R == R_877) { print "allow for switching things in darkness rule"; return; } ! 319, case 1
		if (R == R_878) { print "small kindnesses don't implicitly take inedibles rule"; return; } ! 320, case 1
		if (R == R_879) { print "small kindnesses don't implicitly take unwearables rule"; return; } ! 321, case 1
		if (R == R_889) { print "print library message rule"; return; } ! 322, case 1
		if (R == R_905) { print "custom_internal_i6 reveal any newly visible exterior rule"; return; } ! 323, case 1
		if (R == R_906) { print "fake_newly_visible_exterior rule"; return; } ! 324, case 1
		if (R == R_907) { print "fake_newly_visible_exterior_nothing rule"; return; } ! 325, case 1
		if (R == R_916) { print "reset the prevent undo flag rule"; return; } ! 326, case 1
		if (R == R_917) { print "decide whether the action prevents undo rule"; return; } ! 327, case 1
		if (R == R_1201) { print "Sand-dancer room description body text rule"; return; } ! 328, case 1
		if (R == R_1203) { print "Sand-dancer emergency exit rule"; return; } ! 329, case 1
		if (R == LITTLE_USED_DO_NOTHING_R) { print "little-used do nothing rule"; return; } ! 357, case 1
		if (R == VIRTUAL_MACHINE_STARTUP_R) { print "virtual machine startup rule"; return; } ! 358, case 1
		if (R == INITIALISE_MEMORY_R) { print "initialise memory rule"; return; } ! 359, case 1
		if (R == SEED_RANDOM_NUMBER_GENERATOR_R) { print "seed random number generator rule"; return; } ! 360, case 1
		if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; return; } ! 361, case 1
		if (R == POSITION_PLAYER_IN_MODEL_R) { print "position player in model world rule"; return; } ! 362, case 1
		if (R == ADJUST_LIGHT_R) { print "adjust light rule"; return; } ! 363, case 1
		if (R == ADVANCE_TIME_R) { print "advance time rule"; return; } ! 364, case 1
		if (R == GENERATE_ACTION_R) { print "generate action rule"; return; } ! 365, case 1
		if (R == NOTE_OBJECT_ACQUISITIONS_R) { print "note object acquisitions rule"; return; } ! 366, case 1
		if (R == PARSE_COMMAND_R) { print "parse command rule"; return; } ! 367, case 1
		if (R == TIMED_EVENTS_R) { print "timed events rule"; return; } ! 368, case 1
		if (R == RESURRECT_PLAYER_IF_ASKED_R) { print "resurrect player if asked rule"; return; } ! 369, case 1
		if (R == ASK_FINAL_QUESTION_R) { print "ask the final question rule"; return; } ! 370, case 1
		if (R == DetectSceneChange) { print "scene change machinery rule"; return; } ! 371, case 1
		if (R == BASIC_ACCESSIBILITY_R) { print "basic accessibility rule"; return; } ! 374, case 1
		if (R == BASIC_VISIBILITY_R) { print "basic visibility rule"; return; } ! 375, case 1
		if (R == CARRYING_REQUIREMENTS_R) { print "carrying requirements rule"; return; } ! 376, case 1
		if (R == REQUESTED_ACTIONS_REQUIRE_R) { print "requested actions require persuasion rule"; return; } ! 377, case 1
		if (R == CARRY_OUT_REQUESTED_ACTIONS_R) { print "carry out requested actions rule"; return; } ! 378, case 1
		if (R == DESCEND_TO_SPECIFIC_ACTION_R) { print "descend to specific action-processing rule"; return; } ! 379, case 1
		if (R == WORK_OUT_DETAILS_OF_SPECIFIC_R) { print "work out details of specific action rule"; return; } ! 380, case 1
		if (R == ACCESS_THROUGH_BARRIERS_R) { print "access through barriers rule"; return; } ! 381, case 1
		if (R == CANT_REACH_INSIDE_CLOSED_R) { print "can't reach inside closed containers rule"; return; } ! 382, case 1
		if (R == CANT_REACH_INSIDE_ROOMS_R) { print "can't reach inside rooms rule"; return; } ! 383, case 1
		if (R == CANT_REACH_OUTSIDE_CLOSED_R) { print "can't reach outside closed containers rule"; return; } ! 384, case 1
		if (R == STANDARD_NAME_PRINTING_R) { print "standard name printing rule"; return; } ! 388, case 1
		if (R == STANDARD_CONTENTS_LISTING_R) { print "standard contents listing rule"; return; } ! 401, case 1
		if (R == ENABLE_GLULX_ACCEL_R) { print "enable Glulx acceleration rule"; return; } ! 465, case 1
		if (R == PRINT_OBITUARY_HEADLINE_R) { print "print obituary headline rule"; return; } ! 472, case 1
		if (R == PRINT_FINAL_SCORE_R) { print "print final score rule"; return; } ! 473, case 1
		if (R == DISPLAY_FINAL_STATUS_LINE_R) { print "display final status line rule"; return; } ! 474, case 1
		if (R == IMMEDIATELY_RESTART_VM_R) { print "immediately restart the VM rule"; return; } ! 478, case 1
		if (R == IMMEDIATELY_RESTORE_SAVED_R) { print "immediately restore saved game rule"; return; } ! 479, case 1
		if (R == IMMEDIATELY_QUIT_R) { print "immediately quit rule"; return; } ! 480, case 1
		if (R == IMMEDIATELY_UNDO_R) { print "immediately undo rule"; return; } ! 481, case 1
		if (R == READ_FINAL_ANSWER_R) { print "read the final answer rule"; return; } ! 482, case 1
		if (R == QUIT_THE_GAME_R) { print "quit the game rule"; return; } ! 690, case 1
		if (R == SAVE_THE_GAME_R) { print "save the game rule"; return; } ! 694, case 1
		if (R == RESTORE_THE_GAME_R) { print "restore the game rule"; return; } ! 698, case 1
		if (R == RESTART_THE_GAME_R) { print "restart the game rule"; return; } ! 702, case 1
		if (R == VERIFY_THE_STORY_FILE_R) { print "verify the story file rule"; return; } ! 706, case 1
		if (R == SWITCH_TRANSCRIPT_ON_R) { print "switch the story transcript on rule"; return; } ! 710, case 1
		if (R == SWITCH_TRANSCRIPT_OFF_R) { print "switch the story transcript off rule"; return; } ! 714, case 1
		if (R == ANNOUNCE_STORY_FILE_VERSION_R) { print "announce the story file version rule"; return; } ! 718, case 1
		if (R == ANNOUNCE_SCORE_R) { print "announce the score rule"; return; } ! 722, case 1
		if (R == PREFER_ABBREVIATED_R) { print "prefer abbreviated room descriptions rule"; return; } ! 726, case 1
		if (R == REP_PREFER_ABBREVIATED_R) { print "standard report preferring abbreviated room descriptions rule"; return; } ! 727, case 1
		if (R == PREFER_UNABBREVIATED_R) { print "prefer unabbreviated room descriptions rule"; return; } ! 731, case 1
		if (R == REP_PREFER_UNABBREVIATED_R) { print "standard report preferring unabbreviated room descriptions rule"; return; } ! 732, case 1
		if (R == PREFER_SOMETIMES_ABBREVIATED_R) { print "prefer sometimes abbreviated room descriptions rule"; return; } ! 736, case 1
		if (R == REP_PREFER_SOMETIMES_ABBR_R) { print "standard report preferring sometimes abbreviated room descriptions rule"; return; } ! 737, case 1
		if (R == SWITCH_SCORE_NOTIFY_ON_R) { print "switch score notification on rule"; return; } ! 741, case 1
		if (R == REP_SWITCH_NOTIFY_ON_R) { print "standard report switching score notification on rule"; return; } ! 742, case 1
		if (R == SWITCH_SCORE_NOTIFY_OFF_R) { print "switch score notification off rule"; return; } ! 746, case 1
		if (R == REP_SWITCH_NOTIFY_OFF_R) { print "standard report switching score notification off rule"; return; } ! 747, case 1
		if (R == ANNOUNCE_PRONOUN_MEANINGS_R) { print "announce the pronoun meanings rule"; return; } ! 751, case 1
		if (R == R_14) { print "A first turn sequence rule"; return; } ! 847, case 2
		if (R == R_15) { print "A last turn sequence rule"; return; } ! 848, case 2
		if (R == R_30) { print "last specific action-processing rule"; return; } ! 849, case 2
		if (R == R_159) { print "Setting action variables for exiting"; return; } ! 850, case 2
		if (R == R_744) { print "Report requesting epistemic status of"; return; } ! 851, case 2
		if (R == R_749) { print "Instead of implicit-quizzing"; return; } ! 852, case 2
		if (R == R_750) { print "Instead of implicit-informing"; return; } ! 853, case 2
		if (R == R_751) { print "Instead of implicit-requesting"; return; } ! 854, case 2
		if (R == R_752) { print "Instead of implicit-imploring"; return; } ! 855, case 2
		if (R == R_764) { print "When play begins"; return; } ! 856, case 2
		if (R == R_784) { print "After printing the name of something ( called the target )"; return; } ! 857, case 2
		if (R == R_825) { print "Every turn"; return; } ! 858, case 2
		if (R == R_826) { print "After printing the name of an ambiguously plural thing ( called the suspect )"; return; } ! 859, case 2
		if (R == R_840) { print "Check listing suggested topics when the current interlocutor is not a person"; return; } ! 860, case 2
		if (R == R_842) { print "Carry out listing suggested topics"; return; } ! 861, case 2
		if (R == R_844) { print "topic list displays"; return; } ! 862, case 1
		if (R == R_846) { print "Instead of saying yes"; return; } ! 863, case 2
		if (R == R_847) { print "Instead of saying no"; return; } ! 864, case 2
		if (R == R_848) { print "Instead of finishing conversation when current interlocutor is a person and can't leave conversation early is true"; return; } ! 865, case 2
		if (R == R_849) { print "Every turn when current interlocutor is a person and show topics every turn is true"; return; } ! 866, case 2
		if (R == R_851) { print "Carry out saying hello to a person ( called the conversant )"; return; } ! 867, case 2
		if (R == R_852) { print "Carry out saying goodbye to a person ( called the conversant )"; return; } ! 868, case 2
		if (R == R_853) { print "First after informing somebody about something ( called the thread )"; return; } ! 869, case 2
		if (R == R_854) { print "First after quizzing somebody about something ( called the thread )"; return; } ! 870, case 2
		if (R == R_855) { print "Before listing suggested topics"; return; } ! 871, case 2
		if (R == R_856) { print "After listing suggested topics"; return; } ! 872, case 2
		if (R == R_857) { print "Instead of saying hello to yourself"; return; } ! 873, case 2
		if (R == R_858) { print "Instead of hailing"; return; } ! 874, case 2
		if (R == R_880) { print "Carry out using"; return; } ! 875, case 2
		if (R == R_881) { print "Before showing something ( called the item ) to someone ( called the viewer )"; return; } ! 876, case 2
		if (R == R_882) { print "Before listing contents while taking inventory"; return; } ! 877, case 2
		if (R == R_883) { print "Before listing contents while taking inventory"; return; } ! 878, case 2
		if (R == R_884) { print "Before grouping together things required by a plan"; return; } ! 879, case 2
		if (R == R_885) { print "When play begins"; return; } ! 880, case 2
		if (R == R_910) { print "When play begins"; return; } ! 881, case 2
		if (R == R_911) { print "Every turn when a dramatic scene is not happening and Coyote's Offer has not ended and a random chance of 1 in 40 succeeds"; return; } ! 882, case 2
		if (R == R_912) { print "Before saying hello to when noun is not a spirit animal and noun is not voice"; return; } ! 883, case 2
		if (R == R_918) { print "Carry out smoking"; return; } ! 884, case 2
		if (R == R_919) { print "Rule for deciding whether to allow undo"; return; } ! 885, case 2
		if (R == R_920) { print "Rule for printing the banner text while turn count is 1"; return; } ! 886, case 2
		if (R == R_921) { print "After printing the banner text while turn count is not 1"; return; } ! 887, case 2
		if (R == R_922) { print "When play begins"; return; } ! 888, case 2
		if (R == R_923) { print "Instead of going when player holds freedom"; return; } ! 889, case 2
		if (R == R_924) { print "Instead of going when player holds honor"; return; } ! 890, case 2
		if (R == R_925) { print "Instead of going when player holds spirit"; return; } ! 891, case 2
		if (R == R_926) { print "Does the player mean doing something to a memory"; return; } ! 892, case 2
		if (R == R_927) { print "When play begins"; return; } ! 893, case 2
		if (R == R_929) { print "Every turn when a charged thing ( called the item ) is visible"; return; } ! 894, case 2
		if (R == R_930) { print "Instead of doing anything other than examining when noun is emotional baggage or second noun is emotional baggage"; return; } ! 895, case 2
		if (R == R_931) { print "Instead of waiting"; return; } ! 896, case 2
		if (R == R_933) { print "Check brooding when noun is not a memory"; return; } ! 897, case 2
		if (R == R_934) { print "Carry out brooding"; return; } ! 898, case 2
		if (R == R_935) { print "Instead of doing anything other than brooding or trading to a memory"; return; } ! 899, case 2
		if (R == R_936) { print "Instead of thinking"; return; } ! 900, case 2
		if (R == R_937) { print "Instead of brooding when noun suggests a memory"; return; } ! 901, case 2
		if (R == R_938) { print "Instead of doing anything to the bunny's bow tie"; return; } ! 902, case 2
		if (R == R_939) { print "Before taking cans of food when player holds can opener and player holds luck"; return; } ! 903, case 2
		if (R == R_944) { print "Carry out switching on flashlight"; return; } ! 904, case 2
		if (R == R_945) { print "Carry out switching off flashlight"; return; } ! 905, case 2
		if (R == R_946) { print "Instead of dropping flashlight"; return; } ! 906, case 2
		if (R == R_947) { print "Instead of burning the lighter"; return; } ! 907, case 2
		if (R == R_950) { print "Instead of switching on or switching off lighter"; return; } ! 908, case 2
		if (R == R_953) { print "Every turn when noun is a thing and noun is required by a plan and noun is not noted as useful"; return; } ! 909, case 2
		if (R == R_955) { print "Every turn when doing something to smell of gasoline and gas can is not noted as useful"; return; } ! 910, case 2
		if (R == R_956) { print "Every turn when doing something to cans of food and canned oranges are not noted as useful"; return; } ! 911, case 2
		if (R == R_957) { print "For printing the name of canned oranges while canned oranges are off-stage"; return; } ! 912, case 2
		if (R == R_958) { print "For printing the name of gas can while gas can is off-stage"; return; } ! 913, case 2
		if (R == R_959) { print "Before printing the name of cobwebs when player holds courage"; return; } ! 914, case 2
		if (R == R_960) { print "Before printing the name of cage when player holds strength"; return; } ! 915, case 2
		if (R == R_961) { print "Before printing the name of piece of jade when player holds luck"; return; } ! 916, case 2
		if (R == R_962) { print "After printing the name of pickup when player holds scent"; return; } ! 917, case 2
		if (R == R_963) { print "Instead of dropping a talent"; return; } ! 918, case 2
		if (R == R_964) { print "Instead of inserting a talent into something"; return; } ! 919, case 2
		if (R == R_965) { print "Rule for supplying a missing noun while smoking"; return; } ! 920, case 2
		if (R == R_966) { print "Instead of burning the pack of cigarettes"; return; } ! 921, case 2
		if (R == R_967) { print "Check smoking when count of pack of cigarettes is 0"; return; } ! 922, case 2
		if (R == R_968) { print "Carry out smoking"; return; } ! 923, case 2
		if (R == R_969) { print "Check smoking when noun is not pack of cigarettes"; return; } ! 924, case 2
		if (R == R_970) { print "Check smoking when lighter is not held"; return; } ! 925, case 2
		if (R == R_971) { print "Before smoking when lighter is not held and lighter is visible"; return; } ! 926, case 2
		if (R == R_972) { print "Before smoking when pack of cigarettes is not held and pack of cigarettes is visible"; return; } ! 927, case 2
		if (R == R_973) { print "First report smoking"; return; } ! 928, case 2
		if (R == R_974) { print "Report smoking"; return; } ! 929, case 2
		if (R == R_975) { print "Report smoking"; return; } ! 930, case 2
		if (R == R_976) { print "Report smoking"; return; } ! 931, case 2
		if (R == R_977) { print "Report smoking"; return; } ! 932, case 2
		if (R == R_978) { print "Report smoking"; return; } ! 933, case 2
		if (R == R_979) { print "Last report smoking"; return; } ! 934, case 2
		if (R == R_981) { print "After printing the name of the pack of cigarettes while taking inventory"; return; } ! 935, case 2
		if (R == R_982) { print "Instead of opening photo when the number of retrieved memories is less than 4"; return; } ! 936, case 2
		if (R == R_983) { print "Rule for reaching inside photo"; return; } ! 937, case 2
		if (R == R_984) { print "Instead of inserting anything into photo"; return; } ! 938, case 2
		if (R == R_985) { print "Instead of taking the desert sand"; return; } ! 939, case 2
		if (R == R_987) { print "Instead of attacking pickup truck"; return; } ! 940, case 2
		if (R == R_988) { print "After opening the pickup truck"; return; } ! 941, case 2
		if (R == R_989) { print "After closing the truck"; return; } ! 942, case 2
		if (R == R_990) { print "Before entering truck when truck is closed"; return; } ! 943, case 2
		if (R == R_991) { print "Before exiting when player is in truck and truck is closed"; return; } ! 944, case 2
		if (R == R_992) { print "Instead of switching on or switching off pickup truck"; return; } ! 945, case 2
		if (R == R_993) { print "After switching on the headlights"; return; } ! 946, case 2
		if (R == R_994) { print "After switching off the headlights"; return; } ! 947, case 2
		if (R == R_995) { print "Instead of doing anything to whiffs of evaporating gasoline"; return; } ! 948, case 2
		if (R == R_996) { print "Instead of touching the Saguaro"; return; } ! 949, case 2
		if (R == R_997) { print "Instead of taking the Saguaro"; return; } ! 950, case 2
		if (R == R_998) { print "Before going south in Backtracking"; return; } ! 951, case 2
		if (R == R_999) { print "Instead of opening , entering , or attacking boarded-up door"; return; } ! 952, case 2
		if (R == R_1000) { print "Instead of entering concrete building when location is Backtracking or location is Middle of Nowhere"; return; } ! 953, case 2
		if (R == R_1001) { print "Instead of entering concrete building"; return; } ! 954, case 2
		if (R == R_1002) { print "Instead of going inside from Crumbling Concrete when pane of cracked glass is closed"; return; } ! 955, case 2
		if (R == R_1003) { print "Instead of taking the tumbleweed"; return; } ! 956, case 2
		if (R == R_1004) { print "Instead of consulting the guidebook about ~sand-dancer/sand/dancer/lizard/lizards/brown~"; return; } ! 957, case 2
		if (R == R_1005) { print "Instead of consulting the guidebook about ~hare/rabbit~"; return; } ! 958, case 2
		if (R == R_1006) { print "Instead of consulting the guidebook about ~coyote~"; return; } ! 959, case 2
		if (R == R_1007) { print "Instead of turning or pushing or pulling emergency radio"; return; } ! 960, case 2
		if (R == R_1008) { print "Carry out coarse tuning"; return; } ! 961, case 2
		if (R == R_1009) { print "Check tuning when the noun does not provide a frequency tuned to"; return; } ! 962, case 2
		if (R == R_1010) { print "Check tuning when the frequency understood is less than the minimum frequency of the noun"; return; } ! 963, case 2
		if (R == R_1011) { print "Check tuning when the frequency understood is greater than the maximum frequency of the noun"; return; } ! 964, case 2
		if (R == R_1012) { print "Check tuning when the frequency understood is the frequency tuned to of the noun"; return; } ! 965, case 2
		if (R == R_1013) { print "Check tuning when the radio is switched off"; return; } ! 966, case 2
		if (R == R_1014) { print "Carry out tuning"; return; } ! 967, case 2
		if (R == R_1015) { print "Report tuning"; return; } ! 968, case 2
		if (R == R_1016) { print "Check switching on radio when emergency lights are switched off"; return; } ! 969, case 2
		if (R == R_1017) { print "After switching on radio"; return; } ! 970, case 2
		if (R == R_1018) { print "Instead of opening or closing a window"; return; } ! 971, case 2
		if (R == R_1019) { print "Instead of throwing something not hefty at a closed window"; return; } ! 972, case 2
		if (R == R_1020) { print "Instead of inserting something hefty into the wallet"; return; } ! 973, case 2
		if (R == R_1021) { print "Instead of throwing something ( called the missile ) at a closed window ( called the targeted window )"; return; } ! 974, case 2
		if (R == R_1022) { print "Instead of throwing something at an open window ( called the broken window )"; return; } ! 975, case 2
		if (R == R_1023) { print "Instead of attacking a window"; return; } ! 976, case 2
		if (R == R_1024) { print "Instead of attacking an open window"; return; } ! 977, case 2
		if (R == R_1025) { print "Report going through a window"; return; } ! 978, case 2
		if (R == R_1026) { print "Instead of going through tiny frosted window"; return; } ! 979, case 2
		if (R == R_1027) { print "Instead of going through dust-covered window"; return; } ! 980, case 2
		if (R == R_1028) { print "Instead of touching or rubbing or attacking or pulling the cobwebs when player holds courage"; return; } ! 981, case 2
		if (R == R_1029) { print "Instead of touching or rubbing or attacking or pulling the cobwebs"; return; } ! 982, case 2
		if (R == R_1030) { print "Instead of taking something enclosed by the hole when player does not hold courage"; return; } ! 983, case 2
		if (R == R_1031) { print "After taking the duct tape"; return; } ! 984, case 2
		if (R == R_1032) { print "Instead of taking cobwebs when player holds courage"; return; } ! 985, case 2
		if (R == R_1033) { print "Instead of inserting anything into the hole"; return; } ! 986, case 2
		if (R == R_1034) { print "Instead of going to a room regionally in Office Interior from dim Staging Area"; return; } ! 987, case 2
		if (R == R_1035) { print "Instead of going nowhere from dim Staging Area"; return; } ! 988, case 2
		if (R == R_1036) { print "Instead of examining anything in dim Staging Area"; return; } ! 989, case 2
		if (R == R_1037) { print "After touching desk in dim Staging Area"; return; } ! 990, case 2
		if (R == R_1038) { print "After opening drawer in dim Staging Area"; return; } ! 991, case 2
		if (R == R_1039) { print "Instead of opening desk"; return; } ! 992, case 2
		if (R == R_1040) { print "After taking flashlight in dim Staging Area"; return; } ! 993, case 2
		if (R == R_1041) { print "Before switching on flashlight in dim Staging Area"; return; } ! 994, case 2
		if (R == R_1042) { print "After switching on flashlight"; return; } ! 995, case 2
		if (R == R_1043) { print "Instead of entering half-collapsed desk"; return; } ! 996, case 2
		if (R == R_1044) { print "Instead of taking poster"; return; } ! 997, case 2
		if (R == R_1045) { print "For writing a paragraph about the emergency lights"; return; } ! 998, case 2
		if (R == R_1046) { print "After switching on the emergency lights"; return; } ! 999, case 2
		if (R == R_1047) { print "After switching off the emergency lights"; return; } ! 1000, case 2
		if (R == R_1048) { print "Instead of climbing or entering the utility ladder"; return; } ! 1001, case 2
		if (R == R_1049) { print "Instead of taking cans of food"; return; } ! 1002, case 2
		if (R == R_1050) { print "Instead of opening or eating cans of food"; return; } ! 1003, case 2
		if (R == R_1051) { print "Instead of taking cans of food when player holds can opener"; return; } ! 1004, case 2
		if (R == R_1052) { print "Instead of taking cans of food when player holds can opener and player holds luck and canned oranges are not handled"; return; } ! 1005, case 2
		if (R == R_1053) { print "Instead of taking cans of food when canned oranges are handled"; return; } ! 1006, case 2
		if (R == R_1054) { print "Instead of unlocking cage with rusted key"; return; } ! 1007, case 2
		if (R == R_1055) { print "Instead of attacking closed cage when player holds strength"; return; } ! 1008, case 2
		if (R == R_1056) { print "Instead of attacking closed cage"; return; } ! 1009, case 2
		if (R == R_1057) { print "Instead of attacking cage"; return; } ! 1010, case 2
		if (R == R_1058) { print "Instead of touching blanket when blanket is in cage"; return; } ! 1011, case 2
		if (R == R_1059) { print "Rule for reaching inside the wire mesh cage when we are touching"; return; } ! 1012, case 2
		if (R == R_1060) { print "After wearing blanket"; return; } ! 1013, case 2
		if (R == R_1061) { print "Instead of jumping when location is Roof"; return; } ! 1014, case 2
		if (R == R_1062) { print "Instead of climbing or entering metal rungs"; return; } ! 1015, case 2
		if (R == R_1063) { print "Instead of going nowhere when location is Roof"; return; } ! 1016, case 2
		if (R == R_1064) { print "Instead of going up in Roof when player does not hold courage and huge metal barrel is not placed correctly"; return; } ! 1017, case 2
		if (R == R_1065) { print "Report going up from Roof when player holds courage"; return; } ! 1018, case 2
		if (R == R_1066) { print "For writing a paragraph about huge metal barrel"; return; } ! 1019, case 2
		if (R == R_1067) { print "Instead of entering or climbing the placed correctly huge metal barrel"; return; } ! 1020, case 2
		if (R == R_1068) { print "Instead of entering or climbing the huge metal barrel"; return; } ! 1021, case 2
		if (R == R_1069) { print "Instead of pushing the not placed correctly huge metal barrel when player does not hold strength"; return; } ! 1022, case 2
		if (R == R_1070) { print "Instead of pushing the not placed correctly huge metal barrel when player holds strength"; return; } ! 1023, case 2
		if (R == R_1071) { print "Report going up from Roof when huge metal barrel is placed correctly"; return; } ! 1024, case 2
		if (R == R_1072) { print "Instead of pushing the placed correctly huge metal barrel"; return; } ! 1025, case 2
		if (R == R_1073) { print "Instead of doing anything to smell of gasoline"; return; } ! 1026, case 2
		if (R == R_1074) { print "Instead of smelling Control Center"; return; } ! 1027, case 2
		if (R == R_1075) { print "Instead of searching or taking piles of trash"; return; } ! 1028, case 2
		if (R == R_1076) { print "Instead of searching or taking or looking under or pushing or pulling sheet of corrugated metal"; return; } ! 1029, case 2
		if (R == R_1077) { print "Instead of looking under piles of trash"; return; } ! 1030, case 2
		if (R == R_1078) { print "Instead of looking under piles of trash when player holds scent"; return; } ! 1031, case 2
		if (R == R_1079) { print "Instead of opening gas can"; return; } ! 1032, case 2
		if (R == R_1080) { print "Before going from Around the Tower to Open Desert"; return; } ! 1033, case 2
		if (R == R_1082) { print "Before going to The Open Desert when The Open Desert is unvisited"; return; } ! 1034, case 2
		if (R == R_1083) { print "Report going to The Open Desert when The Open Desert is unvisited"; return; } ! 1035, case 2
		if (R == R_1084) { print "Instead of doing anything to desert flotsam"; return; } ! 1036, case 2
		if (R == R_1085) { print "Before going to Open Desert"; return; } ! 1037, case 2
		if (R == R_1086) { print "Instead of dropping something when location is The Open Desert"; return; } ! 1038, case 2
		if (R == R_1087) { print "Instead of giving anything to the lizard"; return; } ! 1039, case 2
		if (R == R_1088) { print "Instead of attacking or taking or pushing or touching the lizard"; return; } ! 1040, case 2
		if (R == R_1089) { print "Instead of kissing the lizard"; return; } ! 1041, case 2
		if (R == R_1090) { print "Every turn when radio is switched on and frequency tuned to of radio is emergency frequency and voice has not been visible"; return; } ! 1042, case 2
		if (R == R_1091) { print "After quizzing voice about introduction"; return; } ! 1043, case 2
		if (R == R_1092) { print "After informing voice about never mind"; return; } ! 1044, case 2
		if (R == R_1093) { print "After quizzing voice about what that means"; return; } ! 1045, case 2
		if (R == R_1094) { print "After informing voice about being lost"; return; } ! 1046, case 2
		if (R == R_1095) { print "After informing voice about yes-suggestion"; return; } ! 1047, case 2
		if (R == R_1096) { print "Instead of switching off radio when current interlocutor is voice"; return; } ! 1048, case 2
		if (R == R_1098) { print "Rule for setting action variables for trading"; return; } ! 1049, case 2
		if (R == R_1099) { print "Check trading when the trader is not a spirit animal"; return; } ! 1050, case 2
		if (R == R_1100) { print "Check trading when the noun is not a memory"; return; } ! 1051, case 2
		if (R == R_1101) { print "Check trading when the second noun is not a talent"; return; } ! 1052, case 2
		if (R == R_1102) { print "Check trading when the second noun is held"; return; } ! 1053, case 2
		if (R == R_1103) { print "Check trading when the noun is not in emotional baggage"; return; } ! 1054, case 2
		if (R == R_1104) { print "Check trading when trader needs more memories"; return; } ! 1055, case 2
		if (R == R_1106) { print "Carry out trading"; return; } ! 1056, case 2
		if (R == R_1107) { print "First report trading"; return; } ! 1057, case 2
		if (R == R_1108) { print "Instead of taking a not held talent when a spirit animal ( called the potential trader ) is visible"; return; } ! 1058, case 2
		if (R == R_1109) { print "Instead of giving something to a spirit animal ( called the potential trader )"; return; } ! 1059, case 2
		if (R == R_1110) { print "Instead of doing anything other than quizzing , implicit-quizzing or trading to a not held talent"; return; } ! 1060, case 2
		if (R == R_1111) { print "Instead of smoking during a dramatic scene"; return; } ! 1061, case 2
		if (R == R_1112) { print "Every turn when going and location is Break Room during Sinister Voices"; return; } ! 1062, case 2
		if (R == R_1117) { print "Instead of attacking radio"; return; } ! 1063, case 2
		if (R == R_1118) { print "Before saying hello to the emergency radio"; return; } ! 1064, case 2
		if (R == R_1119) { print "When Rainstorm begins"; return; } ! 1065, case 2
		if (R == R_1120) { print "Every turn when a random chance of 1 in 3 succeeds and player is in Office Interior during Rainstorm"; return; } ! 1066, case 2
		if (R == R_1121) { print "When Rainstorm ends"; return; } ! 1067, case 2
		if (R == R_1122) { print "Instead of smelling location when sage is visible"; return; } ! 1068, case 2
		if (R == R_1123) { print "Instead of smelling sage"; return; } ! 1069, case 2
		if (R == R_1124) { print "Instead of going to The Open Desert during Rainstorm"; return; } ! 1070, case 2
		if (R == R_1125) { print "Instead of listening during Rainstorm"; return; } ! 1071, case 2
		if (R == R_1126) { print "Report going from Crumbling Concrete to Staging Area during Rainstorm"; return; } ! 1072, case 2
		if (R == R_1128) { print "Instead of doing anything to the darting shadow"; return; } ! 1073, case 2
		if (R == R_1129) { print "When Pursuit begins"; return; } ! 1074, case 2
		if (R == R_1131) { print "Before going during Pursuit"; return; } ! 1075, case 2
		if (R == R_1132) { print "Carry out going path of darting shadow when darting shadow is visible during Pursuit"; return; } ! 1076, case 2
		if (R == R_1133) { print "Instead of going path of darting shadow when times followed of darting shadow is at least 4 and darting shadow is visible"; return; } ! 1077, case 2
		if (R == R_1134) { print "When Pursuit ends"; return; } ! 1078, case 2
		if (R == R_1136) { print "When Rabbit's Offer begins"; return; } ! 1079, case 2
		if (R == R_1137) { print "Rabbit's conversation starts"; return; } ! 1080, case 1
		if (R == R_1138) { print "After quizzing the rabbit about introduction"; return; } ! 1081, case 2
		if (R == R_1139) { print "After quizzing the rabbit about the rabbit"; return; } ! 1082, case 2
		if (R == R_1140) { print "After quizzing the rabbit about grandma"; return; } ! 1083, case 2
		if (R == R_1141) { print "After informing the rabbit about how he's not real"; return; } ! 1084, case 2
		if (R == R_1142) { print "After quizzing the rabbit about rabbit's judgment"; return; } ! 1085, case 2
		if (R == R_1143) { print "After quizzing the rabbit about how he knows so much about everything"; return; } ! 1086, case 2
		if (R == R_1144) { print "After quizzing the rabbit about down to business"; return; } ! 1087, case 2
		if (R == R_1145) { print "Instead of saying yes when yes-no-suggestion is familiar and location is The Burrow"; return; } ! 1088, case 2
		if (R == R_1146) { print "Instead of saying no when yes-no-suggestion is familiar and location is The Burrow"; return; } ! 1089, case 2
		if (R == R_1147) { print "After informing the rabbit about don't know if I love her"; return; } ! 1090, case 2
		if (R == R_1149) { print "Instead of doing anything to easter basket"; return; } ! 1091, case 2
		if (R == R_1150) { print "After quizzing the rabbit about strength"; return; } ! 1092, case 2
		if (R == R_1151) { print "After quizzing the rabbit about courage"; return; } ! 1093, case 2
		if (R == R_1152) { print "After quizzing the rabbit about more about trading"; return; } ! 1094, case 2
		if (R == R_1153) { print "After informing the rabbit about you don't want to trade"; return; } ! 1095, case 2
		if (R == R_1154) { print "Check trading when the noun is not a memory and the trader is the rabbit"; return; } ! 1096, case 2
		if (R == R_1155) { print "Report trading when Rabbit is visible"; return; } ! 1097, case 2
		if (R == R_1156) { print "After quizzing the rabbit about more coming"; return; } ! 1098, case 2
		if (R == R_1157) { print "Instead of examining up when lookup-suggestion is familiar"; return; } ! 1099, case 2
		if (R == R_1158) { print "When Temptation begins"; return; } ! 1100, case 2
		if (R == R_1159) { print "Instead of doing anything to the distant figure"; return; } ! 1101, case 2
		if (R == R_1160) { print "Instead of waving hands during Temptation"; return; } ! 1102, case 2
		if (R == R_1161) { print "Every turn during Temptation"; return; } ! 1103, case 2
		if (R == R_1162) { print "When Temptation ends"; return; } ! 1104, case 2
		if (R == R_1163) { print "Carry out going during Chase"; return; } ! 1105, case 2
		if (R == R_1164) { print "Every turn during Chase"; return; } ! 1106, case 2
		if (R == R_1165) { print "When Chase begins"; return; } ! 1107, case 2
		if (R == R_1166) { print "When Chase ends"; return; } ! 1108, case 2
		if (R == R_1167) { print "Instead of doing anything to snarling shadows"; return; } ! 1109, case 2
		if (R == R_1168) { print "Instead of brooding during Fight"; return; } ! 1110, case 2
		if (R == R_1169) { print "When Fight begins"; return; } ! 1111, case 2
		if (R == R_1170) { print "Every turn when circle of snarling coyotes is visible"; return; } ! 1112, case 2
		if (R == R_1171) { print "Instead of going when circle of snarling coyotes is visible"; return; } ! 1113, case 2
		if (R == R_1172) { print "When Fight ends in cowardice"; return; } ! 1114, case 2
		if (R == R_1173) { print "Instead of attacking during Fight"; return; } ! 1115, case 2
		if (R == R_1174) { print "Instead of throwing anything at circle of snarling coyotes during Fight"; return; } ! 1116, case 2
		if (R == R_1175) { print "When Fight ends"; return; } ! 1117, case 2
		if (R == R_1176) { print "When Coyote's Offer begins"; return; } ! 1118, case 2
		if (R == R_1177) { print "Coyote's conversation starts"; return; } ! 1119, case 1
		if (R == R_1178) { print "After quizzing Coyote about introduction"; return; } ! 1120, case 2
		if (R == R_1179) { print "When Coyote's Offer begins"; return; } ! 1121, case 2
		if (R == R_1180) { print "Instead of switching on flashlight during Coyote's Offer"; return; } ! 1122, case 2
		if (R == R_1181) { print "Instead of taking cigarette"; return; } ! 1123, case 2
		if (R == R_1182) { print "Instead of dropping cigarette"; return; } ! 1124, case 2
		if (R == R_1183) { print "Instead of smoking when player holds cigarette during Coyote's Offer"; return; } ! 1125, case 2
		if (R == R_1184) { print "Instead of smoking during Coyote's Offer"; return; } ! 1126, case 2
		if (R == R_1185) { print "Instead of saying yes when yes-no-suggestion is familiar and Coyote is visible"; return; } ! 1127, case 2
		if (R == R_1186) { print "Instead of saying no when yes-no-suggestion is familiar and Coyote is visible"; return; } ! 1128, case 2
		if (R == R_1189) { print "After quizzing the Coyote about advice"; return; } ! 1129, case 2
		if (R == R_1190) { print "After quizzing Coyote about Coyote"; return; } ! 1130, case 2
		if (R == R_1191) { print "After quizzing Coyote about the rabbit"; return; } ! 1131, case 2
		if (R == R_1192) { print "After quizzing Coyote about down to business"; return; } ! 1132, case 2
		if (R == R_1193) { print "After quizzing Coyote about luck"; return; } ! 1133, case 2
		if (R == R_1194) { print "After quizzing Coyote about scent"; return; } ! 1134, case 2
		if (R == R_1195) { print "Report trading when Coyote is visible"; return; } ! 1135, case 2
		if (R == R_1196) { print "After quizzing Coyote about more coming"; return; } ! 1136, case 2
		if (R == R_1198) { print "Instead of leaving the building when time for arrival"; return; } ! 1137, case 2
		if (R == R_1199) { print "Every turn during Sand-dancer's Arrival"; return; } ! 1138, case 2
		if (R == R_1200) { print "Report going during Sand-dancer's Arrival"; return; } ! 1139, case 2
		if (R == R_1206) { print "Instead of throwing something at a window during Sand-dancer's Arrival"; return; } ! 1140, case 2
		if (R == R_1207) { print "Before wasting time during Sand-dancer's Arrival"; return; } ! 1141, case 2
		if (R == R_1208) { print "After going up during Sand-dancer's Arrival"; return; } ! 1142, case 2
		if (R == R_1209) { print "Before going up during Sand-dancer's Arrival"; return; } ! 1143, case 2
		if (R == R_1210) { print "When Sand-dancer's Offer begins"; return; } ! 1144, case 2
		if (R == R_1212) { print "Sand-dancer's conversation starts"; return; } ! 1145, case 1
		if (R == R_1213) { print "After quizzing Sand-dancer about introduction"; return; } ! 1146, case 2
		if (R == R_1214) { print "Instead of hailing when Sand-dancer is visible"; return; } ! 1147, case 2
		if (R == R_1215) { print "After quizzing Sand-dancer about Sand-dancer"; return; } ! 1148, case 2
		if (R == R_1216) { print "After quizzing Sand-dancer about thousands of lizards"; return; } ! 1149, case 2
		if (R == R_1217) { print "Instead of quizzing Sand-dancer about final choice when the number of complete plans is 0"; return; } ! 1150, case 2
		if (R == R_1218) { print "After quizzing Sand-dancer about path selection"; return; } ! 1151, case 2
		if (R == R_1220) { print "After taking something required by a plan during Sand-dancer's Offer"; return; } ! 1152, case 2
		if (R == R_1221) { print "After quizzing Sand-dancer about final choice"; return; } ! 1153, case 2
		if (R == R_1222) { print "Instead of saying yes when yes-no-suggestion is familiar and Sand-dancer is visible"; return; } ! 1154, case 2
		if (R == R_1223) { print "Instead of saying no when yes-no-suggestion is familiar and Sand-dancer is visible"; return; } ! 1155, case 2
		if (R == R_1225) { print "After informing Sand-dancer about not sure if I'm happy"; return; } ! 1156, case 2
		if (R == R_1226) { print "After quizzing Sand-dancer about doing the trade"; return; } ! 1157, case 2
		if (R == R_1227) { print "After quizzing Sand-dancer about spirit"; return; } ! 1158, case 2
		if (R == R_1228) { print "After quizzing Sand-dancer about honor"; return; } ! 1159, case 2
		if (R == R_1229) { print "After quizzing Sand-dancer about freedom"; return; } ! 1160, case 2
		if (R == R_1231) { print "Check trading when the trader needs more memories during Sand-dancer's offer"; return; } ! 1161, case 2
		if (R == R_1232) { print "Report trading when Sand-dancer is visible"; return; } ! 1162, case 2
		if (R == R_8) { print "start in the correct scenes rule"; return; } ! 1163, case 1
		if (R == POSITION_PLAYER_IN_MODEL_R) { print "position player in model world rule"; return; } ! 1164, case 1
		if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; return; } ! 1165, case 1
		if (R == SEED_RANDOM_NUMBER_GENERATOR_R) { print "seed random number generator rule"; return; } ! 1166, case 1
		if (R == VIRTUAL_MACHINE_STARTUP_R) { print "virtual machine startup rule"; return; } ! 1167, case 1
		if (R == INITIALISE_MEMORY_R) { print "initialise memory rule"; return; } ! 1168, case 1
		if (R == R_9) { print "when play begins stage rule"; return; } ! 1169, case 1
		if (R == R_10) { print "fix baseline scoring rule"; return; } ! 1170, case 1
		if (R == R_11) { print "display banner rule"; return; } ! 1171, case 1
		if (R == R_12) { print "initial room description rule"; return; } ! 1172, case 1
		if (R == GENERATE_ACTION_R) { print "generate action rule"; return; } ! 1173, case 1
		if (R == PARSE_COMMAND_R) { print "parse command rule"; return; } ! 1174, case 1
		if (R == TIMED_EVENTS_R) { print "timed events rule"; return; } ! 1175, case 1
		if (R == ADVANCE_TIME_R) { print "advance time rule"; return; } ! 1176, case 1
		if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; return; } ! 1177, case 1
		if (R == ADJUST_LIGHT_R) { print "adjust light rule"; return; } ! 1178, case 1
		if (R == NOTE_OBJECT_ACQUISITIONS_R) { print "note object acquisitions rule"; return; } ! 1179, case 1
		if (R == R_16) { print "notify score changes rule"; return; } ! 1180, case 1
		if (R == R_17) { print "when play ends stage rule"; return; } ! 1181, case 1
		if (R == RESURRECT_PLAYER_IF_ASKED_R) { print "resurrect player if asked rule"; return; } ! 1182, case 1
		if (R == R_18) { print "print player's obituary rule"; return; } ! 1183, case 1
		if (R == ASK_FINAL_QUESTION_R) { print "ask the final question rule"; return; } ! 1184, case 1
		if (R == DetectSceneChange) { print "scene change machinery rule"; return; } ! 1185, case 1
		if (R == R_21) { print "before stage rule"; return; } ! 1186, case 1
		if (R == R_19) { print "set pronouns from items from multiple object lists rule"; return; } ! 1187, case 1
		if (R == R_20) { print "announce items from multiple object lists rule"; return; } ! 1188, case 1
		if (R == BASIC_VISIBILITY_R) { print "basic visibility rule"; return; } ! 1189, case 1
		if (R == BASIC_ACCESSIBILITY_R) { print "basic accessibility rule"; return; } ! 1190, case 1
		if (R == CARRYING_REQUIREMENTS_R) { print "carrying requirements rule"; return; } ! 1191, case 1
		if (R == R_22) { print "instead stage rule"; return; } ! 1192, case 1
		if (R == REQUESTED_ACTIONS_REQUIRE_R) { print "requested actions require persuasion rule"; return; } ! 1193, case 1
		if (R == CARRY_OUT_REQUESTED_ACTIONS_R) { print "carry out requested actions rule"; return; } ! 1194, case 1
		if (R == DESCEND_TO_SPECIFIC_ACTION_R) { print "descend to specific action-processing rule"; return; } ! 1195, case 1
		if (R == R_23) { print "end action-processing in success rule"; return; } ! 1196, case 1
		if (R == WORK_OUT_DETAILS_OF_SPECIFIC_R) { print "work out details of specific action rule"; return; } ! 1197, case 1
		if (R == ACCESS_THROUGH_BARRIERS_R) { print "access through barriers rule"; return; } ! 1198, case 1
		if (R == CANT_REACH_INSIDE_ROOMS_R) { print "can't reach inside rooms rule"; return; } ! 1199, case 1
		if (R == CANT_REACH_INSIDE_CLOSED_R) { print "can't reach inside closed containers rule"; return; } ! 1200, case 1
		if (R == CANT_REACH_OUTSIDE_CLOSED_R) { print "can't reach outside closed containers rule"; return; } ! 1201, case 1
		if (R == R_35) { print "can't act in the dark rule"; return; } ! 1202, case 1
		if (R == STANDARD_NAME_PRINTING_R) { print "standard name printing rule"; return; } ! 1203, case 1
		if (R == R_59) { print "standard printing the plural name rule"; return; } ! 1204, case 1
		if (R == R_60) { print "standard printing a number of something rule"; return; } ! 1205, case 1
		if (R == STANDARD_CONTENTS_LISTING_R) { print "standard contents listing rule"; return; } ! 1206, case 1
		if (R == R_61) { print "look around once light available rule"; return; } ! 1207, case 1
		if (R == ENABLE_GLULX_ACCEL_R) { print "enable Glulx acceleration rule"; return; } ! 1208, case 1
		if (R == PRINT_OBITUARY_HEADLINE_R) { print "print obituary headline rule"; return; } ! 1209, case 1
		if (R == PRINT_FINAL_SCORE_R) { print "print final score rule"; return; } ! 1210, case 1
		if (R == DISPLAY_FINAL_STATUS_LINE_R) { print "display final status line rule"; return; } ! 1211, case 1
		if (R == R_69) { print "print the final question rule"; return; } ! 1212, case 1
		if (R == R_68) { print "print the final prompt rule"; return; } ! 1213, case 1
		if (R == READ_FINAL_ANSWER_R) { print "read the final answer rule"; return; } ! 1214, case 1
		if (R == R_70) { print "standard respond to final question rule"; return; } ! 1215, case 1
		if (R == R_91) { print "can't take component parts rule"; return; } ! 1216, case 1
		if (R == R_148) { print "find what to enter rule"; return; } ! 1217, case 1
		if (R == QUIT_THE_GAME_R) { print "quit the game rule"; return; } ! 1218, case 1
		if (R == SAVE_THE_GAME_R) { print "save the game rule"; return; } ! 1219, case 1
		if (R == RESTORE_THE_GAME_R) { print "restore the game rule"; return; } ! 1220, case 1
		if (R == RESTART_THE_GAME_R) { print "restart the game rule"; return; } ! 1221, case 1
		if (R == VERIFY_THE_STORY_FILE_R) { print "verify the story file rule"; return; } ! 1222, case 1
		if (R == SWITCH_TRANSCRIPT_ON_R) { print "switch the story transcript on rule"; return; } ! 1223, case 1
		if (R == SWITCH_TRANSCRIPT_OFF_R) { print "switch the story transcript off rule"; return; } ! 1224, case 1
		if (R == ANNOUNCE_STORY_FILE_VERSION_R) { print "announce the story file version rule"; return; } ! 1225, case 1
		if (R == ANNOUNCE_SCORE_R) { print "announce the score rule"; return; } ! 1226, case 1
		if (R == PREFER_ABBREVIATED_R) { print "prefer abbreviated room descriptions rule"; return; } ! 1227, case 1
		if (R == REP_PREFER_ABBREVIATED_R) { print "standard report preferring abbreviated room descriptions rule"; return; } ! 1228, case 1
		if (R == PREFER_UNABBREVIATED_R) { print "prefer unabbreviated room descriptions rule"; return; } ! 1229, case 1
		if (R == REP_PREFER_UNABBREVIATED_R) { print "standard report preferring unabbreviated room descriptions rule"; return; } ! 1230, case 1
		if (R == PREFER_SOMETIMES_ABBREVIATED_R) { print "prefer sometimes abbreviated room descriptions rule"; return; } ! 1231, case 1
		if (R == REP_PREFER_SOMETIMES_ABBR_R) { print "standard report preferring sometimes abbreviated room descriptions rule"; return; } ! 1232, case 1
		if (R == SWITCH_SCORE_NOTIFY_ON_R) { print "switch score notification on rule"; return; } ! 1233, case 1
		if (R == REP_SWITCH_NOTIFY_ON_R) { print "standard report switching score notification on rule"; return; } ! 1234, case 1
		if (R == SWITCH_SCORE_NOTIFY_OFF_R) { print "switch score notification off rule"; return; } ! 1235, case 1
		if (R == REP_SWITCH_NOTIFY_OFF_R) { print "standard report switching score notification off rule"; return; } ! 1236, case 1
		if (R == ANNOUNCE_PRONOUN_MEANINGS_R) { print "announce the pronoun meanings rule"; return; } ! 1237, case 1
		if (R == R_740) { print "mark items as seen on opening a container rule"; return; } ! 1238, case 1
		if (R == R_760) { print "change greeting command to greeting rule"; return; } ! 1239, case 1
		if (R == R_773) { print "say goodbye when moving rule"; return; } ! 1240, case 1
		if (R == R_859) { print "new can't get off things rule"; return; } ! 1241, case 1
		if (R == R_864) { print "new convert exit into go out rule"; return; } ! 1242, case 1
		if (R == R_867) { print "new describe room emerged into rule"; return; } ! 1243, case 1
		if (R == R_868) { print "new describe room stood up into rule"; return; } ! 1244, case 1
		if (R == R_869) { print "small kindnesses exit leaves when there's only one way to go rule"; return; } ! 1245, case 1
		if (R == R_1201) { print "Sand-dancer room description body text rule"; return; } ! 1246, case 1
		if (R == R_1203) { print "Sand-dancer emergency exit rule"; return; } ! 1247, case 1

		print "(nameless rule at address ", R, ")";
	}
#ifnot;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print "(rulebook ", R, ")";
	} else {
		print "(rule at address ", R, ")";
	}
#endif;
];

[ DebugRulebooks subs parameter i;
	spaces(2*process_rulebook_count);
	print "[", (RulePrintingRule) subs;
	if (parameter) print " / on O", parameter;
	print "]^";
];

[ DB_Rule R N blocked;
	if (R==0) return;
	print "[Rule ~", (RulePrintingRule) R, "~ ";
	#ifdef NUMBERED_RULES; print "(", N, ") "; #endif;
	if (blocked == false) "applies.]";
	"does not apply.]";
];

Global I7S_Tab; ! The array to be sorted, which can have almost any format
Global I7S_Col; ! The "column number" in the array, if any
Global I7S_Dir; ! The direction of sorting: ascending (1) or descending (-1)
Global I7S_Swap; ! The current routine for swapping two fields
Global I7S_Comp; ! The current routine for comparing two fields

#ifdef MEASURE_SORT_PERFORMANCE;
Global I7S_CCOUNT; Global I7S_CCOUNT2; Global I7S_XCOUNT; ! For testing only
#endif;

[ SetSortDomain swapf compf;
	I7S_Swap = swapf;
	I7S_Comp = compf;
];

[ SortArray tab col dir size test_flag algorithm;
	I7S_Tab = tab;
	I7S_Col = col;
	I7S_Dir = dir;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT = 0;
	I7S_CCOUNT2 = 0;
	I7S_XCOUNT = 0;
	#endif;
	SortRange(0, size, algorithm);
	#ifdef MEASURE_SORT_PERFORMANCE;
	if (test_flag)
		print "Sorted array of size ", size, " with ", I7S_CCOUNT2, "*10000 + ", I7S_CCOUNT,
			" comparisons and ", I7S_XCOUNT, " exchanges^";
	#endif;
];

[ SortRange x y algorithm;
	if (y - x < 2) return;
	if (algorithm) {
		(algorithm)(x, y);
	} else {
		InPlaceMergeSortAlgorithm(x, y);
	}
];

[ CompareFields x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT++;
	if (I7S_CCOUNT == 10000) { I7S_CCOUNT = 0; I7S_CCOUNT2++; }
	#endif;
	return I7S_Dir*I7S_Comp(I7S_Tab, I7S_Col, x+1, y+1, I7S_Dir);
];

[ ExchangeFields x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_XCOUNT++;
	if (I7S_XCOUNT < 0) { print "XO^"; I7S_XCOUNT = 0; }
	#endif;
	return I7S_Swap(I7S_Tab, x+1, y+1);
];

[ OldSortAlgorithm x y
	f i j;
	if (y - x < 2) return;
	f = true;
	while (f) {
		f = false;
		for (i=x:i<y:i++)
		    for (j=i+1:j<y:j++)
				if (CompareFields(i, j) > 0) {
					ExchangeFields(i, j); f = true; break;
				}
	}
];

[ InsertionSortAlgorithm from to
	i j;
	if (to > from+1) { 
		for (i = from+1: i < to: i++) { 
			for (j = i: j > from: j--) { 
				if (CompareFields(j, j-1) < 0) 
					ExchangeFields(j, j-1);
				else break;
			}
		}
	}
];

[ InPlaceMergeSortAlgorithm from to
	middle;
	if (to - from < 12) {
		if (to - from < 2) return;
		InsertionSortAlgorithm(from, to);
		return;
	}
	middle = (from + to)/2; 
	InPlaceMergeSortAlgorithm(from, middle); 
	InPlaceMergeSortAlgorithm(middle, to); 
	IPMS_Merge(from, middle, to, middle-from, to - middle); 
];

[ IPMS_Lower from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(mid, val) < 0) {
			from = mid + 1;
			len = len - half -1; 
		} else len = half;
	}
	return from;
];

[ IPMS_Upper from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(val, mid) < 0)
			len = half;
		else {
			from = mid + 1;
			len = len - half -1; 
		}
	}
	return from;
];

[ IPMS_Reverse from to;
	while (from < to) {
		ExchangeFields(from++, to--);
	}
];

[ IPMS_Rotate from mid to
	n val shift p1 p2;
	if ((from==mid) || (mid==to)) return; 
	IPMS_Reverse(from, mid-1); 
	IPMS_Reverse(mid, to-1); 
	IPMS_Reverse(from, to-1);
];

[ IPMS_Merge from pivot to len1 len2
	first_cut second_cut len11 len22 new_mid;
	if ((len1 == 0) || (len2 == 0)) return; 
	if (len1+len2 == 2) { 
		if (CompareFields(pivot, from) < 0) 
		ExchangeFields(pivot, from); 
		return; 
	}
	if (len1 > len2) { 
		len11 = len1/2; 
		first_cut = from + len11; 
		second_cut = IPMS_Lower(pivot, to, first_cut); 
		len22 = second_cut - pivot; 
	} else { 
		len22 = len2/2; 
		second_cut = pivot + len22; 
		first_cut = IPMS_Upper(from, pivot, second_cut); 
		len11 = first_cut - from; 
	} 
	IPMS_Rotate(first_cut, pivot, second_cut); 
	new_mid = first_cut + len22; 
	IPMS_Merge(from, first_cut, new_mid, len11, len22); 
	IPMS_Merge(new_mid, second_cut, to, len1 - len11, len2 - len22); 
];

Constant TB_COLUMN_SIGNED      $4000;
Constant TB_COLUMN_TOPIC       $2000;
Constant TB_COLUMN_DONTSORTME  $1000;
Constant TB_COLUMN_NOBLANKBITS $0800;
Constant TB_COLUMN_CANEXCHANGE $0400;
Constant TB_COLUMN_ALLOCATED   $0200;
Constant TB_COLUMN_NUMBER      $01ff; ! Mask to remove upper bit flags

Constant COL_HSIZE 2; ! Column header size: two words (ID/flags, blank bits)

[ TableFindCol tab col f i no_cols n;
	no_cols = tab-->0;
	for (i=1: i<=no_cols: i++)
		if (col == ((tab-->i)-->1) & TB_COLUMN_NUMBER) return i;
	if (f) { RunTimeProblem(RTP_TABLE_NOCOL, tab); return 0; }
	return 0;
];

[ TableRows tab first_col;
	first_col = tab-->1; if (first_col == 0) return 0;
	return (first_col-->0) - COL_HSIZE;
];

Constant TABLE_NOVALUE = IMPROBABLE_VALUE;

Array CheckTableEntryIsBlank_LU
	->	$$00000001
		$$00000010
		$$00000100
		$$00001000
		$$00010000
		$$00100000
		$$01000000
		$$10000000;
Array CheckTableEntryIsNonBlank_LU
	->	$$11111110
		$$11111101
		$$11111011
		$$11110111
		$$11101111
		$$11011111
		$$10111111
		$$01111111;

[ CheckTableEntryIsBlank tab col row i at;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	if ((tab-->col)-->(row+COL_HSIZE) ~= TABLE_NOVALUE) {
		print "*** CTEIB on nonblank value ", tab, " ", col, " ", row, " ***^";
	}
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) rtrue;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	if ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row%8))) rtrue;
	rfalse;
];

[ ForceTableEntryBlank tab col row i at oldv flags;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) && (oldv ~= 0 or TABLE_NOVALUE))
		BlkFree(oldv);
	(tab-->col)-->(row+COL_HSIZE) = TABLE_NOVALUE;
	if (flags & TB_COLUMN_NOBLANKBITS) return;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row%8));
];

[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) &&
		(oldv == 0 or TABLE_NOVALUE)) {
		kov = UNKNOWN_TY;
		tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
		kov = TC_KOV(tc);
		if (kov ~= UNKNOWN_TY) {
			i = kov;
			if (KindBaseArity(i) > 0) i = KindAtomic(i); else i = 0;
			(tab-->col)-->(row+COL_HSIZE) = BlkValueCreate(kov, 0, i);
		}
	}
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row%8));
];

[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--;
	at1 = ((tab-->col)-->2) + (row1/8);
	row2--;
	at2 = ((tab-->col)-->2) + (row2/8);
	bit1 = ((TB_Blanks->at1) & (CheckTableEntryIsBlank_LU->(row1%8)));
	bit2 = ((TB_Blanks->at2) & (CheckTableEntryIsBlank_LU->(row2%8)));
	if (bit1) bit1 = true; 
	if (bit2) bit2 = true;
	if (bit1 == bit2) return;
	if (bit1) {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) & (CheckTableEntryIsNonBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) | (CheckTableEntryIsBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];

[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--; row2--;
	! Read blank bit for row1:
	at = ((tab-->col)-->2) + (row1/8);
	bit = ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row1%8)));
	if (bit) bit = true;
	! Loop through, setting each blank bit to the next:
	for (rx=row1:rx<row2:rx++) {
		atp1 = ((tab-->col)-->2) + ((rx+1)/8);
		at = ((tab-->col)-->2) + (rx/8);
		if ((TB_Blanks->atp1) & (CheckTableEntryIsBlank_LU->((rx+1)%8))) {
			(TB_Blanks->at)
				= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(rx%8));
		} else {
			(TB_Blanks->at)
				= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(rx%8));
		}
	}
	! Write bit to blank bit for row2:
	at = ((tab-->col)-->2) + (row2/8);
	if (bit) {
		(TB_Blanks->at)
			= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at)
			= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];

[ TableRowCorr tab col lookup_value lookup_col i j f;
	if (col >= 100) col=TableFindCol(tab, col, true);
	lookup_col = tab-->col;
	j = lookup_col-->0 - COL_HSIZE;
	f=0;
	if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=1;
	for (i=1:i<=j:i++) {
		if ((lookup_value == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col,i))) continue;
		if (f) {
			if (BlkValueCompare(lookup_col-->(i+COL_HSIZE), lookup_value) == 0)
				return i;
		} else {
			if (lookup_col-->(i+COL_HSIZE) == lookup_value) return i;
		}
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableRowCorr tab col entry i k v f kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	f=0;
	if (((tab-->col)-->1) & TB_COLUMN_TOPIC) f=1;
	else if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=2;
	k = TableRows(tab);
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i))) continue;
		switch (f) {
			1: if ((v)(entry/100, entry%100) ~= GPR_FAIL) return i;
			2: if (BlkValueCompare(v, entry) == 0) return i;
			default: if (v == entry) return i;
		}
	}
	! print "Giving up^";
	return 0;
];

[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, true);
	if (col2 >= 100) col2=TableFindCol(tab, col2, true);
	cola1 = tab-->col1;
	cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		v = cola2-->i;
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col2,i-COL_HSIZE))) continue;
		if (f == 1) {
			if (BlkValueCompare(v, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((v)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (v ~= lookup_value) continue;
		}
		if (write_flag) {
			ForceTableEntryNonBlank(tab,col1,i-COL_HSIZE);
			switch (write_flag) {
				2: cola1-->i = cola1-->i + write_value;
				3: cola1-->i = cola1-->i - write_value;
				default: cola1-->i = write_value;
			}
			rfalse;
		}
		v = cola1-->i;
		if ((v == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		return v;
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, false);
	if (col2 >= 100) col2=TableFindCol(tab, col2, false);
	if (col1*col2 == 0) rfalse;
	cola1 = tab-->col1; cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		if (f == 1) {
			if (BlkValueCompare(cola2-->i, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((cola2-->i)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (cola2-->i ~= lookup_value) continue;
		}
		if ((cola1-->i == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		rtrue;
	}
	rfalse;
];

[ TableLookUpEntry tab col index write_flag write_value v;
	if (col >= 100) col=TableFindCol(tab, col, true);
	if ((index < 1) || (index > TableRows(tab)))
		return RunTimeProblem(RTP_TABLE_NOROW, tab, index);
	if (write_flag) {
		switch(write_flag) {
			1:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) = write_value;
			2:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) + write_value;
			3:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) - write_value;
			4:	ForceTableEntryBlank(tab,col,index);
			5:	ForceTableEntryNonBlank(tab,col,index);
				return ((tab-->col)-->(index+COL_HSIZE));
		}
		rfalse;
	}
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		return RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index);
	return v;
];

[ ExistsTableLookUpEntry tab col index v;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	if ((index<1) || (index > TableRows(tab))) rfalse;
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		rfalse;
	rtrue;
];

[ TableRowIsBlank tab j k;
	for (k=1:k<=tab-->0:k++) {
		if (((tab-->k)-->(j+COL_HSIZE)) ~= TABLE_NOVALUE) rfalse;
		if (CheckTableEntryIsBlank(tab, k, j) == false) rfalse;
	}
	rtrue;
];

[ TableBlankOutRow tab row k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	for (k=1:k<=tab-->0:k++)
		ForceTableEntryBlank(tab, k, row);
];

[ TableBlankOutColumn tab col n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		ForceTableEntryBlank(tab, col, k);
];

[ TableBlankOutAll tab n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		TableBlankOutRow(tab, k);
];

[ TableBlankRows tab i j c;
	i = TableRows(tab); !print i, " rows^";
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) c++;
	!print c, " blank^";
	return c;
];

[ TableFilledRows tab;
	return TableRows(tab) - TableBlankRows(tab);
];

[ TableBlankRow tab i j;
	i = TableRows(tab);
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) return j;
	RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
	return i;
];

[ TableRandomRow tab i j k;
	i = TableRows(tab);
	j = TableFilledRows(tab);
	if (j==0) return RunTimeProblem(RTP_TABLE_NOROWS, tab);
	if (j>1) j = random(j);
	for (k=1:k<=i:k++) {
		if (TableRowIsBlank(tab, k) == false) j--;
		if (j==0) return k;
	}
];

[ TableSwapRows tab i j k l v1 v2;
	if (i==j) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		v1 = (tab-->k)-->(i+COL_HSIZE);
		v2 = (tab-->k)-->(j+COL_HSIZE);
		(tab-->k)-->(i+COL_HSIZE) = v2;
		(tab-->k)-->(j+COL_HSIZE) = v1;
		if ((v1 == TABLE_NOVALUE) || (v2 == TABLE_NOVALUE))
			TableSwapBlankBits(tab, i, j, k);
	}
];

[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	val1 = (tab-->col)-->(row1+COL_HSIZE);
	val2 = (tab-->col)-->(row2+COL_HSIZE);
	if (val1 == TABLE_NOVALUE) bl1 = CheckTableEntryIsBlank(tab,col,row1);
	if (val2 == TABLE_NOVALUE) bl2 = CheckTableEntryIsBlank(tab,col,row2);
	if ((val1 == val2) && (bl1 == bl2)) {
		if (val1 ~= TABLE_NOVALUE) return 0;
		if (bl1 == false) return 0;
		! The two entries are both blank:
		if (TableRowIsBlank(tab, row1)) {
		    if (TableRowIsBlank(tab, row2)) return 0;
		    return -1*dir;
		}
		if (TableRowIsBlank(tab, row2)) return dir;
		return 0;
	}
	if (bl1) return dir;
	if (bl2) return -1*dir;
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) {
		if (BlkValueCompare(val2, val1) < 0) return 1;
		return -1;
	} else if (f & TB_COLUMN_SIGNED) {
		if (val1 > val2) return 1;
		return -1;
	} else {
		if (UnsignedCompare(val1, val2) > 0) return 1;
		return -1;
	}
];

[ TableMoveRowDown tab r1 r2 rx k l m v f;
	if (r1==r2) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		f = false;
		m = (tab-->k)-->(r1+COL_HSIZE);
		if (m == TABLE_NOVALUE) f = true;
		for (rx=r1:rx<r2:rx++) {
			v = (tab-->k)-->(rx+COL_HSIZE+1);
			(tab-->k)-->(rx+COL_HSIZE) = v;
			if (v == TABLE_NOVALUE) f = true;
		}
		(tab-->k)-->(r2+COL_HSIZE) = m;
		if (f) TableMoveBlankBitsDown(tab, r1, r2, k);
	}
];

[ TableShuffle tab i to;
	TableMoveBlanksToBack(tab, 1, TableRows(tab));
	to = TableFilledRows(tab);
	for (i=2:i<=to:i++) TableSwapRows(tab, i, random(i));
];

[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) RunTimeProblem(RTP_TABLE_CANTRUNTHROUGH, tab);
	signed_arithmetic = f & TB_COLUMN_SIGNED;
	#Iftrue (WORDSIZE == 2);
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $8000; else val = $7fff;
		} else {
		    if (dir == 1) val = 0; else val = $ffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fff; else min_dv = $ffff;
	#ifnot; ! WORDSIZE == 4
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $80000000; else val = $7fffffff;
		} else {
		    if (dir == 1) val = 0; else val = $ffffffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fffffff; else min_dv = $ffffffff;
	#endif;
	k = TableRows(tab);
	if (dir == 1) {
		for (i=1:i<=k:i++) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i>row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i>row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	} else {
		for (i=k:i>=1:i--) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i<row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i<row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	}
	return min_at;
];

[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
	if (torow < fromrow) return;
	fbl = 0; lnbl = 0;
	for (i=fromrow: i<=torow: i++)
		if (TableRowIsBlank(tab, i)) {
			if (fbl == 0) fbl = i;
			blc++;
		} else {
			lnbl = i;
		}
	if ((fbl>0) && (lnbl>0) && (fbl < lnbl)) {
		TableMoveRowDown(tab, fbl, lnbl); ! Move first blank just past last nonblank
		TableMoveBlanksToBack(tab, fbl, lnbl-1);
	}
	return torow-blc; ! Final non-blank row
];

[ TableSort tab col dir test_flag algorithm i j k f;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if ((j-->1) & TB_COLUMN_DONTSORTME)
		    return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
	}
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	if (test_flag) {
		print "After moving blanks to back:^"; TableColumnDebug(tab, col);
	}

	SetSortDomain(TableSwapRows, TableCompareRows);
	SortArray(tab, col, dir, k, test_flag, algorithm);

	if (test_flag) {
		print "Final state:^"; TableColumnDebug(tab, col);
	}
];

[ PrintTableName T;
	switch(T) {
  TheEmptyTable: print "(the empty table)"; return;
  T0_final_question_options: print "Table of Final Question Options"; return;
  T1_locale_priorities: print "Table of Locale Priorities"; return;
  T2_custom_library_messages: print "Table of custom library messages"; return;
  T3_library_messages: print "Table of library messages"; return;

		default: print "** No such table **";
	}
];

[ TablePrint tab i j k row col v tc kov;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    rtrue;
	}
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	print "! ", (PrintTableName) tab, " (", k, ")^";
	for (row=1:row<=k:row++) {
		for (col=1:col<=tab-->0:col++) {
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			v = (tab-->col)-->(row+COL_HSIZE);
			if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,row)))
				print "-- ";
			else {
				if (BlkValueWriteToFile(v, kov) == false) print v;
				print " ";
			}
		}
		print "^";
	}
	rfalse;
];

#ifdef TARGET_GLULX;
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
	for (col=1:col<=tab-->0:col++) {
		j = tab-->col; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	}
	maxrow = TableRows(tab);
	!print maxrow, " rows available.^";
	for (row=1: row<=maxrow: row++) {
		TableBlankOutRow(tab, row);
	}
	for (row=1: row<=maxrow: row++) {
		!print "Reading row ", row, "^";
		ch = FileIO_GetC(auxf);
		if (ch == '!') {
			while (ch ~= -1 or 10 or 13) ch = FileIO_GetC(auxf);
			while (ch == 10 or 13) ch = FileIO_GetC(auxf);
		}
		for (col=1: col<=tab-->0: col++) {
			if (ch == -1) { row++; jump NoMore; }
			if (ch == 10 or 13) break;
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			!print "tc = ", tc, " kov = ", kov, "^";
			sgn = 1;
			if (ch == '-') {
				ch = FileIO_GetC(auxf);
				if (ch == -1) jump NotTable;
				if (ch == '-') { ch = FileIO_GetC(auxf); jump EntryDone; }
				sgn = -1;
			}
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
				ForceTableEntryNonBlank(tab, col, row);
			!print "A";
			v = BlkValueReadFromFile(0, 0, -1, kov);
			if (v) {
				if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
					v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row),
						auxf, ch, kov);
				else
					v = BlkValueReadFromFile(0, auxf, ch, kov);
				ch = 32;
			} else {
				dg = ch - '0';
				if ((dg < 0) || (dg > 9)) jump NotTable;
				v = dg;
				for (::) {
					ch = FileIO_GetC(auxf);
					dg = ch - '0';
					if ((dg < 0) || (dg > 9)) break;
					v = 10*v + dg;
				}
				v = v*sgn;
			}
			!print "v=", v, " ";
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED == 0)
				TableLookUpEntry(tab, col, row, true, v);
			.EntryDone;
			!print "First nd is ", ch, "^";
			while (ch == 9 or 32) ch = FileIO_GetC(auxf);
		}
		while (ch ~= -1 or 10 or 13) {
			if ((ch ~= '-') && (((ch-'0')<0) || ((ch-'0')>9))) jump NotTable;
			if (ch ~= 9 or 32) jump WontFit;
			ch = FileIO_GetC(auxf);
		}
	}
	.NoMore;
	while (ch == 9 or 32 or 10 or 13) ch = FileIO_GetC(auxf);
	if (ch == -1) return;
	.WontFit;
	return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
	.NotTable;
	return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
#ENDIF; ! TARGET_GLULX

[ PrintRank i j v;
#ifdef RANKING_TABLE;
	L__M(##Score, 3);
	j = TableRows(RANKING_TABLE);
	for (i=j:i>=1:i--)
		if (score >= TableLookUpEntry(RANKING_TABLE, 1, i)) {
		    v = TableLookUpEntry(RANKING_TABLE, 2, i);
		    if (v ofclass String) print (string) v;
		    else v();
		    ".";
		}
#endif;
	".";
];

[ TableColumnDebug tab col k i v;
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	print "Table col ", col, ": ";
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "BLANK ";
		else
			print v, " ";
	}
	print "*^";
];

[ HolderOf o;
	if (InitialSituation-->DONE_INIS == false) return thedark;
	if (o && (o.component_parent)) return o.component_parent;
	if (o && (parent(o))) return parent(o);
	return nothing;
];

[ ParentOf o;
	if (o) o = parent(o);
	return o;
];

[ CoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];

[ CoreOfParentOfCoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	if (o) o = parent(o);
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];

[ LocationOf o;
	if (~~(O ofclass K1_room or K2_thing)) return nothing;
	if (O ofclass K4_door) return FrontSideOfDoor(O);
	if (O ofclass K7_backdrop) return nothing;
	while (o) {
		if (o ofclass K1_room) return o;
		o = CoreOfParentOfCoreOf(o);
	}
	return nothing;
];

[ CommonAncestor o1 o2 i j;
	o1 = CoreOf(o1);
	o2 = CoreOf(o2);
	
	for (i=o1: i: i = CoreOfParentOfCoreOf(i))
		for (j=o2: j: j = CoreOfParentOfCoreOf(j))
			if (j == i) return j;

	return nothing;
];

[ IndirectlyContains o1 o2;
	if ((o1 == nothing) || (o2 == nothing)) rfalse;
	if ((o1 ofclass K1_room) && (o2 ofclass K4_door)) {
		if (o1 == FrontSideOfDoor(o2)) rtrue;
		if (o1 == BackSideOfDoor(o2)) rtrue;
		rfalse;
	}
	if (o2 ofclass K7_backdrop) rfalse;
	for (o2 = HolderOf(o2) : o2: o2 = HolderOf(o2)) if (o2 == o1) rtrue;
	rfalse;
];

[ WhetherIn obj;
	if (obj has enterable) {
		if (IndirectlyContains(obj, player)) rtrue;
		rfalse;
	}
	if (obj ofclass K9_region) return TestRegionalContainment(real_location, obj);
	if (obj ofclass K1_room) {
		if (obj == real_location) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_NOTINAROOM, obj);
	rfalse;
];

[ ContainerOf A p;
	if (A ofclass K1_room) return A.map_region;
	p = parent(A);
	if (p == nothing) return nothing;
	if (p ofclass K5_container) return p;
	if (p ofclass K1_room) return p;
	if (p ofclass K9_region) return p;
	return nothing;
];

[ TestContainmentRange obj e f;
	if (obj ofclass K9_region) {
		objectloop (f ofclass K1_room && f.map_region == obj)
			if (f > e) return f;
		return nothing;
	}
	if (obj ofclass K5_container or K1_room) {
		if (e == nothing) return child(obj);
		return sibling(e);
	}
	return nothing;
];

[ SupporterOf obj p;
	p = parent(obj);
	if (p == nothing) return nothing;
	if (p ofclass K6_supporter) return p;
	return nothing;
];

[ CarrierOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj hasnt worn)) return p;
	return nothing;
];

[ WearerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj has worn)) return p;
	return nothing;
];

[ OwnerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person)) return p;
	return nothing;
];

[ MakePart P Of First;
	if (parent(P)) remove P; give P ~worn;
	if (Of == nothing) { DetachPart(P); return; }
	if (P.component_parent) DetachPart(P);
	P.component_parent = Of;
	First = Of.component_child;
	Of.component_child = P; P.component_sibling = First;
];

[ DetachPart P From Daddy O;
	Daddy = P.component_parent; P.component_parent = nothing;
	if (Daddy == nothing) { P.component_sibling = nothing; return; }
	if (Daddy.component_child == P) {
		Daddy.component_child = P.component_sibling;
		P.component_sibling = nothing; return;
	}
	for (O = Daddy.component_child: O: O = O.component_sibling)
		if (O.component_sibling == P) {
			O.component_sibling = P.component_sibling;
			P.component_sibling = nothing; return;
		}
];

[ MoveObject F T opt going_mode was;
	if (F == nothing) return RunTimeProblem(RTP_CANTMOVENOTHING);
	if (F ofclass K7_backdrop) {
		if (T ofclass K9_region) {
			give F ~absent; F.found_in = T.regional_found_in;
			if (TestRegionalContainment(LocationOf(player), T)) move F to LocationOf(player);
			else remove F;
			return; }
		return RunTimeProblem(RTP_BACKDROP, F, T);
	}
	if (~~(F ofclass K2_thing)) return RunTimeProblem(RTP_NOTTHING, F, T);
	if (T ofclass K9_region) return RunTimeProblem(RTP_NOTBACKDROP, F, T);
	if (F has worn) {
		give F ~worn;
		if (F in T) return;
	}
	DetachPart(F);
	if (going_mode == false) {
		if (F == player) { PlayerTo(T, opt); return; }
		if ((IndirectlyContains(F, player)) && (LocationOf(player) ~= LocationOf(T))) {
			was = parent(player);
			move player to real_location;
			move F to T;
			PlayerTo(was, true);
			return;
		}
	}
	move F to T;
];

[ RemoveFromPlay F;
	if (F == nothing) return RunTimeProblem(RTP_CANTREMOVENOTHING);
	if (F == player) return RunTimeProblem(RTP_CANTREMOVEPLAYER);
	if (F ofclass K4_door) return RunTimeProblem(RTP_CANTREMOVEDOORS);
	give F ~worn; DetachPart(F);
	if (F ofclass K7_backdrop) give F absent;
	remove F;
];

[ OnStage O set x;
	if (O ofclass K1_room) rfalse;
	if (set < 0) {
		while (metaclass(O) == Object) {
			if (O ofclass K1_room) rtrue;
			if (O ofclass K9_region) rfalse;
			if (O ofclass K4_door) rtrue;
			if (O ofclass K7_backdrop) { if (O has absent) rfalse; rtrue; }
			x = O.component_parent; if (x) { O = x; continue; }
			x = parent(O); if (x) { O = x; continue; }
			rfalse;
		}
	}
	x = OnStage(O, -1);
	if ((x) && (set == false)) RemoveFromPlay(O);
	if ((x == false) && (set)) MoveObject(O, real_location);
	rfalse;
];

[ PlayerTo newplace flag;
	@push actor; actor = player;
    move player to newplace;
    location = LocationOf(newplace);
    real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
    DivideParagraphPoint();
    if (flag == 0) <Look>;
    if (flag == 1) give location visited;
    if (flag == 2) AbbreviatedRoomDescription();
    @pull actor;
];

[ MoveDuringGoing F T;
	MoveObject(F, T, 0, true);
	if (actor == player) {
		location = LocationOf(player);
		real_location = location;
	}
];

[ FoundEverywhere; rtrue; ];

[ ChangePlayer obj flag i;
	if (~~(obj ofclass K8_person)) return RunTimeProblem(RTP_CANTCHANGE, obj);
	if (~~(OnStage(obj, -1))) return RunTimeProblem(RTP_CANTCHANGEOFFSTAGE, obj);
	if (obj == player) return;

    give player ~concealed;
    if (player has remove_proper) give player ~proper;
    if (player == selfobj) {
    	player.saved_short_name = player.short_name; player.short_name = FORMER__TX;
    }
    player = obj;
    if (player == selfobj) {
    	player.short_name = player.saved_short_name;
    }
    if (player hasnt proper) give player remove_proper; ! when changing out again
    give player concealed proper;

    location = LocationOf(player); real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
];

[ MoveFloatingObjects i k l m address flag;
    if (real_location == nothing) return;
    objectloop (i) {
        address = i.&found_in;
        if (address ~= 0 && i hasnt absent) {
            if (ZRegion(address-->0) == 2) {
                m = address-->0;
                .TestPropositionally;
                if (m.call(real_location) ~= 0) move i to real_location;
                else remove i;
            }
            else {
                k = i.#found_in;
                for (l=0 : l<k/WORDSIZE : l++) {
                    m = address-->l;
                    if (ZRegion(m) == 2) jump TestPropositionally;
                    if (m == real_location || m in real_location) {
                        if (i notin real_location) move i to real_location;
                        flag = true;
                    }
                }
                if (flag == false) { if (parent(i)) remove i; }
            }
        }
    }
];

[ MoveBackdrop bd D x address;
	if (~~(bd ofclass K7_backdrop)) return RunTimeProblem(RTP_BACKDROPONLY, bd);
	if (bd.#found_in > WORDSIZE) {
		address = bd.&found_in;
		address-->0 = D;
	} else bd.found_in = D;
	give bd ~absent;
	MoveFloatingObjects();
];

[ WearObject X P opt;
	if (X == false) rfalse;
	if (X notin P) MoveObject(X, P, opt);
	give X worn;
];

[ MapConnection from_room dir
	in_direction through_door;
	if ((from_room ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((from_room.IK_1)*No_Directions + dir.IK_3);
		if (in_direction ofclass K1_room) return in_direction;
		if (in_direction ofclass K4_door) {
			@push location;
			location = from_room;
			through_door = in_direction.door_to();
			@pull location;
			if (through_door ofclass K1_room) return through_door;
		}
	}
	return nothing;
];

[ DoorFrom obj dir rv;
	rv = RoomOrDoorFrom(obj, dir);
	if (rv ofclass K4_door) return rv;
	return nothing;
];

[ RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
	if ((obj ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((obj.IK_1)*No_Directions + dir.IK_3);
		if (in_direction ofclass K1_room or K4_door) return in_direction;	
	}
	return nothing;
];

[ AssertMapConnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK_1)*No_Directions + dir.IK_3);
	if ((in_direction == 0) || (in_direction ofclass K1_room)) {
		Map_Storage-->((r1.IK_1)*No_Directions + dir.IK_3) = r2;
		return;
	}
	if (in_direction ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	RunTimeProblem(RTP_NOEXIT, r1, dir);
];

[ AssertMapUnconnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK_1)*No_Directions + dir.IK_3);
	if (r1 ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	if (in_direction == r2)
		Map_Storage-->((r1.IK_1)*No_Directions + dir.IK_3) = 0;
	return;
];

[ TestAdjacency R1 R2 i row;
	row = (R1.IK_1)*No_Directions;
	for (i=0: i<No_Directions: i++, row++)
		if (Map_Storage-->row == R2) rtrue;
	rfalse;
];

[ TestRegionalContainment obj region o;
	if ((obj == nothing) || (region == nothing)) rfalse;
	if (~~(obj ofclass K1_room)) obj = LocationOf(obj);
	if (obj == nothing) rfalse;
	o = obj.map_region;
	while (o) {
		if (o == region) rtrue;
		o = parent(o);
	}
	rfalse;
];

[ FrontSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->0; ! Two-sided
	return parent(D); ! One-sided
];

[ BackSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->1; ! Two-sided
	return nothing; ! One-sided
];

[ OtherSideOfDoor D from_room rv;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_to();
		@pull location;
	}
	return rv;
];

[ DirectionDoorLeadsIn D from_room rv dir;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_dir();
		@pull location;
	}
	return rv;
];

[ TestVisibility A B;
	if (~~OffersLight(parent(CoreOf(A)))) rfalse;
	if (suppress_scope_loops) rtrue;
	return TestScope(B, A);
];

[ TestTouchability A B;
	if (TestScope(B,A) == false) rfalse;
	if (ObjectIsUntouchable(B, 1, 0, A)) rfalse;
	rtrue;
];

[ TestConcealment A B;
	if (A ofclass K2_thing && B ofclass K2_thing) {
		particular_possession = B;
		if (CarryOutActivity(DECIDING_CONCEALED_POSSESS_ACT, A)) rtrue;
	}
	rfalse;
];





[ Mistake_Token_269;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 369;
    return GPR_PREPOSITION;
];
[ Cond_Token_314 ;
if ((((real_location == O182_burrow)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_314;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 414;
    return GPR_PREPOSITION;
];
[ Mistake_Token_286;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 386;
    return GPR_PREPOSITION;
];
[ Mistake_Token_251;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 351;
    return GPR_PREPOSITION;
];
[ Mistake_Token_249;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 349;
    return GPR_PREPOSITION;
];
[ Mistake_Token_250;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 350;
    return GPR_PREPOSITION;
];
[ Mistake_Token_248;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 348;
    return GPR_PREPOSITION;
];
[ Mistake_Token_265;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 365;
    return GPR_PREPOSITION;
];
[ Mistake_Token_266;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 366;
    return GPR_PREPOSITION;
];
[ Mistake_Token_270;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 370;
    return GPR_PREPOSITION;
];
[ Mistake_Token_246;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 346;
    return GPR_PREPOSITION;
];
[ Mistake_Token_247;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 347;
    return GPR_PREPOSITION;
];
[ Mistake_Token_252;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 352;
    return GPR_PREPOSITION;
];
[ Mistake_Token_253;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 353;
    return GPR_PREPOSITION;
];
[ Mistake_Token_261;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 361;
    return GPR_PREPOSITION;
];
[ Mistake_Token_262;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 362;
    return GPR_PREPOSITION;
];
[ Mistake_Token_263;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 363;
    return GPR_PREPOSITION;
];
[ Mistake_Token_264;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 364;
    return GPR_PREPOSITION;
];
[ Mistake_Token_267;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 367;
    return GPR_PREPOSITION;
];
[ Mistake_Token_268;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 368;
    return GPR_PREPOSITION;
];
[ Cond_Token_287 ;
if (((((Adj_74_t1_v65(O120_pane_of_cracked_glass)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_303 ;
if ((((~~(((Adj_3_t1_v65(O60_gas_can)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_311;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 411;
    return GPR_PREPOSITION;
];
[ Mistake_Token_312;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 412;
    return GPR_PREPOSITION;
];



[ DECIMAL_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;
	wnc = wn; original_wn = wn; group_wn = wn;

	wn = wnc;
	r = ParseTokenStopped(ELEMENTARY_TT, NUMBER_TOKEN);
	if ((r == GPR_NUMBER) && (parsed_number ~= 10000)) return r;
	wn = wnc;
	wa = WordAddress(wn);
	wl = WordLength(wn);
	sign = 1; base = 10; digit_count = 0;
	if (wa->0 ~= '-' or '$' or '0' or '1' or '2' or '3' or '4'
		or '5' or '6' or '7' or '8' or '9')
		return GPR_FAIL;
	if (wa->0 == '-') { sign = -1; wl--; wa++; }
	if (wl == 0) return GPR_FAIL;
	n = 0;
	while (wl > 0) {
		if (wa->0 >= 'a') digit = wa->0 - 'a' + 10;
		else digit = wa->0 - '0';
		digit_count++;
		switch (base) {
			2:  if (digit_count == 17) return GPR_FAIL;
			10:
				#Iftrue (WORDSIZE == 2);
				if (digit_count == 6) return GPR_FAIL;
				if (digit_count == 5) {
					if (n > 3276) return GPR_FAIL;
					if (n == 3276) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Ifnot; ! i.e., if (WORDSIZE == 4)
				if (digit_count == 11) return GPR_FAIL;
				if (digit_count == 10) {
					if (n > 214748364) return GPR_FAIL;
					if (n == 214748364) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Endif; 
			16: if (digit_count == 5) return GPR_FAIL;
		}
		if (digit >= 0 && digit < base) n = base*n + digit;
		else return GPR_FAIL;
		wl--; wa++;
	}
	parsed_number = n*sign; wn++;
	return GPR_NUMBER;
];

[ TRUTH_STATE_TOKEN original_wn wd;
	original_wn = wn;

	wn = original_wn;
	wd = NextWordStopped();
	if (wd == 'true') { parsed_number = 1; return GPR_NUMBER; }
	if (wd == 'false') { parsed_number = 0; return GPR_NUMBER; }
	wn = original_wn;
	return GPR_FAIL;
];

[ RoundOffTime t1 t2; return ((t1+t2/2)/t2)*t2; ];

[ SquareRoot num
	op res one;
	op = num;
	if (num < 0) { RunTimeProblem(RTP_NEGATIVEROOT); return 1; }
	! "one" starts at the highest power of four <= the argument.
	for (one = WORD_NEXTTOHIGHBIT: one > op: one = one/4) ;

	while (one ~= 0) {
		!print "Round: op = ", op, " res = ", res, ", res**2 = ", res*res, " one = ", one, "^";
		if (op >= res + one) {
			op = op - res - one;
			res = res + one*2;
		}
		res = res/2;
		one = one/4;
	}
	!print "Res is ", res, "^";
	return res;
];

[ CubeRoot num x y n;
	if (num < 0) x = -SquareRoot(-num); else x = SquareRoot(num);
	for (n=0: (y ~= x) && (n++ < 100): y = x, x = (2*x + num/x/x)/3) ;
	return x;
];

[ PrintTimeOfDay t h aop;
	if (t<0) { print "<no time>"; return; }
	if (t >= TWELVE_HOURS) { aop = "pm"; t = t - TWELVE_HOURS; } else aop = "am";
	h = t/ONE_HOUR; if (h==0) h=12;
	print h, ":";
	if (t%ONE_HOUR < 10) print "0"; print t%ONE_HOUR, " ", (string) aop;
];

[ PrintTimeOfDayEnglish t h m dir aop;
	h = (t/ONE_HOUR) % 12; m = t%ONE_HOUR; if (h==0) h=12;
	if (m==0) { print (number) h, " o'clock"; return; }
	dir = "past";
	if (m > HALF_HOUR) { m = ONE_HOUR-m; h = (h+1)%12; if (h==0) h=12; dir = "to"; }
	switch(m) {
		QUARTER_HOUR: print "quarter"; HALF_HOUR: print "half";
		default: print (number) m;
		    if (m%5 ~= 0) {
				if (m == 1) print " minute"; else print " minutes";
		    }
	}
	print " ", (string) dir, " ", (number) h;
];

[ TIME_TOKEN first_word second_word at length flag
	illegal_char offhour hr mn i original_wn;
	original_wn = wn;

	wn = original_wn;
	first_word = NextWordStopped();
	switch (first_word) {
		'midnight': parsed_number = 0; return GPR_NUMBER;
		'midday', 'noon': parsed_number = TWELVE_HOURS;
		return GPR_NUMBER;
	}
	! Next try the format 12:02
	at = WordAddress(wn-1); length = WordLength(wn-1);
	for (i=0: i<length: i++) {
		switch (at->i) {
			':': if (flag == false && i>0 && i<length-1) flag = true;
			else illegal_char = true;
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9': ;
			default: illegal_char = true;
		}
	}
	if (length < 3 || length > 5 || illegal_char) flag = false;
	if (flag) {
		for (i=0: at->i~=':': i++, hr=hr*10) hr = hr + at->i - '0';
		hr = hr/10;
		for (i++: i<length: i++, mn=mn*10) mn = mn + at->i - '0';
		mn = mn/10;
		second_word = NextWordStopped();
		parsed_number = HoursMinsWordToTime(hr, mn, second_word);
		if (parsed_number == -1) return GPR_FAIL;
		if (second_word ~= 'pm' or 'am') wn--;
		return GPR_NUMBER;
	}
	! Lastly the wordy format
	offhour = -1;
	if (first_word == 'half') offhour = HALF_HOUR;
	if (first_word == 'quarter') offhour = QUARTER_HOUR;
	if (offhour < 0) offhour = TryNumber(wn-1);
	if (offhour < 0 || offhour >= ONE_HOUR) return GPR_FAIL;
	second_word = NextWordStopped();
	switch (second_word) {
		! "six o'clock", "six"
		'o^clock', 'am', 'pm', -1:
			hr = offhour; if (hr > 12) return GPR_FAIL;
		! "quarter to six", "twenty past midnight"
		'to', 'past':
			mn = offhour; hr = TryNumber(wn);
			if (hr <= 0) {
				switch (NextWordStopped()) {
					'noon', 'midday': hr = 12;
					'midnight': hr = 0;
					default: return GPR_FAIL;
				}
			}
			if (hr >= 13) return GPR_FAIL;
			if (second_word == 'to') {
				mn = ONE_HOUR-mn; hr--; if (hr<0) hr=23;
			}
			wn++; second_word = NextWordStopped();
		! "six thirty"
		default:
			hr = offhour; mn = TryNumber(--wn);
			if (mn < 0 || mn >= ONE_HOUR) return GPR_FAIL;
			wn++; second_word = NextWordStopped();
	}
	parsed_number = HoursMinsWordToTime(hr, mn, second_word);
	if (parsed_number < 0) return GPR_FAIL;
	if (second_word ~= 'pm' or 'am' or 'o^clock') wn--;
	return GPR_NUMBER;
];

[ HoursMinsWordToTime hour minute word x;
	if (hour >= 24) return -1;
	if (minute >= ONE_HOUR) return -1;
	x = hour*ONE_HOUR + minute; if (hour >= 13) return x;
	x = x % TWELVE_HOURS; if (word == 'pm') x = x + TWELVE_HOURS;
	if (word ~= 'am' or 'pm' && hour == 12) x = x + TWELVE_HOURS;
	return x;
];

[ RELATIVE_TIME_TOKEN first_word second_word offhour mult mn original_wn;
	original_wn = wn;
	wn = original_wn;
	
	first_word = NextWordStopped(); wn--;
	if (first_word == 'an' or 'a//') mn=1; else mn=TryNumber(wn);
	
    if (mn == -1000) {
		first_word = NextWordStopped();
		if (first_word == 'half') offhour = HALF_HOUR;
		if (first_word == 'quarter') offhour = QUARTER_HOUR;
		if (offhour > 0) {
			second_word = NextWordStopped();
			if (second_word == 'of') second_word = NextWordStopped();
			if (second_word == 'an') second_word = NextWordStopped();
			if (second_word == 'hour') {
				parsed_number = offhour;
				return GPR_NUMBER;
			}
		}
		return GPR_FAIL;
    }
	wn++;
	
	first_word = NextWordStopped();
	switch (first_word) {
		'minutes', 'minute': mult = 1;
		'hours', 'hour': mult = 60;
		default: return GPR_FAIL;
	}
	parsed_number = mn*mult;
	if (mult == 60) {
		mn=TryNumber(wn);
		if (mn ~= -1000) {
			wn++;
			first_word = NextWordStopped();
			if (first_word == 'minutes' or 'minute')
				parsed_number = parsed_number + mn;
			else wn = wn - 2;
		}
	}
	return GPR_NUMBER;
];

[ DuringSceneMatching prop sc;
	for (sc=0: sc<NUMBER_SCENES_CREATED: sc++)
		if ((scene_status-->sc == 1) && (prop(sc+1))) rtrue;
	rfalse;
];

[ SceneUtility sc task;
	if (sc <= 0) return 0;
	if (task == 1 or 2) {
		if (scene_endings-->(sc-1) == 0) return RunTimeProblem(RTP_SCENEHASNTSTARTED, sc);
	} else {
		if (scene_endings-->(sc-1) <= 1) return RunTimeProblem(RTP_SCENEHASNTENDED, sc);
	}
	switch (task) {
		1: return (the_time - scene_started-->(sc-1))%(TWENTY_FOUR_HOURS);
		2: return scene_started-->(sc-1);
		3: return (the_time - scene_ended-->(sc-1))%(TWENTY_FOUR_HOURS);
		4: return scene_ended-->(sc-1);
	}
];

[ Designed_Type_GPR_66 original_wn group_wn v wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f w rv x;
    original_wn = wn;
    return GPR_FAIL;
];
[ Designed_Type_GPR_103 original_wn group_wn v wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f w rv x;
    original_wn = wn;
    ! 100.9khz, with offset=0, multiplier=1

    wpos = 0; mid_word = false; matched_number = 0;
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_0;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    sgn = 1; tot = 0; f = false;
    if (cur_addr->wpos == '-') jump Failed_LP_0;
    while ((wpos < cur_len) && (DigitToValue(cur_addr->wpos)>=0)) {
        f = DigitToValue(cur_addr->wpos);
        if (sgn == 1) {
            if ((tot > 3276) || ((tot == 3276) && (f > 7)))
                jump Failed_LP_0;
        } else {
            if ((tot > 3276) || ((tot == 3276) && (f > 8)))
                jump Failed_LP_0;
        }
        tot = 10*tot + f;
        f = true;
        wpos++;
    }
    if (f == false) jump Failed_LP_0;
    if (sgn == 1) {
        if ((tot > 3276) || ((tot == 3276) && (matched_number > 7)))
            jump Failed_LP_0;
    } else {
        if ((tot > 3276) || ((tot == 3276) && (matched_number > 8)))
            jump Failed_LP_0;
    }
    tot = 10*tot + matched_number;
    matched_number = tot;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_0;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    if (cur_addr->wpos++ ~= '.') jump Failed_LP_0;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_0;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    sgn = 1; tot = 0; f = false;
    if (cur_addr->wpos == '-') jump Failed_LP_0;
    while ((wpos < cur_len) && (DigitToValue(cur_addr->wpos)>=0)) {
        f = DigitToValue(cur_addr->wpos);
        if (sgn == 1) {
            if ((tot > 3276) || ((tot == 3276) && (f > 7)))
                jump Failed_LP_0;
        } else {
            if ((tot > 3276) || ((tot == 3276) && (f > 8)))
                jump Failed_LP_0;
        }
        tot = 10*tot + f;
        f = true;
        wpos++;
    }
    if (f == false) jump Failed_LP_0;
    if (tot >= 10) jump Failed_LP_0;
    tot = 1*tot + matched_number;
    matched_number = tot;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_0;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    if (cur_addr->wpos++ ~= 'k') jump Failed_LP_0;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_0;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    if (cur_addr->wpos++ ~= 'h') jump Failed_LP_0;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_0;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    if (cur_addr->wpos++ ~= 'z') jump Failed_LP_0;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    .Succeeded_LP_0;
    if (mid_word) jump Failed_LP_0;
    if (sgn<0) matched_number = -1*matched_number;
    parsed_number = matched_number;
    parsed_number = 1*parsed_number + 0+x;
    if (parser_trace >= 3) { print "  [parsed value ", parsed_number, " by: 100.9khz]^"; }
    return GPR_NUMBER;
    .Failed_LP_0;
    wn = original_wn;
    ! 100.9 khz, with offset=0, multiplier=1

    wpos = 0; mid_word = false; matched_number = 0;
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_1;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    sgn = 1; tot = 0; f = false;
    if (cur_addr->wpos == '-') jump Failed_LP_1;
    while ((wpos < cur_len) && (DigitToValue(cur_addr->wpos)>=0)) {
        f = DigitToValue(cur_addr->wpos);
        if (sgn == 1) {
            if ((tot > 3276) || ((tot == 3276) && (f > 7)))
                jump Failed_LP_1;
        } else {
            if ((tot > 3276) || ((tot == 3276) && (f > 8)))
                jump Failed_LP_1;
        }
        tot = 10*tot + f;
        f = true;
        wpos++;
    }
    if (f == false) jump Failed_LP_1;
    if (sgn == 1) {
        if ((tot > 3276) || ((tot == 3276) && (matched_number > 7)))
            jump Failed_LP_1;
    } else {
        if ((tot > 3276) || ((tot == 3276) && (matched_number > 8)))
            jump Failed_LP_1;
    }
    tot = 10*tot + matched_number;
    matched_number = tot;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_1;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    if (cur_addr->wpos++ ~= '.') jump Failed_LP_1;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_1;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    sgn = 1; tot = 0; f = false;
    if (cur_addr->wpos == '-') jump Failed_LP_1;
    while ((wpos < cur_len) && (DigitToValue(cur_addr->wpos)>=0)) {
        f = DigitToValue(cur_addr->wpos);
        if (sgn == 1) {
            if ((tot > 3276) || ((tot == 3276) && (f > 7)))
                jump Failed_LP_1;
        } else {
            if ((tot > 3276) || ((tot == 3276) && (f > 8)))
                jump Failed_LP_1;
        }
        tot = 10*tot + f;
        f = true;
        wpos++;
    }
    if (f == false) jump Failed_LP_1;
    if (tot >= 10) jump Failed_LP_1;
    tot = 1*tot + matched_number;
    matched_number = tot;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_1;
    }
    if (mid_word) jump Failed_LP_1;
    if (cur_word ~= 'khz') jump Failed_LP_1;
    wn++;
    .Succeeded_LP_1;
    if (mid_word) jump Failed_LP_1;
    if (sgn<0) matched_number = -1*matched_number;
    parsed_number = matched_number;
    parsed_number = 1*parsed_number + 0+x;
    if (parser_trace >= 3) { print "  [parsed value ", parsed_number, " by: 100.9 khz]^"; }
    return GPR_NUMBER;
    .Failed_LP_1;
    wn = original_wn;
    ! 100.9, with offset=0, multiplier=1

    wpos = 0; mid_word = false; matched_number = 0;
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_2;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    sgn = 1; tot = 0; f = false;
    if (cur_addr->wpos == '-') jump Failed_LP_2;
    while ((wpos < cur_len) && (DigitToValue(cur_addr->wpos)>=0)) {
        f = DigitToValue(cur_addr->wpos);
        if (sgn == 1) {
            if ((tot > 3276) || ((tot == 3276) && (f > 7)))
                jump Failed_LP_2;
        } else {
            if ((tot > 3276) || ((tot == 3276) && (f > 8)))
                jump Failed_LP_2;
        }
        tot = 10*tot + f;
        f = true;
        wpos++;
    }
    if (f == false) jump Failed_LP_2;
    if (sgn == 1) {
        if ((tot > 3276) || ((tot == 3276) && (matched_number > 7)))
            jump Failed_LP_2;
    } else {
        if ((tot > 3276) || ((tot == 3276) && (matched_number > 8)))
            jump Failed_LP_2;
    }
    tot = 10*tot + matched_number;
    matched_number = tot;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_2;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    if (cur_addr->wpos++ ~= '.') jump Failed_LP_2;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    if (mid_word == false) {
        cur_word = NextWordStopped(); wn--;
        if (cur_word == -1) jump Failed_LP_2;
    }
    if (mid_word == false) {
        mid_word = true;
        wpos = 0;
        cur_addr = WordAddress(wn);
        cur_len = WordLength(wn);
    }
    sgn = 1; tot = 0; f = false;
    if (cur_addr->wpos == '-') jump Failed_LP_2;
    while ((wpos < cur_len) && (DigitToValue(cur_addr->wpos)>=0)) {
        f = DigitToValue(cur_addr->wpos);
        if (sgn == 1) {
            if ((tot > 3276) || ((tot == 3276) && (f > 7)))
                jump Failed_LP_2;
        } else {
            if ((tot > 3276) || ((tot == 3276) && (f > 8)))
                jump Failed_LP_2;
        }
        tot = 10*tot + f;
        f = true;
        wpos++;
    }
    if (f == false) jump Failed_LP_2;
    if (tot >= 10) jump Failed_LP_2;
    tot = 1*tot + matched_number;
    matched_number = tot;
    if (wpos == cur_len) {
        wn++; mid_word = false;
    }
    .Succeeded_LP_2;
    if (mid_word) jump Failed_LP_2;
    if (sgn<0) matched_number = -1*matched_number;
    parsed_number = matched_number;
    parsed_number = 1*parsed_number + 0+x;
    if (parser_trace >= 3) { print "  [parsed value ", parsed_number, " by: 100.9]^"; }
    return GPR_NUMBER;
    .Failed_LP_2;
    wn = original_wn;
    return GPR_FAIL;
];



[ Noun_Filter_0 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_1 x;
    x=noun;
    return ((noun == O60_gas_can));
];
[ Noun_Filter_2 x;
    x=noun;
    return ((noun == O42_pickup_truck));
];
[ Noun_Filter_3 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_4 x;
    x=noun;
    return ((noun ofclass K119_window) && ((Adj_75_t1_v65(noun))));
];
[ Noun_Filter_5 x;
    x=noun;
    return ((noun ofclass K4_door));
];
[ Noun_Filter_6 x;
    x=noun;
    return ((noun ofclass K4_door));
];
[ Noun_Filter_7 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_8 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_9 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_10 x;
    x=noun;
    return ((noun == O42_pickup_truck));
];
[ Noun_Filter_11 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_12 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_84_t1_v65(noun))));
];
[ Noun_Filter_13 x;
    x=noun;
    return ((noun == O42_pickup_truck));
];
[ Scope_Filter_14 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_15 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_16 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_17 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_18 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_19 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_20 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_21 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_22 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_23 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_24 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_25 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_26 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_71_t1_v65(noun))));
];
[ Noun_Filter_27 x;
    x=noun;
    return ((noun ofclass K4_door));
];
[ Noun_Filter_28 x;
    x=noun;
    return ((noun == O38_lighter));
];
[ Scope_Filter_29 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_30 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_31 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_32 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_31_t1_v65(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_33 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_57_t1_v65(noun))));
];
[ Noun_Filter_34 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_62_t1_v65(noun))));
];
[ Noun_Filter_35 x;
    x=noun;
    return ((noun ofclass K5_container) && ((Adj_75_t1_v65(noun))) && ((Adj_76_t1_v65(noun))));
];
[ Noun_Filter_36 x;
    x=noun;
    return ((noun ofclass K5_container) && ((Adj_74_t1_v65(noun))) && ((Adj_76_t1_v65(noun))));
];
[ Noun_Filter_37 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_79_t1_v65(noun))) && ((Adj_78_t1_v65(noun))));
];
[ Noun_Filter_38 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_80_t1_v65(noun))) && ((Adj_78_t1_v65(noun))));
];
[ Noun_Filter_39 x;
    x=noun;
    return ((noun ofclass K26_device) && ((Adj_85_t1_v65(noun))));
];
[ Noun_Filter_40 x;
    x=noun;
    return ((noun ofclass K4_door));
];
[ Noun_Filter_41 x;
    x=noun;
    return ((noun ofclass K4_door) && ((Adj_74_t1_v65(noun))));
];
[ Noun_Filter_42 x;
    x=noun;
    return ((noun == O38_lighter));
];
[ Noun_Filter_43 x;
    x=noun;
    return ((noun == O76_roll_of_duct_tape));
];
[ Noun_Filter_44 x;
    x=noun;
    return ((noun == O76_roll_of_duct_tape));
];
[ Noun_Filter_45 x;
    x=noun;
    return ((noun == O60_gas_can));
];
[ Noun_Filter_46 x;
    x=noun;
    return ((noun == O133_utility_ladder));
];
[ Noun_Filter_47 x;
    x=noun;
    return ((noun == O39_pack_of_cigarettes));
];
[ Noun_Filter_48 x;
    x=noun;
    return ((noun == O42_pickup_truck));
];
[ Noun_Filter_49 x;
    x=noun;
    return ((noun == O42_pickup_truck));
];
[ Noun_Filter_50 x;
    x=noun;
    return ((noun == O42_pickup_truck));
];
[ Noun_Filter_51 x;
    x=noun;
    return ((noun == O96_fuel_line));
];
[ Noun_Filter_52 x;
    x=noun;
    return ((noun == O96_fuel_line));
];
[ Noun_Filter_53 x;
    x=noun;
    return ((noun == O42_pickup_truck));
];
[ Noun_Filter_54 x;
    x=noun;
    return ((noun == O42_pickup_truck));
];
[ Noun_Filter_55 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_56 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_57 x;
    x=noun;
    return ((noun == O118_emergency_radio));
];


#IFDEF DEBUG;

[ XAbstractSub;
    if (XTestMove(noun, second)) return;
    move noun to second;
    "[Abstracted.]";
];

[ XTestMove obj dest;
    if ((obj <= InformLibrary) || (obj == LibraryMessages))
        "[Can't move ", (name) obj, ": it's a system object.]";
    if (obj.component_parent)
        "[Can't move ", (name) obj, ": it's part of ",
        (the) obj.component_parent, ".]";
    while (dest) {
        if (dest == obj) "[Can't move ", (name) obj, ": it would contain itself.]";
        dest = CoreOfParentOfCoreOf(dest);
    }
    rfalse;
];

[ ActionsOnSub; trace_actions = 1; say__p = 1; "Actions listing on."; ];
[ ActionsOffSub; trace_actions = 0; say__p = 1; "Actions listing off."; ];

[ GonearSub;
	PlayerTo(LocationOf(noun));
];

[ XPurloinSub;
    if (XTestMove(noun, player)) return;
    move noun to player; give noun moved ~concealed;
    say__p = 1;
    "[Purloined.]";
];

[ PredictableSub;
    VM_Seed_RNG(-100);
    say__p = 1;
    "[Random number generator now predictable.]";
];

[ ShowRelationsSub;
   IterateRelations(ShowOneRelation);
];

[ ShowOneRelation rel;
   if ((rel-->RR_PERMISSIONS) & (RELS_SHOW)) {
       (rel-->RR_HANDLER)(rel, RELS_SHOW);
   }
];

[ RulesOnSub;
	debug_rules = 1; say__p = 1;
	"Rules tracing now switched on. Type ~rules off~ to switch it off again,
	 or ~rules all~ to include even rules which do not apply.";
];
[ RulesAllSub;
	debug_rules = 2; say__p = 1;
	"Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";
];
[ RulesOffSub;
	debug_rules = 0; say__p = 1;
	"Rules tracing now switched off. Type ~rules~ to switch it on again.";
];

[ ScenesOnSub;
	debug_scenes = 1;
	ShowSceneStatus(); say__p = 1;
	"(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";
];
[ ScenesOffSub;
	debug_scenes = 0; say__p = 1;
	"(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";
];

Global x_scope_count;
[ ScopeSub;
    x_scope_count = 0;
    LoopOverScope(Print_ScL, noun);
    if (x_scope_count == 0) "Nothing is in scope.";
];
[ Print_ScL obj; print_ret ++x_scope_count, ": ", (a) obj, " (", obj, ")"; ];

[ ShowHeapSub;
	DebugHeap();
];

[ ShowMeSub view na;
	view = noun;
 	if (noun == nothing) noun = real_location;
 	if (ShowMeRecursively(noun, 0, (noun == real_location))) {
 		if (noun == real_location)
			print "* denotes things which are not in scope^";
	}
 	if (view ofclass K2_thing) {
 		print "location:"; ShowRLocation(noun, true); print "^";
 	}
 	if (view ofclass K1_room) { na = 0;
    if ((AllowInShowme(light)) && (view  has light)) { if (na++ > 0) print "; "; print "lighted"; }
    if ((AllowInShowme(light)) && (view  hasnt light)) { if (na++ > 0) print "; "; print "dark"; }
    if ((AllowInShowme(visited)) && (view  has visited)) { if (na++ > 0) print "; "; print "visited"; }
    if ((AllowInShowme(visited)) && (view  hasnt visited)) { if (na++ > 0) print "; "; print "unvisited"; }
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides map_region) print "map region: ", (PrintShortName) GProperty(OBJECT_TY, view, map_region), "^";
}
if (view ofclass K2_thing) { na = 0;
    if ((AllowInShowme(light)) && (view  has light)) { if (na++ > 0) print "; "; print "lit"; }
    if ((AllowInShowme(light)) && (view  hasnt light)) { if (na++ > 0) print "; "; print "unlit"; }
    if ((AllowInShowme(edible)) && (view  has edible)) { if (na++ > 0) print "; "; print "edible"; }
    if ((AllowInShowme(edible)) && (view  hasnt edible)) { if (na++ > 0) print "; "; print "inedible"; }
    if ((AllowInShowme(static)) && (view  has static)) { if (na++ > 0) print "; "; print "fixed in place"; }
    if ((AllowInShowme(static)) && (view  hasnt static)) { if (na++ > 0) print "; "; print "portable"; }
    if ((AllowInShowme(concealed)) && (view  hasnt concealed)) { if (na++ > 0) print "; "; print "described"; }
    if ((AllowInShowme(concealed)) && (view  has concealed)) { if (na++ > 0) print "; "; print "undescribed"; }
    if ((AllowInShowme(workflag)) && (view  has workflag)) { if (na++ > 0) print "; "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (view  hasnt workflag)) { if (na++ > 0) print "; "; print "unmarked for listing"; }
    if ((AllowInShowme(mentioned)) && (view  has mentioned)) { if (na++ > 0) print "; "; print "mentioned"; }
    if ((AllowInShowme(mentioned)) && (view  hasnt mentioned)) { if (na++ > 0) print "; "; print "unmentioned"; }
    if ((AllowInShowme(neuter)) && (view  has neuter)) { if (na++ > 0) print "; "; print "neuter"; }
    if ((AllowInShowme(p67_seen)) && (view  has p67_seen)) { if (na++ > 0) print "; "; print "seen"; }
    if ((AllowInShowme(p67_seen)) && (view  hasnt p67_seen)) { if (na++ > 0) print "; "; print "unseen"; }
    if ((AllowInShowme(p69_familiar)) && (view  has p69_familiar)) { if (na++ > 0) print "; "; print "familiar"; }
    if ((AllowInShowme(p69_familiar)) && (view  hasnt p69_familiar)) { if (na++ > 0) print "; "; print "unfamiliar"; }
    if ((AllowInShowme(p71_ambiguously_plural)) && (view  has p71_ambiguously_plural)) { if (na++ > 0) print "; "; print "ambiguously plural"; }
    if ((AllowInShowme(p71_ambiguously_plural)) && (view  hasnt p71_ambiguously_plural)) { if (na++ > 0) print "; "; print "ordinarily enumerated"; }
    if ((AllowInShowme(p81_hefty)) && (view  has p81_hefty)) { if (na++ > 0) print "; "; print "hefty"; }
    if (na>0) print "^";
}
if (view ofclass K3_direction) { na = 0;
    if ((AllowInShowme(workflag)) && (view  has workflag)) { if (na++ > 0) print "; "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (view  hasnt workflag)) { if (na++ > 0) print "; "; print "unmarked for listing"; }
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
}
if (view ofclass K4_door) { na = 0;
    if ((AllowInShowme(pushable)) && (view  has pushable)) { if (na++ > 0) print "; "; print "pushable between rooms"; }
    if ((AllowInShowme(open)) && (view  has open)) { if (na++ > 0) print "; "; print "open"; }
    if ((AllowInShowme(open)) && (view  hasnt open)) { if (na++ > 0) print "; "; print "closed"; }
    if ((AllowInShowme(openable)) && (view  has openable)) { if (na++ > 0) print "; "; print "openable"; }
    if ((AllowInShowme(openable)) && (view  hasnt openable)) { if (na++ > 0) print "; "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (view  has lockable)) { if (na++ > 0) print "; "; print "lockable"; }
    if ((AllowInShowme(locked)) && (view  has locked)) { if (na++ > 0) print "; "; print "locked"; }
    if ((AllowInShowme(locked)) && (view  hasnt locked)) { if (na++ > 0) print "; "; print "unlocked"; }
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
}
if (view ofclass K5_container) { na = 0;
    if ((AllowInShowme(transparent)) && (view  hasnt transparent)) { if (na++ > 0) print "; "; print "opaque"; }
    if ((AllowInShowme(transparent)) && (view  has transparent)) { if (na++ > 0) print "; "; print "transparent"; }
    if ((AllowInShowme(open)) && (view  has open)) { if (na++ > 0) print "; "; print "open"; }
    if ((AllowInShowme(open)) && (view  hasnt open)) { if (na++ > 0) print "; "; print "closed"; }
    if ((AllowInShowme(openable)) && (view  has openable)) { if (na++ > 0) print "; "; print "openable"; }
    if ((AllowInShowme(openable)) && (view  hasnt openable)) { if (na++ > 0) print "; "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (view  has lockable)) { if (na++ > 0) print "; "; print "lockable"; }
    if ((AllowInShowme(locked)) && (view  has locked)) { if (na++ > 0) print "; "; print "locked"; }
    if ((AllowInShowme(locked)) && (view  hasnt locked)) { if (na++ > 0) print "; "; print "unlocked"; }
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
    if (view provides capacity) print "carrying capacity: ", (DecimalNumber) GProperty(OBJECT_TY, view, capacity), "^";
}
if (view ofclass K6_supporter) { na = 0;
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
    if (view provides capacity) print "carrying capacity: ", (DecimalNumber) GProperty(OBJECT_TY, view, capacity), "^";
}
if (view ofclass K7_backdrop) { na = 0;
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if ((AllowInShowme(pushable)) && (view  has pushable)) { if (na++ > 0) print "; "; print "pushable between rooms"; }
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
}
if (view ofclass K8_person) { na = 0;
    if ((AllowInShowme(female)) && (view  has female)) { if (na++ > 0) print "; "; print "female"; }
    if ((AllowInShowme(female)) && (view  hasnt female)) { if (na++ > 0) print "; "; print "male"; }
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
    if (view provides capacity) print "carrying capacity: ", (DecimalNumber) GProperty(OBJECT_TY, view, capacity), "^";
}
if (view ofclass K9_region) { na = 0;
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
}
if (view == O10_north) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == O11_northeast) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == O12_northwest) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == O13_south) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == O14_southeast) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == O15_southwest) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == O16_east) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == O17_west) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == O18_up) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == O19_down) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == in_obj) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == out_obj) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides p9_opposite) print "opposite: ", (PrintShortName) GProperty(OBJECT_TY, view, p9_opposite), "^";
}
if (view == selfobj) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view ofclass K26_device) { na = 0;
    if ((AllowInShowme(on)) && (view  has on)) { if (na++ > 0) print "; "; print "switched on"; }
    if ((AllowInShowme(on)) && (view  hasnt on)) { if (na++ > 0) print "; "; print "switched off"; }
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
}
if (view ofclass K27_vehicle) { na = 0;
    if ((AllowInShowme(enterable)) && (view  has enterable)) { if (na++ > 0) print "; "; print "enterable"; }
    if (na>0) print "^";
}
if (view ofclass K29_subject) { na = 0;
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
}
if (view ofclass K30_misc_suggestion) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
    if (view provides p16_seqno) print "seqno: ", (DecimalNumber) GProperty(OBJECT_TY, view, p16_seqno), "^";
}
if (view == O31_yes_suggestion) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O32_no_suggestion) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O33_yes_no_suggestion) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O34_self_suggestion) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O35_library_message_debug) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if ((AllowInShowme(p74_on)) && (view  has p74_on)) { if (na++ > 0) print "; "; print "on"; }
    if ((AllowInShowme(p74_on)) && (view  hasnt p74_on)) { if (na++ > 0) print "; "; print "off"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O36_i7_librarymessages) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O37_knock) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O38_lighter) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O39_pack_of_cigarettes) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides p17_count) print "count: ", (DecimalNumber) GProperty(OBJECT_TY, view, p17_count), "^";
}
if (view == O40_glove_box) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O41_denim_jacket) { na = 0;
    if ((AllowInShowme(clothing)) && (view  has clothing)) { if (na++ > 0) print "; "; print "wearable"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O42_pickup_truck) { na = 0;
    if ((AllowInShowme(enterable)) && (view  has enterable)) { if (na++ > 0) print "; "; print "enterable"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view ofclass K43_memory) { na = 0;
    if ((AllowInShowme(p76_retrieved)) && (view  has p76_retrieved)) { if (na++ > 0) print "; "; print "retrieved"; }
    if ((AllowInShowme(p76_retrieved)) && (view  hasnt p76_retrieved)) { if (na++ > 0) print "; "; print "buried"; }
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
}
if (view == O44_subconscious) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O45_emotional_baggage) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O46_last_day_of_high_school) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides article) print "indefinite article: ", (PrintText) GProperty(OBJECT_TY, view, article), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O47_weather_worn_guidebook) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides p78_suggested_memory) print "suggested memory: ", (PrintShortName) GProperty(OBJECT_TY, view, p78_suggested_memory), "^";
}
if (view == O48_wallet) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O49_driver_s_license) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O50_receipt_from_big_jimmy_s) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides p78_suggested_memory) print "suggested memory: ", (PrintShortName) GProperty(OBJECT_TY, view, p78_suggested_memory), "^";
}
if (view == O51_your_shit_job) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O52_piece_of_jade) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides p78_suggested_memory) print "suggested memory: ", (PrintShortName) GProperty(OBJECT_TY, view, p78_suggested_memory), "^";
}
if (view == O53_grandma_s_stories) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O54_rusted_key) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides p78_suggested_memory) print "suggested memory: ", (PrintShortName) GProperty(OBJECT_TY, view, p78_suggested_memory), "^";
}
if (view == O55_meeting_ocean) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O56_bunny_s_bow_tie) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides p78_suggested_memory) print "suggested memory: ", (PrintShortName) GProperty(OBJECT_TY, view, p78_suggested_memory), "^";
}
if (view == O57_her_graduation_night) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O58_lingering_smell_of_orang) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides p78_suggested_memory) print "suggested memory: ", (PrintShortName) GProperty(OBJECT_TY, view, p78_suggested_memory), "^";
}
if (view == O59_ocean_s_perfume) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O60_gas_can) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides p78_suggested_memory) print "suggested memory: ", (PrintShortName) GProperty(OBJECT_TY, view, p78_suggested_memory), "^";
    if (view provides p79_objective) print "objective: ", (PrintShortName) GProperty(OBJECT_TY, view, p79_objective), "^";
}
if (view == O61_road_trips_through_the_d) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O62_ultrasound_of_ocean_s_ba) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides p78_suggested_memory) print "suggested memory: ", (PrintShortName) GProperty(OBJECT_TY, view, p78_suggested_memory), "^";
}
if (view == O63_when_you_heard_the_news) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O64_sage) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides p78_suggested_memory) print "suggested memory: ", (PrintShortName) GProperty(OBJECT_TY, view, p78_suggested_memory), "^";
}
if (view == O65_watching_family_guy) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O66_middle_of_nowhere) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O67_backtracking) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O68_crumbling_concrete) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O69_staging_area) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if ((AllowInShowme(p82_dim)) && (view  has p82_dim)) { if (na++ > 0) print "; "; print "dim"; }
    if ((AllowInShowme(p82_dim)) && (view  hasnt p82_dim)) { if (na++ > 0) print "; "; print "bright"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O70_base_of_the_tower) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O71_flashlight) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view ofclass K72_plan) { na = 0;
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
}
if (view == O73_staying_the_night) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O74_emergency_blanket) { na = 0;
    if ((AllowInShowme(clothing)) && (view  has clothing)) { if (na++ > 0) print "; "; print "wearable"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides p79_objective) print "objective: ", (PrintShortName) GProperty(OBJECT_TY, view, p79_objective), "^";
}
if (view == O75_canned_oranges) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides p79_objective) print "objective: ", (PrintShortName) GProperty(OBJECT_TY, view, p79_objective), "^";
}
if (view == O76_roll_of_duct_tape) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides p79_objective) print "objective: ", (PrintShortName) GProperty(OBJECT_TY, view, p79_objective), "^";
}
if (view == O77_fixing_the_truck) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view ofclass K78_talent) { na = 0;
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O79_strength) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O80_courage) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O81_luck) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O82_scent) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O83_honor) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O84_spirit) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O85_freedom) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O86_photo) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O87_around_the_tower) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O88_weed_strewn_rust) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O89_roof) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O90_tire_tracks) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O91_desert_sand) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O92_sagebrush) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O93_concrete_building) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O94_windshield) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O95_headlights) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O96_fuel_line) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O97_whiffs_of_evaporating_ga) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O98_tall_saguaro) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O99_red_warning_light) { na = 0;
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O100_steel_girder) { na = 0;
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O101_scrawny_weeds) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O102_bits_of_trash) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O103_tumbleweed) { na = 0;
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O104_rusty_tin_can) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O105_huge_electrical_tower) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O106_yellowing_weeds) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O107_scattered_newspapers) { na = 0;
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O108_collection_of_rusted_ba) { na = 0;
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O109_leaking_pipe) { na = 0;
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O110_overturned_barrel) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O111_withered_cactus) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O112_office_interior) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O113_foreman_s_office) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O114_break_room) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O115_storage_room) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O116_boarded_up_door) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O117_layers_of_sand) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O118_emergency_radio) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides p18_frequency_tuned_to) print "frequency tuned to: ", (T45_frequency) GProperty(OBJECT_TY, view, p18_frequency_tuned_to), "^";
    if (view provides p19_maximum_frequency) print "maximum frequency: ", (T45_frequency) GProperty(OBJECT_TY, view, p19_maximum_frequency), "^";
    if (view provides p20_minimum_frequency) print "minimum frequency: ", (T45_frequency) GProperty(OBJECT_TY, view, p20_minimum_frequency), "^";
}
if (view ofclass K119_window) { na = 0;
    if (na>0) print "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O120_pane_of_cracked_glass) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O121_shafts_of_light) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O122_holes_in_the_roof) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O123_patches_of_mold) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O124_hole_in_the_floor) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O125_cobwebs) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O126_metal_desk) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O127_drawer) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O128_dust_covered_window) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O129_half_collapsed_desk) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O130_faded_safety_poster) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O131_emergency_lights) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O132_bare_metal_shelves) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O133_utility_ladder) { na = 0;
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O134_broken_skylight) { na = 0;
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O135_rusted_filing_cabinet) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O136_rows_of_crumbling_shelv) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O137_cans_of_food) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O138_rotting_picnic_tables) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O139_crumbling_trash) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O140_wire_mesh_cage) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O141_tiny_frosted_window) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O142_metal_rungs) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O143_control_center) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O144_huge_metal_barrel) { na = 0;
    if ((AllowInShowme(p84_placed_correctly)) && (view  has p84_placed_correctly)) { if (na++ > 0) print "; "; print "placed correctly"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O145_can_opener) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O146_piles_of_trash) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O147_smell_of_gasoline) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O148_sheet_of_corrugated_met) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O149_open_desert) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view ofclass K150_desert_flotsam) { na = 0;
    if (na>0) print "^";
    if (view provides plural) print "printed plural name: ", (PrintText) GProperty(OBJECT_TY, view, plural), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O151_looming_cactus) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O152_dull_grey_boulder) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O153_dead_cow) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O154_low_bluff) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O155_clutch_of_weeds) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O156_dry_bones) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O157_clumps_of_sagebrush) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O158_dry_streambed) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O159_stand_of_cactus) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O160_scattered_patch_of_dyin) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O161_dead_pine_tree) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O162_weatherbeaten_outcroppi) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O163_lizard_skin) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O164_tower_vicinity) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O166_rabbit) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
    if (view provides p21_price) print "price: ", (DecimalNumber) GProperty(OBJECT_TY, view, p21_price), "^";
}
if (view == O167_coyote) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
    if (view provides p21_price) print "price: ", (DecimalNumber) GProperty(OBJECT_TY, view, p21_price), "^";
}
if (view == O168_sand_dancer) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
    if (view provides p21_price) print "price: ", (DecimalNumber) GProperty(OBJECT_TY, view, p21_price), "^";
}
if (view == O170_desert_hare) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O171_brown_lizard) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O172_voice) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O173_never_mind) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O174_what_that_means) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O175_being_lost) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O176_switch_off_radio) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O177_cigarette) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O178_sunglasses) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(clothing)) && (view  has clothing)) { if (na++ > 0) print "; "; print "wearable"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O179_faded_denim_jacket) { na = 0;
    if ((AllowInShowme(clothing)) && (view  has clothing)) { if (na++ > 0) print "; "; print "wearable"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O180_rain) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O181_darting_shadow) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
    if (view provides p23_times_followed) print "times followed: ", (DecimalNumber) GProperty(OBJECT_TY, view, p23_times_followed), "^";
}
if (view == O182_burrow) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O183_roots) { na = 0;
    if ((AllowInShowme(pluralname)) && (view  has pluralname)) { if (na++ > 0) print "; "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (view  hasnt pluralname)) { if (na++ > 0) print "; "; print "singular-named"; }
    if ((AllowInShowme(scenery)) && (view  has scenery)) { if (na++ > 0) print "; "; print "scenery"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O184_introduction) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O185_go_insane) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O186_grandma) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O187_how_he_s_not_real) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O188_rabbit_s_judgment) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O189_how_he_knows_so_much_ab) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O190_down_to_business) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O191_don_t_know_if_i_love_he) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O192_easter_basket_filled_wi) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O193_more_about_trading) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O194_trade_for_strength) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O195_trade_for_courage) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O196_you_don_t_want_to_trade) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O197_take_inventory) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O198_more_coming) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O199_lookup_suggestion) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O200_distant_figure) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O201_snarling_shadows) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O202_circle_of_snarling_coyo) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
}
if (view == O203_advice) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O204_trade_for_luck) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O205_trade_for_scent) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O206_thousands_of_lizards) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
    if (view provides description) print "description: ", (PrintText) GProperty(OBJECT_TY, view, description), "^";
    if (view provides initial) print "initial appearance: ", (PrintText) GProperty(OBJECT_TY, view, initial), "^";
}
if (view == O207_hello) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O208_path_selection) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O209_grab_something) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O210_final_choice) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O211_not_sure_if_i_m_happy) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O212_doing_the_trade) { na = 0;
    if ((AllowInShowme(proper)) && (view  has proper)) { if (na++ > 0) print "; "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (view  hasnt proper)) { if (na++ > 0) print "; "; print "improper-named"; }
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O213_trade_for_honor) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O214_trade_for_spirit) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}
if (view == O215_trade_for_freedom) { na = 0;
    if (na>0) print "^";
    if (view provides short_name) print "printed name: ", (PrintText) GProperty(OBJECT_TY, view, short_name), "^";
}

];

[ ShowRLocation obj top;
	if (obj ofclass K1_room) return;
	print " ";
	if (parent(obj)) {
		if (obj has worn) print "worn by ";
		else {
			if (parent(obj) has animate) print "carried by ";
			if (parent(obj) has container) print "in ";
			if (parent(obj) ofclass K1_room) print "in ";
			if (parent(obj) has supporter) print "on ";
		}
		print (the) parent(obj);
		ShowRLocation(parent(obj));
	} else {
		if (obj.component_parent) {
			if (top == false) print ", which is ";
			print "part of ", (the) obj.component_parent;
			ShowRLocation(obj.component_parent);
		}
		else print "out of play";
	}
];

[ ShowMeRecursively obj depth f c i k;
	spaces(2*depth);
	if (f && (depth > 0) && (TestScope(obj, player) == false)) { print "*"; c = true; }
	print (name) obj;
	if (depth > 0) {
		if (obj.component_parent) print " (part of ", (name) obj.component_parent, ")";
		if (obj has worn) print " (worn)";
	}
	if (obj provides IK_0) {
		k = KindHierarchy-->((obj.IK_0)*2);
		if ((k ~= K2_thing) || (depth==0)) {
			print " - ";
			if (k == K4_door or K5_container) {
				if (obj has transparent) print "transparent ";
				if (obj has locked) print "locked ";
				else if (obj has open) print "open ";
				else print "closed ";
			}
			print (I7_Kind_Name) k;
		}
	}
	print "^";
	if (obj.component_child) c = c | ShowMeRecursively(obj.component_child, depth+2, f);
	if ((depth>0) && (obj.component_sibling))
		c = c | ShowMeRecursively(obj.component_sibling, depth, f);
	if (child(obj)) c = c | ShowMeRecursively(child(obj), depth+2, f);
	if ((depth>0) && (sibling(obj))) c = c | ShowMeRecursively(sibling(obj), depth, f);
	return c;
];

[ AllowInShowme pr;
	if (pr == workflag or concealed or mentioned) rfalse;
	rtrue;
];

[ ShowVerbSub address lines meta i x;
	wn = 2; x = NextWordStopped();
    if (x == 0 || ((x->#dict_par1) & 1) == 0)
        "Try typing ~showverb~ and then the name of a verb.";
    meta = ((x->#dict_par1) & 2)/2;
    i = DictionaryWordToVerbNum(x);
    address = VM_CommandTableAddress(i);
    lines = address->0;
    address++;
    print "Verb ";
    if (meta) print "meta ";
    VM_PrintCommandWords(i);
    new_line;
    if (lines == 0) "has no grammar lines.";
    for (: lines>0 : lines--) {
        address = UnpackGrammarLine(address);
        print "    "; DebugGrammarLine(); new_line;
    }
    ParaContent();
];

[ DebugGrammarLine pcount;
    print " * ";
    for (: line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
        if ((line_token-->pcount)->0 & $10) print "/ ";
        print (DebugToken) line_token-->pcount, " ";
    }
    print "-> ", (DebugAction) action_to_be;
    if (action_reversed) print " reverse";
];

[ DebugToken token;
    AnalyseToken(token);
    switch (found_ttype) {
      ILLEGAL_TT:
        print "<illegal token number ", token, ">";
      ELEMENTARY_TT:
        switch (found_tdata) {
          NOUN_TOKEN:           print "noun";
          HELD_TOKEN:           print "held";
          MULTI_TOKEN:          print "multi";
          MULTIHELD_TOKEN:      print "multiheld";
          MULTIEXCEPT_TOKEN:    print "multiexcept";
          MULTIINSIDE_TOKEN:    print "multiinside";
          CREATURE_TOKEN:       print "creature";
          SPECIAL_TOKEN:        print "special";
          NUMBER_TOKEN:         print "number";
          TOPIC_TOKEN:          print "topic";
          ENDIT_TOKEN:          print "END";
        }
      PREPOSITION_TT:
        print "'", (address) found_tdata, "'";
      ROUTINE_FILTER_TT:
        print "noun=Routine(", found_tdata, ")";
      ATTR_FILTER_TT:
        print (DebugAttribute) found_tdata;
      SCOPE_TT:
        print "scope=Routine(", found_tdata, ")";
      GPR_TT:
        print "Routine(", found_tdata, ")";
    }
];

#Iftrue (0 > 0);

[ TestScriptSub;
	switch(special_word) {

	default:
		print ">--> The following tests are available:^";

	}
];

#ifdef TARGET_GLULX;
Constant TEST_STACK_SIZE = 128;
#ifnot;
Constant TEST_STACK_SIZE = 48;
#endif;

Array test_stack --> TEST_STACK_SIZE;
Global test_sp = 0;
[ TestStart T R l k;
	if (test_sp >= TEST_STACK_SIZE) ">--> Testing too many levels deep";
	test_stack-->test_sp = T;
	test_stack-->(test_sp+1) = 0;
	test_stack-->(test_sp+3) = l;
	test_sp = test_sp + 4;
	if ((R-->0) && (R-->0 ~= real_location)) {
	     print "(first moving to ", (name) R-->0, ")^";
	     PlayerTo(R-->0, 1);
	}
	k=1;
	while (R-->k) {
	    if (R-->k notin player) {
	        print "(first acquiring ", (the) R-->k, ")^";
	        move R-->k to player;
	    }
	    k++;
	}
	print "(Testing.)^"; say__p = 1;
];
[ TestKeyboardPrimitive a_buffer a_table p i j l spaced ch;
	if (test_sp == 0) {
	    test_stack-->2 = 1;
	    return VM_ReadKeyboard(a_buffer, a_table);
	}
	else {
	    p = test_stack-->(test_sp-4);
	    i = test_stack-->(test_sp-3);
	    l = test_stack-->(test_sp-1);
	    print "[";
	    print test_stack-->2;
	    print "] ";
	    test_stack-->2 = test_stack-->2 + 1;
	    style bold;
	    while ((i < l) && (p->i ~= '/')) {
	    	ch = p->i;
	        if (spaced || (ch ~= ' ')) {
	        	if ((p->i == '[') && (p->(i+1) == '/') && (p->(i+2) == ']')) {
	        		ch = '/'; i = i+2;
	        	}
	            a_buffer->(j+WORDSIZE) = ch;
	            print (char) ch;
	            i++; j++;
	            spaced = true;
	        } else i++;
	    }
	    style roman;
	    print "^";
	    #ifdef TARGET_ZCODE;
	    a_buffer->1 = j;
	    #ifnot; ! TARGET_GLULX
	    a_buffer-->0 = j;
	    #endif;
	    VM_Tokenise(a_buffer, a_table);
	    if (p->i == '/') i++;
	    if (i >= l) {
	        test_sp = test_sp - 4;
	    } else test_stack-->(test_sp-3) = i;
	}
];

#IFNOT;

[ TestScriptSub;
	">--> No test scripts exist for this game.";
];

#ENDIF;

[ TraceOnSub; parser_trace=1; say__p = 1; "[Trace on.]"; ];

[ TraceLevelSub;
    parser_trace = parsed_number; say__p = 1;
    print "[Parser tracing set to level ", parser_trace, ".]^";
];

[ TraceOffSub; parser_trace=0; say__p = 1; "Trace off."; ];

[ XTreeSub i;
    if (noun == 0) {
        objectloop (i)
            if (i ofclass Object && parent(i) == 0) XObj(i);
    }
    else XObj(noun,1);
];

[ XObj obj f;
    if (parent(obj) == 0) print (name) obj; else print (a) obj;
    print " (", obj, ") ";
    if (f == 1 && parent(obj) ~= 0)
        print "(in ", (name) parent(obj), " ", parent(obj), ")";
    new_line;
    if (child(obj) == 0) rtrue;
    if (obj == Class)
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+NOARTICLE_BIT, 1);
    else
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+FULLINV_BIT, 1);
];

[ testcommandnoun obj o2;
	switch (scope_stage) {
		1: rtrue; ! allow multiple objects
		2: objectloop (obj)
        	if ((obj ofclass Object) && (obj provides IK_0))
            	PlaceInScope(obj, true);
        3: print "There seems to be no such object anywhere in the model world.^";
    }
];

Verb meta 'abstract'

    * scope=testcommandnoun 'to' scope=testcommandnoun -> XAbstract;
Verb meta 'actions'

    *                                           -> ActionsOn
    * 'on'                                      -> ActionsOn
    * 'off'                                     -> ActionsOff;
Verb meta 'gonear'

    * scope=testcommandnoun                     -> Gonear;
Verb meta 'purloin'

    * scope=testcommandnoun                     -> XPurloin;
Verb meta 'random'

    *                                           -> Predictable;
Verb meta 'relations'

	*                                           -> ShowRelations;
Verb meta 'rules'

	*                                           -> RulesOn
	* 'all'                                     -> RulesAll
	* 'off'                                     -> RulesOff;
Verb meta 'scenes'

	*                                           -> ScenesOn
	* 'off'                                     -> ScenesOff;
Verb meta 'scope'

    *                                           -> Scope
    * scope=testcommandnoun                     -> Scope;
Verb meta 'showheap'

	*                                           -> ShowHeap;
Verb meta 'showme'

	*                                           -> ShowMe
	* scope=testcommandnoun                     -> ShowMe;
Verb meta 'showverb'

    * special                                   -> Showverb;
Verb meta 'test'

	*                                           -> TestScript
	* special                                   -> TestScript;
Verb meta 'trace'

    *                                           -> TraceOn
    * number                                    -> TraceLevel
    * 'on'                                      -> TraceOn
    * 'off'                                     -> TraceOff;
Verb meta 'tree'

    *                                           -> XTree
    * scope=testcommandnoun                     -> XTree;

[ InternalTestCases;
];

#ENDIF; ! DEBUG

! "Include (- ... -)" inclusions with no specified position appear here.


	[ CheckDPMR result sinp1 sinp2 rv;
		sinp1 = inp1; sinp2 = inp2; inp1 = noun; inp2 = second;
		rv = FollowRulebook( 26 );
		inp1 = sinp1; inp2 = sinp2;
		if ((rv) && RulebookSucceeded()) {
			result = ResultOfRule();
			if (result == RBNO_6 ) return 4;
			if (result == RBNO_7 ) return 3;
			if (result == RBNO_8 ) return 2;
			if (result == RBNO_9 ) return 1;
			if (result == RBNO_10 ) return 0;
		}
		return 2;
	];

[ LITTLE_USED_DO_NOTHING_R; rfalse; ];


[ PlugPlural obj;
	SetPronoun('them', obj);
	SetPronoun('it', obj);
];


[ LibraryMessagesBefore id isImplicitAction;
  id = -1;
  (Global_Vars-->23) = lm_o;
  (Global_Vars-->24) = lm_o2;

Miscellany:
    switch (lm_n) {
       1: id = Q73_libmsg__first_n_objects_;
       2: id = Q72_libmsg__zero_multiple_ob;
       3: id = Q24_libmsg__you_have_died_;
       4: id = Q25_libmsg__you_have_won_;
     ! 5 is "Would you like to restart ...", handled specially by Inform 7
       6: id = Q38_libmsg__undo_not_provide;
       7: id = Q37_libmsg__undo_failed_;
       8: id = Q31_libmsg__restrict_answer_;
       9: id = Q117_libmsg__entering_darkne;
       10: id = Q28_libmsg__empty_line_;
       11: id = Q39_libmsg__cannot_undo_noth;
       12: id = Q40_libmsg__cannot_undo_twic;
       13: id = Q36_libmsg__undo_succeeded_;
       14: id = Q42_libmsg__oops_failed_;
       15: id = Q44_libmsg__oops_no_argument;
       16: id = Q43_libmsg__oops_too_many_ar;
       17: id = Q118_libmsg__dark_descriptio;
       18: id = Q26_libmsg__player_self_desc;
     ! 19 was LibMsg <player description>
	 ! - use "The description of the player is ..." instead
       20: id = Q46_libmsg__again_usage_;
       21: id = Q45_libmsg__cannot_do_again_;
       22: id = Q53_libmsg__cannot_begin_at_;
       23: id = Q91_libmsg__cannot_talk_to_a;
       24: id = Q92_libmsg__cannot_talk_to_i;
       25: id = Q54_libmsg__extra_words_befo;
       26: id = Q75_libmsg__report_implicit_;
       27: id = Q47_libmsg__command_not_unde;
       28: id = Q48_libmsg__command_partly_u;
       29: id = Q52_libmsg__number_not_under;
       30: id = Q55_libmsg__unknown_object_;

       31: id = Q50_libmsg__command_incomple;
       32: id = Q56_libmsg__object_not_held_;
       33: id = Q68_libmsg__verb_cannot_have;
       34: id = Q69_libmsg__too_many_multipl;
       35: id = Q84_libmsg__pronoun_not_set_;
       36: id = Q74_libmsg__excepted_object_;
       37: id = Q58_libmsg__verb_cannot_have;
       38: id = Q57_libmsg__unknown_verb_;
       39: id = Q27_libmsg__unimportant_obje;
       40: (Global_Vars-->23) = pronoun_obj;
	       id = Q85_libmsg__pronoun_absent_;
       41: id = Q49_libmsg__command_badly_en;
       42: id = Q70_libmsg__not_that_many_av;
       43: id = Q72_libmsg__zero_multiple_ob; ! same as Miscellany #2 (?)
       44: id = Q71_libmsg__no_objects_avail;
       45: id = Q79_libmsg__who_disambiguati;
       46: id = Q80_libmsg__which_disambigua;
       47: id = Q83_libmsg__single_object_di;
       48: (Global_Vars-->23) = actor;
	       id = Q81_libmsg__whom_disambiguat;
       49: (Global_Vars-->23) = actor;
	       id = Q82_libmsg__what_disambiguat;
       50: id = Q109_libmsg__score_changed_;
       51: id = Q51_libmsg__command_cut_shor;
       52: id = Q33_libmsg__menu_prompt_;
       53: id = Q32_libmsg__page_prompt_;
       54: id = Q34_libmsg__comment_recorded;
       55: id = Q35_libmsg__comment_not_reco;
     ! 56 = ".^"
     ! 57 = "?^"
       58: id = Q93_libmsg__npc_unable_to_do;
       59: id = Q59_libmsg__noun_needed_;
       60: id = Q60_libmsg__noun_not_needed_;
       61: id = Q61_libmsg__object_needed_;
       62: id = Q62_libmsg__object_not_neede;
       63: id = Q63_libmsg__second_object_ne;
       64: id = Q64_libmsg__second_object_no;
       65: id = Q65_libmsg__second_noun_need;
       66: id = Q66_libmsg__second_noun_not_;
       67: id = Q67_libmsg__something_more_s;
       68: id = Q76_libmsg__report_npc_impli;
       69: id = Q75_libmsg__report_implicit_;
       70: id = Q41_libmsg__undo_forbidden_;
       71: id = Q122_libmsg__dark_room_name_;
       72: id = Q90_libmsg__person_ignores_c;
    }
    jump end_part;

Quit:
    switch (lm_n) {
       1: id = Q30_libmsg__yes_or_no_prompt;
       2: id = Q29_libmsg__confirm_quit_;
    }
    jump end_part;

Restart:
    switch (lm_n) {
       1: id = Q94_libmsg__confirm_restart_;
       2: id = Q95_libmsg__restart_failed_;
    }
    jump end_part;


Restore:
    switch (lm_n) {
       1: id = Q96_libmsg__restore_failed_;
       2: id = Q97_libmsg__restore_succeede;
    }
    jump end_part;

Save:
    switch (lm_n) {
       1: id = Q98_libmsg__save_failed_;
       2: id = Q99_libmsg__save_succeeded_;
    }
    jump end_part;

Verify:
    switch (lm_n) {
       1: id = Q100_libmsg__verify_succeede;
       2: id = Q101_libmsg__verify_failed_;
    }
    jump end_part;

ScriptOn:
    switch (lm_n) {
       1: id = Q102_libmsg__transcript_alre;
       2: id = Q104_libmsg__start_of_transc;
       3: id = Q106_libmsg__transcript_fail;
    }
    jump end_part;

ScriptOff:
    switch (lm_n) {
       1: id = Q103_libmsg__transcript_alre;
       2: id = Q105_libmsg__end_of_transcri;
       3: id = Q107_libmsg__end_transcript_;
    }
    jump end_part;

NotifyOn:
     id = Q110_libmsg__score_notificat;
    jump end_part;
 
NotifyOff:
     id = Q111_libmsg__score_notificat;
    jump end_part;
 
Score:
    switch (lm_n) {
       1: id = Q108_libmsg__score_command_;
       2: id = Q112_libmsg__no_scoring_;
       3: id = Q113_libmsg__score_rank_;
    }
    jump end_part;
 
Pronouns:
    switch (lm_n) {
       1: id = Q86_libmsg__pronouns_initial;
       2: id = Q87_libmsg__pronouns__means_;
       3: id = Q88_libmsg__pronouns__unset_;
       4: id = Q89_libmsg__no_pronouns_know;
    }
    jump end_part;

Inv:
    switch (lm_n) {
       1: id = Q116_libmsg__inventory_no_po;
       2: id = Q115_libmsg__inventory_initi;
     ! 3 is ":^" (used for list style NEWLINE_BIT)
     ! 4 is ".^" (used for list style ENGLISH_BIT)
       5: id = Q114_libmsg__report_npc_taki;
    }
    jump end_part;

Take:
    switch (lm_n) {
       1: id = Q123_libmsg__report_player_t;
       2: id = Q125_libmsg__cannot_take_you;
       3: id = Q126_libmsg__cannot_take_oth;
       4: id = Q127_libmsg__cannot_take_som;
       5: id = Q128_libmsg__cannot_take_som;
       6: id = Q129_libmsg__cannot_take_pos;
       7: id = Q130_libmsg__cannot_take_com;
       8: id = Q131_libmsg__cannot_take_hid;
       9: id = Q132_libmsg__cannot_reach_wi;
       10: id = Q133_libmsg__cannot_take_sce;
       11: id = Q134_libmsg__cannot_take_som;
       12: id = Q136_libmsg__cannot_exceed_c;
       13: id = Q77_libmsg__use_holdall_to_a;
           isImplicitAction = 1;
       14: id = Q135_libmsg__cannot_reach_wi;
     ! 15 doesn't seem to be produced anywhere ("You cannot carry ...")
       16: id = Q124_libmsg__report_npc_taki;
    }
    jump end_part;

Remove:
    switch (lm_n)
    {  1: id = Q139_libmsg__cannot_remove_f;
       2: id = Q140_libmsg__cannot_remove_s;
       3: id = Q137_libmsg__report_player_r; ! TODO - not printed any more? ("Taken" instead)
    }
    jump end_part;

Drop:
    switch (lm_n) {
       1: id = Q143_libmsg__cannot_drop_som;
       2: id = Q144_libmsg__cannot_drop_not;
       3: id = Q146_libmsg__cannot_drop_clo;
           isImplicitAction = 1;
       4: id = Q141_libmsg__report_player_d;
       5,6: id = Q145_libmsg__cannot_drop_if_;   ! 5 = supporter, 6 = container
       7: id = Q142_libmsg__report_npc_drop;
    }
    jump end_part;

Insert:
    switch (lm_n) {
       1: id = Q149_libmsg__cannot_insert_s;
       2: id = Q150_libmsg__cannot_insert_i;
       3: id = Q151_libmsg__cannot_insert_i;
       4: id = Q152_libmsg__need_to_take_of;   ! (unused ?)
       5: id = Q153_libmsg__cannot_insert_s;
       6: id = Q155_libmsg__cannot_insert_c;
           isImplicitAction = 1;
       7: id = Q154_libmsg__cannot_insert_i;
       8,9: id = Q147_libmsg__report_player_i;  ! 8 is for multiple objects
       10: id = Q148_libmsg__report_npc_inse;
    }
    jump end_part;

PutOn:
    switch (lm_n) {
       1: id = Q158_libmsg__cannot_put_some;
       2: id = Q159_libmsg__cannot_put_some;
       3: id = Q160_libmsg__cannot_put_onto;
       4: id = Q161_libmsg__cannot_put_onto;
       5: id = Q162_libmsg__cannot_put_clot;
           isImplicitAction = 1;
       6: id = Q78_libmsg__cannot_put_if_th;
      7,8: id = Q156_libmsg__report_player_p;  ! 7 is for multiple objects
       9: id = Q157_libmsg__report_npc_putt;
    }
    jump end_part;

Give:
    switch (lm_n) {
       1: id = Q166_libmsg__cannot_give_wha;
       2: id = Q167_libmsg__cannot_give_to_;
       3: id = Q168_libmsg__block_giving_;
       4: id = Q169_libmsg__unable_to_recei;
       5: id = Q163_libmsg__report_player_g;
       6: id = Q164_libmsg__report_npc_givi;  
       7: id = Q165_libmsg__report_npc_givi;
   }
    jump end_part;

Show:
    switch (lm_n) {
       1: id = Q170_libmsg__cannot_show_wha;
       2: id = Q171_libmsg__block_showing_;
    }
    jump end_part;

Enter:
    switch (lm_n) {
       1: id = Q174_libmsg__cannot_enter_so;
       2: id = Q175_libmsg__cannot_enter_so;
       3: id = Q176_libmsg__cannot_enter_cl;
       4: id = Q177_libmsg__cannot_enter_so;
       5: id = Q172_libmsg__report_player_e;
       6: id = Q178_libmsg__implicitly_pass;
          isImplicitAction = 1;
       7: id = Q179_libmsg__implicitly_pass;
           isImplicitAction = 1;
       8,9: id = Q173_libmsg__report_npc_ente;  ! 8 = container, 9 = supporter
    }
    jump end_part;

Exit:
    switch (lm_n) {
       1: id = Q182_libmsg__cannot_exit_whe;
       2: id = Q183_libmsg__cannot_exit_clo;
       3: id = Q180_libmsg__report_player_e;
       4: id = Q185_libmsg__cannot_exit_thi;
       5,6: id = Q181_libmsg__report_npc_exit;
    }
    jump end_part;

GetOff:
    id = Q184_libmsg__cannot_get_off_;
    jump end_part;

Go:
    switch (lm_n) {
       1: id = Q187_libmsg__cannot_travel_i;
       2: id = Q186_libmsg__cannot_go_that_;
          (Global_Vars-->23) = noun;   ! the direction
       3: id = Q189_libmsg__cannot_go_up_th;
       4: id = Q190_libmsg__cannot_go_down_;
       5: id = Q191_libmsg__cannot_go_throu;
       6: id = Q192_libmsg__nothing_through;
       7: id = Q193_libmsg__block_vaguely_g;
       8: id = Q194_libmsg__say_npc_goes_;
         (Global_Vars-->23) = O18_up;
       9: id = Q194_libmsg__say_npc_goes_;
         (Global_Vars-->23) = O19_down;
       10: id = Q194_libmsg__say_npc_goes_;
       11: id = Q195_libmsg__say_npc_arrives;
         (Global_Vars-->23) = O18_up;
       12:  id = Q195_libmsg__say_npc_arrives;
         (Global_Vars-->23) = O19_down;
       13:  id = Q195_libmsg__say_npc_arrives;
       14: id = Q196_libmsg__say_npc_arrives;
       15: id = Q197_libmsg__say_npc_arrives;
         (Global_Vars-->24) = O18_up;
       16: id = Q197_libmsg__say_npc_arrives;
         (Global_Vars-->24) = O19_down;
       17: id = Q197_libmsg__say_npc_arrives;
          ! secondary object already defined
       18: id = Q198_libmsg__say_npc_goes_th;
       19: id = Q199_libmsg__say_npc_arrives;
       20,21: id = Q200_libmsg__say_npc_vehicle;
       22: id = Q201_libmsg__say_npc_pushing;
       23: id = Q202_libmsg__say_npc_pushing;
       24: id = Q203_libmsg__say_npc_pushing;
       25: id = Q204_libmsg__say_npc_pushing;
       26: id = Q205_libmsg__say_npc_taking_;
    }
    jump end_part;

LMode1:
    id = Q206_libmsg__brief_look_mode;
    jump end_part;

LMode2:
    id = Q208_libmsg__verbose_look_mo;
    jump end_part;

LMode3:
    id = Q207_libmsg__superbrief_look;
    jump end_part;

Look:
    switch (lm_n) {
       1: id = Q210_libmsg__top_line_what_o;
       2: id = Q211_libmsg__top_line_what_i;
       3: id = Q212_libmsg__top_line_what_a;
       4: id = Q215_libmsg__say_things_on_;
       5: id = Q214_libmsg__say_things_also;
       6: id = Q213_libmsg__say_things_with;
       8: if (lm_o has supporter) id = Q210_libmsg__top_line_what_o;
          else id = Q211_libmsg__top_line_what_i;
       9: id = Q209_libmsg__report_npc_look;
    }
    jump end_part;

Examine:
    switch (lm_n) {
       1: id = Q119_libmsg__examine_while_d;
       2: id = Q217_libmsg__examine_undescr;
       3: id = Q219_libmsg__examine_devices;
       4: id = Q216_libmsg__report_npc_exam;
       5: id = Q218_libmsg__examine_directi;
    }
    jump end_part;

Search:
    switch (lm_n) {
       1: id = Q120_libmsg__search_while_da;
       2: id = Q225_libmsg__nothing_found_o;
     ! 3 prints what is on a supporter; use I6 default behaviour
       4: id = Q222_libmsg__cannot_search_u;
       5: id = Q223_libmsg__cannot_search_c;
       6: id = Q224_libmsg__nothing_found_w;
     ! 7 prints the contents of a container; use I6 default behaviour
       8: id = Q221_libmsg__report_npc_sear;
    }
    jump end_part;

LookUnder:
   switch (lm_n) {
       1: id = Q121_libmsg__look_under_whil;
       2: id = Q228_libmsg__look_under_;
       3: id = Q227_libmsg__report_npc_look;
    }
    jump end_part;

Open:
    switch (lm_n) {
       1: id = Q233_libmsg__cannot_open_unl;
       2: id = Q234_libmsg__cannot_open_som;
       3: id = Q235_libmsg__cannot_open_som;
       4: id = -2; ! reveal any newly visible exterior
       5: id = Q230_libmsg__report_player_o;
       6: id = Q231_libmsg__report_npc_open;
       7: id = Q232_libmsg__report_unseen_n;
    }
    jump end_part;

Close:
    switch (lm_n) {
       1: id = Q241_libmsg__cannot_close_un;
       2: id = Q242_libmsg__cannot_close_so;
       3: id = Q238_libmsg__report_player_c;
       4: id = Q239_libmsg__report_npc_clos;
       5: id = Q240_libmsg__report_unseen_n;
    }
    jump end_part;

Lock:
    switch (lm_n) {
       1: id = Q245_libmsg__cannot_lock_wit;
       2: id = Q246_libmsg__cannot_lock_som;
       3: id = Q247_libmsg__cannot_lock_som;
       4: id = Q248_libmsg__cannot_lock_wit;
       5: id = Q243_libmsg__report_player_l;
       6: id = Q244_libmsg__report_npc_lock;
    }
    jump end_part;

Unlock:
    switch (lm_n) {
       1: id = Q251_libmsg__cannot_unlock_w;
       2: id = Q252_libmsg__cannot_unlock_s;
       3: id = Q253_libmsg__cannot_unlock_w;
       4: id = Q249_libmsg__report_player_u;
       5: id = Q250_libmsg__report_npc_unlo;
    }
    jump end_part;

SwitchOn:
    switch (lm_n) {
       1: id = Q256_libmsg__cannot_switch_o;
       2: id = Q257_libmsg__cannot_switch_o;
       3: id = Q254_libmsg__report_player_s;
       4: id = Q255_libmsg__report_npc_swit;
    }
    jump end_part;

SwitchOff:
    switch (lm_n) {
       1: id = Q260_libmsg__cannot_switch_o;
       2: id = Q261_libmsg__cannot_switch_o;
       3: id = Q258_libmsg__report_player_s;
       4: id = Q259_libmsg__report_npc_swit;
    }
    jump end_part;

Wear:
    switch (lm_n) {
       1: id = Q264_libmsg__cannot_wear_som;
       2: id = Q265_libmsg__cannot_wear_not;
       3: id = Q266_libmsg__cannot_wear_som;
       4: id = Q262_libmsg__report_player_w;
       5: id = Q263_libmsg__report_npc_wear;
    }
    jump end_part;

Disrobe:
    switch (lm_n) {
       1: id = Q269_libmsg__cannot_take_off;
       2: id = Q267_libmsg__report_player_t;
       3: id = Q268_libmsg__report_npc_taki;
    }
    jump end_part;

Eat:
    switch (lm_n) {
       1: id = Q272_libmsg__cannot_eat_unle;
       2: id = Q270_libmsg__report_player_e;
       3: id = Q271_libmsg__report_npc_eati;
    }
    jump end_part;
Drink:
    id = Q273_libmsg__block_drinking_;
    jump end_part;
Taste:
    id = Q274_libmsg__block_tasting_;
    jump end_part;
Smell:
    id = Q275_libmsg__block_smelling_;
    jump end_part;
Listen:
    id = Q276_libmsg__block_listening;
    jump end_part;
Touch:
    switch (lm_n) {
       1: id = Q281_libmsg__report_player_t;
       2: id = Q277_libmsg__report_player_t;
       3: id = Q279_libmsg__report_player_t;
       4: id = Q280_libmsg__report_npc_touc;
	 ! 5 is for touching the player, 6 is for another NPC
       5,6: id = Q282_libmsg__report_npc_touc;
    }
    jump end_part;

Yes:
    id = Q283_libmsg__block_saying_ye;
    jump end_part;
No:
    id = Q284_libmsg__block_saying_no;
    jump end_part;
Sorry:
    id = Q285_libmsg__block_saying_so;
    jump end_part;
Strong:
    id = Q286_libmsg__block_swearing_;
    jump end_part;
Mild:
    id = Q287_libmsg__block_swearing_;
    jump end_part;

Climb:
    id = Q288_libmsg__block_climbing_;
    jump end_part;
Jump:
    id = Q289_libmsg__block_jumping_;
    jump end_part;
Swing:
    id = Q290_libmsg__block_swinging_;
    jump end_part;
WaveHands:
    id = Q291_libmsg__block_waving_ha;
    jump end_part;

Attack:
    id = Q292_libmsg__block_attacking;
    jump end_part;
Burn:
    id = Q293_libmsg__block_burning_;
    jump end_part;
Cut:
    id = Q294_libmsg__block_cutting_;
    jump end_part;
Rub:
    id = Q295_libmsg__block_rubbing_;
    jump end_part;
SetTo:
    id = Q296_libmsg__block_setting_t;
    jump end_part;
Tie:
    id = Q297_libmsg__block_tying_;
    jump end_part;

Wave:
    switch (lm_n) {
       1: id = Q300_libmsg__cannot_wave_som;
       2: id = Q298_libmsg__report_player_w;
       3: id = Q299_libmsg__report_npc_wavi;
    }
    jump end_part;

Squeeze:
    switch (lm_n) {
       1: id = Q301_libmsg__squeezing_peopl;
       2: id = Q302_libmsg__report_player_s;
       3: id = Q303_libmsg__report_npc_sque;
    }
    jump end_part;

ThrowAt:
    switch (lm_n) {
       1: id = Q305_libmsg__throw_at_inanim;
       2: id = Q304_libmsg__block_throwing_;
    }
    jump end_part;

Push:
    switch (lm_n) {
       1: id = Q315_libmsg__cannot_push_som;
       2: id = Q318_libmsg__cannot_push_sce;
       3: id = Q306_libmsg__report_player_p;
       4: id = Q321_libmsg__cannot_push_peo;
     ! 5 does not apply to Push
       6:  id = Q307_libmsg__report_npc_push;
    }
    jump end_part;

PushDir:
    switch (lm_n) {
       1: id = Q312_libmsg__block_pushing_i;
       2: id = Q313_libmsg__not_pushed_in_a;
       3: id = Q314_libmsg__pushed_in_illeg;
    }
    jump end_part;

Pull:
    switch (lm_n) {
       1: id = Q316_libmsg__cannot_pull_som;
       2: id = Q319_libmsg__cannot_pull_sce;
       3: id = Q308_libmsg__report_player_p;
       4: id = Q322_libmsg__cannot_pull_peo;
       5: id = Q309_libmsg__report_npc_pull;
    }
    jump end_part;

Turn:
    switch (lm_n) {
       1: id = Q317_libmsg__cannot_turn_som;
       2: id = Q320_libmsg__cannot_turn_sce;
       3: id = Q310_libmsg__report_player_t;
       4: id = Q323_libmsg__cannot_turn_peo;
     ! 5,6 do not apply to Turn
       7: id = Q311_libmsg__report_npc_turn;
    }
    jump end_part;

Answer:
    id = Q324_libmsg__block_answering;
    jump end_part;
Ask:
    id = Q325_libmsg__block_asking_;
    jump end_part;
Buy:
    id = Q326_libmsg__block_buying_;
    jump end_part;
Kiss:
    id = Q327_libmsg__block_kissing_;
    jump end_part;
Sing:
    id = Q328_libmsg__block_singing_;
    jump end_part;
Tell:
    switch (lm_n) {
       1: id = Q330_libmsg__telling_yoursel;
       2: id = Q329_libmsg__block_telling_;
    }
    jump end_part;

Think:
    id = Q331_libmsg__block_thinking_;
    jump end_part;

Consult:
    switch (lm_n) {
       1: id = Q332_libmsg__block_player_co;
       2: id = Q333_libmsg__block_npc_consu;
    }
    jump end_part;

Sleep:
    id = Q334_libmsg__block_sleeping_;
    jump end_part;

Wait:
    switch (lm_n) {
       1: id = Q337_libmsg__report_player_w;
       2: id = Q338_libmsg__report_npc_wait;
    }
    jump end_part;

Wake:
    id = Q335_libmsg__block_waking_up;
    jump end_part;

WakeOther:
    id = Q336_libmsg__block_waking_ot;
    jump end_part;

default:
.end_part;
    if (id == -1) { rfalse; }

    if (id == -2)  {
        R_905();
		rtrue;
    }
    else {
       (Global_Vars-->21) = id;
       R_889();

	   return (Global_Vars-->22);
    }
];

Constant ALLOWUNDO_ACT = V32_deciding_whether_to_allo;
Constant CANTUNDO_MSG = "That action cannot be undone.^^";

[ AllowUndo flag;
	BeginActivity(ALLOWUNDO_ACT);
	flag = ~~((Global_Vars-->25));
	say__p = 0;
	if (ForActivity(ALLOWUNDO_ACT))
		flag = RulebookSucceeded();
	if (flag == 0 && ~~say__p)
		print (string) CANTUNDO_MSG;
	EndActivity(ALLOWUNDO_ACT);
	return flag;
];




! Request 0: phrase nothing -> nothing
! From the Standard Rules
! To decide if intervened in miscellaneous message:
[ PHR_716_r0 ;
      ! phrase 1
      ! [1: decide on false]
       return 0; 
   rfalse;
];
! Request 1: phrase nothing -> nothing
! From the Standard Rules
! To decide if intervened in miscellaneous list message:
[ PHR_717_r1 ;
      ! phrase 1
      ! [1: decide on false]
       return 0; 
   rfalse;
];
! Request 2: phrase nothing -> nothing
! From the Standard Rules
! To decide if intervened in action message:
[ PHR_718_r2 ;
      ! phrase 1
      ! [1: decide on false]
       return 0; 
   rfalse;
];
! Request 3: phrase nothing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To reset the interlocutor:
[ PHR_765_r3 ;
      ! phrase 1
      ! [1: now the current interlocutor is nothing]
       (Global_Vars-->9) = nothing; 
   rfalse;
];
! Request 4: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To add the custom library messages:
[ PHR_886_r4 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: repeat through the table of custom library messages begin]
       @push ct_0; @push ct_1;
		for (t_0=T2_custom_library_messages,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 2
         ! [2: set message id entry to the message text entry]
         (PHR_887_r5 (TableLookUpEntry(ct_0,107,ct_1),TableLookUpEntry(ct_0,108,ct_1)));
         ! phrase 3
         ! [3: end repeat]
         }
@pull ct_1; @pull ct_0;
   rfalse;
];
! Request 5: phrase (library message id, text) -> nothing
! From "Default Messages" by David Fisher
! To set ( id_ - library message id ) to ( msg_ - text ):
[ PHR_887_r5 
    t_0 ! Call parameter 'id_' = library message id
    t_1 ! Call parameter 'msg_' = text
    ;
      ! phrase 1
      ! [1: update the row with id of id_ to msg_]
      (PHR_888_r83 (t_0,t_1));
   rfalse;
];
! Request 6: phrase nothing -> nothing
! To say sinister-radio-1:
[ PHR_1113_r6 ;
      ! phrase 1
      ! [1: say ~With a sudden growl of static the radio springs to life[radio left off] and it freaks the hell out of you. The voice weaves in and out of crazy whirling distortion and shifting blasts of static. 'Hey... receiving? ...never told... you'll never, never--' A wail like an 8-bit banshee screams through the signal. '...waste of time... who do you think?...' Static, static. 'Very soon now, Nak... akaibito... very...'[paragraph break]Uh. You're pretty sure you never told that dude your name. Maybe you're just hearing things~]
      say__p=1;ParaContent();  print (PrintText) SC_590; ParaContent(); (PHR_1114_r94 ());ParaContent();  print (PrintText) SC_591; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_592;  .L_Say410; .L_SayX367;
   rfalse;
];
! Request 7: phrase nothing -> nothing
! To say sinister-radio-2:
[ PHR_1115_r7 ;
      ! phrase 1
      ! [1: say ~The radio growls to life again[radio left off], the voice distorted now under a constant barrage of electronic rain. 'Where do you think you're going?' it says. 'What are you trying to do? You can't...' A snap, some syncopated crackles. '...can see you, Na... know where... never going to work. Never g--' And the voice cuts off, replaced by a low, tooth-rattling hum.[paragraph break]The voice sounds different than before. I mean it still kind of sounds like the first guy you talked to but it sounds like someone else now too, someone you know, you've known for a long time. Someone you're afraid of~]
      say__p=1;ParaContent();  print (PrintText) SC_593; ParaContent(); (PHR_1114_r94 ());ParaContent();  print (PrintText) SC_594; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_595;  .L_Say411; .L_SayX368;
   rfalse;
];
! Request 8: phrase nothing -> nothing
! To say sinister-radio-3:
[ PHR_1116_r8 
    t_0 ! Local variable e.g. 'item' = object
    t_1 ! Local variable e.g. 'selected memory' = object
    ;
      ! phrase 1
      ! [1: if plan-threatened is false and the player holds something required by a plan ( called the item ) begin]
       if (((((Global_Vars-->28) == 0))) && ((Prop_75() && (t_0=deferred_calling_list-->0, true))))  {
         ! phrase 2
         ! [2: now plan-threatened is true]
          (Global_Vars-->28) = 1; 
         ! phrase 3
         ! [3: say ~Static squeals from the radio[radio left off]. 'Hey,' the speaker shouts, 'hey, do you really think that [item]'s going to help you with anything? You can't even--' and static reclaims it again~]
         say__p=1;ParaContent();  print (PrintText) SC_596; ParaContent(); (PHR_1114_r94 ());ParaContent();  print (PrintText) SC_597; ParaContent();  print (PrintShortName) t_0; ParaContent();  print (PrintText) SC_598;  .L_Say412; .L_SayX369;
         ! phrase 4
         ! [4: otherwise if memory-threatened is false and emotional baggage contains a memory ( called the selected memory )]
          } else if (((((Global_Vars-->29) == 0))) && ((Prop_76() && (t_1=deferred_calling_list-->0, true)))) { 
         ! phrase 5
         ! [5: now memory-threatened is true]
          (Global_Vars-->29) = 1; 
         ! phrase 6
         ! [6: say ~The static on the radio resolves into overlapping whispers[radio left off]. 'It makes for a nice story,' the whispers say, 'but you're remembering [the selected memory] all wrong. That's not really how it happened, was it? Was it, Knock? Was--' and they repeat and overlap and echo and fade back into the mutters of the static~]
         say__p=1;ParaContent();  print (PrintText) SC_599; ParaContent(); (PHR_1114_r94 ());ParaContent();  print (PrintText) SC_600; ParaContent();  print (the) t_1; ParaContent();  print (PrintText) SC_601;  .L_Say413; .L_SayX370;
         ! phrase 7
         ! [7: otherwise if talent-threatened is false and the player holds a talent]
          } else if (((((Global_Vars-->30) == 0))) && ((Prop_77()))) { 
         ! phrase 8
         ! [8: now talent-threatened is true]
          (Global_Vars-->30) = 1; 
         ! phrase 9
         ! [9: say ~'You think just because you've got [a random talent held by player] now you're going to be anything other than a pathetic failure?' the radio squawks angrily[radio left off], before dissolving into harsh buzzing distortions~]
         say__p=1;ParaContent();  print (PrintText) SC_602; ParaContent();  print (a)  (Prop_78()) ; ParaContent();  print (PrintText) SC_603; ParaContent(); (PHR_1114_r94 ());ParaContent();  print (PrintText) SC_604;  .L_Say414; .L_SayX371;
         ! phrase 10
         ! [10: otherwise if final-threatened is false and the player holds a talent]
          } else if (((((Global_Vars-->31) == 0))) && ((Prop_79()))) { 
         ! phrase 11
         ! [11: now final-threatened is true]
          (Global_Vars-->31) = 1; 
         ! phrase 12
         ! [12: say ~'You're nothing,' the radio spews, 'your [list of talents held by player] [is-are] worthless. You'll never amount to anything, and neither will your kid, just another half-breed loser destined to die in poverty and live in debt, isn't that right, Knock?' and with a sudden shock you realize why the voice sounds so familiar. It's your voice. It's your own god-damned voice~]
         say__p=1;ParaContent();  print (PrintText) SC_605; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K78_talent) && (player == HolderOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+NOARTICLE_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_166; ParaContent(); (PHR_789_r49 ());ParaContent();  print (PrintText) SC_606;  .L_Say415; .L_SayX372;
         ! phrase 13
         ! [13: otherwise]
         } else {

         ! phrase 14
         ! [14: say ~[one of]The radio fizzles and growls through weird twists of distortion[or]Angry distortion bubbles and pops from the radio speaker, twisting in weird rhythmic patterns[stopping]~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->18 =
	i7_soo_stop(I7_ST_say_one_of-->18, 2);
	switch((I7_ST_say_one_of-->18)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_607; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_608; ParaContent();  }  .L_Say416; .L_SayX373;
         ! phrase 15
         ! [15: end if]
         }

   rfalse;
];
! Request 9: phrase thing -> nothing
! To note ( item - a thing ) as useful:
[ PHR_954_r9 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now item is noted as useful]
       (Adj_98_t2_v65(t_0)); 
      ! phrase 2
      ! [2: say ~Hey, that [item] might be useful if you decide on [objective of item].~]
      say__p=1;ParaContent();  print (PrintText) SC_609; ParaContent();  print (PrintShortName) t_0; ParaContent();  print (PrintText) SC_610; ParaContent(); @push self;  print (PrintShortName) GProperty(OBJECT_TY, self=t_0,p79_objective); @pull self; ParaContent();  print (PrintText) SC_77;  new_line; .L_Say417; .L_SayX374;
   rfalse;
];
! Request 10: phrase object -> nothing
! From "Plurality" by Emily Short
! To have the parser notice ( o - an object ):
[ PHR_828_r10 
    t_0 ! Call parameter 'o' = object
    ;
      ! phrase 1
      ! [1: if o is ambiguously plural , notice the plurality of o]
       if ((((Adj_92_t1_v65(t_0))))) {  PlugPlural(t_0);   }
      ! phrase 2
      ! [2: otherwise set pronouns from o]
       else {  PronounNotice(t_0);   }
   rfalse;
];
! Request 11: phrase nothing -> nothing
! From "Conditional Undo" by Jesse McGrew
! To prevent undo:
[ PHR_913_r11 ;
      ! phrase 1
      ! [1: change the prevent undo flag to true]
       (Global_Vars-->25) = 1; 
   rfalse;
];
! Request 12: phrase nothing -> nothing
! From "Conditional Undo" by Jesse McGrew
! To do not prevent undo:
[ PHR_914_r12 ;
      ! phrase 1
      ! [1: change the prevent undo flag to false]
       (Global_Vars-->25) = 0; 
   rfalse;
];
! Request 13: phrase thing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To implicitly greet ( character - a thing ):
[ PHR_755_r13 
    t_0 ! Call parameter 'character' = thing
    ;
      ! phrase 1
      ! [1: now the greeting type is implicit]
       (Global_Vars-->10) = Q22_implicit; 
      ! phrase 2
      ! [2: try saying hello to the character]
       TryAction(0, player, ##A89_saying_hello_to, t_0, 0);; 
   rfalse;
];
! Request 14: phrase nothing -> nothing
! To decide whether insufficient memories found:
[ PHR_932_r14 ;
      ! phrase 1
      ! [1: if pursuit is happening and the number of memories in emotional baggage is less than the price of hare , decide yes]
       if (((((scene_status-->(Q341_pursuit-1)==1)))) && ((( (Prop_80())  < GProperty(OBJECT_TY, O170_desert_hare,p21_price))))) {  rtrue;   }
      ! phrase 2
      ! [2: if temptation is happening and the number of memories in emotional baggage is less than the price of coyote , decide yes]
       if (((((scene_status-->(Q343_temptation-1)==1)))) && ((( (Prop_81())  < GProperty(OBJECT_TY, O167_coyote,p21_price))))) {  rtrue;   }
      ! phrase 3
      ! [3: if time for arrival and the number of memories in emotional baggage is less than the price of sand-dancer , decide yes]
       if ((((PHR_1197_r17 ()))) && ((( (Prop_82())  < GProperty(OBJECT_TY, O168_sand_dancer,p21_price))))) {  rtrue;   }
      ! phrase 4
      ! [4: decide no]
       rfalse; 
   rfalse;
];
! Request 15: phrase nothing -> nothing
! To say voice explains choices:
[ PHR_1097_r15 ;
      ! phrase 1
      ! [1: say ~'Look, son,' the voice says, 'I don't know how you got out there but that's not important right now. Weather report's coming in and there's a cold front the size of Texas coming your way. I don't want to scare you but if you don't find a way home, or figure out some food and shelter for the night, you could freeze to death. You hear me? Now on account of the cutbacks I don't have anyone to send out there until morning. But there may be parts around that old tower you can use to patch up your truck and make it back to the highway. Or, there may be emergency supplies that would get you through the night. This storm's gonna blow out all our communication, so you're gonna be on your own. It's up to you. Over and out.'[paragraph break]You rub your face tiredly. Ocean was expecting you tonight after your shift, like usual. If you don't make it she'll be worried sick. Then on the other hand maybe you should worry about yourself first for a change. You feel like you need a cigarette and then you remember you quit. Hell, can't anything be easy~]
      say__p=1;ParaContent();  print (PrintText) SC_611; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_612;  .L_Say418; .L_SayX375;
      ! phrase 2
      ! [2: reset the interlocutor]
      (PHR_765_r3 ());
      ! phrase 3
      ! [3: now voice is off-stage]
       (Adj_9_t3_v65(O172_voice)); 
   rfalse;
];
! Request 16: phrase nothing -> nothing
! To decide whether it's effectively dark:
[ PHR_948_r16 ;
      ! phrase 1
      ! [1: if location is staging area and staging area is dim , decide yes]
       if ((((real_location == O69_staging_area))) && ((((Adj_100_t1_v65(O69_staging_area)))))) {  rtrue;   }
      ! phrase 2
      ! [2: if in darkness , decide yes]
       if (( (location==thedark) )) {  rtrue;   }
      ! phrase 3
      ! [3: decide no]
       rfalse; 
   rfalse;
];
! Request 17: phrase nothing -> nothing
! To decide whether time for arrival:
[ PHR_1197_r17 ;
      ! phrase 1
      ! [1: if the number of complete plans is 1 or the number of in progress plans is 2 , decide yes]
       if (((( (Prop_83())  == 1))) || ((( (Prop_84())  == 2)))) {  rtrue;   }
   rfalse;
];
! Request 18: phrase nothing -> nothing
! To introduce rabbit's choices:
[ PHR_1148_r18 ;
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: now bow tie is off-stage]
       (Adj_9_t3_v65(O56_bunny_s_bow_tie)); 
      ! phrase 3
      ! [3: move strength to location]
       MoveObject(O79_strength, real_location, 0, false); 
      ! phrase 4
      ! [4: now strength is familiar]
       (Adj_90_t2_v65(O79_strength)); 
      ! phrase 5
      ! [5: move courage to location]
       MoveObject(O80_courage, real_location, 0, false); 
      ! phrase 6
      ! [6: now courage is familiar]
       (Adj_90_t2_v65(O80_courage)); 
      ! phrase 7
      ! [7: move easter basket to location]
       MoveObject(O192_easter_basket_filled_wi, real_location, 0, false); 
      ! phrase 8
      ! [8: say ~[line break]'Look,' he says, and now he's big and fluffy and smells like springtime and peeps. 'I can help you make your decisions. I'll trade you for one of these talents.' He holds out an [easter basket filled with plastic green easter grass]; in it are two glowing orbs.[paragraph break]'Strength,' he says, pointing to the first one, 'and courage. Pick whichever one you think will be most useful, but you have to give me something back. Something real, something I can work with.'[add more about trading ask suggestion][add strength ask suggestion][add courage ask suggestion][add trade-for-strength other suggestion][add trade-for-courage other suggestion][add take-inventory other suggestion][add don't want to trade other suggestion]~]
      say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_613; ParaContent();  print (PrintShortName) O192_easter_basket_filled_wi; ParaContent();  print (PrintText) SC_614; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_615;  new_line;ParaContent(); (PHR_834_r25 (O193_more_about_trading));ParaContent(); (PHR_834_r25 (O79_strength));ParaContent(); (PHR_834_r25 (O80_courage));ParaContent(); (PHR_835_r27 (O194_trade_for_strength));ParaContent(); (PHR_835_r27 (O195_trade_for_courage));ParaContent(); (PHR_835_r27 (O197_take_inventory));ParaContent(); (PHR_835_r27 (O196_you_don_t_want_to_trade)); .L_Say419; .L_SayX376;
   rfalse;
];
! Request 19: phrase nothing -> nothing
! To Coyote-talks:
[ PHR_1187_r19 ;
      ! phrase 1
      ! [1: clear all topics]
      (PHR_850_r28 ());
      ! phrase 2
      ! [2: say ~[line break]'Gotta keep an eye on the horizon,' he says in a scratchy, slow voice[if we are saying yes] as you step back, inhaling the dry smoke[end if]. 'Always someone hunting. Border Patrol, National Guard, INS, Minutemen. You want to help people get where they're going out here, you need more than [if player holds strength]strength[otherwise]courage[end if]. You need to learn how to hide.'[paragraph break]'I'm the Coyote,' he says. 'And we've been hiding from each other for a long time.'[make rabbit known][add rabbit ask suggestion][add Coyote ask suggestion][add advice ask suggestion][add down to business ask suggestion]~]
      say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_616; 
	if (~~(((action ==##Yes) &&  (actor==player)))) jump L_Say420;
		ParaContent();  print (PrintText) SC_617; 
	.L_Say420; .L_SayX377;
		ParaContent();  print (PrintText) SC_618; 
	if (~~((((player == HolderOf(O79_strength)))))) jump L_Say421;
		ParaContent();  print (PrintText) SC_619; 
	jump L_SayX378; .L_Say421;
		ParaContent();  print (PrintText) SC_620; 
	.L_Say422; .L_SayX378;
		ParaContent();  print (PrintText) SC_621; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_622;  new_line;ParaContent(); (PHR_783_r47 (O166_rabbit));ParaContent(); (PHR_834_r25 (O166_rabbit));ParaContent(); (PHR_834_r25 (O167_coyote));ParaContent(); (PHR_834_r25 (O203_advice));ParaContent(); (PHR_834_r25 (O190_down_to_business)); .L_Say423; .L_SayX379;
   rfalse;
];
! Request 20: phrase nothing -> nothing
! To say SD-tease:
[ PHR_1224_r20 ;
      ! phrase 1
      ! [1: say ~[if a random complete plan is staying the night]A life on the run, alone, work time in one town, jail time in another, no job, no skills, no family?' [otherwise]Trying to build a family out of nothing, spin futures from government handouts and dusty trailer parks, raising another generation of hopeless dropouts and messed-up losers?' [end if]The lizards scurry angrily, snapping and clawing at each other, with a sound like static and sand.[paragraph break]'It doesn't matter,' he says more calmly, as the lizards subside, 'since you have already made your choice. You cannot take back your actions. You cannot unmake the past.' The lizards around him tilt their head, edge forward cautiously, and he seems to grin. 'But I can~]
      say__p=1;
	if (~~(((( (Prop_85())  == O73_staying_the_night))))) jump L_Say424;
		ParaContent();  print (PrintText) SC_623; 
	jump L_SayX380; .L_Say424;
		ParaContent();  print (PrintText) SC_624; 
	.L_Say425; .L_SayX380;
		ParaContent();  print (PrintText) SC_625; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_626;  .L_Say426; .L_SayX381;
   rfalse;
];
! Request 21: phrase thing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To say remove ( obj - a thing ) other suggestion:
[ PHR_832_r21 
    t_0 ! Call parameter 'obj' = thing
    ;
      ! phrase 1
      ! [1: remove obj from the other-suggestions of the appropriate-suggestion-database , if present]
       LIST_OF_TY_RemoveValue(GProperty(OBJECT_TY, (PHR_836_r82 ()),p15_other_suggestions), t_0, 1); 
   rfalse;
];
! Request 22: phrase nothing -> nothing
! To say SD-business:
[ PHR_1211_r22 ;
      ! phrase 1
      ! [1: say ~[one of]and his voice shakes the earth and creaks the rusty joints of the tower[or]flicking his tongue in and out, slowly[or]his great slitted eye blinking slowly[or]sighing as the lizards in the desert writhe and twitch[cycling]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->19 =
	i7_soo_cyc(I7_ST_say_one_of-->19, 4);
	switch((I7_ST_say_one_of-->19)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_627; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_628; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_629; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_630; ParaContent();  }  .L_Say427; .L_SayX382;
   rfalse;
];
! Request 23: phrase thing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To say remove ( obj - a thing ) ask suggestion:
[ PHR_831_r23 
    t_0 ! Call parameter 'obj' = thing
    ;
      ! phrase 1
      ! [1: remove obj from the ask-suggestions of the appropriate-suggestion-database , if present]
       LIST_OF_TY_RemoveValue(GProperty(OBJECT_TY, (PHR_836_r82 ()),p13_ask_suggestions), t_0, 1); 
   rfalse;
];
! Request 24: phrase thing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To say remove ( obj - a thing ) tell suggestion:
[ PHR_830_r24 
    t_0 ! Call parameter 'obj' = thing
    ;
      ! phrase 1
      ! [1: remove obj from the tell-suggestions of the appropriate-suggestion-database , if present]
       LIST_OF_TY_RemoveValue(GProperty(OBJECT_TY, (PHR_836_r82 ()),p14_tell_suggestions), t_0, 1); 
   rfalse;
];
! Request 25: phrase thing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To say add ( obj - a thing ) ask suggestion:
[ PHR_834_r25 
    t_0 ! Call parameter 'obj' = thing
    ;
      ! phrase 1
      ! [1: add obj to the ask-suggestions of the appropriate-suggestion-database , if absent]
       LIST_OF_TY_InsertItem(GProperty(OBJECT_TY, (PHR_836_r82 ()),p13_ask_suggestions), t_0, 0, 0, 1); 
   rfalse;
];
! Request 26: phrase thing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To say add ( obj - a thing ) tell suggestion:
[ PHR_833_r26 
    t_0 ! Call parameter 'obj' = thing
    ;
      ! phrase 1
      ! [1: add obj to the tell-suggestions of the appropriate-suggestion-database , if absent]
       LIST_OF_TY_InsertItem(GProperty(OBJECT_TY, (PHR_836_r82 ()),p14_tell_suggestions), t_0, 0, 0, 1); 
   rfalse;
];
! Request 27: phrase thing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To say add ( obj - a thing ) other suggestion:
[ PHR_835_r27 
    t_0 ! Call parameter 'obj' = thing
    ;
      ! phrase 1
      ! [1: add obj to the other-suggestions of the appropriate-suggestion-database , if absent]
       LIST_OF_TY_InsertItem(GProperty(OBJECT_TY, (PHR_836_r82 ()),p15_other_suggestions), t_0, 0, 0, 1); 
   rfalse;
];
! Request 28: phrase nothing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To clear all topics:
[ PHR_850_r28 ;
      ! phrase 1
      ! [1: truncate ask-suggestions of current interlocutor to 0 entries]
       LIST_OF_TY_SetLength(GProperty(OBJECT_TY, (Global_Vars-->9),p13_ask_suggestions), 0, -1, 1); 
      ! phrase 2
      ! [2: truncate tell-suggestions of current interlocutor to 0 entries]
       LIST_OF_TY_SetLength(GProperty(OBJECT_TY, (Global_Vars-->9),p14_tell_suggestions), 0, -1, 1); 
      ! phrase 3
      ! [3: truncate other-suggestions of current interlocutor to 0 entries]
       LIST_OF_TY_SetLength(GProperty(OBJECT_TY, (Global_Vars-->9),p15_other_suggestions), 0, -1, 1); 
   rfalse;
];
! Request 29: phrase nothing -> nothing
! To say Coyote-business:
[ PHR_1188_r29 ;
      ! phrase 1
      ! [1: say ~[one of]smoke gusting from his lungs in clouds[or]scratching his stubble with the hand that holds the cigarette[or]itching underneath his jacket, slowly[or]the red tip of the cigarette glowing as he takes another drag[cycling]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->20 =
	i7_soo_cyc(I7_ST_say_one_of-->20, 4);
	switch((I7_ST_say_one_of-->20)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_631; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_632; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_633; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_634; ParaContent();  }  .L_Say428; .L_SayX383;
   rfalse;
];
! Request 30: phrase nothing -> nothing
! To say Sand-dancer talent summary:
[ PHR_1219_r30 ;
      ! phrase 1
      ! [1: if player holds strength , say ~You carry strength that ripped warmth from walls. ~]
       if (((player == HolderOf(O79_strength)))) { say__p=1;ParaContent();  print (PrintText) SC_635;  .L_Say429; .L_SayX384;  }
      ! phrase 2
      ! [2: if player holds courage , say ~You hold courage that earned you a tool for mending. ~]
       if (((player == HolderOf(O80_courage)))) { say__p=1;ParaContent();  print (PrintText) SC_636;  .L_Say430; .L_SayX385;  }
      ! phrase 3
      ! [3: if player holds luck , say ~You wear luck that filled your belly. ~]
       if (((player == HolderOf(O81_luck)))) { say__p=1;ParaContent();  print (PrintText) SC_637;  .L_Say431; .L_SayX386;  }
      ! phrase 4
      ! [4: if player holds scent , say ~You have scent that brought you liquid motion. ~]
       if (((player == HolderOf(O82_scent)))) { say__p=1;ParaContent();  print (PrintText) SC_638;  .L_Say432; .L_SayX387;  }
   rfalse;
];
! Request 31: phrase thing -> nothing
! From "Plurality" by Emily Short
! To mark ( target - a thing ) in output:
[ PHR_785_r31 
    t_0 ! Call parameter 'target' = thing
    ;
      ! phrase 1
      ! [1: if the target acts plural or target is the player , mark-future-plural]
       if ((((PHR_788_r48 (t_0)))) || (((t_0 == player)))) {  say__n = 1;   }
      ! phrase 2
      ! [2: otherwise mark-future-singular]
       else {  say__n = 29;   }
      ! phrase 3
      ! [3: now the prior named noun is the target]
       (Global_Vars-->12) = t_0; 
   rfalse;
];
! Request 32: phrase (object, number) -> nothing
! From the Standard Rules
! To set the/-- locale priority of ( O - an object ) to ( N - a number ):
[ PHR_72_r32 
    t_0 ! Call parameter 'O' = object
    t_1 ! Call parameter 'N' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: if o is a thing begin]
       if (((t_0 ofclass K2_thing)))  {
         ! phrase 2
         ! [2: if n <= 0 , now o is mentioned]
          if (((t_1 <= 0))) {  (Adj_69_t2_v65(t_0));   }
         ! phrase 3
         ! [3: if there is a notable-object of o in the table of locale priorities begin]
          if (( (ExistsTableLookUpCorr(T1_locale_priorities,105,105,t_0)) ))  {
            ! phrase 4
            ! [4: choose row with a notable-object of o in the table of locale priorities]
             ct_0 = T1_locale_priorities; ct_1 = TableRowCorr(ct_0, 105, t_0); 
            ! phrase 5
            ! [5: if n <= 0 , blank out the whole row]
             if (((t_1 <= 0))) {  TableBlankOutRow(ct_0, ct_1);   }
            ! phrase 6
            ! [6: otherwise now the locale description priority entry is n]
             else {  TableLookUpEntry(ct_0,106,ct_1,1,t_1);   }
            ! phrase 7
            ! [7: otherwise]
            } else {

            ! phrase 8
            ! [8: if n is greater than 0 begin]
             if (((t_1 > 0)))  {
               ! phrase 9
               ! [9: choose a blank row in the table of locale priorities]
                ct_0 = T1_locale_priorities; ct_1 = TableBlankRow(ct_0); 
               ! phrase 10
               ! [10: now the notable-object entry is o]
                TableLookUpEntry(ct_0,105,ct_1,1,t_0); 
               ! phrase 11
               ! [11: now the locale description priority entry is n]
                TableLookUpEntry(ct_0,106,ct_1,1,t_1); 
               ! phrase 12
               ! [12: end if]
               }

            ! phrase 13
            ! [13: end if]
            }

         ! phrase 14
         ! [14: end if]
         }

   rfalse;
];
! Request 33: phrase nothing -> direction
! To decide which direction is the bunny's path:
[ PHR_1135_r33 ;
      ! phrase 1
      ! [1: decide on west]
       return O17_west; 
   return O10_north;
];
! Request 34: phrase object -> nothing
! From the Standard Rules
! To describe locale for ( O - object ):
[ PHR_71_r34 
    t_0 ! Call parameter 'O' = object
    ;
      ! phrase 1
      ! [1: carry out the printing the locale description activity with o]
       CarryOutActivity(V29_printing_the_locale_desc, t_0); 
   rfalse;
];
! Request 35: phrase nothing -> nothing
! To describe sand-filled room:
[ PHR_1202_r35 ;
      ! phrase 1
      ! [1: say ~[one of]Waves of sand flow like water through the room, filling it higher and higher[or]Knee-deep sand fills the room, rising at a terrifying rate[or]The deluge of sand thunders in from every side, filling the room[at random].~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->21 =
	i7_soo_ran(I7_ST_say_one_of-->21, 3);
	switch((I7_ST_say_one_of-->21)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_639; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_640; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_641; ParaContent();  } ParaContent();  print (PrintText) SC_77;  new_line; .L_Say433; .L_SayX388;
   rfalse;
];
! Request 36: phrase nothing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To say nothing specific:
[ PHR_841_r36 ;
      ! phrase 1
      ! [1: say ~You have nothing specific in mind to discuss with [the printed name of the current interlocutor] right now.~]
      say__p=1;ParaContent();  print (PrintText) SC_642; ParaContent(); @push self;  print (PrintText) GProperty(OBJECT_TY, self=(Global_Vars-->9),short_name); @pull self; ParaContent();  print (PrintText) SC_643;  new_line; .L_Say434; .L_SayX389;
   rfalse;
];
! Request 37: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say it-them of ( item - a thing ):
[ PHR_814_r37 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~them~]
         say__p=1;ParaContent();  print (PrintText) SC_644;  .L_Say435; .L_SayX390;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_645;  .L_Say436; .L_SayX391;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~him~]
         say__p=1;ParaContent();  print (PrintText) SC_646;  .L_Say437; .L_SayX392;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~her~]
         say__p=1;ParaContent();  print (PrintText) SC_647;  .L_Say438; .L_SayX393;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~it~]
         say__p=1;ParaContent();  print (PrintText) SC_648;  .L_Say439; .L_SayX394;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 38: phrase nothing -> nothing
! From "Conditional Undo" by Jesse McGrew
! To decide whether undo is prevented:
[ PHR_915_r38 ;
      ! phrase 1
      ! [1: decide on the prevent undo flag]
       return (Global_Vars-->25); 
   rfalse;
];
! Request 39: phrase nothing -> text
! To decide which text is best course of action:
[ PHR_980_r39 ;
      ! phrase 1
      ! [1: if player is in truck begin]
       if (((O42_pickup_truck == ContainerOf(player))))  {
         ! phrase 2
         ! [2: decide on ~you could start by getting out of this truck~]
          return SC_649; 
         ! phrase 3
         ! [3: otherwise if crumbling concrete is unvisited]
          } else if ((((Adj_54_t1_v65(O68_crumbling_concrete))))) { 
         ! phrase 4
         ! [4: decide on ~you could start by looking around the area, seeing if maybe there's a phone or something~]
          return SC_650; 
         ! phrase 5
         ! [5: otherwise if pane of cracked glass is closed]
          } else if ((((Adj_75_t1_v65(O120_pane_of_cracked_glass))))) { 
         ! phrase 6
         ! [6: decide on ~you could break open a window to get inside that building~]
          return SC_651; 
         ! phrase 7
         ! [7: otherwise if flashlight is not handled]
          } else if (((~~(((Adj_64_t1_v65(O71_flashlight))))))) { 
         ! phrase 8
         ! [8: decide on ~you could try exploring the building by feel, even though it's so dark~]
          return SC_652; 
         ! phrase 9
         ! [9: otherwise if storage room is unvisited]
          } else if ((((Adj_54_t1_v65(O115_storage_room))))) { 
         ! phrase 10
         ! [10: decide on ~you should poke around the building more, see what else there is to find~]
          return SC_653; 
         ! phrase 11
         ! [11: otherwise if emergency lights are switched off]
          } else if ((((Adj_85_t1_v65(O131_emergency_lights))))) { 
         ! phrase 12
         ! [12: decide on ~you should switch on those emergency lights in the storage room so you can get a better look at things~]
          return SC_654; 
         ! phrase 13
         ! [13: otherwise if voice has not been visible]
          } else if (~~(TestSinglePastState(0, 7, false, 5))) { 
         ! phrase 14
         ! [14: decide on ~you maybe should see if you can call for help with that emergency radio in the break room~]
          return SC_655; 
         ! phrase 15
         ! [15: otherwise if open desert is unvisited]
          } else if ((((Adj_54_t1_v65(O149_open_desert))))) { 
         ! phrase 16
         ! [16: decide on ~you should see if the open desert has anything to offer~]
          return SC_656; 
         ! phrase 17
         ! [17: otherwise if burrow is unvisited]
          } else if ((((Adj_54_t1_v65(O182_burrow))))) { 
         ! phrase 18
         ! [18: decide on ~you should try to catch up with that weird shadow~]
          return SC_657; 
         ! phrase 19
         ! [19: otherwise if strength is held and emergency blanket is not handled]
          } else if (((((Adj_2_t1_v65(O79_strength))))) && (((~~(((Adj_64_t1_v65(O74_emergency_blanket)))))))) { 
         ! phrase 20
         ! [20: decide on ~you're strong enough now to bust open that mesh cage with the blanket inside~]
          return SC_658; 
         ! phrase 21
         ! [21: otherwise if courage is held and duct tape is not handled]
          } else if (((((Adj_2_t1_v65(O80_courage))))) && (((~~(((Adj_64_t1_v65(O76_roll_of_duct_tape)))))))) { 
         ! phrase 22
         ! [22: decide on ~you're brave enough to reach for that duct tape in the hole in the floor now~]
          return SC_659; 
         ! phrase 23
         ! [23: otherwise if duct tape is not handled]
          } else if (((~~(((Adj_64_t1_v65(O76_roll_of_duct_tape))))))) { 
         ! phrase 24
         ! [24: decide on ~you should investigate that hole in the floor of the staging area~]
          return SC_660; 
         ! phrase 25
         ! [25: otherwise if there is an in progress plan and temptation has not happened]
          } else if (((Prop_86())) && (( (scene_endings-->(Q343_temptation-1) == 0) ))) { 
         ! phrase 26
         ! [26: decide on ~you ought to head back to the desert and see if you can find that rabbit dude again~]
          return SC_661; 
         ! phrase 27
         ! [27: otherwise if luck is held and canned oranges are not handled]
          } else if (((((Adj_2_t1_v65(O81_luck))))) && (((~~(((Adj_64_t1_v65(O75_canned_oranges)))))))) { 
         ! phrase 28
         ! [28: decide on ~you're lucky enough now to find something to eat in the Storage room~]
          return SC_662; 
         ! phrase 29
         ! [29: otherwise if scent is held and control center is unvisited]
          } else if (((((Adj_2_t1_v65(O82_scent))))) && ((((Adj_54_t1_v65(O143_control_center)))))) { 
         ! phrase 30
         ! [30: decide on ~you should try to get up that ladder above the roof~]
          return SC_663; 
         ! phrase 31
         ! [31: otherwise if scent is held and gas can is not handled]
          } else if (((((Adj_2_t1_v65(O82_scent))))) && (((~~(((Adj_64_t1_v65(O60_gas_can)))))))) { 
         ! phrase 32
         ! [32: decide on ~you should try to sniff out that gas now~]
          return SC_664; 
         ! phrase 33
         ! [33: otherwise]
         } else {

         ! phrase 34
         ! [34: decide on ~~]
          return EMPTY_TEXT_VALUE; 
         ! phrase 35
         ! [35: end if]
         }

   return EMPTY_TEXT_VALUE;
];
! Request 40: phrase spirit animal -> nothing
! To decide whether ( trader - Sand-dancer ) needs more memories:
[ PHR_1230_r40 
    t_0 ! Call parameter 'trader' = spirit animal
    t_1 ! Local variable e.g. 'projected total' = number
    ;
      ! phrase 1
      ! [1: if the number of memories in emotional baggage is at least 2 and the second noun is freedom , decide yes]
       if (((( (Prop_87())  >= 2))) && (((second == O85_freedom)))) {  rtrue;   }
      ! phrase 2
      ! [2: let the projected total be the number of memories held by trader + 1]
       t_1 =  ( (Prop_88(,t_0)) +1) ; 
      ! phrase 3
      ! [3: if the projected total is less than the price of trader , decide yes]
       if (((t_1 < GProperty(OBJECT_TY, t_0,p21_price)))) {  rtrue;   }
      ! phrase 4
      ! [4: decide no]
       rfalse; 
   rfalse;
];
! Request 41: phrase person -> nothing
! To decide whether ( trader - a person ) needs more memories:
[ PHR_1105_r41 
    t_0 ! Call parameter 'trader' = person
    t_1 ! Local variable e.g. 'projected total' = number
    ;
      ! phrase 1
      ! [1: let the projected total be the number of memories held by trader + 1]
       t_1 =  ( (Prop_89(,t_0)) +1) ; 
      ! phrase 2
      ! [2: if the projected total is less than the price of trader , decide yes]
       if (((t_1 < GProperty(OBJECT_TY, t_0,p21_price)))) {  rtrue;   }
      ! phrase 3
      ! [3: decide no]
       rfalse; 
   rfalse;
];
! Request 42: phrase (library message id, rule) -> nothing
! From "Default Messages" by David Fisher
! To display ( id_ - a library message id ) / ( original_rule - a rule ):
[ PHR_904_r42 
    t_0 ! Call parameter 'id_' = library message id
    t_1 ! Call parameter 'original_rule' = rule
    ;
      ! phrase 1
      ! [1: change library-message-id to id_]
       (Global_Vars-->21) = t_0; 
      ! phrase 2
      ! [2: follow the print library message rule]
       FollowRulebook(R_889); 
      ! phrase 3
      ! [3: if libmsg_printed is 0 , follow original_rule]
       if ((((Global_Vars-->22) == 0))) {  FollowRulebook(t_1);   }
   rfalse;
];
! Request 43: phrase nothing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To show the/-- topic suggestions implicitly:
[ PHR_845_r43 ;
      ! phrase 1
      ! [1: now topic-request is implicit]
       (Global_Vars-->17) = Q22_implicit; 
      ! phrase 2
      ! [2: try listing suggested topics]
       TryAction(0, player, ##A93_listing_suggested_topics, 0, 0);; 
      ! phrase 3
      ! [3: now topic-request is explicit]
       (Global_Vars-->17) = Q23_explicit; 
   rfalse;
];
! Request 44: phrase nothing -> nothing
! From the Standard Rules
! To say no line break -- running on ( documented at phs_nolinebreak ):
[ PHR_335_r44 ;
      ! phrase 1
      ! [1: do nothing]
       ; 
   rfalse;
];
! Request 45: phrase object -> nothing
! From the Standard Rules
! To say contents of ( O - an object ) ( deprecated ) ( documented at phs_contents_dep ):
[ PHR_357_r45 
    t_0 ! Call parameter 'O' = object
    ;
      ! phrase 1
      ! [1: list the contents of o , as a sentence]
       WriteListFrom(child(t_0), 8); 
   rfalse;
];
! Request 46: phrase object -> nothing
! From the Standard Rules
! To say the contents of ( O - an object ) ( deprecated ) ( documented at phs_contents_dep ):
[ PHR_358_r46 
    t_0 ! Call parameter 'O' = object
    ;
      ! phrase 1
      ! [1: list the contents of o , as a sentence , using the definite article]
       WriteListFrom(child(t_0), 264); 
   rfalse;
];
! Request 47: phrase thing -> nothing
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To say make ( obj - a thing ) known:
[ PHR_783_r47 
    t_0 ! Call parameter 'obj' = thing
    ;
      ! phrase 1
      ! [1: now obj is familiar]
       (Adj_90_t2_v65(t_0)); 
   rfalse;
];
! Request 48: phrase object -> nothing
! From "Plurality" by Emily Short
! To decide whether ( item - an object ) acts plural:
[ PHR_788_r48 
    t_0 ! Call parameter 'item' = object
    ;
      ! phrase 1
      ! [1: if the item is plural-named or the item is ambiguously plural begin]
       if (((((Adj_45_t1_v65(t_0))))) || ((((Adj_92_t1_v65(t_0))))))  {
         ! phrase 2
         ! [2: yes]
          rtrue; 
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: no]
       rfalse; 
   rfalse;
];
! Request 49: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say is-are:
[ PHR_789_r49 ;
      ! phrase 1
      ! [1: say is-are of prior named noun]
      say__p=1;ParaContent(); (PHR_790_r50 ((Global_Vars-->12))); .L_Say440; .L_SayX395;
   rfalse;
];
! Request 50: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say is-are of ( item - a thing ):
[ PHR_790_r50 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: if prior named noun acts plural or the prior named noun is the player , say ~are~]
       if ((((PHR_788_r48 ((Global_Vars-->12))))) || ((((Global_Vars-->12) == player)))) { say__p=1;ParaContent();  print (PrintText) SC_262;  .L_Say441; .L_SayX396;  }
      ! phrase 3
      ! [3: otherwise say ~is~]
       else { say__p=1;ParaContent();  print (PrintText) SC_665;  .L_Say442; .L_SayX397;  }
   rfalse;
];
! Request 51: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say has-have:
[ PHR_791_r51 ;
      ! phrase 1
      ! [1: say has-have of prior named noun]
      say__p=1;ParaContent(); (PHR_792_r52 ((Global_Vars-->12))); .L_Say443; .L_SayX398;
   rfalse;
];
! Request 52: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say has-have of ( item - a thing ):
[ PHR_792_r52 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_788_r48 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~have~]
         say__p=1;ParaContent();  print (PrintText) SC_666;  .L_Say444; .L_SayX399;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~has~]
         say__p=1;ParaContent();  print (PrintText) SC_667;  .L_Say445; .L_SayX400;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 53: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say es:
[ PHR_795_r53 ;
      ! phrase 1
      ! [1: say es of prior named noun]
      say__p=1;ParaContent(); (PHR_796_r54 ((Global_Vars-->12))); .L_Say446; .L_SayX401;
   rfalse;
];
! Request 54: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say es of ( item - a thing ):
[ PHR_796_r54 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_788_r48 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~~]
         say__p=1;ParaContent();  print (PrintText) EMPTY_TEXT_VALUE;  .L_Say447; .L_SayX402;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~es~]
         say__p=1;ParaContent();  print (PrintText) SC_493;  .L_Say448; .L_SayX403;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 55: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say ies:
[ PHR_797_r55 ;
      ! phrase 1
      ! [1: say ies of prior named noun]
      say__p=1;ParaContent(); (PHR_798_r56 ((Global_Vars-->12))); .L_Say449; .L_SayX404;
   rfalse;
];
! Request 56: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say ies of ( item - a thing ):
[ PHR_798_r56 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_788_r48 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~y~]
         say__p=1;ParaContent();  print (PrintText) SC_668;  .L_Say450; .L_SayX405;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~ies~]
         say__p=1;ParaContent();  print (PrintText) SC_669;  .L_Say451; .L_SayX406;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 57: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say that-those:
[ PHR_799_r57 ;
      ! phrase 1
      ! [1: say that-those prior named noun]
      say__p=1;ParaContent(); (PHR_803_r61 ((Global_Vars-->12))); .L_Say452; .L_SayX407;
   rfalse;
];
! Request 58: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap that-those:
[ PHR_800_r58 ;
      ! phrase 1
      ! [1: say cap that-those prior named noun]
      say__p=1;ParaContent(); (PHR_802_r60 ((Global_Vars-->12))); .L_Say453; .L_SayX408;
   rfalse;
];
! Request 59: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say that-those of ( item - a thing ):
[ PHR_801_r59 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~those~]
         say__p=1;ParaContent();  print (PrintText) SC_670;  .L_Say454; .L_SayX409;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_645;  .L_Say455; .L_SayX410;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~he~]
         say__p=1;ParaContent();  print (PrintText) SC_671;  .L_Say456; .L_SayX411;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~she~]
         say__p=1;ParaContent();  print (PrintText) SC_672;  .L_Say457; .L_SayX412;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~that~]
         say__p=1;ParaContent();  print (PrintText) SC_673;  .L_Say458; .L_SayX413;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 60: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap that-those ( item - a thing ):
[ PHR_802_r60 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~Those~]
         say__p=1;ParaContent();  print (PrintText) SC_674;  .L_Say459; .L_SayX414;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_675;  .L_Say460; .L_SayX415;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_676;  .L_Say461; .L_SayX416;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_677;  .L_Say462; .L_SayX417;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~That~]
         say__p=1;ParaContent();  print (PrintText) SC_678;  .L_Say463; .L_SayX418;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 61: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say that-those ( item - a thing ):
[ PHR_803_r61 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~those~]
         say__p=1;ParaContent();  print (PrintText) SC_670;  .L_Say464; .L_SayX419;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_645;  .L_Say465; .L_SayX420;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~he~]
         say__p=1;ParaContent();  print (PrintText) SC_671;  .L_Say466; .L_SayX421;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~she~]
         say__p=1;ParaContent();  print (PrintText) SC_672;  .L_Say467; .L_SayX422;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~that~]
         say__p=1;ParaContent();  print (PrintText) SC_673;  .L_Say468; .L_SayX423;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 62: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap that-those of ( item - a thing ):
[ PHR_804_r62 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~Those~]
         say__p=1;ParaContent();  print (PrintText) SC_674;  .L_Say469; .L_SayX424;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_675;  .L_Say470; .L_SayX425;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_676;  .L_Say471; .L_SayX426;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_677;  .L_Say472; .L_SayX427;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~That~]
         say__p=1;ParaContent();  print (PrintText) SC_678;  .L_Say473; .L_SayX428;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 63: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say it-they:
[ PHR_805_r63 ;
      ! phrase 1
      ! [1: say it-they of prior named noun]
      say__p=1;ParaContent(); (PHR_806_r64 ((Global_Vars-->12))); .L_Say474; .L_SayX429;
   rfalse;
];
! Request 64: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say it-they of ( item - a thing ):
[ PHR_806_r64 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~they~]
         say__p=1;ParaContent();  print (PrintText) SC_679;  .L_Say475; .L_SayX430;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_645;  .L_Say476; .L_SayX431;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~he~]
         say__p=1;ParaContent();  print (PrintText) SC_671;  .L_Say477; .L_SayX432;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~she~]
         say__p=1;ParaContent();  print (PrintText) SC_672;  .L_Say478; .L_SayX433;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~it~]
         say__p=1;ParaContent();  print (PrintText) SC_648;  .L_Say479; .L_SayX434;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 65: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-they:
[ PHR_807_r65 ;
      ! phrase 1
      ! [1: say cap it-they of prior named noun]
      say__p=1;ParaContent(); (PHR_808_r66 ((Global_Vars-->12))); .L_Say480; .L_SayX435;
   rfalse;
];
! Request 66: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-they of ( item - a thing ):
[ PHR_808_r66 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~They~]
         say__p=1;ParaContent();  print (PrintText) SC_680;  .L_Say481; .L_SayX436;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_675;  .L_Say482; .L_SayX437;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_676;  .L_Say483; .L_SayX438;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_677;  .L_Say484; .L_SayX439;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~It~]
         say__p=1;ParaContent();  print (PrintText) SC_681;  .L_Say485; .L_SayX440;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 67: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say its-their:
[ PHR_809_r67 ;
      ! phrase 1
      ! [1: say its-their of prior named noun]
      say__p=1;ParaContent(); (PHR_810_r68 ((Global_Vars-->12))); .L_Say486; .L_SayX441;
   rfalse;
];
! Request 68: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say its-their of ( item - a thing ):
[ PHR_810_r68 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~their~]
         say__p=1;ParaContent();  print (PrintText) SC_682;  .L_Say487; .L_SayX442;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~your~]
         say__p=1;ParaContent();  print (PrintText) SC_683;  .L_Say488; .L_SayX443;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~his~]
         say__p=1;ParaContent();  print (PrintText) SC_684;  .L_Say489; .L_SayX444;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~her~]
         say__p=1;ParaContent();  print (PrintText) SC_647;  .L_Say490; .L_SayX445;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~its~]
         say__p=1;ParaContent();  print (PrintText) SC_685;  .L_Say491; .L_SayX446;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 69: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-their:
[ PHR_811_r69 ;
      ! phrase 1
      ! [1: say cap its-their of prior named noun]
      say__p=1;ParaContent(); (PHR_812_r70 ((Global_Vars-->12))); .L_Say492; .L_SayX447;
   rfalse;
];
! Request 70: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-their of ( item - a thing ):
[ PHR_812_r70 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~Their~]
         say__p=1;ParaContent();  print (PrintText) SC_686;  .L_Say493; .L_SayX448;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~Your~]
         say__p=1;ParaContent();  print (PrintText) SC_687;  .L_Say494; .L_SayX449;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~His~]
         say__p=1;ParaContent();  print (PrintText) SC_688;  .L_Say495; .L_SayX450;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Her~]
         say__p=1;ParaContent();  print (PrintText) SC_689;  .L_Say496; .L_SayX451;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~Its~]
         say__p=1;ParaContent();  print (PrintText) SC_690;  .L_Say497; .L_SayX452;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 71: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say it-them:
[ PHR_813_r71 ;
      ! phrase 1
      ! [1: say it-them of prior named noun]
      say__p=1;ParaContent(); (PHR_814_r37 ((Global_Vars-->12))); .L_Say498; .L_SayX453;
   rfalse;
];
! Request 72: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-them:
[ PHR_815_r72 ;
      ! phrase 1
      ! [1: say cap it-them of prior named noun]
      say__p=1;ParaContent(); (PHR_816_r73 ((Global_Vars-->12))); .L_Say499; .L_SayX454;
   rfalse;
];
! Request 73: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-them of ( item - a thing ):
[ PHR_816_r73 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~Them~]
         say__p=1;ParaContent();  print (PrintText) SC_691;  .L_Say500; .L_SayX455;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_675;  .L_Say501; .L_SayX456;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~Him~]
         say__p=1;ParaContent();  print (PrintText) SC_692;  .L_Say502; .L_SayX457;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Her~]
         say__p=1;ParaContent();  print (PrintText) SC_689;  .L_Say503; .L_SayX458;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~It~]
         say__p=1;ParaContent();  print (PrintText) SC_681;  .L_Say504; .L_SayX459;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 74: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say its-theirs:
[ PHR_817_r74 ;
      ! phrase 1
      ! [1: say its-theirs of prior named noun]
      say__p=1;ParaContent(); (PHR_818_r75 ((Global_Vars-->12))); .L_Say505; .L_SayX460;
   rfalse;
];
! Request 75: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say its-theirs of ( item - a thing ):
[ PHR_818_r75 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~theirs~]
         say__p=1;ParaContent();  print (PrintText) SC_693;  .L_Say506; .L_SayX461;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~yours~]
         say__p=1;ParaContent();  print (PrintText) SC_694;  .L_Say507; .L_SayX462;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~his~]
         say__p=1;ParaContent();  print (PrintText) SC_684;  .L_Say508; .L_SayX463;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~hers~]
         say__p=1;ParaContent();  print (PrintText) SC_695;  .L_Say509; .L_SayX464;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~its~]
         say__p=1;ParaContent();  print (PrintText) SC_685;  .L_Say510; .L_SayX465;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 76: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-theirs:
[ PHR_819_r76 ;
      ! phrase 1
      ! [1: say its-theirs of prior named noun]
      say__p=1;ParaContent(); (PHR_818_r75 ((Global_Vars-->12))); .L_Say511; .L_SayX466;
   rfalse;
];
! Request 77: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-theirs of ( item - a thing ):
[ PHR_820_r77 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_788_r48 (t_0))))  {
         ! phrase 4
         ! [4: say ~Theirs~]
         say__p=1;ParaContent();  print (PrintText) SC_696;  .L_Say512; .L_SayX467;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~Yours~]
         say__p=1;ParaContent();  print (PrintText) SC_697;  .L_Say513; .L_SayX468;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_82_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~His~]
         say__p=1;ParaContent();  print (PrintText) SC_688;  .L_Say514; .L_SayX469;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_81_t1_v65(t_0))))) && (((~~(((Adj_83_t1_v65(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Hers~]
         say__p=1;ParaContent();  print (PrintText) SC_698;  .L_Say515; .L_SayX470;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~Its~]
         say__p=1;ParaContent();  print (PrintText) SC_690;  .L_Say516; .L_SayX471;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 78: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say possessive:
[ PHR_821_r78 ;
      ! phrase 1
      ! [1: say possessive of prior named noun]
      say__p=1;ParaContent(); (PHR_822_r79 ((Global_Vars-->12))); .L_Say517; .L_SayX472;
   rfalse;
];
! Request 79: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say possessive of ( item - a thing ):
[ PHR_822_r79 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item is the player begin]
       if (((t_0 == player)))  {
         ! phrase 4
         ! [4: say ~your~]
         say__p=1;ParaContent();  print (PrintText) SC_683;  .L_Say518; .L_SayX473;
         ! phrase 5
         ! [5: otherwise if the item acts plural]
          } else if (((PHR_788_r48 (t_0)))) { 
         ! phrase 6
         ! [6: say ~[the item][apostrophe]~]
         say__p=1;ParaContent();  print (the) t_0; ParaContent();  print "'";  .L_Say519; .L_SayX474;
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~[the item][apostrophe]s~]
         say__p=1;ParaContent();  print (the) t_0; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_699;  .L_Say520; .L_SayX475;
         ! phrase 9
         ! [9: end if]
         }

   rfalse;
];
! Request 80: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap possessive:
[ PHR_823_r80 ;
      ! phrase 1
      ! [1: say cap possessive of prior named noun]
      say__p=1;ParaContent(); (PHR_824_r81 ((Global_Vars-->12))); .L_Say521; .L_SayX476;
   rfalse;
];
! Request 81: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap possessive of ( item - a thing ):
[ PHR_824_r81 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->12) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_785_r31 ((Global_Vars-->12)));
      ! phrase 3
      ! [3: if the item is the player begin]
       if (((t_0 == player)))  {
         ! phrase 4
         ! [4: say ~Your~]
         say__p=1;ParaContent();  print (PrintText) SC_687;  .L_Say522; .L_SayX477;
         ! phrase 5
         ! [5: otherwise if the item acts plural]
          } else if (((PHR_788_r48 (t_0)))) { 
         ! phrase 6
         ! [6: say ~[The item][apostrophe]~]
         say__p=1;ParaContent();  print (The) t_0; ParaContent();  print "'";  .L_Say523; .L_SayX478;
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~[The item][apostrophe]s~]
         say__p=1;ParaContent();  print (The) t_0; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_699;  .L_Say524; .L_SayX479;
         ! phrase 9
         ! [9: end if]
         }

   rfalse;
];
! Request 82: phrase nothing -> object
! From "Conversation Framework for Sand-dancer" by Aaron Reed
! To decide which object is the appropriate-suggestion-database:
[ PHR_836_r82 ;
      ! phrase 1
      ! [1: decide on the current interlocutor]
       return (Global_Vars-->9); 
   return nothing;
];
! Request 83: phrase (library message id, text) -> nothing
! From "Default Messages" by David Fisher
! To update the row with id of ( id_ - library message id ) to ( msg_ - text ):
[ PHR_888_r83 
    t_0 ! Call parameter 'id_' = library message id
    t_1 ! Call parameter 'msg_' = text
    t_2 ! Local variable e.g. 'n1' = number
    t_3 ! Local variable e.g. 'n2' = number
    t_4 ! Local variable e.g. 'mid_' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let n1 be 1]
       t_2 = 1; 
      ! phrase 2
      ! [2: let n2 be the number of rows in the table of library messages]
       t_3 =  TableRows(T3_library_messages) ; 
      ! phrase 3
      ! [3: while n1 <= n2 begin]
       while (((t_2 <= t_3)))  {
         ! phrase 4
         ! [4: let mid_ be n1 plus n2]
          t_4 =  (t_2+t_3) ; 
         ! phrase 5
         ! [5: change mid_ to mid_ divided by 2]
          t_4 =  (IntegerDivide(t_4,2)) ; 
         ! phrase 6
         ! [6: choose row mid_ in the table of library messages]
          ct_0 = T3_library_messages; ct_1 = t_4; 
         ! phrase 7
         ! [7: if the message id entry is id_ begin]
          if (((TableLookUpEntry(ct_0,107,ct_1) == t_0)))  {
            ! phrase 8
            ! [8: change the message text entry to msg_]
             TableLookUpEntry(ct_0,108,ct_1,1,t_1); 
            ! phrase 9
            ! [9: change n1 to n2 + 1]
             t_2 =  (t_3+1) ; 
            ! phrase 10
            ! [10: end if]
            }

         ! phrase 11
         ! [11: if the message id entry < id_ , change n1 to mid_ plus 1]
          if (((TableLookUpEntry(ct_0,107,ct_1) < t_0))) {  t_2 =  (t_4+1) ;   }
         ! phrase 12
         ! [12: if the message id entry > id_ , change n2 to mid_ minus 1]
          if (((TableLookUpEntry(ct_0,107,ct_1) > t_0))) {  t_3 =  (t_4-1) ;   }
         ! phrase 13
         ! [13: end while]
         }

   rfalse;
];
! Request 84: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say dot:
[ PHR_895_r84 ;
      ! phrase 1
      ! [1: say ~/unicode 46/~]
      say__p=1;ParaContent();  print (PrintText) SC_700;  .L_Say525; .L_SayX480;
   rfalse;
];
! Request 85: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say ExMark:
[ PHR_896_r85 ;
      ! phrase 1
      ! [1: say ~/unicode 33/~]
      say__p=1;ParaContent();  print (PrintText) SC_701;  .L_Say526; .L_SayX481;
   rfalse;
];
! Request 86: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say QMark:
[ PHR_897_r86 ;
      ! phrase 1
      ! [1: say ~/unicode 63/~]
      say__p=1;ParaContent();  print (PrintText) SC_702;  .L_Say527; .L_SayX482;
   rfalse;
];
! Request 87: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say LeftSqBr:
[ PHR_898_r87 ;
      ! phrase 1
      ! [1: say ~/unicode 91/~]
      say__p=1;ParaContent();  print (PrintText) SC_703;  .L_Say528; .L_SayX483;
   rfalse;
];
! Request 88: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say RightSqBr:
[ PHR_899_r88 ;
      ! phrase 1
      ! [1: say ~/unicode 93/~]
      say__p=1;ParaContent();  print (PrintText) SC_704;  .L_Say529; .L_SayX484;
   rfalse;
];
! Request 89: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say /n:
[ PHR_900_r89 ;
      ! phrase 1
      ! [1: say line break]
      say__p=1;ParaContent();  new_line;  .L_Say530; .L_SayX485;
   rfalse;
];
! Request 90: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say /p:
[ PHR_901_r90 ;
      ! phrase 1
      ! [1: say paragraph break]
      say__p=1;ParaContent();  DivideParagraphPoint(); new_line;  .L_Say531; .L_SayX486;
   rfalse;
];
! Request 91: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say /r:
[ PHR_902_r91 ;
      ! phrase 1
      ! [1: say run paragraph on]
      say__p=1;ParaContent();  RunParagraphOn();  .L_Say532; .L_SayX487;
   rfalse;
];
! Request 92: phrase nothing -> nothing
! To say bro:
[ PHR_909_r92 ;
      ! phrase 1
      ! [1: say ~[one of]bro[or]man[or]dude[or]amigo[or]brohim[as decreasingly likely outcomes]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->22 =
	i7_soo_tap(I7_ST_say_one_of-->22, 5);
	switch((I7_ST_say_one_of-->22)%(5+1)-1) {
		0: ParaContent();  print (PrintText) SC_705; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_706; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_707; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_708; ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_709; ParaContent();  }  .L_Say533; .L_SayX488;
   rfalse;
];
! Request 93: phrase nothing -> nothing
! To say explain lighting conditions:
[ PHR_986_r93 ;
      ! phrase 1
      ! [1: say ~The [desert sand] and clumps of pale [sagebrush] are all [if lit by headlights]your dimming [headlights] pick out before barely reaching[otherwise if lit by flashlight]your flashlight picks out, other than[otherwise]you can see in the glow of[end if] [the concrete building] to the north~]
      say__p=1;ParaContent();  print (PrintText) SC_89; ParaContent();  print (PrintShortName) O91_desert_sand; ParaContent();  print (PrintText) SC_710; ParaContent();  print (PrintShortName) O92_sagebrush; ParaContent();  print (PrintText) SC_711; 
	if (~~(((((Adj_38_t1_v65(self))))))) jump L_Say534;
		ParaContent();  print (PrintText) SC_712; ParaContent();  print (PrintShortName) O95_headlights; ParaContent();  print (PrintText) SC_713; ParaContent(); 
	jump L_SayX489; .L_Say534; if (~~(((((Adj_39_t1_v65(self))))))) jump L_Say535;
		ParaContent();  print (PrintText) SC_714; 
	jump L_SayX489; .L_Say535;
		ParaContent();  print (PrintText) SC_715; 
	.L_Say536; .L_SayX489;
		ParaContent();  print (PrintText) SC_166; ParaContent();  print (the) O93_concrete_building; ParaContent();  print (PrintText) SC_716;  .L_Say537; .L_SayX490;
   rfalse;
];
! Request 94: phrase nothing -> nothing
! To say radio left off:
[ PHR_1114_r94 ;
      ! phrase 1
      ! [1: if radio was switched off , say ~[first time], which is weird because you're damn sure you turned it off[only]~]
       if (TestSinglePastState(1, 8, false, 1)) { say__p=1;ParaContent();  
	if ((I7_ST_say_first_time-->3)++ == 0) {
		ParaContent();  print (PrintText) SC_717; ParaContent();  }  .L_Say538; .L_SayX491;  }
   rfalse;
];
! Request 95: phrase nothing -> nothing
! To decide whether the shadow appears:
[ PHR_1127_r95 ;
      ! phrase 1
      ! [1: if location is the open desert for at least six turns , decide on whether or not a random chance of 1 in 4 succeeds]
       if (TestSinglePastState(0, 9, false, 2) >= 6 ) {  return  ((( (GenerateRandomNumber(1, 4) <= 1) ))) ;   }
      ! phrase 2
      ! [2: if location is roof , decide no]
       if (((real_location == O89_roof))) {  rfalse;   }
      ! phrase 3
      ! [3: if location is in around the tower , decide on whether or not a random chance of 1 in 3 succeeds]
       if (((TestRegionalContainment(real_location,O87_around_the_tower)))) {  return  ((( (GenerateRandomNumber(1, 3) <= 1) ))) ;   }
      ! phrase 4
      ! [4: decide no]
       rfalse; 
   rfalse;
];
! Request 96: phrase nothing -> direction
! To decide which direction is the bunny's path:
[ PHR_1130_r96 ;
      ! phrase 1
      ! [1: decide on a random cardinal direction]
       return CheckKindReturned( (Prop_90()) ,K3_direction); 
   return O10_north;
];
[ LTR_0;
    if (inventory_stage == 1) {
        c_style = c_style | (ENGLISH_BIT + NOARTICLE_BIT);
        c_style = c_style &~ (NEWLINE_BIT + INDENT_BIT);
    }
    rfalse;
];
[ LTR_1;
    if (inventory_stage == 1) {
        c_style = c_style | (ENGLISH_BIT + NOARTICLE_BIT);
        c_style = c_style &~ (NEWLINE_BIT + INDENT_BIT);
    }
    rfalse;
];
[ text_routine_0;
say__p=1;
	if (~~(((((Adj_74_t1_v65(noun))))))) jump L_Say539;
		ParaContent();  print (PrintText) SC_718; 
	jump L_SayX492; .L_Say539;
		ParaContent();  print (PrintText) SC_719;  .L_Say540; .L_SayX492;
    rtrue;
];

[ text_routine_1;
say__p=1;
	if (~~(((((Adj_2_t1_v65(self))))))) jump L_Say541;
		ParaContent();  print (PrintText) SC_720; 
	jump L_SayX493; .L_Say541;
		ParaContent();  print (PrintText) SC_721;  .L_Say542; .L_SayX493;
    rtrue;
];

[ text_routine_2;
say__p=1;ParaContent();  I7_ST_say_one_of-->23 =
	i7_soo_shu(I7_ST_say_one_of-->23, 4);
	switch((I7_ST_say_one_of-->23)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_722; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K150_desert_flotsam) && ((Adj_3_t1_v65(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+ISARE_BIT);
		@pull subst__v; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_723; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K150_desert_flotsam) && ((Adj_3_t1_v65(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_724; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K150_desert_flotsam) && ((Adj_3_t1_v65(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+NOARTICLE_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_725; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_726; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K150_desert_flotsam) && ((Adj_3_t1_v65(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_727; ParaContent();  } ParaContent();  print (PrintText) SC_77;  .L_Say543; .L_SayX494;
    rtrue;
];

[ text_routine_3;
say__p=1;ParaContent(); (Resolver_11((Global_Vars-->9),"source", 1));
	if (~~((((PHR_788_r48 ((Global_Vars-->9))))))) jump L_Say544;
		ParaContent();  print (PrintText) SC_728; 
	jump L_SayX495; .L_Say544;
		ParaContent();  print (PrintText) SC_729; 
	.L_Say545; .L_SayX495;
		 .L_Say546; .L_SayX496;
    rtrue;
];

[ text_routine_4;
say__p=1;ParaContent();  print (PrintText) SC_730; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_731;  .L_Say547; .L_SayX497;
    rtrue;
];

[ text_routine_5;
say__p=1;
	if (~~((((O42_pickup_truck == ContainerOf(player)))))) jump L_Say548;
		ParaContent();  print (PrintText) SC_732; ParaContent();  print (PrintShortName) O98_tall_saguaro; ParaContent();  print (PrintText) SC_733; ParaContent();  print (the) O94_windshield; ParaContent();  print (PrintText) SC_734; ParaContent();  print (PrintShortName) O91_desert_sand; ParaContent();  print (PrintText) SC_735; ParaContent();  
	if ((I7_ST_say_first_time-->4)++ == 0) {
		ParaContent();  print (PrintText) SC_736; ParaContent();  } ParaContent();  print (PrintText) SC_77; 
	jump L_SayX498; .L_Say548;
		ParaContent();  print (PrintText) SC_89; ParaContent();  print (PrintShortName) O90_tire_tracks; ParaContent();  print (PrintText) SC_737; ParaContent(); (PHR_986_r93 ());ParaContent();  print (PrintText) SC_77;  .L_Say549; .L_SayX498;
    rtrue;
];

[ text_routine_6;
say__p=1;
	if (~~((((O42_pickup_truck == ContainerOf(player)))))) jump L_Say550;
		ParaContent();  print (PrintText) SC_738; 
	jump L_SayX499; .L_Say550;
		ParaContent();  
	if ((I7_ST_say_first_time-->5)++ == 0) {
		ParaContent();  print (PrintText) SC_739; ParaContent();  print (PrintShortName) O96_fuel_line; ParaContent();  print (PrintText) SC_740; ParaContent();  } ParaContent();  print (PrintText) SC_741; 
	.L_Say551; .L_SayX499;
		ParaContent();  print (PrintText) SC_77;  .L_Say552; .L_SayX500;
    rtrue;
];

[ text_routine_7;
say__p=1;ParaContent();  print (PrintText) SC_742; ParaContent();  print (PrintShortName) O42_pickup_truck; ParaContent();  print (PrintText) SC_743; ParaContent();  print (a) O98_tall_saguaro; ParaContent();  print (PrintText) SC_475; ParaContent();  print (PrintShortName) O97_whiffs_of_evaporating_ga; ParaContent();  print (PrintText) SC_744;  .L_Say553; .L_SayX501;
    rtrue;
];

[ text_routine_8;
say__p=1;
	if (~~(((((Adj_75_t1_v65(self))))))) jump L_Say554;
		ParaContent();  print (PrintText) SC_745; 
	.L_Say554; .L_SayX502;
		ParaContent();  print (PrintText) SC_746;  .L_Say555; .L_SayX503;
    rtrue;
];

[ text_routine_9;
say__p=1;
	if (~~(((((Adj_75_t1_v65(self))))))) jump L_Say556;
		ParaContent();  print (PrintText) SC_747; 
	jump L_SayX504; .L_Say556;
		ParaContent();  print (PrintText) SC_748; ParaContent();  print (a) O62_ultrasound_of_ocean_s_ba; ParaContent();  print (PrintText) SC_77;  .L_Say557; .L_SayX504;
    rtrue;
];

[ text_routine_10;
say__p=1;ParaContent();  print (PrintText) SC_749; 
	if (~~((((GProperty(OBJECT_TY, O39_pack_of_cigarettes,p17_count) >= 1))))) jump L_Say558;
		ParaContent();  print (PrintText) SC_750; ParaContent(); @push self;  print (number) say__n=(GProperty(OBJECT_TY, self=O39_pack_of_cigarettes,p17_count)); @pull self; ParaContent();  print (PrintText) SC_532; 
	jump L_SayX505; .L_Say558;
		ParaContent();  print (PrintText) SC_751; 
	.L_Say559; .L_SayX505;
		ParaContent();  print (PrintText) SC_77;  .L_Say560; .L_SayX506;
    rtrue;
];

[ text_routine_11;
say__p=1;ParaContent();  I7_ST_say_one_of-->24 =
	i7_soo_stop(I7_ST_say_one_of-->24, 3);
	switch((I7_ST_say_one_of-->24)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_752; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_753; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_754; ParaContent();  } ParaContent();  print (PrintText) SC_77;  .L_Say561; .L_SayX507;
    rtrue;
];

[ text_routine_12;
say__p=1;
	if (~~((((O42_pickup_truck == ContainerOf(player)))))) jump L_Say562;
		ParaContent();  print (PrintText) SC_755; ParaContent();  print (PrintShortName) O98_tall_saguaro; 
	jump L_SayX508; .L_Say562;
		ParaContent();  print (PrintText) SC_756; 
	.L_Say563; .L_SayX508;
		ParaContent();  print (PrintText) SC_77;  .L_Say564; .L_SayX509;
    rtrue;
];

[ text_routine_13;
say__p=1;ParaContent();  print (PrintText) SC_757; ParaContent();  print (PrintShortName) O90_tire_tracks; ParaContent();  print (PrintText) SC_758; ParaContent();  print (PrintShortName) O91_desert_sand; ParaContent();  print (PrintText) SC_759;  .L_Say565; .L_SayX510;
    rtrue;
];

[ text_routine_14;
say__p=1;ParaContent();  print (PrintText) SC_760; ParaContent();  print (PrintShortName) O93_concrete_building; ParaContent();  print (PrintText) SC_761; ParaContent();  print (the) O105_huge_electrical_tower; ParaContent();  print (PrintText) SC_762; 
	if (~~(((((Adj_38_t1_v65(self))))))) jump L_Say566;
		ParaContent();  print (PrintText) SC_98; ParaContent();  print (a) O120_pane_of_cracked_glass; ParaContent();  print (PrintText) SC_763; ParaContent(); 
	jump L_SayX511; .L_Say566; if (~~(((((Adj_39_t1_v65(self))))))) jump L_Say567;
		ParaContent();  print (PrintText) SC_764; 
	.L_Say567; .L_SayX511;
		ParaContent();  print (PrintText) SC_765; ParaContent();  print (PrintShortName) O91_desert_sand; ParaContent();  print (PrintText) SC_766; ParaContent();  print (a) O116_boarded_up_door; ParaContent();  print (PrintText) SC_767;  .L_Say568; .L_SayX512;
    rtrue;
];

[ text_routine_15;
say__p=1;
	if (~~(((((~~(((Adj_39_t1_v65(real_location))))))) && (((~~(((Adj_37_t1_v65(real_location)))))))))) jump L_Say569;
		ParaContent();  print (PrintText) SC_768; ParaContent();  print (PrintShortName) O121_shafts_of_light; ParaContent();  print (PrintText) SC_769; 
	jump L_SayX513; .L_Say569;
		ParaContent();  print (PrintText) SC_770; ParaContent();  print (PrintShortName) O122_holes_in_the_roof; ParaContent();  print (PrintText) SC_771; ParaContent();  print (PrintShortName) O91_desert_sand; ParaContent();  print (PrintText) SC_772; ParaContent();  print (PrintShortName) O123_patches_of_mold; ParaContent();  print (PrintText) SC_140; ParaContent();  print (The) O116_boarded_up_door; ParaContent();  print (PrintText) SC_773; 
	.L_Say570; .L_SayX513;
		ParaContent();  print (PrintText) SC_77;  .L_Say571; .L_SayX514;
    rtrue;
];

[ text_routine_16;
say__p=1;ParaContent();  print (PrintText) SC_774; 
	if (~~((((O124_hole_in_the_floor == ContainerOf(O76_roll_of_duct_tape)))))) jump L_Say572;
		ParaContent();  print (PrintText) SC_775; ParaContent();  print (PrintShortName) O125_cobwebs; 
	.L_Say572; .L_SayX515;
		ParaContent();  print (PrintText) SC_77;  .L_Say573; .L_SayX516;
    rtrue;
];

[ text_routine_17;
say__p=1;ParaContent();  print (PrintText) SC_776; ParaContent();  print (the) O93_concrete_building; ParaContent();  print (PrintText) SC_777; ParaContent();  print (a) O128_dust_covered_window; ParaContent();  print (PrintText) SC_445; ParaContent();  print (a) O100_steel_girder; ParaContent();  print (PrintText) SC_778; ParaContent();  print (the) O91_desert_sand; 
	if (~~(((((Adj_39_t1_v65(self))))))) jump L_Say574;
		ParaContent();  print (PrintText) SC_779; ParaContent(); 
	jump L_SayX517; .L_Say574; if (~~(((((Adj_38_t1_v65(self))))))) jump L_Say575;
		ParaContent();  print (PrintText) SC_780; ParaContent();  print (the) O105_huge_electrical_tower; ParaContent();  print (PrintText) SC_781; 
	jump L_SayX517; .L_Say575;
		ParaContent();  print (PrintText) SC_782; ParaContent();  print (a) O99_red_warning_light; ParaContent();  print (PrintText) SC_783; 
	.L_Say576; .L_SayX517;
		ParaContent();  print (PrintText) SC_140; ParaContent();  CIndefArt(O103_tumbleweed); ParaContent();  print (PrintText) SC_784; ParaContent();  print (PrintShortName) O101_scrawny_weeds; ParaContent();  print (PrintText) SC_772; ParaContent();  print (PrintShortName) O139_crumbling_trash; ParaContent();  print (PrintText) SC_785; 
	if (~~(((((Adj_37_t1_v65(self))))))) jump L_Say577;
		ParaContent();  print (PrintText) SC_786; 
	.L_Say577; .L_SayX518;
		ParaContent();  print (PrintText) SC_787;  .L_Say578; .L_SayX519;
    rtrue;
];

[ text_routine_18;
say__p=1;ParaContent();  print (PrintText) SC_788; ParaContent();  print (PrintShortName) O93_concrete_building; ParaContent();  print (PrintText) SC_789; ParaContent();  print (PrintShortName) O141_tiny_frosted_window; ParaContent();  print (PrintText) SC_790; ParaContent();  print (PrintShortName) O106_yellowing_weeds; ParaContent();  print (PrintText) SC_791; ParaContent();  print (a) O109_leaking_pipe; ParaContent();  print (PrintText) SC_792; ParaContent();  print (a) O108_collection_of_rusted_ba; ParaContent();  print (PrintText) SC_793; ParaContent();  print (PrintShortName) O107_scattered_newspapers; ParaContent();  print (PrintText) SC_794;  .L_Say579; .L_SayX520;
    rtrue;
];

[ text_routine_19;
say__p=1;
	if (~~(((( (Prop_91())  >= 1))))) jump L_Say580;
		ParaContent();  print (PrintText) SC_795; ParaContent();  print (PrintShortName) O110_overturned_barrel; ParaContent();  print (PrintText) SC_166; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (O110_overturned_barrel == SupporterOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+ISARE_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_77; 
	jump L_SayX521; .L_Say580;
		ParaContent();  print (PrintText) SC_796; ParaContent();  print (PrintShortName) O110_overturned_barrel; ParaContent();  print (PrintText) SC_797; 
	.L_Say581; .L_SayX521;
		 .L_Say582; .L_SayX522;
    rtrue;
];

[ text_routine_20;
say__p=1;ParaContent();  print (PrintText) SC_798; ParaContent();  print (the) O105_huge_electrical_tower; ParaContent();  print (PrintText) SC_799;  .L_Say583; .L_SayX523;
    rtrue;
];

[ text_routine_21;
say__p=1;ParaContent();  CIndefArt(O144_huge_metal_barrel); ParaContent();  print (PrintText) SC_800; 
	if (~~(((((Adj_102_t1_v65(self))))))) jump L_Say584;
		ParaContent();  print (PrintText) SC_801; 
	jump L_SayX524; .L_Say584;
		ParaContent();  print (PrintText) SC_802; 
	.L_Say585; .L_SayX524;
		ParaContent();  print (PrintText) SC_77;  .L_Say586; .L_SayX525;
    rtrue;
];

[ text_routine_22;
say__p=1;
	if (~~(((((Adj_39_t1_v65(real_location))))))) jump L_Say587;
		ParaContent();  print (PrintText) SC_803; 
	jump L_SayX526; .L_Say587;
		ParaContent();  print (PrintText) SC_804; 
	.L_Say588; .L_SayX526;
		ParaContent();  print (PrintText) SC_805; ParaContent();  print (a) O128_dust_covered_window; ParaContent();  print (PrintText) SC_806;  .L_Say589; .L_SayX527;
    rtrue;
];

[ text_routine_23;
say__p=1;ParaContent();  print (PrintText) SC_807; ParaContent();  print (T45_frequency) (Global_Vars-->27); ParaContent();  print (PrintText) SC_77;  .L_Say590; .L_SayX528;
    rtrue;
];

[ text_routine_24;
say__p=1;ParaContent();  print (PrintText) SC_808; ParaContent();  print (PrintShortName) O141_tiny_frosted_window; ParaContent();  print (PrintText) SC_809; ParaContent();  print (PrintShortName) O138_rotting_picnic_tables; ParaContent();  print (PrintText) SC_810; ParaContent();  print (PrintShortName) O117_layers_of_sand; ParaContent();  print (PrintText) SC_772; ParaContent();  print (PrintShortName) O139_crumbling_trash; ParaContent();  print (PrintText) SC_811;  .L_Say591; .L_SayX529;
    rtrue;
];

[ text_routine_25;
say__p=1;ParaContent();  print (PrintText) SC_812; ParaContent(); @push self;  print (T45_frequency) GProperty(OBJECT_TY, self=O118_emergency_radio,p18_frequency_tuned_to); @pull self; ParaContent();  print (PrintText) SC_643;  .L_Say592; .L_SayX530;
    rtrue;
];

[ text_routine_26;
say__p=1;ParaContent();  print (PrintText) SC_813; ParaContent();  print (PrintShortName) O132_bare_metal_shelves; ParaContent();  print (PrintText) SC_445; 
	if (~~(((((Adj_39_t1_v65(real_location))))))) jump L_Say593;
		ParaContent();  print (PrintText) SC_814; 
	jump L_SayX531; .L_Say593;
		ParaContent();  print (PrintText) SC_815; 
	.L_Say594; .L_SayX531;
		ParaContent();  print (PrintText) SC_816; ParaContent();  print (PrintShortName) O133_utility_ladder; ParaContent();  print (PrintText) SC_817; ParaContent();  print (a) O134_broken_skylight; ParaContent();  print (PrintText) SC_818;  .L_Say595; .L_SayX532;
    rtrue;
];

[ text_routine_27;
say__p=1;ParaContent();  print (PrintText) SC_819; 
	if (~~(((((Adj_84_t1_v65(O131_emergency_lights))))))) jump L_Say596;
		ParaContent();  print (PrintText) SC_164; 
	jump L_SayX533; .L_Say596;
		ParaContent();  print (PrintText) SC_582; 
	.L_Say597; .L_SayX533;
		ParaContent();  print (PrintText) SC_77;  .L_Say598; .L_SayX534;
    rtrue;
];

[ text_routine_28;
say__p=1;
	if (~~(((((Adj_84_t1_v65(O71_flashlight))))))) jump L_Say599;
		ParaContent();  print (PrintText) SC_820; 
	jump L_SayX535; .L_Say599;
		ParaContent();  print (PrintText) SC_821;  .L_Say600; .L_SayX535;
    rtrue;
];

[ text_routine_29;
say__p=1;ParaContent();  print (PrintText) SC_822; ParaContent();  print (PrintShortName) O146_piles_of_trash; ParaContent();  print (PrintText) SC_823;  .L_Say601; .L_SayX536;
    rtrue;
];

[ text_routine_30;
say__p=1;
	if (~~((((player == HolderOf(O82_scent)))))) jump L_Say602;
		ParaContent();  print (PrintText) SC_824; ParaContent();  print (PrintShortName) O148_sheet_of_corrugated_met; 
	jump L_SayX537; .L_Say602;
		ParaContent();  print (PrintText) SC_825; 
	.L_Say603; .L_SayX537;
		ParaContent();  print (PrintText) SC_77;  .L_Say604; .L_SayX538;
    rtrue;
];

[ text_routine_31;
say__p=1;ParaContent();  I7_ST_say_one_of-->25 =
	i7_soo_shu(I7_ST_say_one_of-->25, 4);
	switch((I7_ST_say_one_of-->25)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_826; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_827; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_828; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_829; ParaContent();  } ParaContent();  print (PrintText) SC_830; ParaContent();  I7_ST_say_one_of-->26 =
	i7_soo_shu(I7_ST_say_one_of-->26, 5);
	switch((I7_ST_say_one_of-->26)%(5+1)-1) {
		0: ParaContent();  print (PrintText) SC_831; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_832; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_833; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_834; ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_835; ParaContent();  } ParaContent();  print (PrintText) SC_77;  .L_Say605; .L_SayX539;
    rtrue;
];

[ text_routine_32;
say__p=1;ParaContent();  print (PrintText) SC_836; ParaContent();  print (PrintShortName) O179_faded_denim_jacket; ParaContent();  print (PrintText) SC_837; ParaContent();  print (PrintShortName) O178_sunglasses; ParaContent();  print (PrintText) SC_838; ParaContent();  print (PrintShortName) O177_cigarette; ParaContent();  print (PrintText) SC_839;  .L_Say606; .L_SayX540;
    rtrue;
];

[ text_routine_33;
say__p=1;
	if (~~(((((Adj_104_t1_v65(O168_sand_dancer))))))) jump L_Say607;
		ParaContent();  print (PrintText) SC_840; 
	jump L_SayX541; .L_Say607;
		ParaContent();  print (PrintText) SC_841; 
	.L_Say608; .L_SayX541;
		ParaContent();  print (PrintText) SC_842;  .L_Say609; .L_SayX542;
    rtrue;
];

[ text_routine_34;
say__p=1;ParaContent();  print (PrintText) SC_843; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && ((Adj_3_t1_v65(subst__v))) && (~~((Adj_2_t1_v65(subst__v)))) && ((subst__v.p79_objective) ofclass K72_plan)))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+DEFART_BIT);
		@pull subst__v;  .L_Say610; .L_SayX543;
    rtrue;
];

[ text_routine_35;
say__p=1;ParaContent();  I7_ST_say_one_of-->27 =
	i7_soo_shu(I7_ST_say_one_of-->27, 3);
	switch((I7_ST_say_one_of-->27)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_845; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_846; ParaContent();  } ParaContent();  print (PrintText) SC_847; ParaContent();  I7_ST_say_one_of-->28 =
	i7_soo_shu(I7_ST_say_one_of-->28, 3);
	switch((I7_ST_say_one_of-->28)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_848; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_849; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_850; ParaContent();  } ParaContent();  print (PrintText) SC_851; ParaContent(); @push self;  print (PrintShortName) GProperty(OBJECT_TY, self=O181_darting_shadow,p22_path); @pull self; ParaContent();  print (PrintText) SC_77;  .L_Say611; .L_SayX544;
    rtrue;
];

[ text_routine_36;
say__p=1;ParaContent();  I7_ST_say_one_of-->29 =
	i7_soo_stop(I7_ST_say_one_of-->29, 2);
	switch((I7_ST_say_one_of-->29)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_852; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_853; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_854; ParaContent();  }  .L_Say612; .L_SayX545;
    rtrue;
];

[ text_routine_37;
say__p=1;ParaContent();  print (PrintText) SC_855; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_856;  .L_Say613; .L_SayX546;
    rtrue;
];

[ text_routine_38;
say__p=1;ParaContent();  print (PrintText) SC_857; ParaContent();  print (PrintShortName) O206_thousands_of_lizards; ParaContent();  print (PrintText) SC_858; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_859; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_860;  .L_Say614; .L_SayX547;
    rtrue;
];

[ text_routine_39;
say__p=1;ParaContent();  I7_ST_say_one_of-->30 =
	i7_soo_stop(I7_ST_say_one_of-->30, 2);
	switch((I7_ST_say_one_of-->30)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_861; 
	if (~~(((((Adj_84_t1_v65(O118_emergency_radio))))))) jump L_Say615;
		ParaContent();  print (PrintText) SC_862; 
	.L_Say615; .L_SayX548;
		ParaContent();  print (PrintText) SC_77; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_863; ParaContent();  }  .L_Say616; .L_SayX549;
    rtrue;
];

[ text_routine_40;
say__p=1;ParaContent();  print (PrintText) SC_864; ParaContent(); (PHR_909_r92 ());ParaContent();  print (PrintText) SC_77; ParaContent(); (PHR_900_r89 ()); .L_Say617; .L_SayX550;
    rtrue;
];

[ text_routine_41;
say__p=1;ParaContent();  print (PrintText) SC_865; ParaContent(); (PHR_900_r89 ()); .L_Say618; .L_SayX551;
    rtrue;
];

[ text_routine_42;
say__p=1;ParaContent();  I7_ST_say_one_of-->31 =
	i7_soo_stop(I7_ST_say_one_of-->31, 2);
	switch((I7_ST_say_one_of-->31)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_866; ParaContent(); (PHR_909_r92 ());ParaContent();  print (PrintText) SC_77; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_867; ParaContent();  } ParaContent(); (PHR_900_r89 ()); .L_Say619; .L_SayX552;
    rtrue;
];

[ text_routine_43;
say__p=1;ParaContent();  print (PrintText) SC_868; ParaContent(); (PHR_900_r89 ()); .L_Say620; .L_SayX553;
    rtrue;
];

[ text_routine_44;
say__p=1;ParaContent();  print (PrintText) SC_869; ParaContent(); (PHR_909_r92 ());ParaContent();  print (PrintText) SC_870; ParaContent(); (PHR_900_r89 ()); .L_Say621; .L_SayX554;
    rtrue;
];

[ text_routine_45;
say__p=1;ParaContent();  print (PrintText) SC_871; ParaContent(); (PHR_909_r92 ());ParaContent();  print (PrintText) SC_77; ParaContent(); (PHR_900_r89 ()); .L_Say622; .L_SayX555;
    rtrue;
];

[ text_routine_46;
say__p=1;ParaContent();  I7_ST_say_one_of-->32 =
	i7_soo_ran(I7_ST_say_one_of-->32, 3);
	switch((I7_ST_say_one_of-->32)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_872; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_873; 
	if (~~((((PHR_788_r48 (noun)))))) jump L_Say623;
		ParaContent();  print "'"; ParaContent();  print (PrintText) SC_874; 
	jump L_SayX556; .L_Say623;
		ParaContent();  print (PrintText) SC_648; 
	.L_Say624; .L_SayX556;
		ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_875; ParaContent(); (PHR_909_r92 ());ParaContent();  } ParaContent();  print (PrintText) SC_77; ParaContent(); (PHR_900_r89 ()); .L_Say625; .L_SayX557;
    rtrue;
];

[ text_routine_47;
say__p=1;ParaContent();  I7_ST_say_one_of-->33 =
	i7_soo_tap(I7_ST_say_one_of-->33, 3);
	switch((I7_ST_say_one_of-->33)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_876; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_877; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_878; ParaContent();  print (a) noun; ParaContent();  print (PrintText) SC_77; ParaContent();  } ParaContent(); (PHR_900_r89 ()); .L_Say626; .L_SayX558;
    rtrue;
];

[ text_routine_48;
say__p=1;ParaContent();  I7_ST_say_one_of-->34 =
	i7_soo_ran(I7_ST_say_one_of-->34, 3);
	switch((I7_ST_say_one_of-->34)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_879; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_880; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_881; ParaContent();  } ParaContent();  print (PrintText) SC_77; ParaContent(); (PHR_900_r89 ()); .L_Say627; .L_SayX559;
    rtrue;
];

[ text_routine_49;
say__p=1;ParaContent();  print (PrintText) SC_882; ParaContent(); (PHR_909_r92 ());ParaContent();  print (PrintText) SC_77; ParaContent(); (PHR_900_r89 ()); .L_Say628; .L_SayX560;
    rtrue;
];

[ text_routine_50;
say__p=1;ParaContent();  print (PrintText) SC_883; ParaContent(); (PHR_900_r89 ()); .L_Say629; .L_SayX561;
    rtrue;
];

[ text_routine_51;
say__p=1;ParaContent();  print (PrintText) SC_884; ParaContent(); (PHR_900_r89 ()); .L_Say630; .L_SayX562;
    rtrue;
];

[ text_routine_52;
say__p=1;ParaContent();  print (PrintText) SC_885; ParaContent(); (PHR_909_r92 ());ParaContent();  print (PrintText) SC_886; ParaContent(); (PHR_900_r89 ()); .L_Say631; .L_SayX563;
    rtrue;
];

[ text_routine_53;
say__p=1;ParaContent();  print (PrintText) SC_887; ParaContent(); (PHR_909_r92 ());ParaContent();  print (PrintText) SC_888; ParaContent(); (PHR_900_r89 ()); .L_Say632; .L_SayX564;
    rtrue;
];

[ text_routine_54;
say__p=1;ParaContent();  print (PrintText) SC_889; ParaContent(); (PHR_900_r89 ()); .L_Say633; .L_SayX565;
    rtrue;
];

[ text_routine_55;
say__p=1;ParaContent();  print (PrintText) SC_890; ParaContent(); (PHR_900_r89 ()); .L_Say634; .L_SayX566;
    rtrue;
];

[ text_routine_56;
say__p=1;ParaContent();  print (PrintText) SC_891; ParaContent(); (PHR_900_r89 ()); .L_Say635; .L_SayX567;
    rtrue;
];

[ text_routine_57;
say__p=1;ParaContent();  print (PrintText) SC_892; ParaContent(); (PHR_909_r92 ());ParaContent();  print (PrintText) SC_893; ParaContent(); (PHR_900_r89 ()); .L_Say636; .L_SayX568;
    rtrue;
];

[ text_routine_58
    t_0 ! Local variable e.g. 'ask-suggs' = number
    t_1 ! Local variable e.g. 'tell-suggs' = number
    t_2 ! Local variable e.g. 'other-suggs' = number
    t_3 ! Local variable e.g. 'sugg-rep' = indexed text
    ;
t_0=LocalParking-->0;
t_1=LocalParking-->1;
t_2=LocalParking-->2;
t_3=LocalParking-->3;
    say__p=1;ParaContent();  print (LIST_OF_TY_Say) (Global_Vars-->15);  .L_Say637; .L_SayX569;
    rtrue;
];

[ text_routine_59
    t_0 ! Local variable e.g. 'ask-suggs' = number
    t_1 ! Local variable e.g. 'tell-suggs' = number
    t_2 ! Local variable e.g. 'other-suggs' = number
    t_3 ! Local variable e.g. 'sugg-rep' = indexed text
    ;
t_0=LocalParking-->0;
t_1=LocalParking-->1;
t_2=LocalParking-->2;
t_3=LocalParking-->3;
    say__p=1;ParaContent();  LIST_OF_TY_Say((Global_Vars-->13), 2);  .L_Say638; .L_SayX570;
    rtrue;
];

[ text_routine_60
    t_0 ! Local variable e.g. 'ask-suggs' = number
    t_1 ! Local variable e.g. 'tell-suggs' = number
    t_2 ! Local variable e.g. 'other-suggs' = number
    t_3 ! Local variable e.g. 'sugg-rep' = indexed text
    ;
t_0=LocalParking-->0;
t_1=LocalParking-->1;
t_2=LocalParking-->2;
t_3=LocalParking-->3;
    say__p=1;ParaContent();  LIST_OF_TY_Say((Global_Vars-->14), 2);  .L_Say639; .L_SayX571;
    rtrue;
];






[ ChronologyPoint pt;
	for (pt=0:pt<NO_PAST_TENSE_CONDS:pt++)
		past_chronological_record-->pt = present_chronological_record-->pt;
];

[ UPDATE_CHRONOLOGICAL_RECORDS_R pt;
	for (pt=0: pt<NO_PAST_TENSE_CONDS: pt++) TestSinglePastState(false, pt, true, -1);
	ChronologyPoint();
	rfalse;
];

Array PastActionsI6Routines --> 0 0;

Constant NO_PAST_TENSE_CONDS 10;
Constant NO_PAST_TENSE_ACTIONS 0;

[ TestSinglePastState past_flag pt turn_end wanted
	old new trips consecutives ct_0 ct_1;
	if (past_flag) {
		new = (past_chronological_record-->pt) & 1;
		trips = ((past_chronological_record-->pt) & $$11111110)/2;
		consecutives = ((past_chronological_record-->pt) & $$111111100000000)/256;
	} else {
		old = (present_chronological_record-->pt) & 1;
		trips = ((present_chronological_record-->pt) & $$11111110)/2;
		consecutives = ((present_chronological_record-->pt) & $$111111100000000)/256;
		switch(pt) {
! Test cases for conditions by PT number: each sets "new" to whether it is true or false now
0: new = ((((Adj_3_t1_v65(O172_voice)))));
1: new = ((((Adj_3_t1_v65(O172_voice)))));
2: new = (((GProperty(OBJECT_TY, O118_emergency_radio,p18_frequency_tuned_to) == (Global_Vars-->27))));
3: new = ((Prop_92()));
4: new = ((((Adj_3_t1_v65(O172_voice)))));
5: new = ((((scene_status-->(Q344_chase-1)==1))));
6: new = ((((scene_status-->(Q345_fight-1)==1))));
7: new = ((((Adj_3_t1_v65(O172_voice)))));
8: new = ((((Adj_85_t1_v65(O118_emergency_radio)))));
9: new = (((real_location == O149_open_desert)));
default: print "*** No such past tense condition ***^"; new = false;

		}
		if (new == false) {
			consecutives = 0;
		} else {
			if (old == false) { trips++; if (trips > 127) trips = 127; }
			if (turn_end) { consecutives++; if (consecutives > 127) consecutives = 127; }
		}
		present_chronological_record-->pt = new + 2*trips + 256*consecutives;
	}
	! print pt, ": old=", old, " new=", new, " trips=", trips, " consec=", consecutives,
	!	" wanted=", wanted, "^";
	switch(wanted) {
		0: if (new) return new;
		1: if (new) return trips;
		2: if (new) return consecutives+1; ! Plus one because we count the current turn
		4: return new;
		5: return trips;
		6: return consecutives;
	}
	return 0;
];

[ TrackActions readjust oow ct_0 ct_1 i;
	for (i=0: PastActionsI6Routines-->i: i++) {
		if ((PastActionsI6Routines-->i).call()) {
			! Yes, the current action matches action pattern i:
			if (readjust) continue;
			(TimesActionHasHappened-->i)++;
			if (LastTurnActionHappenedOn-->i ~= turns + 5) {
				LastTurnActionHappenedOn-->i = turns + 5;
				ActionCurrentlyHappeningFlag->i = 1;
				if (keep_silent == false)
					(TurnsActionHasBeenHappening-->i)++;
			}
		} else {
			! No, the current action doesn't match action pattern i:
			if (oow == false) {
				if (keep_silent == false) { TurnsActionHasBeenHappening-->i = 0; }
				if (LastTurnActionHappenedOn-->i ~= turns + 5)
					ActionCurrentlyHappeningFlag->i = 0;
			}
		}
	}
];

Array TimesActionHasHappened-->(NO_PAST_TENSE_ACTIONS+1);
Array TurnsActionHasBeenHappening-->(NO_PAST_TENSE_ACTIONS+1);
Array LastTurnActionHappenedOn-->(NO_PAST_TENSE_ACTIONS+1);
Array ActionCurrentlyHappeningFlag->(NO_PAST_TENSE_ACTIONS+1);

Array past_chronological_record-->(NO_PAST_TENSE_CONDS+1);
Array present_chronological_record-->(NO_PAST_TENSE_CONDS+1);




[ GPR_Line_128
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'fix') jump Fail_1;
        return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'repair') jump Fail_2;
        return rv;
        .Fail_2; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'patch') jump Fail_3;
        return rv;
        .Fail_3; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

Verb 'take' 'carry' 'hold' 'steal' 'grab' 'acquire' 'snatch' 'bring'
    * 'inventory'  -> Inv
    * multi  -> Take
    * 'off' noun  -> Disrobe
    * noun 'off'  -> Disrobe
    * multiinside 'from' noun  -> Remove
    * multiinside 'off' noun  -> Remove
;
Verb 'get'
    * 'out' / 'off' / 'down' / 'up'  -> Exit
    * 'in' / 'on'  -> Enter
    * multi  -> Take
    * 'in' / 'into' / 'on' / 'onto' noun  -> Enter
    * 'off' / 'down' noun  -> GetOff
    * 'out' 'of' noun=Noun_Filter_0  -> GetOff
    * multiinside 'from' noun  -> Remove
;
Verb 'pick'
    * 'up' multi  -> Take
    * multi 'up'  -> Take
;
Verb 'stand'
    *  -> A94_standing
    * 'up'  -> A94_standing
    * 'on' noun  -> Enter
;
Verb 'remove'
    * held  -> Disrobe
    * multiinside 'from' noun  -> Remove
;
Verb 'shed' 'doff' 'disrobe'
    * held  -> Disrobe
;
Verb 'wear' 'don'
    * held  -> Wear
;
Verb 'put' 'place' 'stick' 'shove' 'stuff'
    * 'on' held  -> Wear
    * held 'on'  -> Wear
    * 'down' multiheld  -> Drop
    * multiheld 'down'  -> Drop
    * Mistake_Token_269 noun=Noun_Filter_1 'in' noun=Noun_Filter_2  -> MistakeAction
    * multiexcept 'in' / 'inside' / 'into' noun  -> Insert
    * multiexcept 'on' / 'onto' noun  -> PutOn
;
Verb 'insert'
    * multiexcept 'in' / 'into' noun  -> Insert
;
Verb 'drop' 'throw' 'discard' 'toss' 'fling' 'hurl'
    * multiheld  -> Drop
    * held 'away'  -> Drop
    * 'away' held  -> Drop
    * held 'at' / 'against' / 'on' / 'onto' noun  -> ThrowAt
    * held 'into' / 'through' / 'to' noun  -> ThrowAt
    * multiexcept 'in' / 'into' / 'down' noun  -> Insert
    * multiexcept 'on' / 'onto' noun  -> PutOn
;
Verb 'give' 'pay' 'offer' 'feed' 'hand' 'deliver'
    * creature held  -> Give reverse
    * held 'to' creature  -> Give
;
Verb 'show' 'present' 'display'
    * creature held  -> Show reverse
    * held 'to' creature  -> Show
;
Verb 'go' 'walk' 'run' 'proceed' 'wander' 'explore'
    *  -> Go
    * Cond_Token_314 Mistake_Token_314 'insane'  -> MistakeAction
    * 'back'  -> A95_retreating
    * noun=Noun_Filter_3  -> Go
    * noun  -> Enter
    * 'into' / 'in' / 'inside' / 'through' noun  -> Enter
;
Verb 'inventory' 'i//' 'inv'
    *  -> Inv
;
Verb 'look' 'l//' 'see'
    *  -> Look
    * 'around' / 'about'  -> Look
    * noun  -> Examine
    * Mistake_Token_286 'through' / 'in' / 'inside' / 'into' noun=Noun_Filter_4  -> MistakeAction
    * 'at' noun  -> Examine
    * 'inside' / 'in' / 'into' / 'through' noun  -> Search
    * 'under' noun  -> LookUnder
    * 'up' topic 'in' noun  -> Consult reverse
;
Verb 'consult' 'read about'
    * noun 'on' / 'about' topic  -> Consult
;
Verb 'open' 'unwrap' 'uncover' 'unfold'
    * noun  -> Open
    * noun 'with' held  -> Unlock
;
Verb 'close' 'shut' 'cover' 'fold'
    * noun  -> Close
    * 'up' noun  -> Close
    * 'off' noun  -> SwitchOff
;
Verb 'enter' 'cross' 'board'
    *  -> Enter
    * noun  -> Enter
;
Verb 'sit'
    * 'down'  -> Enter
    * noun  -> Enter
    * 'on' / 'in' / 'inside' noun  -> Enter
    * 'down' 'on' / 'in' noun  -> Enter
    * 'on' 'top' 'of' noun  -> Enter
;
Verb 'exit' 'leave' 'out' 'depart' 'escape'
    *  -> Exit
    * noun=Noun_Filter_5  -> Enter
    * noun=Noun_Filter_7  -> GetOff
    * 'through' / 'using' / 'by' / 'out' noun=Noun_Filter_6  -> Enter
;
Verb 'examine' 'x//' 'watch' 'describe' 'check' 'view' 'observe' 'inspect'
    * noun  -> Examine
;
Verb 'read'
    * noun  -> Examine
    * 'about' topic 'in' noun  -> Consult reverse
    * topic 'in' noun  -> Consult reverse
;
Verb 'yes' 'y//'
    *  -> Yes
;
Verb 'no'
    *  -> No
;
Verb 'sorry'
    *  -> Sorry
;
Verb 'bother' 'curses' 'drat' 'darn'
    *  -> Mild
;
Verb 'shit' 'fuck' 'damn'
    *  -> Strong
;
Verb 'search'
    * noun  -> Search
;
Verb 'wave'
    *  -> WaveHands
    * noun  -> Wave
;
Verb 'adjust'
    * noun 'to' topic  -> SetTo
;
Verb 'pull' 'drag' 'raise' 'lift'
    * noun  -> Pull
;
Verb 'push' 'move' 'shift' 'clear' 'press' 'lower'
    * Mistake_Token_251  -> MistakeAction
    * noun  -> Push
    * noun noun=Noun_Filter_8  -> PushDir
    * noun 'to' noun=Noun_Filter_9  -> PushDir
;
Verb 'turn' 'rotate' 'twist' 'unscrew' 'screw' 'spin'
    * Mistake_Token_250 'key'  -> MistakeAction
    * noun  -> Turn
    * Mistake_Token_249 'on' noun=Noun_Filter_10  -> MistakeAction
    * noun 'on'  -> SwitchOn
    * 'on' noun  -> SwitchOn
    * noun 'off'  -> SwitchOff
    * 'off' noun  -> SwitchOff
    * noun=Noun_Filter_11 'to' Designed_Type_GPR_103  -> A99_tuning_it_to
;
Verb 'switch' 'activate' 'start' 'deactivate' 'stop'
    * Mistake_Token_248 noun=Noun_Filter_13  -> MistakeAction
    * noun=Noun_Filter_12  -> SwitchOff
    * noun  -> SwitchOn
    * 'on' noun  -> SwitchOn
    * noun 'on'  -> SwitchOn
    * noun 'off'  -> SwitchOff
    * 'off' noun  -> SwitchOff
;
Verb 'lock'
    * noun 'with' held  -> Lock
;
Verb 'unlock'
    * noun 'with' held  -> Unlock
;
Verb 'attack' 'break' 'smash' 'hit' 'fight' 'torture' 'wreck' 'crack' 'destroy' 'murder' 'kill' 'punch' 'thump' 'injure' 'kick' 'strike'
    * noun  -> Attack
    * 'in' / 'into' / 'down' / 'through' noun  -> Attack
    * noun 'in' / 'down'  -> Attack
    * noun 'with' held  -> ThrowAt reverse
;
Verb 'wait' 'z//'
    *  -> Wait
;
Verb 'speak' 'say' 'shout'
    * 'hello' / 'hi'  -> A90_hailing
    * 'hello' / 'hi' 'to' noun  -> A89_saying_hello_to
    * 'bye' / 'goodbye' / 'farewell' / 'cheerio' 'to' creature  -> A92_saying_goodbye_to
    * topic 'to' creature  -> Answer reverse
;
Verb 'tell'
    * scope=Scope_Filter_15  -> A86_implicit_informing
    * 'him' scope=Scope_Filter_16  -> A86_implicit_informing
    * 'her' scope=Scope_Filter_17  -> A86_implicit_informing
    * creature 'about' scope=Scope_Filter_14  -> A84_informing_it_about
;
Verb 'ask'
    * scope=Scope_Filter_22  -> A85_implicit_quizzing
    * 'about' scope=Scope_Filter_20  -> A85_implicit_quizzing
    * 'for' scope=Scope_Filter_21  -> A87_implicit_requesting
    * 'him' scope=Scope_Filter_23  -> A85_implicit_quizzing
    * 'her' scope=Scope_Filter_24  -> A85_implicit_quizzing
    * creature 'for' scope=Scope_Filter_18  -> A81_requesting_it_for
    * creature 'about' scope=Scope_Filter_19  -> A83_quizzing_it_about
    * creature 'about' topic  -> Ask
    * creature 'for' topic  -> A82_imploring_it_for
    * 'for' topic  -> A88_implicit_imploring
;
Verb 'eat'
    * held  -> Eat
;
Verb 'sleep' 'nap'
    *  -> Sleep
;
Verb 'sing' 'whistle' 'hum'
    *  -> Sing
;
Verb 'climb' 'scale'
    * noun=Noun_Filter_25  -> Go
    * noun  -> Climb
    * 'on' / 'in' / 'into' / 'onto' noun=Noun_Filter_26  -> Enter
    * 'in' / 'into' / 'through' noun=Noun_Filter_27  -> Enter
    * 'up' / 'over' noun  -> Climb
    * 'on' / 'in' / 'into' / 'onto' noun  -> Climb
;
Verb 'buy' 'purchase'
    * noun  -> Buy
;
Verb 'squeeze' 'squash'
    * noun  -> Squeeze
;
Verb 'swing'
    * noun  -> Swing
    * 'on' noun  -> Swing
;
Verb 'wake' 'awake' 'awaken'
    *  -> Wake
    * 'up'  -> Wake
    * creature  -> WakeOther
    * creature 'up'  -> WakeOther
    * 'up' creature  -> WakeOther
;
Verb 'kiss' 'embrace' 'hug'
    * creature  -> Kiss
;
Verb 'think'
    *  -> Think
    * 'about' noun  -> A97_brooding
;
Verb 'smell' 'sniff'
    *  -> Smell
    * noun  -> Smell
;
Verb 'listen'
    *  -> Listen
    * noun  -> Listen
    * 'to' noun  -> Listen
;
Verb 'hear'
    * noun  -> Listen
;
Verb 'taste'
    * noun  -> Taste
;
Verb 'touch' 'feel'
    * noun  -> Touch
;
Verb 'scrub' 'shine' 'polish' 'sweep' 'clean' 'dust' 'wipe'
    * noun  -> Rub
;
Verb 'tie' 'attach' 'fasten'
    * noun 'to' noun  -> Tie
;
Verb 'burn' 'light' 'melt' 'ignite' 'incinerate' 'kindle' 'parch' 'bake' 'toast' 'flick'
    * noun  -> Burn
    * 'on' noun=Noun_Filter_28  -> Burn
    * 'up' noun  -> A98_smoking
;
Verb 'drink' 'swallow' 'sip'
    * noun  -> Drink
;
Verb 'cut' 'slice' 'prune' 'chop' 'carve'
    * noun  -> Cut
;
Verb 'jump' 'skip' 'hop'
    *  -> Jump
    * 'on' / 'in' / 'into' / 'onto' noun  -> Enter
;
Verb 'score'
    *  -> Score
;
Verb 'quit'
    *  -> Quit
;
Verb 'q//'
    *  -> Quit
;
Verb 'save'
    *  -> Save
;
Verb 'restart'
    *  -> Restart
;
Verb 'restore'
    *  -> Restore
;
Verb 'verify'
    *  -> Verify
;
Verb 'version'
    *  -> Version
;
Verb 'script'
    *  -> ScriptOn
    * 'on'  -> ScriptOn
    * 'off'  -> ScriptOff
;
Verb 'transcript'
    *  -> ScriptOn
    * 'on'  -> ScriptOn
    * 'off'  -> ScriptOff
;
Verb 'superbrief'
    *  -> LMode3
;
Verb 'short'
    *  -> LMode3
;
Verb 'verbose'
    *  -> LMode2
;
Verb 'long'
    *  -> LMode2
;
Verb 'brief'
    *  -> LMode1
;
Verb 'normal'
    *  -> LMode1
;
Verb 'nouns'
    *  -> Pronouns
;
Verb 'pronouns'
    *  -> Pronouns
;
Verb 'notify'
    *  -> NotifyOn
    * 'on'  -> NotifyOn
    * 'off'  -> NotifyOff
;
Verb 'epistat'
    * scope=Scope_Filter_29  -> A80_requesting_epistemic_sta
;
Verb 'a//'
    * scope=Scope_Filter_30  -> A85_implicit_quizzing
;
Verb 't//'
    * scope=Scope_Filter_31  -> A86_implicit_informing
;
Verb 'talk'
    * 'to' noun  -> A89_saying_hello_to
    * 'about' scope=Scope_Filter_32  -> A86_implicit_informing
;
Verb 'greet'
    * noun  -> A89_saying_hello_to
;
Verb 'hello'
    *  -> A90_hailing
;
Verb 'hi'
    *  -> A90_hailing
;
Verb 'bye'
    *  -> A91_leavetaking
;
Verb 'goodbye'
    *  -> A91_leavetaking
;
Verb 'cheerio'
    *  -> A91_leavetaking
;
Verb 'farewell'
    *  -> A91_leavetaking
;
Verb 'topics'
    *  -> A93_listing_suggested_topics
;
Verb 'back'
    *  -> A95_retreating
;
Verb 'return'
    *  -> A95_retreating
;
Verb 'retreat'
    *  -> A95_retreating
;
Verb 'use'
    * Mistake_Token_265 noun=Noun_Filter_43  -> MistakeAction
    * Mistake_Token_270 noun=Noun_Filter_45  -> MistakeAction
    * noun=Noun_Filter_42  -> Burn
    * noun=Noun_Filter_46  -> Enter
    * noun=Noun_Filter_35  -> Open
    * noun=Noun_Filter_36  -> Close
    * noun=Noun_Filter_39  -> SwitchOn
    * noun=Noun_Filter_41  -> Enter
    * noun=Noun_Filter_33  -> Eat
    * noun=Noun_Filter_34  -> Wear
    * noun=Noun_Filter_40  -> Open
    * noun  -> A96_using
    * Mistake_Token_266 noun=Noun_Filter_44 'on' / 'with' noun  -> MistakeAction
    * held 'on' noun=Noun_Filter_37  -> Unlock reverse
    * held 'on' noun=Noun_Filter_38  -> Lock reverse
;
Verb 'brood'
    * noun  -> A97_brooding
    * 'about' / 'on' / 'over' noun  -> A97_brooding
;
Verb 'smoke'
    *  -> A98_smoking
    * noun  -> A98_smoking
;
Verb 'have'
    * noun=Noun_Filter_47  -> A98_smoking
;
Verb 'drive'
    * Mistake_Token_246  -> MistakeAction
    * Mistake_Token_247 noun=Noun_Filter_48  -> MistakeAction
;
Verb 'steer'
    * Mistake_Token_252  -> MistakeAction
;
Verb 'brake'
    * Mistake_Token_253  -> MistakeAction
;
Verb 'no.verb'
    * Mistake_Token_261 GPR_Line_128 noun=Noun_Filter_49  -> MistakeAction
    * Mistake_Token_263 GPR_Line_128 noun=Noun_Filter_51  -> MistakeAction
    * Mistake_Token_262 GPR_Line_128 noun=Noun_Filter_50 'with' noun  -> MistakeAction
    * Mistake_Token_264 GPR_Line_128 noun=Noun_Filter_52 'with' noun  -> MistakeAction
;
Verb 'tape'
    * Mistake_Token_267 noun=Noun_Filter_53  -> MistakeAction
;
Verb 'fill'
    * Mistake_Token_268 noun=Noun_Filter_54  -> MistakeAction
;
Verb 'tune' 'set'
    * noun=Noun_Filter_55 'to' Designed_Type_GPR_103  -> A99_tuning_it_to
    * noun=Noun_Filter_56 'to' DECIMAL_TOKEN  -> A100_coarse_tuning
;
Verb 'trade'
    * Mistake_Token_311 'for' noun  -> MistakeAction
    * held 'for' noun  -> A101_trading
;
Verb 'unplug'
    * Mistake_Token_312 noun=Noun_Filter_57  -> MistakeAction
;
[ Parse_Name_GV1
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV2
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV3
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV4
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV5
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV6
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV7
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV8
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV9
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_249_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'upstairs') jump group_249_1_2;
            jump group_249_1_end;
            .group_249_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'ascend') jump Fail_1;
            .group_249_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV10
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_250_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'downstairs') jump group_250_1_2;
            jump group_250_1_end;
            .group_250_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'descend') jump Fail_1;
            .group_250_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV11
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV12
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV96
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        if (parser_action == ##TheSame) return 0;
            group_wn = wn;
            .group_251_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'himself') jump group_251_1_2;
            jump group_251_1_end;
            .group_251_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'herself') jump Fail_1;
            .group_251_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV112
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_252_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'cigarette') jump group_252_1_2;
            jump group_252_1_end;
            .group_252_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'cig') jump group_252_1_3;
            jump group_252_1_end;
            .group_252_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'cigs') jump group_252_1_4;
            jump group_252_1_end;
            .group_252_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'smokes') jump Fail_1;
            .group_252_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV113
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        if (parser_action == ##TheSame) return 0;
            group_wn = wn;
            .group_253_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'memory') jump group_253_1_2;
            jump group_253_1_end;
            .group_253_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'memories') jump Fail_1;
            .group_253_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV115
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_254_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'ocean^s') jump group_254_1_2;
            jump group_254_1_end;
            .group_254_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'oceans') jump Fail_1;
            .group_254_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            group_wn = wn;
            .group_255_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'memory') jump group_255_1_2;
            jump group_255_1_end;
            .group_255_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'memories') jump Fail_2;
            .group_255_1_end;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV116
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_256_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'memory') jump group_256_1_2;
            jump group_256_1_end;
            .group_256_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'memories') jump Fail_1;
            .group_256_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV117
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_257_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'i//') jump group_257_1_2;
            jump group_257_1_end;
            .group_257_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'baby') jump group_257_1_3;
            jump group_257_1_end;
            .group_257_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'ocean^s') jump Fail_1;
            .group_257_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            group_wn = wn;
            .group_258_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'memory') jump group_258_1_2;
            jump group_258_1_end;
            .group_258_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'memories') jump Fail_2;
            .group_258_1_end;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV118
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            if (NextWordStopped() ~= 'with') jump Fail_1;
            if (NextWordStopped() ~= 'karl') jump Fail_1;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            group_wn = wn;
            .group_260_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'memory') jump group_260_1_2;
            jump group_260_1_end;
            .group_260_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'memories') jump Fail_2;
            .group_260_1_end;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV121
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_261_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'photograph') jump group_261_1_2;
            jump group_261_1_end;
            .group_261_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'pic') jump group_261_1_3;
            jump group_261_1_end;
            .group_261_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'picture') jump group_261_1_4;
            jump group_261_1_end;
            .group_261_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'folded') jump group_261_1_5;
            jump group_261_1_end;
            .group_261_1_5; wn = group_wn;
            if (NextWordStopped() ~= 'unfolded') jump Fail_1;
            .group_261_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV122
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_262_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'car') jump group_262_1_2;
            jump group_262_1_end;
            .group_262_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'door') jump group_262_1_3;
            jump group_262_1_end;
            .group_262_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'poor') jump group_262_1_4;
            jump group_262_1_end;
            .group_262_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'old') jump group_262_1_5;
            jump group_262_1_end;
            .group_262_1_5; wn = group_wn;
            if (NextWordStopped() ~= 'dash') jump Fail_1;
            .group_262_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV123
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_263_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'glovebox') jump group_263_1_2;
            jump group_263_1_end;
            .group_263_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'compartment') jump Fail_1;
            .group_263_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV127
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            if (NextWordStopped() ~= 'head') jump Fail_1;
            if (NextWordStopped() ~= 'lights') jump Fail_1;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            if (NextWordStopped() ~= 'head') jump Fail_2;
            if (NextWordStopped() ~= 'light') jump Fail_2;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
            if (NextWordStopped() ~= 'high') jump Fail_3;
            if (NextWordStopped() ~= 'beams') jump Fail_3;
            try_from_wn = wn; f = true;
            .Fail_3; wn = try_from_wn;
            group_wn = wn;
            .group_267_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'headlight') jump group_267_1_2;
            jump group_267_1_end;
            .group_267_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'lights') jump group_267_1_3;
            jump group_267_1_end;
            .group_267_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'light') jump group_267_1_4;
            jump group_267_1_end;
            .group_267_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'beams') jump Fail_4;
            .group_267_1_end;
            try_from_wn = wn; f = true;
            .Fail_4; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV132
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_268_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'fumes') jump group_268_1_2;
            jump group_268_1_end;
            .group_268_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'fume') jump group_268_1_3;
            jump group_268_1_end;
            .group_268_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'whiff') jump Fail_1;
            .group_268_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV133
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV134
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_269_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'board') jump group_269_1_2;
            jump group_269_1_end;
            .group_269_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'boards') jump group_269_1_3;
            jump group_269_1_end;
            .group_269_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'boarded') jump Fail_1;
            .group_269_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV135
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! Match any number of visible property values
        try_from_wn = wn; g = true; while (g) {
            g = false;
            ! Parsing property open
            wn = try_from_wn; if ((self  has open)  && (NextWordStopped()=='open')) {
                try_from_wn = wn;
                g = true;
                f = true;
                jump pvp_pass_L_0;
            }
            wn = try_from_wn; if ((self  hasnt open)  && (NextWordStopped()=='closed')) {
                try_from_wn = wn;
                g = true;
                f = true;
                jump pvp_pass_L_0;
            }
            .pvp_pass_L_0;
        }
        ! try_from_wn is now advanced past any visible property values
        wn = try_from_wn;
            if (Cond_Token_287() == GPR_FAIL) jump Fail_1;
            group_wn = wn;
            .group_270_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'empty') jump group_270_1_2;
            jump group_270_1_end;
            .group_270_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'frame') jump Fail_1;
            .group_270_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV136
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_271_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'rusted') jump group_271_1_2;
            jump group_271_1_end;
            .group_271_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'metal') jump Fail_1;
            .group_271_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV137
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV138
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_272_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'book') jump group_272_1_2;
            jump group_272_1_end;
            .group_272_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'pages') jump group_272_1_3;
            jump group_272_1_end;
            .group_272_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'page') jump group_272_1_4;
            jump group_272_1_end;
            .group_272_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'guide') jump Fail_1;
            .group_272_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            group_wn = wn;
            .group_273_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'guide') jump group_273_1_2;
            jump group_273_1_end;
            .group_273_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'book') jump group_273_1_3;
            jump group_273_1_end;
            .group_273_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'page') jump group_273_1_4;
            jump group_273_1_end;
            .group_273_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'pages') jump Fail_2;
            .group_273_1_end;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV139
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_274_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'dial') jump group_274_1_2;
            jump group_274_1_end;
            .group_274_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'big') jump group_274_1_3;
            jump group_274_1_end;
            .group_274_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'fifties') jump group_274_1_4;
            jump group_274_1_end;
            .group_274_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'knob') jump group_274_1_5;
            jump group_274_1_end;
            .group_274_1_5; wn = group_wn;
            if (NextWordStopped() ~= 'switch') jump Fail_1;
            .group_274_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV141
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        if (parser_action==##TheSame) {
            if (parser_trace >= 4) print "p1, p2 = ", parser_one, ", ", parser_two, "^";
            ss = self;
            ! Distinguishing property open
            if ((parser_one  has open) && (~~(parser_two  has open))) return -2;
            if ((parser_two  has open) && (~~(parser_one  has open))) return -2;
            self = ss; return 0;
        }
        ! Match any number of visible property values
        try_from_wn = wn; g = true; while (g) {
            g = false;
            ! Parsing property open
            wn = try_from_wn; if ((self  has open)  && (NextWordStopped()=='open')) {
                try_from_wn = wn;
                g = true;
                f = true;
                jump pvp_pass_L_1;
            }
            wn = try_from_wn; if ((self  hasnt open)  && (NextWordStopped()=='closed')) {
                try_from_wn = wn;
                g = true;
                f = true;
                jump pvp_pass_L_1;
            }
            .pvp_pass_L_1;
        }
        ! try_from_wn is now advanced past any visible property values
        wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV142
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_275_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'spiderweb') jump group_275_1_2;
            jump group_275_1_end;
            .group_275_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'spiderwebs') jump group_275_1_3;
            jump group_275_1_end;
            .group_275_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'cobweb') jump group_275_1_4;
            jump group_275_1_end;
            .group_275_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'spider') jump group_275_1_5;
            jump group_275_1_end;
            .group_275_1_5; wn = group_wn;
            if (NextWordStopped() ~= 'spiders') jump group_275_1_6;
            jump group_275_1_end;
            .group_275_1_6; wn = group_wn;
            if (NextWordStopped() ~= 'web') jump group_275_1_7;
            jump group_275_1_end;
            .group_275_1_7; wn = group_wn;
            if (NextWordStopped() ~= 'webs') jump Fail_1;
            .group_275_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV143
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            if (NextWordStopped() ~= 'flash') jump Fail_1;
            if (NextWordStopped() ~= 'light') jump Fail_1;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            group_wn = wn;
            .group_277_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'beam') jump group_277_1_2;
            jump group_277_1_end;
            .group_277_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'cold') jump group_277_1_3;
            jump group_277_1_end;
            .group_277_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'blue') jump group_277_1_4;
            jump group_277_1_end;
            .group_277_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'metal') jump group_277_1_5;
            jump group_277_1_end;
            .group_277_1_5; wn = group_wn;
            if (NextWordStopped() ~= 'hefty') jump group_277_1_6;
            jump group_277_1_end;
            .group_277_1_6; wn = group_wn;
            if (NextWordStopped() ~= 'large') jump group_277_1_7;
            jump group_277_1_end;
            .group_277_1_7; wn = group_wn;
            if (NextWordStopped() ~= 'lump') jump group_277_1_8;
            jump group_277_1_end;
            .group_277_1_8; wn = group_wn;
            if (NextWordStopped() ~= 'lumpy') jump group_277_1_9;
            jump group_277_1_end;
            .group_277_1_9; wn = group_wn;
            if (NextWordStopped() ~= 'something') jump group_277_1_10;
            jump group_277_1_end;
            .group_277_1_10; wn = group_wn;
            if (NextWordStopped() ~= 'switch') jump Fail_2;
            .group_277_1_end;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV144
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_278_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'peeling') jump group_278_1_2;
            jump group_278_1_end;
            .group_278_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'text') jump group_278_1_3;
            jump group_278_1_end;
            .group_278_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'section') jump group_278_1_4;
            jump group_278_1_end;
            .group_278_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'emergency') jump group_278_1_5;
            jump group_278_1_end;
            .group_278_1_5; wn = group_wn;
            if (NextWordStopped() ~= 'radio') jump group_278_1_6;
            jump group_278_1_end;
            .group_278_1_6; wn = group_wn;
            if (NextWordStopped() ~= 'frequency') jump Fail_1;
            .group_278_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV145
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            if (NextWordStopped() ~= 'light') jump Fail_1;
            if (NextWordStopped() ~= 'bulb') jump Fail_1;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            if (NextWordStopped() ~= 'light') jump Fail_2;
            if (NextWordStopped() ~= 'bulbs') jump Fail_2;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
            group_wn = wn;
            .group_281_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'bare') jump group_281_1_2;
            jump group_281_1_end;
            .group_281_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'bulbs') jump group_281_1_3;
            jump group_281_1_end;
            .group_281_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'control') jump group_281_1_4;
            jump group_281_1_end;
            .group_281_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'panel') jump Fail_3;
            .group_281_1_end;
            try_from_wn = wn; f = true;
            .Fail_3; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV146
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_282_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'can') jump group_282_1_2;
            jump group_282_1_end;
            .group_282_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'hundreds') jump Fail_1;
            .group_282_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV147
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_283_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'ladder') jump group_283_1_2;
            jump group_283_1_end;
            .group_283_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'rung') jump Fail_1;
            .group_283_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV148
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            if (NextWordStopped() ~= 'can') jump Fail_1;
            if (NextWordStopped() ~= 'opener') jump Fail_1;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            if (NextWordStopped() ~= 'opener') jump Fail_2;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV149
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_286_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'broken') jump group_286_1_2;
            jump group_286_1_end;
            .group_286_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'equipment') jump group_286_1_3;
            jump group_286_1_end;
            .group_286_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'junk') jump Fail_1;
            .group_286_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV150
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_287_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'faint') jump group_287_1_2;
            jump group_287_1_end;
            .group_287_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'whiff') jump Fail_1;
            .group_287_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            if (Cond_Token_303() == GPR_FAIL) jump Fail_2;
            if (NextWordStopped() ~= 'gas') jump Fail_2;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV151
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            if (NextWordStopped() ~= 'sand') jump Fail_1;
            if (NextWordStopped() ~= 'dancer') jump Fail_1;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            group_wn = wn;
            .group_290_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'lizard') jump group_290_1_2;
            jump group_290_1_end;
            .group_290_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'huge') jump group_290_1_3;
            jump group_290_1_end;
            .group_290_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'sand') jump group_290_1_4;
            jump group_290_1_end;
            .group_290_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'dancer') jump Fail_2;
            .group_290_1_end;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
            group_wn = wn;
            .group_291_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'himself') jump group_291_1_2;
            jump group_291_1_end;
            .group_291_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'herself') jump Fail_3;
            .group_291_1_end;
            try_from_wn = wn; f = true;
            .Fail_3; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV152
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            if (NextWordStopped() ~= 'sand') jump Fail_1;
            if (NextWordStopped() ~= 'dancer') jump Fail_1;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            group_wn = wn;
            .group_293_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'brown-colored') jump group_293_1_2;
            jump group_293_1_end;
            .group_293_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'colored') jump group_293_1_3;
            jump group_293_1_end;
            .group_293_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'sand-dancer') jump group_293_1_4;
            jump group_293_1_end;
            .group_293_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'dancer') jump Fail_2;
            .group_293_1_end;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
            group_wn = wn;
            .group_294_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'himself') jump group_294_1_2;
            jump group_294_1_end;
            .group_294_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'herself') jump Fail_3;
            .group_294_1_end;
            try_from_wn = wn; f = true;
            .Fail_3; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV153
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            if (NextWordStopped() ~= 'i//') jump Fail_1;
            if (NextWordStopped() ~= 'am') jump Fail_1;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            group_wn = wn;
            .group_296_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'im') jump group_296_1_2;
            jump group_296_1_end;
            .group_296_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'i^m') jump Fail_2;
            .group_296_1_end;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV156
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_297_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'movement') jump group_297_1_2;
            jump group_297_1_end;
            .group_297_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'moving') jump group_297_1_3;
            jump group_297_1_end;
            .group_297_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'something') jump Fail_1;
            .group_297_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV157
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_298_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'that') jump group_298_1_2;
            jump group_298_1_end;
            .group_298_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'you') jump Fail_1;
            .group_298_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV158
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV159
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_299_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'moving') jump group_299_1_2;
            jump group_299_1_end;
            .group_299_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'shadow') jump group_299_1_3;
            jump group_299_1_end;
            .group_299_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'animal') jump group_299_1_4;
            jump group_299_1_end;
            .group_299_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'form') jump group_299_1_5;
            jump group_299_1_end;
            .group_299_1_5; wn = group_wn;
            if (NextWordStopped() ~= 'forms') jump group_299_1_6;
            jump group_299_1_end;
            .group_299_1_6; wn = group_wn;
            if (NextWordStopped() ~= 'snarl') jump group_299_1_7;
            jump group_299_1_end;
            .group_299_1_7; wn = group_wn;
            if (NextWordStopped() ~= 'growl') jump group_299_1_8;
            jump group_299_1_end;
            .group_299_1_8; wn = group_wn;
            if (NextWordStopped() ~= 'howl') jump group_299_1_9;
            jump group_299_1_end;
            .group_299_1_9; wn = group_wn;
            if (NextWordStopped() ~= 'coyote') jump group_299_1_10;
            jump group_299_1_end;
            .group_299_1_10; wn = group_wn;
            if (NextWordStopped() ~= 'sound') jump group_299_1_11;
            jump group_299_1_end;
            .group_299_1_11; wn = group_wn;
            if (NextWordStopped() ~= 'sounds') jump group_299_1_12;
            jump group_299_1_end;
            .group_299_1_12; wn = group_wn;
            if (NextWordStopped() ~= 'coyotes') jump group_299_1_13;
            jump group_299_1_end;
            .group_299_1_13; wn = group_wn;
            if (NextWordStopped() ~= 'wolf') jump group_299_1_14;
            jump group_299_1_end;
            .group_299_1_14; wn = group_wn;
            if (NextWordStopped() ~= 'call') jump group_299_1_15;
            jump group_299_1_end;
            .group_299_1_15; wn = group_wn;
            if (NextWordStopped() ~= 'feral') jump group_299_1_16;
            jump group_299_1_end;
            .group_299_1_16; wn = group_wn;
            if (NextWordStopped() ~= 'wild') jump group_299_1_17;
            jump group_299_1_end;
            .group_299_1_17; wn = group_wn;
            if (NextWordStopped() ~= 'shifting') jump group_299_1_18;
            jump group_299_1_end;
            .group_299_1_18; wn = group_wn;
            if (NextWordStopped() ~= 'pack') jump group_299_1_19;
            jump group_299_1_end;
            .group_299_1_19; wn = group_wn;
            if (NextWordStopped() ~= 'snarls') jump group_299_1_20;
            jump group_299_1_end;
            .group_299_1_20; wn = group_wn;
            if (NextWordStopped() ~= 'teeth') jump group_299_1_21;
            jump group_299_1_end;
            .group_299_1_21; wn = group_wn;
            if (NextWordStopped() ~= 'mangy') jump group_299_1_22;
            jump group_299_1_end;
            .group_299_1_22; wn = group_wn;
            if (NextWordStopped() ~= 'fur') jump Fail_1;
            .group_299_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            group_wn = wn;
            .group_300_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'himself') jump group_300_1_2;
            jump group_300_1_end;
            .group_300_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'herself') jump Fail_2;
            .group_300_1_end;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV160
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_301_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'himself') jump group_301_1_2;
            jump group_301_1_end;
            .group_301_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'herself') jump Fail_1;
            .group_301_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV161
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_302_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'guy') jump group_302_1_2;
            jump group_302_1_end;
            .group_302_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'man') jump Fail_1;
            .group_302_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
            group_wn = wn;
            .group_303_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'himself') jump group_303_1_2;
            jump group_303_1_end;
            .group_303_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'herself') jump Fail_2;
            .group_303_1_end;
            try_from_wn = wn; f = true;
            .Fail_2; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV162
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_304_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'you') jump group_304_1_2;
            jump group_304_1_end;
            .group_304_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'you^re') jump group_304_1_3;
            jump group_304_1_end;
            .group_304_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'i//') jump group_304_1_4;
            jump group_304_1_end;
            .group_304_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'i^m') jump Fail_1;
            .group_304_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV163
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
    if (parser_trace >= 3) print "Two-pass parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 2: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        ! On pass 1 only, advance wn past name property words
        ! (but do not do this for ##TheSame, when wn is undefined)
        if ((parser_action ~= ##TheSame) && (pass == 1)) {
            while (WordInProperty(NextWordStopped(), self, name)) f = true;
            wn--; try_from_wn = wn;
        }
            group_wn = wn;
            .group_305_1_1; wn = group_wn;
            if (NextWordStopped() ~= 'getting') jump group_305_1_2;
            jump group_305_1_end;
            .group_305_1_2; wn = group_wn;
            if (NextWordStopped() ~= 'on') jump group_305_1_3;
            jump group_305_1_end;
            .group_305_1_3; wn = group_wn;
            if (NextWordStopped() ~= 'with') jump group_305_1_4;
            jump group_305_1_end;
            .group_305_1_4; wn = group_wn;
            if (NextWordStopped() ~= 'trading') jump Fail_1;
            .group_305_1_end;
            try_from_wn = wn; f = true;
            .Fail_1; wn = try_from_wn;
        ! On pass 2 only, match name property words at end
        if (pass == 2)
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Consult_Grammar_164
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'restart') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_165
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'restore') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_166
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'amusing') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_167
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'quit') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_168
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'undo') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_169
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'yes') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_170
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'no') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_171
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'sorry') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_172
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_314_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'sand-dancer') jump group_314_1_2;
        jump group_314_1_end;
        .group_314_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'sand') jump group_314_1_3;
        jump group_314_1_end;
        .group_314_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'dancer') jump group_314_1_4;
        jump group_314_1_end;
        .group_314_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'lizard') jump group_314_1_5;
        jump group_314_1_end;
        .group_314_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'lizards') jump group_314_1_6;
        jump group_314_1_end;
        .group_314_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'brown') jump Fail_1;
        .group_314_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_173
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_315_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'hare') jump group_315_1_2;
        jump group_315_1_end;
        .group_315_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'rabbit') jump Fail_1;
        .group_315_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_174
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'coyote') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];



#IFTRUE (1 == 1);
[ UnknownVerb; verb_wordnum = 0; return 'no.verb'; ];
[ PrintVerb v;
	if (v == 'no.verb') { print "do something to"; rtrue; }
	rfalse;
];
#Ifnot;
[ UnknownVerb; rfalse; ]; [ PrintVerb v; rfalse; ];
#ENDIF;


Array Rel_Record_63 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "leading-through relation" RELS_X_UNIQUE+RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND door_to KD4_relation_of_rooms_to_doors Rel_Handler_63 "Leading-through relates one room (called the other side) to various doors";
[ Rel_Handler_63 rr task X Y;
    switch (task) {
        RELS_TEST: if (X == (Y.door_to)) rtrue; rfalse;
        RELS_ASSERT_TRUE: Y.door_to = X; rtrue;
        RELS_ASSERT_FALSE: Relation_NowN1toV(Y,door_to,X); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(rr-->RR_STORAGE, X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(rr-->RR_STORAGE, X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_65 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "lock-fitting relation" RELS_X_UNIQUE+RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND with_key KD5_relation_of_things_to_thin Rel_Handler_65 "Lock-fitting relates one thing (called the matching key) to various things";
[ Rel_Handler_65 rr task X Y;
    switch (task) {
        RELS_TEST: if (X == (Y.with_key)) rtrue; rfalse;
        RELS_ASSERT_TRUE: Y.with_key = X; rtrue;
        RELS_ASSERT_FALSE: Relation_NowN1toV(Y,with_key,X); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(rr-->RR_STORAGE, X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(rr-->RR_STORAGE, X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_67 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "suggestion relation" RELS_Y_UNIQUE+RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND p78_suggested_memory KD6_relation_of_things_to_memo Rel_Handler_67 "Suggestion relates various things to one memory (called the suggested memory)";
[ Rel_Handler_67 rr task X Y;
    switch (task) {
        RELS_TEST: if (Y == (X.p78_suggested_memory)) rtrue; rfalse;
        RELS_ASSERT_TRUE: X.p78_suggested_memory = Y; rtrue;
        RELS_ASSERT_FALSE: Relation_NowN1toV(X,p78_suggested_memory,Y); rtrue;
        RELS_SHOW: Relation_ShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return VtoORelRouteTo(rr-->RR_STORAGE, X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(VtoORelRouteTo(rr-->RR_STORAGE, X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_69 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "requirement relation" RELS_X_UNIQUE+RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND p79_objective KD7_relation_of_plans_to_thing Rel_Handler_69 "Requirement relates one plan (called the objective) to various things";
[ Rel_Handler_69 rr task X Y;
    switch (task) {
        RELS_TEST: if (X == (Y.p79_objective)) rtrue; rfalse;
        RELS_ASSERT_TRUE: Y.p79_objective = X; rtrue;
        RELS_ASSERT_FALSE: Relation_NowN1toV(Y,p79_objective,X); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(rr-->RR_STORAGE, X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(rr-->RR_STORAGE, X, Y), X, Y);
    }
    rfalse;
];
[ CreateDynamicRelations i rel;
];

! Force this to be true via 'now':
! [ ForAll x IN[ memory(x) IN] : is('subconscious', ContainerOf(x)) ]
! in '                                       '
[ Prop_0  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK43_First: x: x=x.IK43_Link){
        qcn_0++;
        MoveObject(x,O44_subconscious);
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! True or false?
! [ Exists x : scene(x) & 'dramatic'(x) & NOT[ 'happening'(x) NOT] ]
! in '                                                                                                                          '
[ Prop_1  x x_ix ;
    for (x=1: x<=11: x++){
        if ((GProperty(SCENE_TY, x, p85_dramatic))){
            if (~~(((scene_status-->(x-1)==1)))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & called='item'(x) & 'charged'(x) & 'visible'(x) ]
! in '                                                              '
[ Prop_2  x x_ix ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_35_t1_v65(x))) && ((Adj_3_t1_v65(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ spirit animal(x) & 'visible'(x) ]
! in '                                                '
[ Prop_3  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK165_First: x: x=x.IK165_Link){
            if (((Adj_3_t1_v65(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Force this to be true via 'now':
! [ ForAll x IN[ thing(x) & 'handled'(x) & 'visible'(x) IN] : 'described'(x) ]
! in '                                            '
[ Prop_4  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_64_t1_v65(x))) && ((Adj_3_t1_v65(x)))){
            qcn_0++;
            (Adj_65_t2_v65(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];

! Find next x satisfying:
! [ direction(x) & 'cardinal'(x) ]
! in '                                                             '
[ Prop_5  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK3_First: x: x=x.IK3_Link){
        if (((Adj_43_t1_v65(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ desert flotsam(x) & 'visible'(x) ]
! in '                                                             '
[ Prop_6  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK150_First: x: x=x.IK150_Link){
        if (((Adj_3_t1_v65(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Abstraction for set of x such that:
! [ desert flotsam(x) ]
! in '                                             '
[ Prop_7 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK150_First: x: x=x.IK150_Link){
                if (property_loop_sign>0) {
                    if (x.property_to_be_totalled >= best) {
                        best = x.property_to_be_totalled;
                        best_with = x;
                    }
                } else {
                    if (x.property_to_be_totalled <= best) {
                        best = x.property_to_be_totalled;
                        best_with = x;
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK150_First: x: x=x.IK150_Link){
                total = total + x.property_to_be_totalled;
                jump NextOuterLoop_6;
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK150_First: x: x=x.IK150_Link){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK150_First: x: x=x.IK150_Link){
                counter++;
                jump NextOuterLoop_5;
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK150_First: x: x=x.IK150_Link){
                return x;
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K150_desert_flotsam)){
                rtrue;
            }
            rfalse;
    }
];

! How many x satisfy this?
! [ person(x) & 'visible'(x) & NOT[ is(x, 'player') NOT] ]
! in '                                                             '
[ Prop_8  x x_ix counter;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((Adj_3_t1_v65(x)))){
            if (~~((x == player))){
                counter++;
                jump NextOuterLoop_5;
            }
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find a random x satisfying:
! [ person(x) & 'visible'(x) & NOT[ is(x, 'player') NOT] ]
! in '                                                                     '
[ Prop_9  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((Adj_3_t1_v65(x)))){
                if (~~((x == player))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! How many x satisfy this?
! [ plan(x) & 'complete'(x) ]
! in '                                                                                         '
[ Prop_10  x x_ix counter;
    for (x=IK72_First: x: x=x.IK72_Link){
        if (((Adj_42_t1_v65(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ memory(x) & 'retrieved'(x) ]
! in '                                                                             '
[ Prop_11  x x_ix counter;
    for (x=IK43_First: x: x=x.IK43_Link){
        if (((Adj_96_t1_v65(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! True or false?
! [ Exists x : spirit animal(x) & called='potential trader'(x) & 'visible'(x) ]
! in '                                                                                                   '
[ Prop_12  x x_ix ;
    for (x=IK165_First: x: x=x.IK165_Link){
        if (((Adj_3_t1_v65(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ direction(x) & 'brighter'(x) IN] ]
! in '                                                                                                                                                                                                                                                                                                                                                                                                                            '
[ Prop_13  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK3_First: x: x=x.IK3_Link){
        if (((Adj_40_t1_v65(x)))){
            qcn_0++;
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ memory(x) & is(('noun'.p78_suggested_memory), x) ]
! in '                                                                                                '
[ Prop_14  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK43_First: x: x=x.IK43_Link){
            if (((noun.p78_suggested_memory) == x)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Abstraction for set of x such that:
! [ scene(x) & 'dramatic'(x) ]
! in '                                          '
[ Prop_15 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=1: x<=11: x++){
                if ((GProperty(SCENE_TY, x, p85_dramatic))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=1: x<=11: x++){
                if ((GProperty(SCENE_TY, x, p85_dramatic))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=1: x<=11: x++){
                    if ((GProperty(SCENE_TY, x, p85_dramatic))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=1: x<=11: x++){
                if ((GProperty(SCENE_TY, x, p85_dramatic))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=1: x<=11: x++){
                if ((GProperty(SCENE_TY, x, p85_dramatic))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((true) && (GProperty(SCENE_TY, x, p85_dramatic))){
                rtrue;
            }
            rfalse;
    }
];

! How many x satisfy this?
! [ direction(x) & 'viable'(x) ]
! in '                                                     '
[ Prop_16  x x_ix counter;
    for (x=IK3_First: x: x=x.IK3_Link){
        if (((Adj_33_t1_v65(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find a random x satisfying:
! [ thing(x) & is('emotional baggage', ContainerOf(x)) ]
! in '                                                    '
[ Prop_17  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(O45_emotional_baggage): x: x=TestContainmentRange(O45_emotional_baggage,x)){
            if ((x ofclass K2_thing)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('emotional baggage', ContainerOf(x)) ]
! in '                                                                     '
[ Prop_18  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((O45_emotional_baggage == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ memory(x) ]
! in '                                                                     '
[ Prop_19  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK43_First: x: x=x.IK43_Link){
            counter++;
            if (counter == selection) return x;
            jump NextOuterLoop_7;
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Abstraction for set of x such that:
! [ thing(x) & plan((x.p79_objective)) ]
! in '                                                             '
[ Prop_20 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((x.p79_objective) ofclass K72_plan)){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((x.p79_objective) ofclass K72_plan)){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if (((x.p79_objective) ofclass K72_plan)){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((x.p79_objective) ofclass K72_plan)){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((x.p79_objective) ofclass K72_plan)){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && ((x.p79_objective) ofclass K72_plan)){
                rtrue;
            }
            rfalse;
    }
];

! Abstraction for set of x such that:
! [ thing(x) & 'held'(x) ]
! in '                                                    '
[ Prop_21 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_2_t1_v65(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_2_t1_v65(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if (((Adj_2_t1_v65(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_2_t1_v65(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_2_t1_v65(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && ((Adj_2_t1_v65(x)))){
                rtrue;
            }
            rfalse;
    }
];

! True or false?
! [ Card>=2 x IN[ window(x) IN] : 'open'(x) ]
! in '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         '
[ Prop_22  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK119_First: x: x=x.IK119_Link){
        qcn_0++;
        if (((Adj_74_t1_v65(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 2){
        rtrue;
    }
    rfalse;
];

! Abstraction for set of x such that:
! [ thing(x) & plan((x.p79_objective)) ]
! in '                                                             '
[ Prop_23 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((x.p79_objective) ofclass K72_plan)){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((x.p79_objective) ofclass K72_plan)){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if (((x.p79_objective) ofclass K72_plan)){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((x.p79_objective) ofclass K72_plan)){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((x.p79_objective) ofclass K72_plan)){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && ((x.p79_objective) ofclass K72_plan)){
                rtrue;
            }
            rfalse;
    }
];

! Abstraction for set of x such that:
! [ thing(x) & 'held'(x) ]
! in '                                                    '
[ Prop_24 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_2_t1_v65(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_2_t1_v65(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if (((Adj_2_t1_v65(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_2_t1_v65(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_2_t1_v65(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && ((Adj_2_t1_v65(x)))){
                rtrue;
            }
            rfalse;
    }
];

! Find a random x satisfying:
! [ plan(x) & 'complete'(x) ]
! in '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          '
[ Prop_25  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK72_First: x: x=x.IK72_Link){
            if (((Adj_42_t1_v65(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Force this to be true via 'now':
! [ ForAll x IN[ room(x) & 'within range of headlights'(x) IN] : 'lighted'(x) ]
! in '                                                    '
[ Prop_26  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        if (((Adj_36_t1_v65(x)))){
            qcn_0++;
            (Adj_51_t2_v65(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];

! Force this to be true via 'now':
! [ ForAll x IN[ room(x) & 'within range of headlights'(x) IN] : 'dark'(x) ]
! in '                                                                                        '
[ Prop_27  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        if (((Adj_36_t1_v65(x)))){
            qcn_0++;
            (Adj_52_t2_v65(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];

! Force this to be true via 'now':
! [ ForAll x IN[ room(x) & region-contains('tower vicinity', x) IN] : 'lighted'(x) ]
! in '                                                      '
[ Prop_28  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        if ((TestRegionalContainment(x,O164_tower_vicinity))){
            qcn_0++;
            (Adj_51_t2_v65(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];

! Force this to be true via 'now':
! [ ForAll x IN[ room(x) & region-contains('tower vicinity', x) IN] : 'dark'(x) ]
! in '                                                   '
[ Prop_29  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        if ((TestRegionalContainment(x,O164_tower_vicinity))){
            qcn_0++;
            (Adj_52_t2_v65(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];

! Force this to be true via 'now':
! [ ForAll x IN[ room(x) & 'within range of headlights'(x) IN] : 'lighted'(x) ]
! in '                                                    '
[ Prop_30  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        if (((Adj_36_t1_v65(x)))){
            qcn_0++;
            (Adj_51_t2_v65(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];

! Find next x satisfying:
! [ thing(x) & 'switchable'(x) & encloses('location', x) ]
! in '                                                                                '
[ Prop_31  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_34_t1_v65(x))) && (IndirectlyContains(real_location,x))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : thing(x) & called='box'(x) & 'enterable'(x) & is('location', ContainerOf(x)) ]
! in '                                                                                      '
[ Prop_32  x x_ix ;
    for (x=TestContainmentRange(real_location): x: x=TestContainmentRange(real_location,x)){
        if ((x ofclass K2_thing) && ((Adj_71_t1_v65(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) ]
! in '                                             '
[ Prop_33  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ thing(x) ]
! in '                                             '
[ Prop_34  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ thing(x) ]
! in '                                             '
[ Prop_35  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! How many x satisfy this?
! [ thing(x) & 'marked for listing'(x) ]
! in '                                                     '
[ Prop_36  x x_ix counter;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_67_t1_v65(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find next x satisfying:
! [ thing(x) & 'marked for listing'(x) ]
! in '                                                                     '
[ Prop_37  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_67_t1_v65(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Abstraction for set of x such that:
! [ thing(x) & 'unmentioned'(x) ]
! in '                                           '
[ Prop_38 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_70_t1_v65(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_70_t1_v65(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if (((Adj_70_t1_v65(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_70_t1_v65(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_70_t1_v65(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && ((Adj_70_t1_v65(x)))){
                rtrue;
            }
            rfalse;
    }
];

! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
! in '                                                  '
[ Prop_39  const_0 x x_ix ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_30_t1_v65(x)))){
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
! in '                                                                '
[ Prop_40  const_0 x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
! in '                                                  '
[ Prop_41  const_0 x x_ix ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_30_t1_v65(x)))){
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
! in '                                                                '
[ Prop_42  const_0 x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! How many x satisfy this?
! [ thing(x) & is('actor', CarrierOf(x)) ]
! in '                                                                                                 '
[ Prop_43  x x_ix counter;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! True or false?
! [ Exists x : player's holdall(x) & called='current working sack'(x) & is('actor', HolderOf(x)) ]
! in '                                                                                    '
[ Prop_44  x x_ix ;
    for (x=nothing: false: ){
        if ((actor == HolderOf(x))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & is('actor', CarrierOf(x)) ]
! in '                                                                               '
[ Prop_45  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! How many x satisfy this?
! [ thing(x) & is('actor', CarrierOf(x)) ]
! in '                                                                                                                                                                        '
[ Prop_46  x x_ix counter;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is(const_0, SupporterOf(x)) ]
! in '                                                                         '
[ Prop_47  const_0 x x_ix counter;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is(const_0, ContainerOf(x)) ]
! in '                                                                         '
[ Prop_48  const_0 x x_ix counter;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is('second noun', SupporterOf(x)) ]
! in '                                                                                                                                                                                        '
[ Prop_49  x x_ix counter;
    objectloop (x in second) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is('second noun', ContainerOf(x)) ]
! in '                                                                                                                                                                                            '
[ Prop_50  x x_ix counter;
    for (x=TestContainmentRange(second): x: x=TestContainmentRange(second,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find a random x satisfying:
! [ thing(x) & is('emotional baggage', ContainerOf(x)) ]
! in '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            '
[ Prop_51  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(O45_emotional_baggage): x: x=TestContainmentRange(O45_emotional_baggage,x)){
            if ((x ofclass K2_thing)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! How many x satisfy this?
! [ room(x) & 'adjacent'(x) ]
! in '                                                                      '
[ Prop_52  x x_ix counter;
    for (x=IK1_First: x: x=x.IK1_Link){
        if (((Adj_11_t1_v65(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find a random x satisfying:
! [ room(x) & 'adjacent'(x) ]
! in '                                                                                       '
[ Prop_53  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK1_First: x: x=x.IK1_Link){
            if (((Adj_11_t1_v65(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find next x satisfying:
! [ thing(x) & encloses('location', x) ]
! in '                                                                               '
[ Prop_54  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if ((IndirectlyContains(real_location,x))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : container(x) & 'opaque'(x) & 'closed'(x) & encloses(x, const_0) ]
! in '                                                                                '
[ Prop_55  const_0 x x_ix ;
    for (x=IK5_First: x: x=x.IK5_Link){
        if (((Adj_72_t1_v65(x))) && ((Adj_75_t1_v65(x))) && (IndirectlyContains(x,const_0))){
            rtrue;
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & 'visible'(x) & 'detrital'(x) ]
! in '                                                                                                                                                                                                                                                                                             '
[ Prop_56  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if (((Adj_3_t1_v65(x))) && ((Adj_44_t1_v65(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : thing(x) & NOT[ 'scenery'(x) NOT] & is('noun', ContainerOf(x)) ]
! in '                                                                                                           '
[ Prop_57  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            if (~~(((Adj_61_t1_v65(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'player') NOT] & is('noun', ContainerOf(x)) ]
! in '                                                                                                           '
[ Prop_58  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & NOT[ 'scenery'(x) NOT] & is('noun', SupporterOf(x)) ]
! in '                                                                                                           '
[ Prop_59  x x_ix ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            if (~~(((Adj_61_t1_v65(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'player') NOT] & is('noun', SupporterOf(x)) ]
! in '                                                                                                           '
[ Prop_60  x x_ix ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', ContainerOf(x)) ]
! in '                                                                                                                          '
[ Prop_61  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_65_t1_v65(x)))){
            if (~~(((Adj_61_t1_v65(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', SupporterOf(x)) ]
! in '                                                                                                                          '
[ Prop_62  x x_ix ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_65_t1_v65(x)))){
            if (~~(((Adj_61_t1_v65(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & encloses('noun', x) ]
! in '                                                                           '
[ Prop_63  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if ((IndirectlyContains(noun,x))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Force this to be true via 'now':
! [ ForAll x IN[ thing(x) & is(const_0, HolderOf(x)) IN] : 'familiar'(x) ]
! in '                                                  '
[ Prop_64  const_0 x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        if ((const_0 == HolderOf(x))){
            qcn_0++;
            (Adj_90_t2_v65(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];

! Find a random x satisfying:
! [ person(x) & 'visible'(x) & NOT[ is(x, 'player') NOT] ]
! in '                                                             '
[ Prop_65  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((Adj_3_t1_v65(x)))){
                if (~~((x == player))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Force this to be true via 'now':
! [ ForAll x IN[ thing(x) & is(const_0, HolderOf(x)) IN] : 'unfamiliar'(x) ]
! in '                                                    '
[ Prop_66  const_0 x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        if ((const_0 == HolderOf(x))){
            qcn_0++;
            (Adj_91_t2_v65(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];

! Abstraction for set of x such that:
! [ thing(x) & 'unknown'(x) ]
! in '                                        '
[ Prop_67 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_32_t1_v65(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_32_t1_v65(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if (((Adj_32_t1_v65(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_32_t1_v65(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_32_t1_v65(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && ((Adj_32_t1_v65(x)))){
                rtrue;
            }
            rfalse;
    }
];

! True or false?
! [ Exists x : talent(x) & is('player', HolderOf(x)) ]
! in '                                                                                                                                                                     '
[ Prop_68  x x_ix ;
    for (x=IK78_First: x: x=x.IK78_Link){
        if ((player == HolderOf(x))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : plan(x) & 'in progress'(x) ]
! in '                                                                                                                                                                                                                                                                                                                                  '
[ Prop_69  x x_ix ;
    for (x=IK72_First: x: x=x.IK72_Link){
        if (((Adj_41_t1_v65(x)))){
            rtrue;
        }
    }
    rfalse;
];

! How many x satisfy this?
! [ plan(x) & 'in progress'(x) ]
! in '                                                                                                                                                                                                                                                                                                                                  '
[ Prop_70  x x_ix counter;
    for (x=IK72_First: x: x=x.IK72_Link){
        if (((Adj_41_t1_v65(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find a random x satisfying:
! [ plan(x) & 'in progress'(x) ]
! in '                                                                                                                                                                                                                                                                                                                                  '
[ Prop_71  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK72_First: x: x=x.IK72_Link){
            if (((Adj_41_t1_v65(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find next x satisfying:
! [ talent(x) & 'visible'(x) & not-'held'(x) ]
! in '                                                               '
[ Prop_72  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK78_First: x: x=x.IK78_Link){
        if (((Adj_3_t1_v65(x))) && (~~((Adj_2_t1_v65(x))))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : thing(x) & 'handled'(x) & is(const_0, (x.p79_objective)) ]
! in '          '
[ Prop_73  const_0 x x_ix ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_64_t1_v65(x))) && (const_0 == (x.p79_objective))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Card>=2 x IN[ thing(x) & 'handled'(x) IN] : is(const_0, (x.p79_objective)) ]
! in '          '
[ Prop_74  const_0 x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_64_t1_v65(x)))){
            qcn_0++;
            if ((const_0 == (x.p79_objective))){
                qcy_0++;
            }
        }
    }
    if (qcy_0 >= 2){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & plan((x.p79_objective)) & called='item'((x.p79_objective)) & is('player', HolderOf(x)) ]
! in '                                                                                                       '
[ Prop_75  x x_ix ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((x.p79_objective) ofclass K72_plan) && (player == HolderOf(x))){
            deferred_calling_list-->0 = (x.p79_objective);
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : memory(x) & called='selected memory'(x) & is('emotional baggage', ContainerOf(x)) ]
! in '                                                                                                              '
[ Prop_76  x x_ix ;
    for (x=TestContainmentRange(O45_emotional_baggage): x: x=TestContainmentRange(O45_emotional_baggage,x)){
        if ((x ofclass K43_memory)){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : talent(x) & is('player', HolderOf(x)) ]
! in '                                                                     '
[ Prop_77  x x_ix ;
    for (x=IK78_First: x: x=x.IK78_Link){
        if ((player == HolderOf(x))){
            rtrue;
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ talent(x) & is('player', HolderOf(x)) ]
! in '                                                                                                                                                                                                                                     '
[ Prop_78  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK78_First: x: x=x.IK78_Link){
            if ((player == HolderOf(x))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : talent(x) & is('player', HolderOf(x)) ]
! in '                                                                    '
[ Prop_79  x x_ix ;
    for (x=IK78_First: x: x=x.IK78_Link){
        if ((player == HolderOf(x))){
            rtrue;
        }
    }
    rfalse;
];

! How many x satisfy this?
! [ memory(x) & is('emotional baggage', ContainerOf(x)) ]
! in '                                                                                                                   '
[ Prop_80  x x_ix counter;
    for (x=TestContainmentRange(O45_emotional_baggage): x: x=TestContainmentRange(O45_emotional_baggage,x)){
        if ((x ofclass K43_memory)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ memory(x) & is('emotional baggage', ContainerOf(x)) ]
! in '                                                                                                                        '
[ Prop_81  x x_ix counter;
    for (x=TestContainmentRange(O45_emotional_baggage): x: x=TestContainmentRange(O45_emotional_baggage,x)){
        if ((x ofclass K43_memory)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ memory(x) & is('emotional baggage', ContainerOf(x)) ]
! in '                                                                                                                      '
[ Prop_82  x x_ix counter;
    for (x=TestContainmentRange(O45_emotional_baggage): x: x=TestContainmentRange(O45_emotional_baggage,x)){
        if ((x ofclass K43_memory)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ plan(x) & 'complete'(x) ]
! in '                                                                                         '
[ Prop_83  x x_ix counter;
    for (x=IK72_First: x: x=x.IK72_Link){
        if (((Adj_42_t1_v65(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ plan(x) & 'in progress'(x) ]
! in '                                                                                         '
[ Prop_84  x x_ix counter;
    for (x=IK72_First: x: x=x.IK72_Link){
        if (((Adj_41_t1_v65(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find a random x satisfying:
! [ plan(x) & 'complete'(x) ]
! in '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              '
[ Prop_85  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK72_First: x: x=x.IK72_Link){
            if (((Adj_42_t1_v65(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : plan(x) & 'in progress'(x) ]
! in '                                                                         '
[ Prop_86  x x_ix ;
    for (x=IK72_First: x: x=x.IK72_Link){
        if (((Adj_41_t1_v65(x)))){
            rtrue;
        }
    }
    rfalse;
];

! How many x satisfy this?
! [ memory(x) & is('emotional baggage', ContainerOf(x)) ]
! in '                                                                                                        '
[ Prop_87  x x_ix counter;
    for (x=TestContainmentRange(O45_emotional_baggage): x: x=TestContainmentRange(O45_emotional_baggage,x)){
        if ((x ofclass K43_memory)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ memory(x) & is(const_0, HolderOf(x)) ]
! in '                                                                    '
[ Prop_88  const_0 x x_ix counter;
    for (x=IK43_First: x: x=x.IK43_Link){
        if ((const_0 == HolderOf(x))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ memory(x) & is(const_0, HolderOf(x)) ]
! in '                                                                    '
[ Prop_89  const_0 x x_ix counter;
    for (x=IK43_First: x: x=x.IK43_Link){
        if ((const_0 == HolderOf(x))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find a random x satisfying:
! [ direction(x) & 'cardinal'(x) ]
! in '                                     '
[ Prop_90  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK3_First: x: x=x.IK3_Link){
            if (((Adj_43_t1_v65(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! How many x satisfy this?
! [ thing(x) & is('overturned barrel', SupporterOf(x)) ]
! in '                                                                                                                                                                                                                                   '
[ Prop_91  x x_ix counter;
    objectloop (x in O110_overturned_barrel) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! True or false?
! [ Card>=1 x IN[ thing(x) & plan((x.p79_objective)) IN] : 'carried'(x) ]
! in '                                                                                                                                                                        '
[ Prop_92  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((x.p79_objective) ofclass K72_plan)){
            qcn_0++;
            if (((Adj_1_t1_v65(x)))){
                qcy_0++;
            }
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];




[ Resolver_0 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_954_r9 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_1 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction)))) { return  RoomOrDoorFrom(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_2 t_0 t_1 filename line;
if ((((t_0 ofclass K4_door)))) { return  OtherSideOfDoor(t_0,t_1) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_3 t_0 t_1 t_2 filename line;
if ((((t_0 ofclass K3_direction)))) {  AssertMapConnection(t_1,t_0,t_2);  rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_4 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_755_r13 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_5 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_831_r23 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_6 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_830_r24 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_7 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_785_r31 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_8 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction))) && (((t_1 ofclass K1_room)))) { return  MapConnection(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_9 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction)))) { return  MapConnection(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_10 t_0 t_1 filename line;
if ((((t_1 ofclass K1_room)))) { return  RoomOrDoorFrom(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_11 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_814_r37 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_12 t_0 filename line;
if ((t_0 == O168_sand_dancer)) { return ((PHR_1230_r40 (t_0))); }
return ((PHR_1105_r41 (t_0)));
  rfalse; ];
[ Resolver_13 t_0 t_1 filename line;
if ((((t_1 ofclass K1_room)))) { return  MapConnection(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];



Array ConstantListPointers --> 
 0 0;

Constant SC_439 = "         S A N D - D A N C E R";
Constant SC_166 = " ";
Constant SC_480 = " - ";
Constant SC_585 = " - custom}";
Constant SC_483 = " / ";
Constant SC_201 = " a slightly brighter place to ";
Constant SC_505 = " about ";
Constant SC_323 = " again?~ Buster asks, sniffing disdainfully, except he's not Buster any more, more like Eminem. ~I thought you quit that shit, dawg. It's cool, I won't tell your grandma, but it makes Thumper cry a little, you know what I'm sayin";
Constant SC_326 = " all those windows,~ Buster says, except he's not Buster any more, more like Eminem. ~Way to stick it to the man. You hella bad, dawg. Maybe you can tag some shit when you get back to town too.~ ";
Constant SC_601 = " all wrong. That's not really how it happened, was it? Was it, Knock? Was--~ and they repeat and overlap and echo and fade back into the mutters of the static";
Constant SC_772 = " and ";
Constant SC_740 = " and all your gas has drained away, sucked dry by the thirsty desert sand. ";
Constant SC_401 = " and blackness swallows you up";
Constant SC_710 = " and clumps of pale ";
Constant SC_791 = " and dirt near ";
Constant SC_771 = " and everything is strewn with ";
Constant SC_256 = " and free, most of all free. You walk backwards across the sand to your truck, sucking up your footprints as you go, and slip behind the wheel. There's this crazy wrenching bang and you jerk backwards as the engine starts, uncrashing your pickup off the cactus and juddering back onto the highway, and you smile. You're going back, back to a second chance, back to make it all right.^^You speed up, drive backwards at a thousand miles an hour to work, and unfix junkers and repack parts in a flash, faster and faster. The days rewind like videotape, unwork, unsleep, giving back kisses from Ocean one by one";
Constant SC_591 = " and it freaks the hell out of you. The voice weaves in and out of crazy whirling distortion and shifting blasts of static. ~Hey... receiving? ...never told... you'll never, never--~ A wail like an 8-bit banshee screams through the signal. ~...waste of time... who do you think?...~ Static, static. ~Very soon now, Nak... akaibito... very...~";
Constant SC_789 = " and its ";
Constant SC_408 = " and pull out the duct tape.";
Constant SC_793 = " and some ";
Constant SC_727 = " and that's about it";
Constant SC_277 = " and your blanket keeps you warm and you keep going.^^When you hit the Pacific you roll up your jeans and wade into the surf for the first time in your life. And it's warm on the top and cool underneath and this is all you want, this moment, this here and now. You'll find work and you'll find love but you'll never find home and that's okay. It's okay. You wade deeper and the waves lap higher and then a big one rolls in, blue and white, and you feel ";
Constant SC_711 = " are all ";
Constant SC_758 = " are hardly visible in the ";
Constant SC_811 = " are pushed against one wall, and open doorways lead west and north.";
Constant SC_280 = " as it crests and smashes into you with the force of all the water in the world, and you laugh and try to stay on your feet but it's too late, you're crashing, you're crashing, you crash...";
Constant SC_617 = " as you step back, inhaling the dry smoke";
Constant SC_259 = " before your luck started turning around, yeah, cause";
Constant SC_574 = " behind.";
Constant SC_783 = " blinks on and off";
Constant SC_200 = " by your feet, and";
Constant SC_531 = " cig";
Constant SC_817 = " climbs through ";
Constant SC_430 = " control panel for the building's emergency lights.";
Constant SC_314 = " could you have driven fifteen miles off the road and not remember? How is that even possible?";
Constant SC_492 = " do";
Constant SC_535 = " doesn't go any higher than ";
Constant SC_534 = " doesn't go any lower than ";
Constant SC_766 = " drift against ";
Constant SC_784 = " drifts lazily against the rusted metal among ";
Constant SC_269 = " even though you think you're finally strong enough to take her old man";
Constant SC_734 = " except a few feet of ";
Constant SC_263 = " falling, plummeting back faster and faster like you got pushed off the cliff of now. You're unmeeting Ocean and unditching school and unsmoking for the first time behind the dumpsters, faster and faster, stomach in your throat, memories blowing back your hair as they rocket past. You're a kid again unskateboarding and unlearning video game combos, screaming backwards faster and faster and you get it now, you get the lizard's joke. He's making you free by unmaking you, fixing the burden by erasing the guy who's bearing it, and you're unlearning to read and unlearning to walk and uncrawling and uncrying and then some brilliant moment of light and noise and chaos comes shrieking towards you hella fast, fast, faster than anything and it's too late, you're crashing, you're crashing, you crash...";
Constant SC_543 = " from ";
Constant SC_737 = " from the south stop abruptly here, but where the hell are you? ";
Constant SC_769 = " from your dimming headlights seep through the empty window frame, but you can barely make out anything of the interior";
Constant SC_358 = " has its place. But if you're always in the spotlight, you'll never learn how to live in the shadows. And most of us spend a lot of time in the shadows.~";
Constant SC_454 = " here";
Constant SC_210 = " in exasperation. How did you get into this mess?";
Constant SC_175 = " in front of it, but it just flicks its tongue in and out a little faster, staying put.";
Constant SC_184 = " is already broken.";
Constant SC_536 = " is already tuned to that frequency.";
Constant SC_790 = " is nothing but a scraggly patch of ";
Constant SC_773 = " is southwest, alongside the empty window frame; other rooms lie north and east";
Constant SC_797 = " is stained with rust.";
Constant SC_837 = " is, and with those ";
Constant SC_115 = " isn't here.";
Constant SC_333 = " job.~ And there's actually like a bleep, too, and now that you think of it you only ever saw 8 Mile on TV.";
Constant SC_532 = " left";
Constant SC_744 = " linger in the chill air.";
Constant SC_781 = " looming like some gargantuan spider into blackness above you";
Constant SC_85 = " makes you want to brood about ";
Constant SC_610 = " might be useful if you decide on ";
Constant SC_761 = " must've been some sort of utility structure for ";
Constant SC_568 = " nods. ~Yes,~ he says, ~a fair trade.~ And something happens inside you as he says it. ";
Constant SC_494 = " not respond.";
Constant SC_603 = " now you're going to be anything other than a pathetic failure?~ the radio squawks angrily";
Constant SC_328 = " off those cancer sticks,~ Buster says, except he's not Buster any more, more like Eminem. ~Don't think I ain't watchin";
Constant SC_431 = " once led to a control booth higher up the tower, but the lower handholds have rotted away and collapsed. ";
Constant SC_444 = " or ";
Constant SC_436 = " over underneath, though";
Constant SC_713 = " pick out before barely reaching";
Constant SC_643 = " right now.";
Constant SC_778 = " rises from ";
Constant SC_799 = " rising up in front of you. At your feet is the way back down.";
Constant SC_438 = " rusts quietly some distance away";
Constant SC_160 = " says. ~That's not how it works. You have to TRADE something for it.~";
Constant SC_186 = " says. ~You have to TRADE it for something.~";
Constant SC_559 = " says.";
Constant SC_569 = " shifts and wriggles and fades away and it's still there, but now it's shifted, become something else. And yeah, it kinda does feel like you could call it ";
Constant SC_306 = " sinks into the sand.";
Constant SC_842 = " sits before you, breathing, watching.";
Constant SC_182 = " smashes through ";
Constant SC_460 = " smell it, sweaty fur and terror. You race after it.";
Constant SC_839 = " smoke.";
Constant SC_763 = " sparkles faintly in the beam of your headlights";
Constant SC_800 = " stands upright and intact nearby, ";
Constant SC_578 = " stands. As you watch he raises a hand and waves.";
Constant SC_810 = " strewn with ";
Constant SC_278 = " strong, strong";
Constant SC_427 = " supporting hundreds of dusty ";
Constant SC_261 = " this time you unmake love. And the moment unpasses and your future is safe and uncomplicated, no kid, no nightmares, no arguments, no lectures, and you just have to get this thing out of reverse now and do it right this time (or mebbe not at all, it's too hot anyway ya know babe?) and this time you'll make everything perfecto.^^But you don't turn around. You try, but it's kinda like trying to stop falling, and you suddenly get that you ";
Constant SC_805 = " this tiny office, probably once where the boss sat under ";
Constant SC_565 = " through your nerve endings. ~Good,~ he says, ~I'll take that, although it's not enough to complete the trade.~";
Constant SC_743 = " ticks and groans, smashed gracelessly against ";
Constant SC_539 = " to ";
Constant SC_716 = " to the north";
Constant SC_762 = " to the north, now abandoned";
Constant SC_767 = " to the northeast leading inside; you could also walk around to the east or head south back to your truck.";
Constant SC_818 = " to the roof.";
Constant SC_564 = " touches your fingertips and pulls ";
Constant SC_433 = " underneath, though";
Constant SC_90 = " waves again, out in the deep desert.";
Constant SC_606 = " worthless. You'll never amount to anything, and neither will your kid, just another half-breed loser destined to die in poverty and live in debt, isn't that right, Knock?~ and with a sudden shock you realize why the voice sounds so familiar. It's your voice. It's your own god-damned voice";
Constant SC_329 = " ya.~ ";
Constant SC_449 = " you ";
Constant SC_838 = " you can't even tell whether he's smirking at you or just twitching his mouth. There's a weird smell coming off him, sweat and dirt and a little wet dog and something deeper, earth, desert, rain, all mixed with ";
Constant SC_424 = " you should have given up months ago";
Constant SC_282 = " you want to brood about, it's ";
Constant SC_202 = " your shivering hand";
Constant SC_308 = "~...out there?~ the speaker blurts and holy crap, someone's responding, and they say ~Roger roger, tower station nineteen, read you now loud and clear, what's your forty?~ and the voice is staticky and whirled through with weird rhythmic distortions but you can hear it just fine and now what?";
Constant SC_334 = "~Anyway, look, man, we both know you're in trouble. I just gotta ask you one question.~ And he changes again into like a giant silhouette, and it's the Playboy Bunny, ears and bow tie and all. ~Do you love her?~";
Constant SC_383 = "~By your actions and through your talents, you have chosen ";
Constant SC_312 = "~Copy that,~ the voice says briskly after a moment. ~You're at tower station nineteen, son, about thirty-two miles southwest of Oro Oeste, fifteen miles or so from the state highway.~ And if the mike wasn't attached to the radio you'd drop it on the floor. Fifteen miles? How in the ";
Constant SC_616 = "~Gotta keep an eye on the horizon,~ he says in a scratchy, slow voice";
Constant SC_315 = "~Hello?~ the radio says. ~Hello, son, do you copy?~";
Constant SC_360 = "~Here we have luck,~ he says, bobbing the left, ~and scent. And look, I'll be straight with you. These are precious things and I can't afford whatever blue light special deal the bunny gave you. I need double his price. I need two memories to part with one of these. Oh, they're worth it, believe me. Both have saved my ass more times than you'd believe. Both could save yours. But it's up to you. Which'll it be?~";
Constant SC_327 = "~Hey yo, you been hella good about keepin";
Constant SC_332 = "~Hey, back off, man,~ he says, ~it's my ****in";
Constant SC_374 = "~I am Sand-dancer,~ he breathes, ";
Constant SC_340 = "~I came all this way to help you,~ the rabbit says, ~I'm even missing the big parade,~ and it wiggles its tail with a smell of sugar and frosting. ~I think we'd better make a trade.~";
Constant SC_560 = "~I only have talents to offer you,~ says ";
Constant SC_558 = "~I'm only interested in trading memories,~ ";
Constant SC_622 = "~I'm the Coyote,~ he says. ~And we've been hiding from each other for a long time.~";
Constant SC_626 = "~It doesn't matter,~ he says more calmly, as the lizards subside, ~since you have already made your choice. You cannot take back your actions. You cannot unmake the past.~ The lizards around him tilt their head, edge forward cautiously, and he seems to grin. ~But I can";
Constant SC_343 = "~Look up, Naki,~ he says again.";
Constant SC_611 = "~Look, son,~ the voice says, ~I don't know how you got out there but that's not important right now. Weather report's coming in and there's a cold front the size of Texas coming your way. I don't want to scare you but if you don't find a way home, or figure out some food and shelter for the night, you could freeze to death. You hear me? Now on account of the cutbacks I don't have anyone to send out there until morning. But there may be parts around that old tower you can use to patch up your truck and make it back to the highway. Or, there may be emergency supplies that would get you through the night. This storm's gonna blow out all our communication, so you're gonna be on your own. It's up to you. Over and out.~";
Constant SC_613 = "~Look,~ he says, and now he's big and fluffy and smells like springtime and peeps. ~I can help you make your decisions. I'll trade you for one of these talents.~ He holds out an ";
Constant SC_361 = "~Looks like you're already pretty tough,~ he says appraisingly, looking you over. ~With a little luck, you ought to make it through the night and get on with the rest of your life.~";
Constant SC_337 = "~Might be useful for surviving through the night,~ he says, ~if that's what you're planning.~";
Constant SC_378 = "~Much has happened tonight. You've made bargains and plans. ";
Constant SC_567 = "~No, no, I don't want that,~ says the rabbit, twitching its nose indignantly. ~For a talent like this, you ought to put up something real. Something you care about.~";
Constant SC_185 = "~No, not like that,~ ";
Constant SC_252 = "~No?~ Sand-dancer says, and the lizards quiver anxiously. ~You're not happy with the path you've chosen? ";
Constant SC_319 = "~Oh come on, pal, you know me,~ he says with this kind of stupid cheerful tone, and suddenly he looks more like Buster from Arthur, scrawny and poorly animated. ~I've been keeping an eye on you from the TV all these years. Your grandma asked me to, remember?~ He grins, buck teeth protruding.";
Constant SC_321 = "~Oh, don't say that!~ the rabbit says, animated eyes going round like saucers. ~Then it'd be just you here all alone, and wouldn't that be boring. It's much more interesting if I'm really around.~";
Constant SC_320 = "~She was wrong about lots of stuff,~ Buster says, scratching himself with a hind paw thoughtfully, ~but right about lots too. Oh, lots.~";
Constant SC_318 = "~So what'd you expect from an animal guardian?~ it says, but like not with its lips, somewhere in your head instead. ~Were you thinking big, nasty, sharp, pointy teeth? Waistcoat and pocket watch? Nah. Tricks are for kids. What's up, Knock?~ Its whiskers twitch.";
Constant SC_615 = "~Strength,~ he says, pointing to the first one, ~and courage. Pick whichever one you think will be most useful, but you have to give me something back. Something real, something I can work with.~";
Constant SC_348 = "~That's better,~ he says. He takes a drag on the cigarette, then pulls another from behind his ear and offers it to you. ~Smoke?~";
Constant SC_571 = "~The choice is made,~ he rumbles, ~your path is set. Goodbye, Nakaibito.~ And he turns and dives into the sand. The lizards twist and writhe and follow him.";
Constant SC_366 = "~The last of us is coming,~ Coyote's voice says out of the black, ~last and most powerful, and most dangerous, and most afraid. Sand-dancer. Be careful of him, Knock. ";
Constant SC_341 = "~The others are coming,~ he says, ~they'll be here soon,~ and now he looks like Frank from Donnie Darko and his face is behind that freaky metal mask and his voice is distorted and makes your skin crawl.";
Constant SC_382 = "~The tape and the gas can will return you to her. The blanket and the can of food will look out for you. Take one.~";
Constant SC_244 = "~Then what are you still doing with her?~ the bunny says. ~Get out while the getting's good. You think either of you will be happier if you put that off? There's fish in other oceans kid. You've got your whole life ahead to swim.~ It winks.";
Constant SC_243 = "~Then you should probably get home and tell her,~ the bunny says. ~Patch up that truck and fly down that highway before she gets away.~ It winks.";
Constant SC_342 = "~Watch out for them,~ he says. ~We all want to help, but... the others are wilier than me. Look up.~";
Constant SC_396 = "~With freedom, Nakaibito, you can make your troubles vanish. True freedom is the power of unmaking the past, of undoing what's done and regretted. This power is great and terrible, but I promise you.~ He flicks his tongue. ~It will set you free.~";
Constant SC_335 = "~Yeah,~ the bunny says, ~well this is the night to figure it out. Whether you decide to go home to her tonight or take care of yourself tonight might have consequences on a night with a storm like the one that's coming. Just sayin";
Constant SC_250 = "~Yes?~ Sand-dancer says, and the lizards quiver anxiously. ~You're happy with the path you've chosen? ";
Constant SC_325 = "~Yo, nice work breakin";
Constant SC_322 = "~Yo, you started smokin";
Constant SC_159 = "~You can't just have it,~ ";
Constant SC_363 = "~You found some cojones, kid,~ he says, ~If you can just sniff out the right finds, you can probably get back to that little lady you're so fond of, if that's what you want.~";
Constant SC_362 = "~You found some cojones, kid,~ he says, looking you over appraisingly, ~which'll be good for fixing your truck and getting back to your girl. I don't know if luck'll help you out much there, though.~";
Constant SC_395 = "~You have the tools to fix your truck,~ he says, ~but to return to Ocean and stand by her side you will need honor.~";
Constant SC_394 = "~You have the warmth and energy you need to stay through the night,~ he says, ~but to continue looking out for yourself, you will need spirit.~";
Constant SC_352 = "~You know who I am,~ he says, ";
Constant SC_602 = "~You think just because you've got ";
Constant SC_339 = "~You won't lose what you trade entirely,~ he says, twitching his whiskers, ~but it will change, transverse, be resurrected as something else. Reborn.~";
Constant SC_338 = "~You're going to need it to get home to Ocean,~ he says, ~if that's what you want.~";
Constant SC_605 = "~You're nothing,~ the radio spews, ~your ";
Constant SC_364 = "~You're pretty tough,~ he says, ~but I don't know that a good nose is going to help you make it through the night and get on with the rest of your life, if that's what you're trying to do.~";
Constant SC_598 = "'s going to help you with anything? You can't even--~ and static reclaims it again";
Constant SC_499 = "(";
Constant SC_330 = "(Oh hey, Rabbit Smith, you get it.)";
Constant SC_118 = "(addressing ";
Constant SC_581 = "(first getting ";
Constant SC_103 = "(first getting out of ";
Constant SC_123 = "(first taking the cigarettes)";
Constant SC_122 = "(first taking the lighter)";
Constant SC_104 = ")";
Constant SC_445 = ", ";
Constant SC_561 = ", ~";
Constant SC_377 = ", ~they come with me wherever I go. They will not bother you.~";
Constant SC_830 = ", and ";
Constant SC_248 = ", and leans forward for you to light up off him. His sunglasses reflect back nothing but your own face weirdly lit by the glow from the cig, and for a moment it's like the blackness behind them is deep, deeper than the sky, deeper than the universe...";
Constant SC_257 = ", and the smell of the past unfurling is like wine and ozone";
Constant SC_540 = ", and the static resolves into a clear signal";
Constant SC_541 = ", and the voice dissolves into static";
Constant SC_759 = ", and you can barely make out the way north back to your truck.";
Constant SC_345 = ", and, ridiculously in the darkness, a pair of cheap ";
Constant SC_114 = ", at least on this frequency";
Constant SC_604 = ", before dissolving into harsh buzzing distortions";
Constant SC_255 = ", braver than the sun now";
Constant SC_823 = ", broken equipment, and junk are everywhere. Back down is the only place to go.";
Constant SC_407 = ", brushing the cobwebs away impatiently,";
Constant SC_524 = ", but ";
Constant SC_862 = ", but the speaker keeps buzzing and the lighted dial keeps flickering";
Constant SC_415 = ", but you are not afraid";
Constant SC_893 = ", but you can't seem to snap yourself out of whatever this is. Doesn't feel like a dream, anyway.";
Constant SC_260 = ", but";
Constant SC_229 = ", causing a nearby window to quiver in the reflected light";
Constant SC_268 = ", crazy courage her sister at least appreciated if not her old man";
Constant SC_777 = ", featureless except for ";
Constant SC_402 = ", leaving only the ghostly beam of your flashlight";
Constant SC_404 = ", like tons of sand sliding over metal";
Constant SC_792 = ", littered by ";
Constant SC_858 = ", little sand-dancers, are burrowing up from somewhere underground, scattering and writhing in some complex pattern in a huge circle all around you.";
Constant SC_292 = ", mangy shadows slinking away into the desert. Except for one last coyote who stands his ground.";
Constant SC_272 = ", not afraid any more";
Constant SC_780 = ", one of three legs of ";
Constant SC_886 = ", probably not a good plan.";
Constant SC_588 = ", revealing ";
Constant SC_775 = ", revealing a hole criss-crossed with ";
Constant SC_183 = ", shattering it.";
Constant SC_423 = ", still smelling liked spilled gas";
Constant SC_273 = ", strong enough now to wait out the night";
Constant SC_254 = ", stronger than wind now";
Constant SC_550 = ", swallowing it whole. ~";
Constant SC_594 = ", the voice distorted now under a constant barrage of electronic rain. ~Where do you think you're going?~ it says. ~What are you trying to do? You can't...~ A snap, some syncopated crackles. ~...can see you, Na... know where... never going to work. Never g--~ And the voice cuts off, replaced by a low, tooth-rattling hum.";
Constant SC_735 = ", then blackness";
Constant SC_347 = ", then holds up a hand in annoyance to block your flashlight beam. ~Turn that thing off,~ he says, and either you do it or it goes off by itself, because the next thing you know it's darker and he's closer and the only light comes from the red glow of the cigarette.";
Constant SC_405 = ", then quickly resolves into nothing more than a quiet hum";
Constant SC_888 = ", they already think you have anger management issues.";
Constant SC_851 = ", to the ";
Constant SC_870 = ", weight training?";
Constant SC_733 = ", which is all you can see out ";
Constant SC_717 = ", which is weird because you're damn sure you turned it off";
Constant SC_443 = ",";
Constant SC_384 = ",~ he says, ";
Constant SC_391 = ",~ he says, ~the last talent you need to achieve your goal, and you can have it for three memories. But perhaps I have something else to trade.~";
Constant SC_847 = "-- ";
Constant SC_140 = ". ";
Constant SC_618 = ". ~Always someone hunting. Border Patrol, National Guard, INS, Minutemen. You want to help people get where they're going out here, you need more than ";
Constant SC_351 = ". ~But it's not my stories that will help you.~";
Constant SC_380 = ". ~But now is the time.~";
Constant SC_355 = ". ~He's got his upsides, I guess. ";
Constant SC_597 = ". ~Hey,~ the speaker shouts, ~hey, do you really think that ";
Constant SC_375 = ". ~I am the desert and the dust and the rain and the wind. I was there the first time you went hungry and the first time you made love and the last time you asked for help, but I could not help you then. But tonight, Nakaibito, tonight I can.~";
Constant SC_353 = ". ~I'm the one who runs on both sides of the fence. I'm the one who scouts ahead. I'm the one with songs in my blood and dirt under my nails and people owe me money in every trailer park town from here to Yuma, or maybe I owe them money but anyway they don't want to see me. You know who I am, Knock.~";
Constant SC_600 = ". ~It makes for a nice story,~ the whispers say, ~but you're remembering ";
Constant SC_350 = ". ~Kid,~ he says, ~you don't want my advice. I could tell you some stories and you'll smile and be sure they'll never happen to you. I could tell you some stories and you'll yawn and think you know them already. I could tell you some stories and you'll think they're wise and not realize you don't understand them until you make the same mistakes yourself and try to turn your failure into advice and fail at that, too. I could tell you some stories.~ He looks off towards the horizon, ";
Constant SC_285 = ". ~Yes, hello, little one. Strange thing to say when I've always been with you, watching, waiting. But hello, hello at last, Nakaibito.~";
Constant SC_385 = ". ~You have looked into yourself and found your story, the path you will walk tomorrow.~";
Constant SC_258 = ". And then it's that night, the night you made the Big Mistake";
Constant SC_203 = ". As your thumb starts to burn you let the puny light go out.";
Constant SC_570 = ". Cool.";
Constant SC_794 = ". Desert stretches in all directions; back west is the front of the building.";
Constant SC_346 = ". He lights a ";
Constant SC_736 = ". Hell, you must have driven off the road and crashed. Ocean keeps telling you this night commute on this lonely highway's gonna kill you; maybe you should start listening";
Constant SC_178 = ". In legends, the sand-dancer was a clever trickster and twister of words, who created night by tricking the sun into spending half the day underground.~ Huh.";
Constant SC_725 = ". Nothing to write home about";
Constant SC_371 = ". Remember the shadows.~";
Constant SC_270 = ". She's awake of course, always no matter how quiet you are, and she holds out a hand from somewhere under the blankets. And as she's doing it you're suddenly exhausted, beyond exhausted but also safe, warm even before you slip under the covers. She half turns to kiss you as you fumble with the blankets but you're so tired all you can do is push your face against her neck and slip an arm around her warm skin, and she starts to ask you something but it's too late, you're crashing, you're crashing, you crash...";
Constant SC_809 = ". Some ";
Constant SC_765 = ". Tendrils of ";
Constant SC_816 = ". The break room lies back to the south and a ";
Constant SC_785 = ". The desert stretches in all directions except back south or southeast towards the ";
Constant SC_806 = ". The only exit is to the south.";
Constant SC_147 = ". You lift it ";
Constant SC_621 = ". You need to learn how to hide.~";
Constant SC_470 = ". You think about Ocean and how pissed she's gonna be that you're not home. Like you tell her not to wait up for you but she always does anyway.^^Some wind kicks up and chucks sand in your face. You blink it out and kinda realize while you're doing it that you haven't really been paying attention to where you've been going. Another gust whines through the sagebrush and you realize with a kind of heavy feeling that with all the dust this wind is kicking up you can't see a damn thing. You can't see your pickup, you can't see the electrical tower. Not even your damn footprints. You're lost. Well, shit.";
Constant SC_77 = ".";
Constant SC_336 = ".~ It winks.";
Constant SC_251 = ".~";
Constant SC_507 = ".)";
Constant SC_731 = ".^^Almost nothing. Yeah, exactly what you'd turn into on the cold day in hell you move to Juza. But on the other hand, that was before you met Ocean. Now the road back to Oro Oeste seems longer and longer every night.";
Constant SC_274 = ".^^In the morning some highway patrol dude shakes you awake with a lecture and a ride back to town. Oro Oeste? he asks but you tell him no, take a left instead, and you end up on a street corner in Pobre Vista and keep going. Seven Sticks and then Gallup and then Flagstaff, hitching west. The cash in your wallet runs out but a trucker buys you a value meal and ";
Constant SC_267 = ".^^You shut off the headlights as you pull up to the trailer, and climb in through her window for old times sake";
Constant SC_701 = "/unicode 33/";
Constant SC_700 = "/unicode 46/";
Constant SC_702 = "/unicode 63/";
Constant SC_703 = "/unicode 91/";
Constant SC_704 = "/unicode 93/";
Constant SC_98 = ": ";
Constant SC_764 = ": it seems dead and alone in the dusty beam of your flashlight";
Constant SC_455 = ":";
Constant SC_475 = "; ";
Constant SC_782 = "; far above you ";
Constant SC_614 = "; in it are two glowing orbs.";
Constant SC_503 = "; or ";
Constant SC_779 = "; you shine your flashlight up towards the tower looming above you";
Constant SC_446 = "> ";
Constant SC_61 = ">";
Constant SC_151 = "?";
Constant SC_324 = "?~ ";
Constant SC_437 = "A ";
Constant SC_2 = "A Desert Fable";
Constant SC_756 = "A brown-colored lizard clings to the cactus";
Constant SC_86 = "A coyote snaps his teeth, lunging forward then fading back into the pack.";
Constant SC_388 = "A glistening egg rises from the sand, glowing with neon potential, and the lizard glances down at it almost dismissively. ~This is ";
Constant SC_551 = "A good start,~ he says, ~but you must trade more.~";
Constant SC_92 = "A howl from behind you, and an answer from somewhere ahead. Coyotes. Hungry, sounds like.";
Constant SC_623 = "A life on the run, alone, work time in one town, jail time in another, no job, no skills, no family?~ ";
Constant SC_3 = "Aaron Reed and Alexei Othenin-Girard";
Constant SC_876 = "About what you'd expect.";
Constant SC_807 = "According to the poster, the emergency radio frequency is ";
Constant SC_196 = "All you can do is run.";
Constant SC_722 = "All you can make out in the darkness ";
Constant SC_33 = "Almost looks like an antique. How long has this place been deserted, anyway?";
Constant SC_15 = "Always a faint whiff of gas in your truck, even on the highway at midnight with the windows cranked and scorching summer air sending Ocean's hair twisting and curling behind the passenger seat. The two of you driving through the night to visit her aunt in Santa Rosa, about a week before it happened, talking and laughing and sometimes her hand on your leg and sometimes your hand on hers, nothing alive but you and her and the truck and the road and the blackness beyond.^^Then all quick she leans forward at a green phantom roadsign and goes hey look, it's the road to Nakaibito! And you have no idea what she's talking about till you remember the story (and that you told her the story) and she says come on, let's go, let's find out what's there. And you're like what, now? And she laughs and says when else? And it's crazy and you tell her it's crazy, it'd be like a four hour drive there and four hours back, totally out of your way and probably for nothing, a couple trailers and broken glass, and you pass the exit and drive on and tease her a little but inside you're thinking, this is why I love her (if I do), that crazy, that what-the-hell let's do something wild and go with it spark, that's Ocean. That's your girl. And maybe you should have done it because now maybe your days of crazy gambling road trips are over, and maybe you'll never find out what's in Nakaibito or anywhere else.";
Constant SC_372 = "And it seems like he's growing, larger and larger, the red tip of his cigarette pulsing and glowing now high up in the sky, and you stumble back, shivering, and suddenly remember your flashlight in your hand and switch it on...";
Constant SC_856 = "And then the ground drops out from under you, heaves, and drops again. Struts groan and boards snap and then with a whooshing bang sand starts pouring in through the window and every crack, jets of sand, and already it's shin-deep and holy christ you've got to get out of here.";
Constant SC_60 = "And then you blink, and realize he's not a coyote after all. Just... just a guy.";
Constant SC_572 = "And then, just as quiet settles, another huge rumble shakes the ground, and, almost like an afterthought, the building breaches the sand and rises to the surface.";
Constant SC_860 = "And with a mighty heave, a huge lizard crests through the sand right in front of you.";
Constant SC_528 = "And you still haven't quit smoking. ";
Constant SC_608 = "Angry distortion bubbles and pops from the radio speaker, twisting in weird rhythmic patterns";
Constant SC_5 = "As good-looking as ever.";
Constant SC_239 = "As if. All you can really do is BROOD ABOUT it.";
Constant SC_305 = "As you take it, ";
Constant SC_795 = "Atop one ";
Constant SC_304 = "Barely able to reach the ladder through sand up to your waist, you haul yourself up the rungs and pull free just in time.";
Constant SC_776 = "Behind ";
Constant SC_788 = "Behind the rather small ";
Constant SC_440 = "Beta testing courtesy of Duncan Bowsman, Jacqueline A. Lott, Juhana Leinonen, Sharon R., and Stephanie Camus.";
Constant SC_198 = "Better keep it with you. It's hella dark out.";
Constant SC_105 = "Better not. ";
Constant SC_357 = "Bravery";
Constant SC_34 = "But hey, on one pile here's a perfectly good can opener.";
Constant SC_379 = "But these things together do not help you. No, you still haven't decided.~ The lizard stares at you with one eye, ";
Constant SC_826 = "Clouds of dust swirl through the air";
Constant SC_821 = "Cold blue metal, and hefty.";
Constant SC_887 = "Come on ";
Constant SC_93 = "Coyotes call all around you now, circling in the dark, unseen, but coming closer, closer.";
Constant SC_863 = "Damnit, you already did!";
Constant SC_156 = "Dodging after the fleeing, skittering shadow, you're almost caught up to it when your foot trips on a rock and you stumble to the ground. But the ground doesn't stop your fall, it collapses, and you're tumbling in a shower of dirt clods down a hole, rolling down some crazy underground tunnel clutching at mud and roots, till finally you slide into some damp, fetid place, and come up a stop against something soft, huge, warm. And furry.";
Constant SC_719 = "Dusty glass panes.";
Constant SC_512 = "Eh. You couldn't really get into a good brood about that when it's this damn cold.";
Constant SC_880 = "El zilcho";
Constant SC_820 = "Emitting a good, strong beam: thank god it works.";
Constant SC_102 = "Except it's more like a foundation now, the building's sunken almost entirely into the sand.";
Constant SC_190 = "Fading away in the chill night air, but enough to tell you something on your truck's busted bad.";
Constant SC_768 = "Faint ";
Constant SC_311 = "Feeling a little stupid, you come clean and tell the voice that you drove off the road and aren't sure really exactly where you are.";
Constant SC_62 = "Fiction";
Constant SC_891 = "For whatever reason you've never felt more awake.";
Constant SC_16 = "Four weeks ago now, a little colder and a little darker. On a night just like this one except you didn't drive off the road and crash into a cactus, you got off work and drove the state highway in the dark and crossed over the edge of the res to Ocean's dad's trailer, and she told you that night while you were dead exhausted, Knock, I'm pregnant.^^And all you could think was how totally not real it seemed, after an hour of blackness and New Mexican night streaming by, bugs exploding in tiny tragedies on your windshield, you just felt like driving on, like this thing was some podunk town you could breeze by, no services, ranch exit only. And you thought of every movie they ever made you watch in school and every lecture and every living example, the drunken uncles and snaggle-toothed coworkers who knocked up their high school sweethearts and started families on minimum wage and no prospects and never went anywhere and never did anything and what did you do? How could this happen? Why were you both so stupid?^^Ocean's aunt is paying for the baby but it's been made clear the money stops when the baby's born. Ocean wants to keep it, she's always wanted to be a mommy. But you never thought you'd be a daddy. And when she pushed this into your hand last night she told you, Knock, it's time to decide. If you aren't with me on this, if you don't want this as much as I do, then this can't go on anymore and you should go. Fly. Head west. Find Nakaibito. She smiled just a little and traced your ear.^^But decide soon, Knock. Decide soon.";
Constant SC_297 = "From here, the only way out is to ";
Constant SC_298 = "From here, you can go ";
Constant SC_798 = "From the roof of the building, you can see ";
Constant SC_29 = "Garbage, even if they weren't smeared and streaked illegible.";
Constant SC_739 = "Getting down on your knees in the cold sand, you look underneath. Sure enough; you ripped up the ";
Constant SC_556 = "Give me more,~ he says.";
Constant SC_892 = "Good call, ";
Constant SC_873 = "Got ";
Constant SC_23 = "Grandma said it will bring you luck, which hasn't really been working out. You can't remember now how it ended up in your pickup truck. Maybe someday you'll see someone lucky and you can throw it at him.";
Constant SC_468 = "Gratefully, you slip inside the building, out of the storm.";
Constant SC_726 = "Half-lost in shadows, you see ";
Constant SC_386 = "He breathes. ~And are you happy with your story?~ he asks, and there's some dangerous undertone to the question and you don't know why. The lizards tense, quivering, twisting their little heads back and forth as they await your answer.";
Constant SC_542 = "He flicks out his tongue and pulls ";
Constant SC_354 = "He grins, not unkindly but not exactly kindly either. ~That cute little jackalope?~ he says, ";
Constant SC_349 = "He laughs, ";
Constant SC_752 = "He looks pretty pissed that you crashed into his cactus. What did grandma used to call those little dudes? You can't remember any more";
Constant SC_359 = "He presses his hands together, still clutching the cigarette with thumb and index finger, and smoke rises past his hidden eyes as he slowly rubs his palms together. He mutters something rhythmic to himself and you realize it's a song, and you can't quite make out the lyrics but the melody is simple and makes you think of Johnny Cash and the end of the world. And then he stops, and pulls his hands apart, and in each he holds a talent.";
Constant SC_249 = "He shrugs, takes a puff on his, and exhales the smoke into the desert night. Wind whips it away and he stares towards the horizon, forehead wrinkling in something (annoyance, maybe contemplation) you can't read through the sunglasses.";
Constant SC_365 = "He tucks the other talent back in his jacket, and without its faint glow it seems darker than ever, the pulsing red tip of his cigarette all you can see.";
Constant SC_344 = "He wears a couple days of stubble, a scuffed and ";
Constant SC_676 = "He";
Constant SC_884 = "He's real.";
Constant SC_195 = "He's too far away. You can barely see him.";
Constant SC_132 = "Heaving, you push against the barrel, and with a horrible grating noise, it slides across the roof till it rests underneath the metal rungs.";
Constant SC_889 = "Heh heh... fire... fire.";
Constant SC_689 = "Her";
Constant SC_698 = "Hers";
Constant SC_890 = "Hey, let's not just piss people off for no reason.";
Constant SC_609 = "Hey, that ";
Constant SC_844 = "Hey, there it is again";
Constant SC_193 = "Hey, you're not even sure you saw it.";
Constant SC_692 = "Him";
Constant SC_38 = "His scales are thick, sand still spilling off them in rivulets and trickles, and they recede and collide in fractal complexities that make you dizzy. He rumbles somewhere inside him, and the sand jitters at his feet.";
Constant SC_688 = "His";
Constant SC_74 = "I know, right? Looks like it's too late though.";
Constant SC_555 = "I must have more,~ he says.";
Constant SC_107 = "I";
Constant SC_448 = "In ";
Constant SC_110 = "In a storm like this? No way.";
Constant SC_296 = "In fact, you can't see any obvious exits.";
Constant SC_63 = "It figures that your pickup would die on a night like this and leave you stranded in the dark New Mexico desert. But nothing else figures about this night, man. Nothing at all.";
Constant SC_721 = "It glimmers and sparkles.";
Constant SC_238 = "It looks like these windows have been rusted shut for years.";
Constant SC_230 = "It looks like you can TUNE it to a frequency.";
Constant SC_214 = "It would disintegrate if you tried to remove it from the wall.";
Constant SC_681 = "It";
Constant SC_748 = "It's ";
Constant SC_168 = "It's a drop off on all sides.";
Constant SC_853 = "It's a rabbit.";
Constant SC_237 = "It's already busted open.";
Constant SC_213 = "It's already on its last legs.";
Constant SC_191 = "It's coming from beneath that ";
Constant SC_519 = "It's dark outside the beam of your headlights";
Constant SC_521 = "It's darker than you can remember it ever being";
Constant SC_14 = "It's full of gas.";
Constant SC_846 = "It's gone now... no, wait";
Constant SC_852 = "It's huge, covered in sweaty fur stained with mud, and a huge eye stares out you above long black whiskers. You can feel its breath on your face and its heartbeat thudding through the floor and you cringe back in terror against the wall. It's... well.";
Constant SC_189 = "It's just a few lines on a silhouette.";
Constant SC_720 = "It's just kind of part of you now.";
Constant SC_233 = "It's just potential, or something.";
Constant SC_129 = "It's no good; the window shatters and sand rushes in through it.";
Constant SC_281 = "It's not ";
Constant SC_234 = "It's not important, man.";
Constant SC_294 = "It's not real, bro.";
Constant SC_770 = "It's obvious this place has been abandoned for years. Cold night air breathes through ";
Constant SC_289 = "It's over. The coyotes dive in for the kill, jaws snapping, ";
Constant SC_580 = "It's over. The coyotes dive in for the kill, jaws snapping, and you cower in fear.^^But then one of them flicks his head and bares his teeth, and the others pull back. He's not bigger or stronger or anything but there's something about him that's different. He takes the littlest step forward and the others scatter, mangy shadows slinking away into the desert and then you're left alone with the leader, the alpha coyote.";
Constant SC_579 = "It's over. They've caught you. They surround you, circling, growling, looking for weakness, moving in for the kill.";
Constant SC_520 = "It's pitch black outside the beam of your flashlight";
Constant SC_757 = "It's quieter and darker over here, the black desert night bleeding in. Your ";
Constant SC_170 = "It's too high up for you to pull yourself through.";
Constant SC_169 = "It's too small for you to wriggle through.";
Constant SC_690 = "Its";
Constant SC_99 = "Just a photo.";
Constant SC_718 = "Just an empty frame.";
Constant SC_141 = "Just your luck.";
Constant SC_730 = "Juza straddles the 371 like a drunk at last call, smelly and without a plan for the future. Shiny cars whiz by at ninety once in a while, only stopping for gas or directions (hint: not this way). No one ever stops for the stalls selling food and jewelry and blankets and cheap t-shirts that cluster around the dirt turn-off onto the rez. At least, no one buying anything.^^Big Jimmy shook his head when he heard you lived in Oro Oeste. Hell of a drive, kid, he said, popping up his Lumberjacks cap to scratch the straw pate underneath. You should get a place in Hoo-zuh. Little Jimmy'll set you up in that trailer cross the road for almost nothin";
Constant SC_370 = "Keep your nose to the wind";
Constant SC_640 = "Knee-deep sand fills the room, rising at a terrifying rate";
Constant SC_212 = "Let it blow on. Wherever it's going is bound to be better than here.";
Constant SC_181 = "Like that's going to break anything.";
Constant SC_877 = "Looks normal.";
Constant SC_527 = "Maybe ";
Constant SC_128 = "Maybe you could just attack them directly.";
Constant SC_205 = "More like mud right now.";
Constant SC_553 = "More,~ he says.";
Constant SC_864 = "Mos def, ";
Constant SC_30 = "Most of the pages are faded or worn away, but flipping through, it looks like a guide to local animal life. You could try looking up various animals in it.";
Constant SC_300 = "Most of the thinking you do nowadays comes from either smoking or brooding.";
Constant SC_819 = "Mounted to the wall is a control panel for the building's emergency lights. They are switched ";
Constant SC_879 = "Nada";
Constant SC_299 = "Nah, man, better keep busy or else it's back to brooding about ";
Constant SC_426 = "Near some ";
Constant SC_724 = "Nearby: ";
Constant SC_236 = "Nice thought, but the last thing you need is a sliced open hand. Maybe you could use something less likely to bleed.";
Constant SC_883 = "No surprises.";
Constant SC_288 = "No time for that now.";
Constant SC_153 = "No wait... there's patterns, slowly shifting, barely visible in the darkness, and miles away. Like clouds. And then a drop of water falls on your face, and then another, and you realize suddenly you're outside, and it's starting to rain...";
Constant SC_173 = "Not gonna fit.";
Constant SC_307 = "Not like you think anything's going to happen, but what the hell. You grab the dusty old mike, press the call button, and ask is there anybody";
Constant SC_537 = "Not much point when it's not turned on.";
Constant SC_142 = "Not your lucky day.";
Constant SC_881 = "Nothin";
Constant SC_753 = "Oh yeah, you remember, she called them sand-dancers. This little sand-dancer still looks pissed";
Constant SC_450 = "On ";
Constant SC_112 = "On a night as freakishly dark as this, that's insane.";
Constant SC_575 = "Out of the corner of your eye you spot a glimpse of something moving in the darkness, off in the desert to the ";
Constant SC_106 = "Outside the wavering glow of your headlights, i";
Constant SC_188 = "Push it any more and it'll fall off the roof. Keep it here and you can get to the rungs.";
Constant SC_67 = "QUIT";
Constant SC_64 = "RESTART";
Constant SC_65 = "RESTORE a saved game";
Constant SC_46 = "Rain batters down on the desert.";
Constant SC_80 = "Rain beats constantly on the roof, loud and furious";
Constant SC_59 = "Rain starts to come down, pattering on the desert sand. Soon it's gonna be a muddy deathtrap out here.";
Constant SC_47 = "Roots push through the earthen roof, casting weird shadows in the beam of your flashlight. It's round and small and underground in here and filled with hot sweat and animal stench. But mostly filled with something big and alive.";
Constant SC_840 = "Sand-dancer";
Constant SC_865 = "Say what?";
Constant SC_808 = "Shadows and grime linger in dark corners of this dismal room with just one ";
Constant SC_12 = "She grinned when you picked her up, and you drove on in to Mike's and the lot was filled with trucks and Mike's was filled with Indian guys and Indian girls and she was still the most beautiful, and you danced a lot and drank some and left early to go lie down under the stars and count the shooting ones.^^And that was maybe you think the first time she said she loved you, and you said it back cause it felt all right and shit, but you didn't really know if you meant it, or if she did, or what it even really means. I mean you like Ocean a lot, really a lot, but then you also aren't really sure you even know her, anything about her that's important or real or meaningful. She could be anyone, really, on the inside. So could you.";
Constant SC_11 = "She was buying a Fresca at Big Jimmy's when you got off your shift, shoving work keys in your pocket, and you stood behind her waiting to get some cigs, almost too tired to notice how cute she was but still noticing, yeah, still noticing.^^She turned around and caught you noticing and you were pretty embarrassed and covered in sweat and grease from the garage, so you stepped up and bought some Camels and were pretty surprised she was still there when you turned around.^^She told you her name was Ocean Running Deer and she lived on the rez and you told her your name was Nakaibito Morales and you lived in Oro Oeste. She said isn't Nakaibito the name of a town way off west and you told her your mom had picked it off a map because it sounded like a good Indian name. You never tell anyone that story but for some reason you told her. She laughed, sweetly though, and said maybe the two of you should go there sometime and see what it was like. Somehow two weeks later you were dating although you never ended up going to Nakaibito.^^And now... no, you can't think about that yet.";
Constant SC_677 = "She";
Constant SC_872 = "Snagged";
Constant SC_96 = "Snarls and teeth and mangy fur on every side.";
Constant SC_458 = "Some crazy thrill comes over you. You feel like a hunter. You can almost smell the thing you're chasing in the air. You ";
Constant SC_822 = "Some kind of electrical control stuff must have happened here once, but it's totally trashed now. Like, ";
Constant SC_143 = "Some of these should still be good, right?";
Constant SC_522 = "Some weird shit went down in the desert, but you do feel like you have more ";
Constant SC_219 = "Someone in elementary school dared you to do that once and you beat him up.";
Constant SC_26 = "Someone left a tin can here years ago: ridged ripples run down its rusty side.";
Constant SC_84 = "Something about ";
Constant SC_91 = "Something snarls off in the distance, a warning growl.";
Constant SC_566 = "Somewhere inside you, things are shifting, moving, growing.";
Constant SC_161 = "Sounds like a good way to lose something forever.";
Constant SC_514 = "Sounds like something your high school buddies would try.";
Constant SC_596 = "Static squeals from the radio";
Constant SC_368 = "Stay brave";
Constant SC_369 = "Stay lucky";
Constant SC_367 = "Stay strong";
Constant SC_554 = "Still more,~ he says.";
Constant SC_356 = "Strength";
Constant SC_152 = "Stupidly, you tilt your head back and stare up at the dirt ceiling, and all you can see is blackness.";
Constant SC_875 = "Sure thing, ";
Constant SC_32 = "Tacked to the wall is a peeling safety poster, text almost faded away except for a section mentioning an emergency radio frequency.";
Constant SC_409 = "Taken.";
Constant SC_489 = "Talking to yourself is unrewarding.";
Constant SC_529 = "That was your last cigarette, too";
Constant SC_678 = "That";
Constant SC_127 = "That's not the best idea in a storm like this.";
Constant SC_89 = "The ";
Constant SC_35 = "The Coyote watches you intently.";
Constant SC_83 = "The air is frigid, and turns your breath into clouds";
Constant SC_78 = "The building groans as wind and rain lash it from outside";
Constant SC_97 = "The building shakes and groans as sand continues to pour in, rising higher and higher.";
Constant SC_242 = "The building's sinking into the sand! You've got to get out some other way!";
Constant SC_24 = "The cactus seems totally undamaged. Go figure.";
Constant SC_87 = "The circle of snarling coyotes tightens.";
Constant SC_48 = "The closer you look the weirder it gets, like it doesn't start or end in any one place or something all new-agey like that.";
Constant SC_82 = "The cold night air swirls around you, and you pull your jacket closer";
Constant SC_88 = "The coyotes growl, pulling closer, snapping at your heels.";
Constant SC_641 = "The deluge of sand thunders in from every side, filling the room";
Constant SC_399 = "The desert springs into existence around you.";
Constant SC_829 = "The desert stretches around you in all directions";
Constant SC_397 = "The door creaks open with difficulty, rusted joints straining.";
Constant SC_228 = "The door won't budge. You slam your hands against the boards in frustration";
Constant SC_827 = "The dust storm rages around you";
Constant SC_226 = "The engine just turns over. It won't start.";
Constant SC_287 = "The figure waves back, then seems to beckon you forward.";
Constant SC_774 = "The floor has half-collapsed near one corner";
Constant SC_416 = "The generator whines as it powers off, slowly falling silent.";
Constant SC_72 = "The glass is too filthy for you to see anything on the other side.";
Constant SC_284 = "The ground rumbles as the lizards shift. ~Hello,~ he says, ";
Constant SC_381 = "The ground shudders and shifts beneath you, and out of the sand rise ";
Constant SC_841 = "The huge lizard";
Constant SC_412 = "The lights die out, except for a ghostly glow from outside that must be your headlights.";
Constant SC_413 = "The lights die out, leaving only the beam of your flashlight.";
Constant SC_414 = "The lights flicker and die out";
Constant SC_754 = "The little sand-dancer lizard stares at you with one slitted eye";
Constant SC_387 = "The lizard turns his head sharply, and all the lizards in the desert around writhe angrily, clawing and biting at each other in agitation. ~And when will you know, Knock?~ the lizard asks. ~When will you own your life? When will you become a man? Tonight. It must be tonight.~";
Constant SC_373 = "The lizard's tongue snakes through the air, tasting it, tasting you. One slitted eye studies you intently. It pauses, as if waiting for you to say something.";
Constant SC_393 = "The lizards begin to circle restlessly as they wait for you to choose. Sand-dancer merely watches, and waits.";
Constant SC_376 = "The lizards hiss and writhe as you ask, almost as if they are laughing. ~Little sand-dancers,~ he says, ";
Constant SC_625 = "The lizards scurry angrily, snapping and clawing at each other, with a sound like static and sand.";
Constant SC_392 = "The lizards whisper in anticipation as a second egg rises. This one's bigger, and almost blinding with its intensity, and the lizards draw back, chittering in awe and amazement. ~This,~ Sand-dancer says, ~is freedom. Pure, undiluted, and absolute. Many crave it and few get a chance to take it. I offer it to you, Nakaibito, but it does not come cheaply.~ He grins. ~For freedom, you must give up everything. You must give me all your memories.~";
Constant SC_125 = "The metal rungs have rusted away and crumbled; the lowest are well above your head. You don't have the courage to make the jump.";
Constant SC_95 = "The pack's at your heels, snapping, growling, and you've never in your life been this terrified.";
Constant SC_317 = "The rabbit breathes and stares. You wonder if it's going to start talking like in some crap disney movie and then jesus christ it does...";
Constant SC_331 = "The rabbit just scratches his ear with a hind paw, smirking.";
Constant SC_854 = "The rabbit stares at you, whispers twitching, and it's freaking you out.";
Constant SC_607 = "The radio fizzles and growls through weird twists of distortion";
Constant SC_593 = "The radio growls to life again";
Constant SC_223 = "The radio is destroyed, but the sound still plays, echoing and reverberating through the room.";
Constant SC_573 = "The rain's dying down, the sounds of the storm fading, water sinking into the thirsty sand leaving only the smell of ";
Constant SC_857 = "The sand swirls and churns like something liquid or alive around you, and then you look and see it is alive, thousands and ";
Constant SC_804 = "The stark emergency lights illume";
Constant SC_599 = "The static on the radio resolves into overlapping whispers";
Constant SC_796 = "The top of the ";
Constant SC_595 = "The voice sounds different than before. I mean it still kind of sounds like the first guy you talked to but it sounds like someone else now too, someone you know, you've known for a long time. Someone you're afraid of";
Constant SC_813 = "The walls are lined with ";
Constant SC_686 = "Their";
Constant SC_696 = "Theirs";
Constant SC_691 = "Them";
Constant SC_859 = "Then, suddenly, everything stops.";
Constant SC_10 = "There are dark spirits who roam the earth, little Knock. Grandma used to say that, holding you tight and stroking your hair. There are dark spirits who roam the earth, but you're not alone. Oh, no. I'm here. (She'd kiss your head and you'd squeeze her back.) But others are watching out for you too. You have three animal guardians, hmm? Spirits who are always watching over you. Oh, you can't always trust them to know what's best. Remember that, Knock. But when you need help, they'll come, and protect you from the worser things in the world.^^Mom would yell at Grandma a lot for filling your head with that new-age bullshit. Grandma grew up white and midwestern and Baptist, but had started wearing things with feathers and playing the pan flute by the time you were born. She seemed to really like having a son-in-law who was Native American or American Indian or Indigenous Peoples or whatever she'd decided the term was that week, and she was pretty pissed when mom left him. Anyway. Her stories were mostly BS, you guess, but some of them stuck with you. When it's dark you still wonder if your spirit animals are out there somewhere, and what the hell is taking them so long to find you.";
Constant SC_488 = "There is no reply.";
Constant SC_855 = "There's like this faint tickle through the soles of your feet, some vibration, almost like whispers in the sand. You want to bend down, put your ear to the ground, listen forever.";
Constant SC_495 = "There's no one here but you.";
Constant SC_116 = "There's no one here to talk to.";
Constant SC_557 = "There's no one here to trade with.";
Constant SC_120 = "There's no time, man! The room's filling with sand!";
Constant SC_57 = "They crawl over and under and around each other, restless, always moving.";
Constant SC_680 = "They";
Constant SC_56 = "They're all around you, teeth and fur and sweat and muscles, angry, closing.";
Constant SC_760 = "This ";
Constant SC_293 = "This isn't really the best time for that, man.";
Constant SC_674 = "Those";
Constant SC_58 = "Thousands of lizards writhe in the desert around you.";
Constant SC_755 = "Through the windshield, you see a little lizard clinging frantically to the ";
Constant SC_867 = "Try a different noun with that command.";
Constant SC_624 = "Trying to build a family out of nothing, spin futures from government handouts and dusty trailer parks, raising another generation of hopeless dropouts and messed-up losers?~ ";
Constant SC_68 = "UNDO the last command";
Constant SC_885 = "Uh, ";
Constant SC_866 = "Uh, not sure about the noun there, ";
Constant SC_592 = "Uh. You're pretty sure you never told that dude your name. Maybe you're just hearing things";
Constant SC_812 = "Vintage, man. A chrome switch on the side to turn it on and off, and a big fifties dial on the front. It looks like it's tuned to ";
Constant SC_79 = "Water from the storm trickles down from unseen cracks and holes";
Constant SC_639 = "Waves of sand flow like water through the room, filling it higher and higher";
Constant SC_180 = "Weird, it looks like somebody's ripped out the page.";
Constant SC_517 = "Well, you're still stuck here. ";
Constant SC_869 = "What is this, ";
Constant SC_18 = "Whatcha watchin, Knock? he asked, lurching out of mom's room smelling of sage incense and holding a beer and crashing into the lazyboy, and you said Nothing Mr Morales (and god damn it kid, can't you at least call me Karl if you won't call me dad? but that conversation's been buried a year now at least out loud) and he squinted and said is this that Family Guy crap? I thought your mother said she didn't want you watching this crap (because it's always mother who wants you to do things or be things or say things, never Mr Morales) I thought your mother said you ought to start learning about your culture.^^So while Peter is trying to start a rock band or something Karl starts spouting some story about Mexican myths with eagles and feathered serpent gods, and he must be so into the stepdad thing he's forgotten that's his culture, not yours (well, sort of). Not that your real dad or Peter Griffin ever helped you figure out what your culture's supposed to be either. It hits you that your culture must be somewhere in the middle, between Family Guy and Quetzalcoatl, and you start laughing and get grounded because you can't even imagine what the middle between those two could possibly look like.";
Constant SC_21 = "When the highway patrol pulls you over they see your kind of crazy uncombed hair (morning), your brown name (Nakaibito Morales) and brown skin (actually more kinda tan), your D.O.B. (eighteen years ago just barely) and tribal affiliation card (expired) and assume you're either some kind of native eco-terrorist, illegal drug-running border jumper, or delinquent high school dropout (all lies except for kinda maybe the last one a little). Unless it's Jimmy Kay who pulled you over since he usually just wants to buy you a beer and talk about your dad, which is weird but better than getting a ticket.";
Constant SC_224 = "When you were a kid, it smelt like camping and adventure. Now it just smells like desert and confusion.";
Constant SC_411 = "With a sharp buzz, a whiff of static and an electrical groan, bare light bulbs flicker on throughout the building.";
Constant SC_590 = "With a sudden growl of static the radio springs to life";
Constant SC_25 = "Worthless and forgotten, drifting against snags like non-biodegradable snow.";
Constant SC_442 = "Would you like to ";
Constant SC_878 = "Yeah, it's ";
Constant SC_303 = "Yeah, it's a flashlight all right. You grip it in sudden relief, turning it in your hands till your finger finds the switch.";
Constant SC_158 = "Yeah, sorry, but you're not putting your hand in there.";
Constant SC_227 = "Yeah, you could get on top of it, but while it's over here you couldn't reach a whole lot.";
Constant SC_211 = "Yeah, you did that once as a kid, on accident. Not happening again.";
Constant SC_868 = "Yeah, you do need to get a hold of yourself.";
Constant SC_511 = "Yeah, you wish you could unsmoke all the cigs you've inhaled. Life doesn't work like that.";
Constant SC_845 = "Yeah, you're sure you saw it";
Constant SC_552 = "Yes,~ he says, ~but more.~";
Constant SC_447 = "You ";
Constant SC_882 = "You ain't that hungry, ";
Constant SC_871 = "You already got that shit, ";
Constant SC_490 = "You are already talking to ";
Constant SC_155 = "You aren't close enough to the building.";
Constant SC_194 = "You aren't sure you believe in it enough for that.";
Constant SC_498 = "You aren't talking to anyone right now.";
Constant SC_836 = "You can barely see him in the darkness, can't tell whether he's old or how old, what color his ";
Constant SC_31 = "You can barely see it in the gloom but it's huge, like a metal spider web weaving into space. Way above, a red light blinks on, off, on, off.";
Constant SC_824 = "You can clearly smell gasoline coming from under that ";
Constant SC_126 = "You can hardly see anything in here; touch is about the only way you could navigate.";
Constant SC_94 = "You can smell them now, wild, feral. Shifting shadows whirl around you, panting, whining with the thrill of the chase.";
Constant SC_723 = "You can sort of see ";
Constant SC_145 = "You can touch the warm wool through the mesh, but you can't get it out.";
Constant SC_167 = "You can't go that way.";
Constant SC_286 = "You can't hear anything at all above the pounding noise of water slapping sand.";
Constant SC_235 = "You can't imagine being without it, now.";
Constant SC_121 = "You can't really get into a good conversation right now.";
Constant SC_509 = "You can't see an open way back.";
Constant SC_295 = "You can't see which way to go in this darkness.";
Constant SC_738 = "You can't tell what the damage is from in here";
Constant SC_192 = "You can't tell where the smell is coming from";
Constant SC_533 = "You can't tune that.";
Constant SC_635 = "You carry strength that ripped warmth from walls. ";
Constant SC_825 = "You catch a faint whiff of gasoline coming from somewhere";
Constant SC_457 = "You chase after the shadow, faster and faster, breath misting in the cold air.";
Constant SC_400 = "You click the headlights off";
Constant SC_467 = "You climb up on the barrel, reach, grab the bottom rungs, and pull yourself up.";
Constant SC_500 = "You could ";
Constant SC_435 = "You could probably push that ";
Constant SC_163 = "You couldn't go that way even if you weren't ";
Constant SC_174 = "You dangle ";
Constant SC_9 = "You didn't expect it was going to be your last day. But that morning you got called in to the principal's office and fat bald Mr. Cox and pissy old Mrs. Burke were there, and they looked kind of like strong animals stalking weak animals, and you knew something bad was up.^^Cox said I have here, Mr. Morales (a bad start since you hate that name) a test you took last week in Mrs. Burke's sophomore English class. Questions have been raised (he looked up at Mrs. Burke like he was trying to pass the buck) questions have been raised about the quality of your essay, and whether a student with your academic and behavioral record (he scratched his bloated nose meaningfully) could have plausibly produced such an essay, and you get the idea. They thought you cheated.^^No. They knew you cheated, deep in their smug empty hearts. They wanted you to admit it, say you were a cheater and a liar. But you weren't. You wrote that essay, every god damn word, because you really really liked the book for once and wanted to show Mrs. Burke that maybe if they gave people better books to read kids would actually learn something. But they wanted a confession. They wanted a thieving example they could parade in front of the school. Someone of your academic and behavioral and economic and racial background and yeah, screw this shit. So you got up and left and never came back. Drop out, hell. You walked out and you'd do it again.";
Constant SC_19 = "You don't really want to think about what you look like right now, especially when there's a totally legit likeness on the driver's license in your wallet.";
Constant SC_218 = "You don't want to spill it.";
Constant SC_225 = "You drop it to the ground and stub it out with your foot.";
Constant SC_301 = "You feel around the edge of the desk, and find that it has a drawer.";
Constant SC_204 = "You flick it open and shut a few times, an old habit.";
Constant SC_199 = "You flick the lighter, but the light seems grey and tiny in the face of the dark. All you can really see is";
Constant SC_403 = "You flip a bulky switch on the radio's side. A hiss of static pours from the speakers";
Constant SC_479 = "You flip the switch back and forth, but there doesn't seem to be any power. Damn.";
Constant SC_465 = "You gather your courage and leap off the edge of the roof. Your hands grasp the metal of the bottommost rung, scraping and sliding, but holding. ";
Constant SC_474 = "You glance wildly at the exits ";
Constant SC_264 = "You go, and the clouds are gone and the stars are so bright you squint. You patch the fuel line and refill the tank and she starts like a beauty, and then you're back on the highway again, headed for Ocean, ";
Constant SC_271 = "You go, and the night collapses in on you so hard you barely remember curling up in a corner with the blanket";
Constant SC_253 = "You go, with a strange, kinda tingly feeling in the backs of your hands and inside your eyes. You feel powerful";
Constant SC_215 = "You grab one and turn it over and over in your hand, but water has soaked and crumbled away the label, and you don't have any way to get it open. Your stomach growls a little as you put it back on the shelf.";
Constant SC_131 = "You grip the mesh in one hand and pull, and realize it's so rusted you can easily peel it back. The door rips free and you drop it to the floor.";
Constant SC_240 = "You have a feeling this conversation isn't over.";
Constant SC_642 = "You have nothing specific in mind to discuss with ";
Constant SC_638 = "You have scent that brought you liquid motion. ";
Constant SC_111 = "You have some feeling that when the last spirit animal decides to make an appearance, it will find you.";
Constant SC_456 = "You head off in the direction of the movement, scanning with your flashlight over the skittering shadows.";
Constant SC_109 = "You heft your flashlight nervously, licking your lips, but decide not to head out into the desert just yet. There might be more around here you should investigate before taking such a drastic step.";
Constant SC_636 = "You hold courage that earned you a tool for mending. ";
Constant SC_134 = "You impatiently brush the cobwebs away.";
Constant SC_316 = "You jabber something positive and sit back, still shaken.";
Constant SC_462 = "You jog forward, eyes snapping left and right at the moving shadows around you.";
Constant SC_747 = "You just can't deal with that right now. Maybe after you've spent more time brooding.";
Constant SC_221 = "You kick the radio off the table and it clatters to the ground, but still keeps laughing with hisses and whines.";
Constant SC_206 = "You kneel down and let some run through your fingers, vague memories of better times slipping through your fingers. But the ground is freezing and you get back to your feet.";
Constant SC_197 = "You know you're crazy when you start talking to yourself.";
Constant SC_176 = "You look up the brown-colored lizard in the guidebook and quickly identify it: those eyes are a dead giveaway. The entry says it's a ~rare subspecies of the common desert lizard found only in the deep desert near Oro Oeste, and known to native peoples as a ";
Constant SC_179 = "You look up the hare in the guidebook. ~Common desert rabbit,~ it says, ~frequently mistaken for a hare. Lives in underground burrows which it uses to keep warm through chill desert nights. Trusted by native peoples as a guide and symbol of rebirth.~";
Constant SC_124 = "You lose sight of whatever it was.";
Constant SC_461 = "You move nervously forward.";
Constant SC_309 = "You mutter something about how you think you've made a mistake and you have to go but the voice interrupts. ~Hang on, hang on, son, there shouldn't be anybody out there. Not at all, especially not this late. Why don't you tell me what's going on?~";
Constant SC_117 = "You need to specify who you want to speak to.";
Constant SC_587 = "You open ";
Constant SC_515 = "You pat your pockets, but can't seem to find your lighter.";
Constant SC_135 = "You pull down a can from the shelf, grip it with the rusty can opener, and peel open the lid. Yuck: ";
Constant SC_516 = "You pull out a cigarette and flick it into life. Thoughts tumble through your head.";
Constant SC_245 = "You pull out your pack and ";
Constant SC_466 = "You pull yourself up the rungs into the control center. Hey, it wasn't that hard after all.";
Constant SC_130 = "You push against the side, but you're not strong enough to move the barrel.";
Constant SC_406 = "You reach down into the hole";
Constant SC_150 = "You reach for the switch, but hesitate, hand hovering above it as the static whirls and roars.";
Constant SC_231 = "You reach out to grab it, but in a flash it scurries around to the other side of the cactus and disappears.";
Constant SC_157 = "You reach your hand towards the hole, then pull back with a start as you brush cobwebs. Nightmare visions of fat black spiders shudder through your brain. No way are you reaching in there.";
Constant SC_861 = "You rip the cord out of the wall";
Constant SC_217 = "You root around in the trash hopelessly, but there's a lot of it. You don't turn up anything useful.";
Constant SC_612 = "You rub your face tiredly. Ocean was expecting you tonight after your shift, like usual. If you don't make it she'll be worried sick. Then on the other hand maybe you should worry about yourself first for a change. You feel like you need a cigarette and then you remember you quit. Hell, can't anything be easy";
Constant SC_133 = "You run your fingers along the cans, waiting until one feels right. There's nothing, nothing, but then... yeah. That's the one. You snag it down, twist it open, and boom: mandarin oranges, unspoiled and delicious. You scarf them down, picking them out segment by segment with your chilly fingers. By the time you've polished them off you're a lot less hungry. You grab the next can down for later.";
Constant SC_464 = "You run.";
Constant SC_497 = "You say goodbye to ";
Constant SC_491 = "You say hello to ";
Constant SC_576 = "You see that weird movement again, out in the shadows to the ";
Constant SC_81 = "You shiver in the cold air";
Constant SC_432 = "You should be able to clamber up onto the ";
Constant SC_71 = "You should wait until you've got everything you need before you start making repairs.";
Constant SC_220 = "You slam a fist into the top of the radio, but it just keeps hissing with static.";
Constant SC_398 = "You slam the door shut.";
Constant SC_302 = "You slide the drawer open by feel in the darkness. Something large and lumpy rolls around inside-- a flashlight?";
Constant SC_172 = "You sling the key into the lock, but as you turn it, the rusted metal snaps off inside. The crumbling fragments fall to the ground as you slam your fist against the wire mesh in frustration. This is not your day.";
Constant SC_441 = "You slip your hand into your pocket and remember you don't have your smokes on you.";
Constant SC_207 = "You smack ";
Constant SC_222 = "You smash the radio over and over again, until it lies in pieces on the ground, but the static still continues, and more and more it sounds like sand.";
Constant SC_100 = "You stare back down the pickup's path uneasily. The tracks are swallowed by blackness, quickly melding, blending, and vanishing into a maze of ATV tracks, coyote trails, rocky outcrops, and shadows. You squint at the horizon. There's no distant sweep of headlights, no sound of trucks shifting through lonely gears. Nothing. Nothing at all. ";
Constant SC_241 = "You start to go out, but then you stop. Something's not right. Something's... weird.";
Constant SC_577 = "You stop in mid-stride as your eyes flick to the horizon. Way out in the desert, silhouetted on a rise, a ";
Constant SC_803 = "You sweep the beam of your flashlight around";
Constant SC_162 = "You take a drag, thoughts and adrenaline whirring through your head.";
Constant SC_171 = "You take a step and crack your shin against what feels like a metal desk. Ouch.";
Constant SC_154 = "You think you'd rather keep him on your side.";
Constant SC_283 = "You try to flee and instantly teeth and claws block your path; you pull back to the center of the circle, terrified.";
Constant SC_187 = "You try to get a grip on the mesh to rip it open, but you're just not strong enough.";
Constant SC_310 = "You try to make some joke about not having forty of anything, but the voice cuts you off. ~Ten forty means situation report, son. Obviously you're not on duty. Ain't nobody on duty out there anymore, specially not this time of night. What's going on?~";
Constant SC_113 = "You try to raise someone, but there's no response";
Constant SC_538 = "You tune ";
Constant SC_13 = "You used to like it. The perfume. But you like how Ocean smells without it better, but she doesn't believe you. She says girls are supposed to smell sweet, like oranges and rose petals. But you've always liked bitter fruits. Tamarind and lemon.^^And sometimes, maybe after a fight or something, you'll drive off and that's all you can smell is her orange perfume. And even after smoking three cigarettes with the windows of your pickup rolled down you can still smell it, and it's still too sweet, and you wonder if this is working out. Because it's such a little pointless thing but it drives you crazy. And if a little thing like perfume is driving you this crazy maybe the whole thing is doomed. Maybe Ocean would be better off with some guy who likes orange perfume.^^You don't know what's going to happen now.";
Constant SC_473 = "You wade through the sand, which is rising all the time.";
Constant SC_469 = "You walk for a long time, thoughts turning over like the sand under your sneakers. You think about ";
Constant SC_637 = "You wear luck that filled your belly. ";
Constant SC_144 = "You won't be hungry again till morning.";
Constant SC_417 = "You wrap it around your shoulders, and soon your shivering stops.";
Constant SC_675 = "You";
Constant SC_510 = "You'll have to try a more specific verb than use.";
Constant SC_741 = "You'll need to find some way to patch up the line, plus some fuel, to have any hope of fixing her";
Constant SC_508 = "You're already up.";
Constant SC_749 = "You're kind of trying to quit, but man, ";
Constant SC_496 = "You're not talking to ";
Constant SC_119 = "You're not talking to anyone.";
Constant SC_513 = "You're out of cigarettes.";
Constant SC_434 = "You're pretty sure you could make the leap, though";
Constant SC_463 = "You're running now, jumping over sagebrush and stumbling on rocks, as snarling animal forms close in around you.";
Constant SC_101 = "You're way off the road, and there's no chance at all of finding it again in this demon dark.";
Constant SC_232 = "You've already busted it open.";
Constant SC_562 = "You've already got the talent of ";
Constant SC_216 = "You've already ripped it open. No point in going mental.";
Constant SC_563 = "You've already traded away that memory.";
Constant SC_518 = "You've finally lit the place up a little";
Constant SC_523 = "You've found ";
Constant SC_530 = "You've got ";
Constant SC_73 = "You've got to say both what memory you're trading and what talent you're trading it for.";
Constant SC_75 = "You've got";
Constant SC_732 = "You've smashed up against a ";
Constant SC_22 = "Your baby too.";
Constant SC_20 = "Your guidance counselor used to say you're always carrying it with you. You imagine it's kind of ugly, lumpy, and green, and definitely has a stuck zipper.";
Constant SC_742 = "Your poor old ";
Constant SC_146 = "Your sense of smell leads you straight to a ";
Constant SC_410 = "Your surroundings spring into brightness around you.";
Constant SC_828 = "Your tracks are swallowed up in moments by the billowing sand";
Constant SC_70 = "Your truck's not going anywhere in this condition.";
Constant SC_687 = "Your";
Constant SC_697 = "Yours";
Constant SC_501 = "@{5C}band@{5C}b";
Constant SC_850 = "a darting shadow";
Constant SC_452 = "also ";
Constant SC_708 = "amigo";
Constant SC_627 = "and his voice shakes the earth and creaks the rusty joints of the tower";
Constant SC_291 = "and suddenly this bolt of courage runs through you and without even thinking about it you leap towards the biggest coyote with a terrible scream.^^It flinches back, suddenly unsure, and you charge at it full speed, still screaming, arms outstretched, until it turns tail and bolts away. The other coyotes circle uncertainly, but you turn your snarling furious rage on them too and then they're all scattering";
Constant SC_266 = "and the urge to breathe the same air as her leads you on like a bloodhound";
Constant SC_149 = "and throw it aside, revealing a gas can.";
Constant SC_290 = "and without hardly realizing what you're doing you make a fist and slam it into the one that's closest.^^The coyote squeals, flung sideways by the strength of your punch, blood dripping from its nose, and the rest of the pack pulls back in sudden caution. Another coyote makes to lunge and you whirl towards it in fury, pulling back for another blow, but the pack breaks in some collective decision and scatters";
Constant SC_265 = "and you've never felt luckier";
Constant SC_262 = "are";
Constant SC_504 = "ask ";
Constant SC_41 = "ask him about getting on with the trading";
Constant SC_138 = "black and mold-covered mushrooms";
Constant SC_705 = "bro";
Constant SC_709 = "brohim";
Constant SC_471 = "brush away remnants of broken glass and ";
Constant SC_787 = "building.";
Constant SC_76 = "but it's too late, you're crashing, you're crashing, you crash...";
Constant SC_451 = "can ";
Constant SC_459 = "can";
Constant SC_814 = "casting strange patterns of shadow as you sweep your flashlight beam around";
Constant SC_620 = "courage";
Constant SC_279 = "crazy brave";
Constant SC_801 = "directly underneath the bottom rungs ";
Constant SC_707 = "dude";
Constant SC_148 = "effortlessly ";
Constant SC_874 = "em";
Constant SC_493 = "es";
Constant SC_835 = "every inch of sand looks just like every other";
Constant SC_484 = "familiar";
Constant SC_28 = "fixing your truck and getting out of here";
Constant SC_628 = "flicking his tongue in and out, slowly";
Constant SC_419 = "flimsy-looking ";
Constant SC_745 = "folded ";
Constant SC_421 = "food";
Constant SC_422 = "gas";
Constant SC_786 = "glow of the ";
Constant SC_834 = "god damn it's dark";
Constant SC_418 = "hardly noticeable ";
Constant SC_667 = "has";
Constant SC_666 = "have";
Constant SC_247 = "he grins, like he knew you'd say yes";
Constant SC_671 = "he";
Constant SC_313 = "hell";
Constant SC_647 = "her";
Constant SC_695 = "hers";
Constant SC_646 = "him";
Constant SC_629 = "his great slitted eye blinking slowly";
Constant SC_684 = "his";
Constant SC_390 = "honor";
Constant SC_669 = "ies";
Constant SC_165 = "in";
Constant SC_429 = "is the";
Constant SC_665 = "is";
Constant SC_648 = "it";
Constant SC_633 = "itching underneath his jacket, slowly";
Constant SC_685 = "its";
Constant SC_49 = "just, you know, go insane";
Constant SC_486 = "known";
Constant SC_802 = "large enough you could climb up on top of it";
Constant SC_55 = "look up";
Constant SC_420 = "lucky ";
Constant SC_706 = "man";
Constant SC_136 = "moldy peas";
Constant SC_849 = "movement";
Constant SC_589 = "nothing.";
Constant SC_582 = "off";
Constant SC_164 = "on";
Constant SC_502 = "or";
Constant SC_583 = "out of";
Constant SC_746 = "photo";
Constant SC_137 = "rotten condensed milk";
Constant SC_815 = "rusting away";
Constant SC_699 = "s";
Constant SC_177 = "sand-dancer";
Constant SC_39 = "say hello";
Constant SC_7 = "say no.";
Constant SC_8 = "say yes or no";
Constant SC_6 = "say yes";
Constant SC_632 = "scratching his stubble with the hand that holds the cigarette";
Constant SC_453 = "see ";
Constant SC_66 = "see some suggestions for AMUSING things to do";
Constant SC_246 = "see that it's empty, but Coyote grins and hands you his last one";
Constant SC_481 = "seen";
Constant SC_729 = "self";
Constant SC_728 = "selves";
Constant SC_672 = "she";
Constant SC_630 = "sighing as the lizards in the desert writhe and twitch";
Constant SC_631 = "smoke gusting from his lungs in clouds";
Constant SC_139 = "something nasty-smelling and green";
Constant SC_848 = "something's moving";
Constant SC_27 = "spending the night here";
Constant SC_389 = "spirit";
Constant SC_619 = "strength";
Constant SC_476 = "surfaces for a moment then gets buried";
Constant SC_45 = "switch off the radio";
Constant SC_108 = "t's black. Pitch. Storm must have rolled in; there's no stars above, no anything but blackness around. Only the smell of the desert tells you it's still out there.";
Constant SC_843 = "take ";
Constant SC_54 = "take inventory of what you've got";
Constant SC_506 = "tell ";
Constant SC_50 = "tell him that you don't know";
Constant SC_53 = "tell him you don't want to trade";
Constant SC_40 = "tell him you're not sure if you're happy";
Constant SC_673 = "that";
Constant SC_209 = "the hood";
Constant SC_634 = "the red tip of the cigarette glowing as he takes another drag";
Constant SC_208 = "the wheel";
Constant SC_4 = "the";
Constant SC_682 = "their";
Constant SC_693 = "theirs";
Constant SC_644 = "them";
Constant SC_679 = "they";
Constant SC_670 = "those";
Constant SC_52 = "trade something for courage";
Constant SC_44 = "trade something for freedom";
Constant SC_42 = "trade something for honor";
Constant SC_36 = "trade something for luck";
Constant SC_37 = "trade something for scent";
Constant SC_43 = "trade something for spirit";
Constant SC_51 = "trade something for strength";
Constant SC_477 = "tumbles in the flow";
Constant SC_485 = "unfamiliar";
Constant SC_487 = "unknown";
Constant SC_482 = "unseen";
Constant SC_425 = "useful stuff: ";
Constant SC_478 = "vanishes under the sand";
Constant SC_17 = "watching Family Guy with Karl";
Constant SC_275 = "with a little more luck you keep from being hungry";
Constant SC_472 = "wriggle through the window.";
Constant SC_668 = "y";
Constant SC_715 = "you can see in the glow of";
Constant SC_525 = "you can't see how they're going to be helpful together";
Constant SC_651 = "you could break open a window to get inside that building";
Constant SC_750 = "you could really go for one right now. It looks like you've only got ";
Constant SC_649 = "you could start by getting out of this truck";
Constant SC_650 = "you could start by looking around the area, seeing if maybe there's a phone or something";
Constant SC_652 = "you could try exploring the building by feel, even though it's so dark";
Constant SC_655 = "you maybe should see if you can call for help with that emergency radio in the break room";
Constant SC_661 = "you ought to head back to the desert and see if you can find that rabbit dude again";
Constant SC_832 = "you plod wearily through the sand";
Constant SC_276 = "you seem to have a knack for sniffing out enough to stay fed";
Constant SC_831 = "you shiver in the chill night air";
Constant SC_660 = "you should investigate that hole in the floor of the staging area";
Constant SC_653 = "you should poke around the building more, see what else there is to find";
Constant SC_656 = "you should see if the open desert has anything to offer";
Constant SC_654 = "you should switch on those emergency lights in the storage room so you can get a better look at things";
Constant SC_657 = "you should try to catch up with that weird shadow";
Constant SC_663 = "you should try to get up that ladder above the roof";
Constant SC_664 = "you should try to sniff out that gas now";
Constant SC_428 = "you spot a dark";
Constant SC_526 = "you still need something else if you plan on ";
Constant SC_833 = "you wish you could see more than twenty feet in front of you";
Constant SC_645 = "you";
Constant SC_659 = "you're brave enough to reach for that duct tape in the hole in the floor now";
Constant SC_662 = "you're lucky enough now to find something to eat in the Storage room";
Constant SC_658 = "you're strong enough now to bust open that mesh cage with the blanket inside";
Constant SC_751 = "you're totally out";
Constant SC_548 = "your core";
Constant SC_712 = "your dimming ";
Constant SC_714 = "your flashlight picks out, other than";
Constant SC_546 = "your gut";
Constant SC_544 = "your head";
Constant SC_545 = "your heart";
Constant SC_547 = "your palm";
Constant SC_549 = "your soul";
Constant SC_683 = "your";
Constant SC_694 = "yours";
Constant SC_584 = "{";
Constant SC_586 = "}";
Constant SC_69 = "@@126";

#ifndef p0_specification; Constant p0_specification = 0; #endif;
#ifndef p1_indefinite_appearance_tex; Constant p1_indefinite_appearance_tex = 0; #endif;
#ifndef p2_variable_initial_value; Constant p2_variable_initial_value = 0; #endif;
#ifndef short_name; Constant short_name = 0; #endif;
#ifndef plural; Constant plural = 0; #endif;
#ifndef article; Constant article = 0; #endif;
#ifndef description; Constant description = 0; #endif;
#ifndef map_region; Constant map_region = 0; #endif;
#ifndef initial; Constant initial = 0; #endif;
#ifndef p9_opposite; Constant p9_opposite = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef capacity; Constant capacity = 0; #endif;
#ifndef with_key; Constant with_key = 0; #endif;
#ifndef p13_ask_suggestions; Constant p13_ask_suggestions = 0; #endif;
#ifndef p14_tell_suggestions; Constant p14_tell_suggestions = 0; #endif;
#ifndef p15_other_suggestions; Constant p15_other_suggestions = 0; #endif;
#ifndef p16_seqno; Constant p16_seqno = 0; #endif;
#ifndef p17_count; Constant p17_count = 0; #endif;
#ifndef p18_frequency_tuned_to; Constant p18_frequency_tuned_to = 0; #endif;
#ifndef p19_maximum_frequency; Constant p19_maximum_frequency = 0; #endif;
#ifndef p20_minimum_frequency; Constant p20_minimum_frequency = 0; #endif;
#ifndef p21_price; Constant p21_price = 0; #endif;
#ifndef p22_path; Constant p22_path = 0; #endif;
#ifndef p23_times_followed; Constant p23_times_followed = 0; #endif;
#ifndef pluralname; Constant pluralname = 0; #endif;
#ifndef proper; Constant proper = 0; #endif;
#ifndef privately_named; Constant privately_named = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef visited; Constant visited = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef edible; Constant edible = 0; #endif;
#ifndef static; Constant static = 0; #endif;
#ifndef scenery; Constant scenery = 0; #endif;
#ifndef clothing; Constant clothing = 0; #endif;
#ifndef pushable; Constant pushable = 0; #endif;
#ifndef moved; Constant moved = 0; #endif;
#ifndef concealed; Constant concealed = 0; #endif;
#ifndef workflag; Constant workflag = 0; #endif;
#ifndef mentioned; Constant mentioned = 0; #endif;
#ifndef enterable; Constant enterable = 0; #endif;
#ifndef transparent; Constant transparent = 0; #endif;
#ifndef open; Constant open = 0; #endif;
#ifndef openable; Constant openable = 0; #endif;
#ifndef lockable; Constant lockable = 0; #endif;
#ifndef locked; Constant locked = 0; #endif;
#ifndef female; Constant female = 0; #endif;
#ifndef neuter; Constant neuter = 0; #endif;
#ifndef on; Constant on = 0; #endif;
#ifndef p65_recurring; Constant p65_recurring = 0; #endif;
#ifndef p67_seen; Constant p67_seen = 0; #endif;
#ifndef p69_familiar; Constant p69_familiar = 0; #endif;
#ifndef p71_ambiguously_plural; Constant p71_ambiguously_plural = 0; #endif;
#ifndef p73_message_text; Constant p73_message_text = 0; #endif;
#ifndef p74_on; Constant p74_on = 0; #endif;
#ifndef p76_retrieved; Constant p76_retrieved = 0; #endif;
#ifndef p78_suggested_memory; Constant p78_suggested_memory = 0; #endif;
#ifndef p79_objective; Constant p79_objective = 0; #endif;
#ifndef p80_noted_as_useful; Constant p80_noted_as_useful = 0; #endif;
#ifndef p81_hefty; Constant p81_hefty = 0; #endif;
#ifndef p82_dim; Constant p82_dim = 0; #endif;
#ifndef p84_placed_correctly; Constant p84_placed_correctly = 0; #endif;
#ifndef p85_dramatic; Constant p85_dramatic = 0; #endif;
#ifndef p86_named; Constant p86_named = 0; #endif;
#ifndef worn; Constant worn = 0; #endif;
#ifndef component_parent; Constant component_parent = 0; #endif;
#ifndef component_child; Constant component_child = 0; #endif;
#ifndef component_sibling; Constant component_sibling = 0; #endif;
#ifndef found_in; Constant found_in = 0; #endif;
#ifndef vector; Constant vector = 0; #endif;
#ifndef mark_as_room; Constant mark_as_room = 0; #endif;
#ifndef mark_as_thing; Constant mark_as_thing = 0; #endif;
#ifndef room_index; Constant room_index = 0; #endif;
#ifndef door_dir; Constant door_dir = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef absent; Constant absent = 0; #endif;
#ifndef cap_short_name; Constant cap_short_name = 0; #endif;
#ifndef list_together; Constant list_together = 0; #endif;
#ifndef regional_found_in; Constant regional_found_in = 0; #endif;
#ifndef IK_0; Constant IK_0 = 0; #endif;
#ifndef IK0_Link; Constant IK0_Link = 0; #endif;
#ifndef IK_1; Constant IK_1 = 0; #endif;
#ifndef IK1_Link; Constant IK1_Link = 0; #endif;
#ifndef IK_2; Constant IK_2 = 0; #endif;
#ifndef IK2_Link; Constant IK2_Link = 0; #endif;
#ifndef IK_3; Constant IK_3 = 0; #endif;
#ifndef IK3_Link; Constant IK3_Link = 0; #endif;
#ifndef IK_4; Constant IK_4 = 0; #endif;
#ifndef IK4_Link; Constant IK4_Link = 0; #endif;
#ifndef IK_5; Constant IK_5 = 0; #endif;
#ifndef IK5_Link; Constant IK5_Link = 0; #endif;
#ifndef IK_6; Constant IK_6 = 0; #endif;
#ifndef IK6_Link; Constant IK6_Link = 0; #endif;
#ifndef IK_7; Constant IK_7 = 0; #endif;
#ifndef IK7_Link; Constant IK7_Link = 0; #endif;
#ifndef IK_8; Constant IK_8 = 0; #endif;
#ifndef IK8_Link; Constant IK8_Link = 0; #endif;
#ifndef IK_9; Constant IK_9 = 0; #endif;
#ifndef IK9_Link; Constant IK9_Link = 0; #endif;
#ifndef IK_23; Constant IK_23 = 0; #endif;
#ifndef IK23_Link; Constant IK23_Link = 0; #endif;
#ifndef IK_24; Constant IK_24 = 0; #endif;
#ifndef IK24_Link; Constant IK24_Link = 0; #endif;
#ifndef IK_25; Constant IK_25 = 0; #endif;
#ifndef IK25_Link; Constant IK25_Link = 0; #endif;
#ifndef IK_26; Constant IK_26 = 0; #endif;
#ifndef IK26_Link; Constant IK26_Link = 0; #endif;
#ifndef IK_27; Constant IK_27 = 0; #endif;
#ifndef IK27_Link; Constant IK27_Link = 0; #endif;
#ifndef IK_28; Constant IK_28 = 0; #endif;
#ifndef IK28_Link; Constant IK28_Link = 0; #endif;
#ifndef IK_29; Constant IK_29 = 0; #endif;
#ifndef IK29_Link; Constant IK29_Link = 0; #endif;
#ifndef IK_30; Constant IK_30 = 0; #endif;
#ifndef IK30_Link; Constant IK30_Link = 0; #endif;
#ifndef IK_43; Constant IK_43 = 0; #endif;
#ifndef IK43_Link; Constant IK43_Link = 0; #endif;
#ifndef IK_72; Constant IK_72 = 0; #endif;
#ifndef IK72_Link; Constant IK72_Link = 0; #endif;
#ifndef IK_78; Constant IK_78 = 0; #endif;
#ifndef IK78_Link; Constant IK78_Link = 0; #endif;
#ifndef IK_119; Constant IK_119 = 0; #endif;
#ifndef IK119_Link; Constant IK119_Link = 0; #endif;
#ifndef IK_150; Constant IK_150 = 0; #endif;
#ifndef IK150_Link; Constant IK150_Link = 0; #endif;
#ifndef IK_165; Constant IK_165 = 0; #endif;
#ifndef IK165_Link; Constant IK165_Link = 0; #endif;
#ifndef IK_169; Constant IK_169 = 0; #endif;
#ifndef IK169_Link; Constant IK169_Link = 0; #endif;
#ifndef name; Constant name = 0; #endif;
#ifndef parse_name; Constant parse_name = 0; #endif;
#ifndef action_bitmap; Constant action_bitmap = 0; #endif;

#IFNDEF cap_short_name;
Constant cap_short_name = short_name;
#ENDIF;
Array I7_ST_say_one_of --> 37;
Array I7_ST_say_first_time --> 8;

Array Runtime_Quotations_Displayed --> 1;

[ InitialHeapAllocation obj pv;
    pv = (Global_Vars-->13); (Global_Vars-->13) = BlkValueCreate(LIST_OF_TY,pv,KD3_list_of_objects);
    pv = (Global_Vars-->14); (Global_Vars-->14) = BlkValueCreate(LIST_OF_TY,pv,KD3_list_of_objects);
    pv = (Global_Vars-->15); (Global_Vars-->15) = BlkValueCreate(LIST_OF_TY,pv,KD3_list_of_objects);
    if (p13_ask_suggestions) objectloop (obj provides p13_ask_suggestions && (~~(obj ofclass VPH_Class))) { pv = obj.p13_ask_suggestions; obj.p13_ask_suggestions = BlkValueCreate(LIST_OF_TY,pv,KD3_list_of_objects); }
    if (p14_tell_suggestions) objectloop (obj provides p14_tell_suggestions && (~~(obj ofclass VPH_Class))) { pv = obj.p14_tell_suggestions; obj.p14_tell_suggestions = BlkValueCreate(LIST_OF_TY,pv,KD3_list_of_objects); }
    if (p15_other_suggestions) objectloop (obj provides p15_other_suggestions && (~~(obj ofclass VPH_Class))) { pv = obj.p15_other_suggestions; obj.p15_other_suggestions = BlkValueCreate(LIST_OF_TY,pv,KD3_list_of_objects); }
];
[ DistributeBlockConstants obj pv;
];
#ifdef TARGET_ZCODE;
Constant MEMORY_HEAP_SIZE = 8192;
#ifnot;
Constant MEMORY_HEAP_SIZE = 32768;
#endif;


Array KD0_phrase_nothing_to_nothing --> ! phrase nothing -> nothing
    MAP_TY 1    UNKNOWN_TY;
Array Default_Value_0 --> KD0_phrase_nothing_to_nothing Def_Phrase_0 "default value of phrase nothing -> nothing";
[ Def_Phrase_0 a b c d e f g h;
    return false;
];

Array KD1_values_based_rule_producin --> ! values based rule producing values
    RULE_TY 2 VALUE_TY VALUE_TY;
Array KD2_activity --> ! activity
    ACTIVITY_TY 1 NIL_TY;
Array KD3_list_of_objects --> ! list of objects
    LIST_OF_TY 1 OBJECT_TY;
Array KD4_relation_of_rooms_to_doors --> ! relation of rooms to doors
    RELATION_TY 2 OBJECT_TY OBJECT_TY;
Array KD5_relation_of_things_to_thin --> ! relation of things to things
    RELATION_TY 2 OBJECT_TY OBJECT_TY;
Array KD6_relation_of_things_to_memo --> ! relation of things to memories
    RELATION_TY 2 OBJECT_TY OBJECT_TY;
Array KD7_relation_of_plans_to_thing --> ! relation of plans to things
    RELATION_TY 2 OBJECT_TY OBJECT_TY;
[ DefaultValueFinder K;
    if (K == KD0_phrase_nothing_to_nothing) return Default_Value_0;
    return 0;
];


Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_FLAG_MULTIPLE = $$00000001;
Constant BLK_FLAG_16_BIT   = $$00000010;
Constant BLK_FLAG_WORD     = $$00000100;
Constant BLK_FLAG_RESIDENT = $$00001000;
Constant BLK_HEADER_KOV = 1;

Constant BLK_DATA_OFFSET = 2*WORDSIZE;

Constant BLK_DATA_MULTI_OFFSET = 4*WORDSIZE;
Constant BLK_NEXT 2;
Constant BLK_PREV 3;

#IFDEF MEMORY_HEAP_SIZE;

! Constant SHOW_ALLOCATIONS = 1; ! Uncomment this for debugging purposes

[ BlkType txb;
	return txb-->BLK_HEADER_KOV;
];

[ BlkSize txb bsize n; ! Size of an individual block, including header
	if (txb == 0) return 0;
	for (bsize=1: n<txb->BLK_HEADER_N: bsize=bsize*2) n++;
	return bsize;
];

[ BlkTotalSize txb tsize; ! Combined size of multiple-blocks for a value
	if (txb == 0) return 0;
	if ((txb->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE == 0)
		return BlkSize(txb);
	for (:txb~=NULL:txb=txb-->BLK_NEXT) {
		tsize = tsize + BlkSize(txb);
	}
	return tsize;
];

[ BlkDebug txb n k i bsize tot dtot kov;
	if (txb == 0) "Block never created.";
	kov = txb-->BLK_HEADER_KOV;
	print "Block ", txb, " (kov ", kov, "): ";
	for (:txb~=NULL:txb = txb-->BLK_NEXT) {
		if (k++ == 100) " ... and so on.";
		if (txb-->BLK_HEADER_KOV ~= kov)
			print "*Wrong kov=", txb-->BLK_HEADER_KOV, "* ";
		n = txb->BLK_HEADER_N;
		for (bsize=1:n>0:n--) bsize=bsize*2;
		i = bsize - BLK_DATA_OFFSET;
		dtot = dtot+i;
		tot = tot+bsize;
		print txb, "(", bsize, ") > ";
	}
	print dtot, " data in ", tot, " bytes^";
];

[ BlkDebugDecomposition from to txb pf;
	if (to==0) to = NULL;
	for (txb=from:(txb~=to) && (txb~=NULL):txb=txb-->BLK_NEXT) {
		if (pf) print "+";
		print BlkSize(txb);
		pf = true;
	}
	print "^";
];

Array Blk_Heap -> MEMORY_HEAP_SIZE + 16; ! Plus 16 to allow room for head-free-block

[ HeapInitialise n bsize blk2;
	blk2 = Blk_Heap + 16;
	Blk_Heap->BLK_HEADER_N = 4;
	Blk_Heap-->BLK_HEADER_KOV = 0;
	Blk_Heap->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	Blk_Heap-->BLK_NEXT = blk2;
	Blk_Heap-->BLK_PREV = NULL;
	for (bsize=1: bsize < MEMORY_HEAP_SIZE: bsize=bsize*2) n++;
	blk2->BLK_HEADER_N = n;
	blk2-->BLK_HEADER_KOV = 0;
	blk2->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	blk2-->BLK_NEXT = NULL;
	blk2-->BLK_PREV = Blk_Heap;
];

[ HeapNetFreeSpace multiple txb asize;
	for (txb=Blk_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = asize + BlkSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
	}
	return asize;
];

Constant SMALLEST_BLK_WORTH_ALLOCATING = 12; ! i.e. 2^12 = 4096 bytes

[ HeapMakeSpace size multiple  newblocksize newblock B n;
	for (::) {
		if (multiple) {
			if (HeapNetFreeSpace(multiple) >= size) rtrue;
		} else {
			if (HeapLargestFreeBlock(0) >= size) rtrue;
		}
		newblocksize = 1;
		for (n=0: (n<SMALLEST_BLK_WORTH_ALLOCATING) || (newblocksize<size): n++)
			newblocksize = newblocksize*2;
		while (newblocksize < size+16) newblocksize = newblocksize*2;
		newblock = VM_AllocateMemory(newblocksize);
		if (newblock == 0) rfalse;
		newblock->BLK_HEADER_N = n;
		newblock-->BLK_HEADER_KOV = 0;
		newblock->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		newblock-->BLK_NEXT = NULL;
		newblock-->BLK_PREV = NULL;
		for (B = Blk_Heap-->BLK_NEXT:B ~= NULL:B = B-->BLK_NEXT)
			if (B-->BLK_NEXT == NULL) {
				B-->BLK_NEXT = newblock;
				newblock-->BLK_PREV = B;
				jump Linked;
			}
		Blk_Heap-->BLK_NEXT = newblock;
		newblock-->BLK_PREV = Blk_Heap;
		.Linked; ;
		#ifdef SHOW_ALLOCATIONS;
		print "Increasing heap to free space map: "; BlkDebugDecomposition(Blk_Heap, 0);
		#endif;
	}
	rtrue;
];

[ HeapLargestFreeBlock multiple txb asize best;
	best = 0;
	for (txb=Blk_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = BlkSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
		if (asize > best) best = asize;
	}
	return best;
];

[ BlkAllocate size kov flags
	dsize n m free_block min_m max_m smallest_oversized_block secondhalf i hsize head tail;
	
	if (HeapMakeSpace(size, flags & BLK_FLAG_MULTIPLE) == false) 
		return BlkAllocationError("ran out");

	! Calculate the header size for a block of this KOV
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;

	! Calculate the data size
	n=0; for (dsize=1: dsize < hsize+size: dsize=dsize*2) n++;

	! Seek a free block closest to the correct size, but starting from the
	! block after the fixed head-free-block, which we can't touch
	min_m = 10000; max_m = 0;
	for (free_block = Blk_Heap-->BLK_NEXT:
		free_block ~= NULL:
		free_block = free_block-->BLK_NEXT) {
		m = free_block->BLK_HEADER_N;
		! Current block the ideal size
		if (m == n) jump CorrectSizeFound;
		! Current block too large: find the smallest which is larger than needed
		if (m > n) {
			if (min_m > m) {
				min_m = m;
				smallest_oversized_block = free_block;
			}
		}
		! Current block too small: find the largest which is smaller than needed
		if (m < n) {
			if (max_m < m) {
				max_m = m;
			}
		}
	}

	if (min_m == 10000) {
		! Case I: No block is large enough to hold the entire size
		if (flags & BLK_FLAG_MULTIPLE == 0) return BlkAllocationError("too fragmented");
		! Set dsize to the size in bytes if the largest block available
		for (dsize=1: max_m > 0: dsize=dsize*2) max_m--;
		! Split as a head (dsize-hsize), which we can be sure fits into one block,
		! plus a tail (size-(dsize-hsize), which might be a list of blocks
		head = BlkAllocate(dsize-hsize, kov, flags);
		if (head == 0) return BlkAllocationError("head block not available");
		tail = BlkAllocate(size-(dsize-hsize), kov, flags);
		if (tail == 0) return BlkAllocationError("tail block not available");
		head-->BLK_NEXT = tail;
		tail-->BLK_PREV = head;
		return head;
	}

	! Case II: No block is the right size, but some exist which are too big
	! Set dsize to the size in bytes of the smallest oversized block
	for (dsize=1,m=1: m<=min_m: dsize=dsize*2) m++;
	free_block = smallest_oversized_block;
	while (min_m > n) {
		! Repeatedly halve free_block at the front until the two smallest
		! fragments left are the correct size: then take the frontmost
		dsize = dsize/2;
		secondhalf = free_block + dsize;
		secondhalf-->BLK_NEXT = free_block-->BLK_NEXT;
		if (secondhalf-->BLK_NEXT ~= NULL)
			(secondhalf-->BLK_NEXT)-->BLK_PREV = secondhalf;
		secondhalf-->BLK_PREV = free_block;
		free_block-->BLK_NEXT = secondhalf;
		free_block->BLK_HEADER_N = (free_block->BLK_HEADER_N) - 1;
		secondhalf->BLK_HEADER_N = free_block->BLK_HEADER_N;
		secondhalf-->BLK_HEADER_KOV = free_block-->BLK_HEADER_KOV;
		secondhalf->BLK_HEADER_FLAGS = free_block->BLK_HEADER_FLAGS;
		min_m--;
	}
	
	! Once that is done, free_block points to a block which is exactly the
	! right size, so we can fall into...
	
	! Case III: There is a free block which has the correct size.
	.CorrectSizeFound;
	! Delete the free block from the double linked list of free blocks: note
	! that it cannot be the head of this list, which is fixed
	if (free_block-->BLK_NEXT == NULL) {
		! We remove final block, so previous is now final
		(free_block-->BLK_PREV)-->BLK_NEXT = NULL;
	} else {
		! We remove a middle block, so join previous to next
		(free_block-->BLK_PREV)-->BLK_NEXT = free_block-->BLK_NEXT;
		(free_block-->BLK_NEXT)-->BLK_PREV = free_block-->BLK_PREV;
	}
	free_block-->BLK_HEADER_KOV = KindAtomic(kov);
	free_block->BLK_HEADER_FLAGS = flags;
	if (flags & BLK_FLAG_MULTIPLE) {
		free_block-->BLK_NEXT = NULL;
		free_block-->BLK_PREV = NULL;
	}
	
	! Zero out the data bytes in the memory allocated
	for (i=hsize:i<dsize:i++) free_block->i=0;
	return free_block;
];

[ BlkAllocationError reason;
	print "*** Memory ", (string) reason, " ***^";
	RunTimeProblem(RTP_HEAPERROR);
	rfalse;
];

[ BlkMerge block first last pv nx;
	first = block; last = block;
	while (last-->BLK_NEXT == last+BlkSize(last))
		last = last-->BLK_NEXT;
	while ((first-->BLK_PREV + BlkSize(first-->BLK_PREV) == first) &&
		(first-->BLK_PREV ~= Blk_Heap))
		first = first-->BLK_PREV;
	pv = first-->BLK_PREV;
	nx = last-->BLK_NEXT;
	#ifdef SHOW_ALLOCATIONS;
	print "Merging: "; BlkDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
	#endif;
	if (BlkRecut(first, last)) {
		#ifdef SHOW_ALLOCATIONS;
		print " --> "; BlkDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
		#endif;
	}
];

[ BlkRecut first last tsize backsize mfrom mto bnext backend n dsize fine_so_far;
	if (first == last) rfalse;
	mfrom = first; mto = last + BlkSize(last);
	bnext = last-->BLK_NEXT;
	fine_so_far = true;
	for (:mto>mfrom: mto = mto - backsize) {
		for (n=0, backsize=1: backsize*2 <= mto-mfrom: n++) backsize=backsize*2;
		if ((fine_so_far) && (backsize == BlkSize(last))) {
			bnext = last; last = last-->BLK_PREV;
			bnext-->BLK_PREV = last;
			last-->BLK_NEXT = bnext;
			continue;
		}
		fine_so_far = false; ! From this point, "last" is meaningless
		backend = mto - backsize;
		backend->BLK_HEADER_N = n;
		backend-->BLK_HEADER_KOV = 0;
		backend->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		backend-->BLK_NEXT = bnext;
		if (bnext ~= NULL) {
			bnext-->BLK_PREV = backend;
			bnext = backend;
		}
	}
	if (fine_so_far) rfalse;
	rtrue;
];

[ BlkFree block fromtxb ptxb;
	if (block == 0) return;
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_RESIDENT) return;
	BlkValueDestroy(block);
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) {
		if (block-->BLK_PREV ~= NULL) (block-->BLK_PREV)-->BLK_NEXT = NULL;
		fromtxb = block;
		for (:(block-->BLK_NEXT)~=NULL:block = block-->BLK_NEXT) ;
		while (block ~= fromtxb) {
			ptxb = block-->BLK_PREV; BlkFreeSingleBlock(block); block = ptxb;
		}
	}
	BlkFreeSingleBlock(block);
];

[ BlkFreeSingleBlock block free nx;
	block-->BLK_HEADER_KOV = 0;
	block->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	for (free = Blk_Heap:free ~= NULL:free = free-->BLK_NEXT) {
		nx = free-->BLK_NEXT;
		if (nx == NULL) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = NULL;
			BlkMerge(block);
			return;
		}
		if (UnsignedCompare(nx, block) == 1) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = nx;
			nx-->BLK_PREV = block;
			BlkMerge(block);
			return;
		}
	}
];

[ BlkResize block req newsize dsize newblk kov n i otxb flags;
	if (block == 0) "*** Cannot resize null block ***";
	kov = block-->BLK_HEADER_KOV;
	flags = block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0) "*** Cannot resize inextensible block ***";
	otxb = block;
	newsize = req;
	for (:: block = block-->BLK_NEXT) {
		n = block->BLK_HEADER_N;
		for (dsize=1: n>0: n--) dsize = dsize*2;
		i = dsize - BLK_DATA_MULTI_OFFSET;
		newsize = newsize - i;
		if (newsize > 0) {
			if (block-->BLK_NEXT ~= NULL) continue;
			newblk = BlkAllocate(newsize, kov, flags);
			if (newblk == 0) rfalse;
			block-->BLK_NEXT = newblk;
			newblk-->BLK_PREV = block;
			rtrue;
		}
		if (block-->BLK_NEXT ~= NULL) {
			BlkFree(block-->BLK_NEXT);
			block-->BLK_NEXT = NULL;
		}
		rtrue;
	}
];

[ DebugHeap;
	print "Managing a heap of initially ", MEMORY_HEAP_SIZE+16, " bytes.^";
	print HeapNetFreeSpace(false), " bytes currently free.^";
	print "Free space decomposition: "; BlkDebugDecomposition(Blk_Heap);
	print "Free space map: "; BlkDebug(Blk_Heap);
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ HeapInitialise; ];
[ BlkFree; ];
[ DebugHeap;
	"This story file does not use a heap of managed memory.";
];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE;

[ BlkValueExtent block  tsize flags;
	if (block == 0) return 0;
	flags = block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0)
		tsize = BlkSize(block) - BLK_DATA_OFFSET;
	else
		for (:block~=NULL:block=block-->BLK_NEXT)
			tsize = tsize + BlkSize(block) - BLK_DATA_MULTI_OFFSET;
	if (flags & BLK_FLAG_16_BIT) return tsize/2;
	if (flags & BLK_FLAG_WORD) return tsize/WORDSIZE;
	return tsize;
];

[ BlkValueSetExtent block tsize flags wsize;
	if (block == 0) return 0;
	flags = block->BLK_HEADER_FLAGS; wsize = 1;
	if (flags & BLK_FLAG_WORD) wsize = WORDSIZE;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	return BlkResize(block, (tsize)*wsize);
];

[ BlkValueRead block pos dsize hsize flags wsize ot op;
	if (block==0) rfalse;
	flags = block->BLK_HEADER_FLAGS; wsize = 1;
	if (flags & BLK_FLAG_WORD) wsize = WORDSIZE;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	ot = block; op = pos;
	pos = pos*wsize;
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;
	for (:block~=NULL:block=block-->BLK_NEXT) {
		dsize = BlkSize(block) - hsize;
		if ((pos >= 0) && (pos<dsize)) {
			block = block + hsize + pos;
			switch(wsize) {
				1: return block->0;
				2:	#Iftrue (WORDSIZE == 2); return block-->0;
					#ifnot; return (block->0)*256 + (block->1);
					#endif;
				4: return block-->0;
			}
		}
		pos = pos - dsize;
	}
	"*** BlkValueRead: reading from index out of range: ", op, " in ", ot, " ***";
];

[ BlkValueWrite block pos val dsize hsize flags wsize ot op;
	if (block==0) rfalse;
	flags = block->BLK_HEADER_FLAGS; wsize = 1;
	if (flags & BLK_FLAG_WORD) wsize = WORDSIZE;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	ot = block; op = pos;
	pos = pos*wsize;
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;
	for (:block~=NULL:block=block-->BLK_NEXT) {
		dsize = BlkSize(block) - hsize;
		if ((pos >= 0) && (pos<dsize)) {
			block = block + hsize + pos;
			switch(wsize) {
				1: block->0 = val;
				2:	#Iftrue (WORDSIZE == 2); block-->0 = val;
					#ifnot; block->0 = (val/256)%256; block->1 = val%256;
					#endif;
				4: block-->0 = val;
			}
			return;
		}
		pos = pos - dsize;
	}
	"*** BlkValueWrite: writing to index out of range: ", op, " in ", ot, " ***";
];

Constant CREATE_KOVS     = 1;
Constant CAST_KOVS       = 2;
Constant DESTROY_KOVS    = 3;
Constant PRECOPY_KOVS    = 4;
Constant COPY_KOVS       = 5;
Constant COMPARE_KOVS    = 6;
Constant READ_FILE_KOVS  = 7;
Constant WRITE_FILE_KOVS = 8;
Constant HASH_KOVS       = 9;

Global block_value_tally;
[ BlkValueCreate kov cast_from skov  block sf;

	if (skov == 0 && (kov < 0 || kov >= BASE_KIND_HWM)) skov = kov;

	sf = KOVSupportFunction(kov);
	if (sf) block = sf(CREATE_KOVS, cast_from, skov);
	else { print "*** Impossible runtime creation ***^"; rfalse; }

#ifdef SHOW_ALLOCATIONS;
	print "[created ", kov, " at ", block, ": ", block_value_tally++, "]^";
#endif;
	return block;
];

[ BlkValueCast block tokov fromkov fromval  sf;
	sf = KOVSupportFunction(tokov);
	if (sf) return sf(CAST_KOVS, fromval, fromkov, block);
	else { print "*** Impossible runtime cast ***^"; rfalse; }
];

[ BlkValueDestroy block  k rv sf;
	if (block == 0) return;
	k = block-->BLK_HEADER_KOV;
	sf = KOVSupportFunction(k);
	if (sf) return sf(DESTROY_KOVS, block);
	else { print "*** Impossible runtime deallocation ***^"; rfalse; }
];

[ BlkValueCopy blockto blockfrom dsize i sf;
	if (blockto == 0) { print "*** Deep copy failed: destination empty ***^"; rfalse; }
	if (blockfrom == 0) { print "*** Deep copy failed: source empty ***^"; rfalse; }

	if (blockfrom->BLK_HEADER_N == 0) {
		! A hack to handle precompiled array constants: N=0 blocks otherwise don't exist
		LIST_OF_TY_CopyRawArray(blockto, blockfrom, 1);
		return blockto;
	}

	if (blockfrom-->BLK_HEADER_KOV ~= blockto-->BLK_HEADER_KOV) {
		print "*** Deep copy failed: types mismatch ***^"; rfalse;
	}

	BlkValueDestroy(blockto);

	dsize = BlkValueExtent(blockfrom);

	if (((blockfrom->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) &&
		(BlkValueSetExtent(blockto, dsize, -1) == false)) {
		print "*** Deep copy failed: resizing failed ***^"; rfalse;
	}

	sf = KOVSupportFunction(blockfrom-->BLK_HEADER_KOV);

	if (sf) sf(PRECOPY_KOVS, blockto, blockfrom);

	for (i=0:i<dsize:i++) BlkValueWrite(blockto, i, BlkValueRead(blockfrom, i));

	if (sf) sf(COPY_KOVS, blockto, blockfrom);
	else { print "*** Impossible runtime copy ***^"; rfalse; }
	return blockto;
];

[ BlkValueCompare blockleft blockright  kov sf;
	if ((blockleft == 0) && (blockright == 0)) return 0;
	if (blockleft == 0) return 1;
	if (blockright == 0) return -1;
	if (blockleft-->BLK_HEADER_KOV ~= blockright-->BLK_HEADER_KOV)
		return blockleft-->BLK_HEADER_KOV - blockright-->BLK_HEADER_KOV;
	kov = blockleft-->BLK_HEADER_KOV;

	sf = KOVSupportFunction(kov);
	if (sf) return sf(COMPARE_KOVS, blockleft, blockright);
	else { print "*** Impossible runtime comparison ***^"; rfalse; }
];

[ BlkValueInitialCopy blockto blockfrom dsize i;
	if (blockto == 0) { print "*** Initial copy failed: destination empty ***^"; rfalse; }
	if (blockfrom == 0) { print "*** Initial copy failed: source empty ***^"; rfalse; }
	dsize = 1; for (i=1: i<=blockfrom->BLK_HEADER_N: i++) dsize=dsize*2;
	for (i=0:i<dsize:i++) blockto->i = blockfrom->i;
	return blockto;
];

[ BlkValueHash block  kov sf;
	if (block == 0) return 0;
	kov = block-->BLK_HEADER_KOV;
	sf = KOVSupportFunction(kov);
	if (sf) return sf(HASH_KOVS, block);
	else { print "*** Impossible runtime hashing ***^"; rfalse; }
];

[ KOVHashValue kov value;
	if (KOVIsBlockValue(kov)) return BlkValueHash(value);
	return value;
];

[ BlkValueReadFromFile block auxf ch kov  sf;
	sf = KOVSupportFunction(kov);
	if (sf) return sf(READ_FILE_KOVS, block, auxf, ch);
	rfalse;
];

[ BlkValueWriteToFile block kov  sf;
	sf = KOVSupportFunction(kov);
	if (sf) return sf(WRITE_FILE_KOVS, block);
	rfalse;
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ BlkValueReadFromFile; rfalse; ];
[ BlkValueWriteToFile; rfalse; ];
[ BlkValueCreate; ];
[ BlkValueCompare x y; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of indexed texts

#IFDEF TARGET_ZCODE;
Constant IT_Storage_Flags = BLK_FLAG_MULTIPLE;
Constant ZSCII_Tables;
#IFNOT;
Constant IT_Storage_Flags = BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT;
Constant Large_Unicode_Tables;
#ENDIF;

Constant UNIC_NCT = 10000; ! Safe as highest case-change delta is 8383

#IFDEF ZSCII_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $009b (   3) (       3) $00a1 (   1) (UNIC_NCT)
    $00a4 (   2) (       3) $00a6 (   1) (UNIC_NCT) $00a9 (   6) (       6)
    $00b5 (   5) (       5) $00bf (   5) (       5) $00c9 (  -3) (       1)
    $00cd (   3) (       3) $00d3 (  -3) (       1) $00d7 (   2) (       2)
    $00dc (   1) (       1) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $009e (   3) (      -3) $00a7 (   2) (      -3)
    $00af (   6) (      -6) $00ba (   5) (      -5) $00c4 (   5) (      -5)
    $00ca (  -3) (      -1) $00d0 (   3) (      -3) $00d4 (  -3) (      -1)
    $00d9 (   2) (      -2) $00dd (   1) (      -1) $0000
;
#ENDIF; ! ZSCII_Tables

#IFDEF Small_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (UNIC_NCT) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (UNIC_NCT)
    $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0000
;

#ENDIF; ! Small_Unicode_Tables

#IFDEF Large_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (     743) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (     121)
    $0101 ( -47) (      -1) $0131 (   1) (    -232) $0133 (  -5) (      -1) $0138 (   1) (UNIC_NCT)
    $013a ( -15) (      -1) $0149 (   1) (UNIC_NCT) $014b ( -45) (      -1) $017a (  -5) (      -1)
    $017f (   1) (    -300) $0180 (   1) (UNIC_NCT) $0183 (  -3) (      -1) $0188 (   1) (      -1)
    $018c (   1) (      -1) $018d (   1) (UNIC_NCT) $0192 (   1) (      -1) $0195 (   1) (      97)
    $0199 (   1) (      -1) $019a (   2) (UNIC_NCT) $019e (   1) (     130) $01a1 (  -5) (      -1)
    $01a8 (   1) (      -1) $01aa (   2) (UNIC_NCT) $01ad (   1) (      -1) $01b0 (   1) (      -1)
    $01b4 (  -3) (      -1) $01b9 (   1) (      -1) $01ba (   1) (UNIC_NCT) $01bd (   1) (      -1)
    $01be (   1) (UNIC_NCT) $01bf (   1) (      56) $01c6 (   1) (      -2) $01c9 (   1) (      -2)
    $01cc (   1) (      -2) $01ce ( -15) (      -1) $01dd (   1) (     -79) $01df ( -17) (      -1)
    $01f0 (   1) (UNIC_NCT) $01f3 (   1) (      -2) $01f5 (   1) (      -1) $01f9 ( -39) (      -1)
    $0221 (   1) (UNIC_NCT) $0223 ( -17) (      -1) $0234 (   3) (UNIC_NCT) $0250 (   3) (UNIC_NCT)
    $0253 (   1) (    -210) $0254 (   1) (    -206) $0255 (   1) (UNIC_NCT) $0256 (   2) (    -205)
    $0258 (   1) (UNIC_NCT) $0259 (   1) (    -202) $025a (   1) (UNIC_NCT) $025b (   1) (    -203)
    $025c (   4) (UNIC_NCT) $0260 (   1) (    -205) $0261 (   2) (UNIC_NCT) $0263 (   1) (    -207)
    $0264 (   4) (UNIC_NCT) $0268 (   1) (    -209) $0269 (   1) (    -211) $026a (   5) (UNIC_NCT)
    $026f (   1) (    -211) $0270 (   2) (UNIC_NCT) $0272 (   1) (    -213) $0273 (   2) (UNIC_NCT)
    $0275 (   1) (    -214) $0276 (  10) (UNIC_NCT) $0280 (   1) (    -218) $0281 (   2) (UNIC_NCT)
    $0283 (   1) (    -218) $0284 (   4) (UNIC_NCT) $0288 (   1) (    -218) $0289 (   1) (UNIC_NCT)
    $028a (   2) (    -217) $028c (   6) (UNIC_NCT) $0292 (   1) (    -219) $0293 (  29) (UNIC_NCT)
    $0390 (   1) (UNIC_NCT) $03ac (   1) (     -38) $03ad (   3) (     -37) $03b0 (   1) (UNIC_NCT)
    $03b1 (  17) (     -32) $03c2 (   1) (     -31) $03c3 (   9) (     -32) $03cc (   1) (     -64)
    $03cd (   2) (     -63) $03d0 (   1) (     -62) $03d1 (   1) (     -57) $03d5 (   1) (     -47)
    $03d6 (   1) (     -54) $03d7 (   1) (UNIC_NCT) $03d9 ( -23) (      -1) $03f0 (   1) (     -86)
    $03f1 (   1) (     -80) $03f2 (   1) (       7) $03f3 (   1) (UNIC_NCT) $03f5 (   1) (     -96)
    $03f8 (   1) (      -1) $03fb (   1) (      -1) $0430 (  32) (     -32) $0450 (  16) (     -80)
    $0461 ( -33) (      -1) $048b ( -53) (      -1) $04c2 ( -13) (      -1) $04d1 ( -37) (      -1)
    $04f9 (   1) (      -1) $0501 ( -15) (      -1) $0561 (  38) (     -48) $0587 (   1) (UNIC_NCT)
    $1d00 (  44) (UNIC_NCT) $1d62 (  10) (UNIC_NCT) $1e01 (-149) (      -1) $1e96 (   5) (UNIC_NCT)
    $1e9b (   1) (     -59) $1ea1 ( -89) (      -1) $1f00 (   8) (       8) $1f10 (   6) (       8)
    $1f20 (   8) (       8) $1f30 (   8) (       8) $1f40 (   6) (       8) $1f50 (   1) (UNIC_NCT)
    $1f51 (   1) (       8) $1f52 (   1) (UNIC_NCT) $1f53 (   1) (       8) $1f54 (   1) (UNIC_NCT)
    $1f55 (   1) (       8) $1f56 (   1) (UNIC_NCT) $1f57 (   1) (       8) $1f60 (   8) (       8)
    $1f70 (   2) (      74) $1f72 (   4) (      86) $1f76 (   2) (     100) $1f78 (   2) (     128)
    $1f7a (   2) (     112) $1f7c (   2) (     126) $1f80 (   8) (       8) $1f90 (   8) (       8)
    $1fa0 (   8) (       8) $1fb0 (   2) (       8) $1fb2 (   1) (UNIC_NCT) $1fb3 (   1) (       9)
    $1fb4 (  -3) (UNIC_NCT) $1fb7 (   1) (UNIC_NCT) $1fbe (   1) (   -7205) $1fc2 (   1) (UNIC_NCT)
    $1fc3 (   1) (       9) $1fc4 (  -3) (UNIC_NCT) $1fc7 (   1) (UNIC_NCT) $1fd0 (   2) (       8)
    $1fd2 (   2) (UNIC_NCT) $1fd6 (   2) (UNIC_NCT) $1fe0 (   2) (       8) $1fe2 (   3) (UNIC_NCT)
    $1fe5 (   1) (       7) $1fe6 (   2) (UNIC_NCT) $1ff2 (   1) (UNIC_NCT) $1ff3 (   1) (       9)
    $1ff4 (  -3) (UNIC_NCT) $1ff7 (   1) (UNIC_NCT) $2071 (   1) (UNIC_NCT) $207f (   1) (UNIC_NCT)
    $210a (   1) (UNIC_NCT) $210e (   2) (UNIC_NCT) $2113 (   1) (UNIC_NCT) $212f (   1) (UNIC_NCT)
    $2134 (   1) (UNIC_NCT) $2139 (   1) (UNIC_NCT) $213d (   1) (UNIC_NCT) $2146 (   4) (UNIC_NCT)
    $fb00 (   7) (UNIC_NCT) $fb13 (   5) (UNIC_NCT) $ff41 (  26) (     -32) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0100 ( -47) (       1)
    $0130 (   1) (    -199) $0132 (  -5) (       1) $0139 ( -15) (       1) $014a ( -45) (       1)
    $0178 (   1) (    -121) $0179 (  -5) (       1) $0181 (   1) (     210) $0182 (  -3) (       1)
    $0186 (   1) (     206) $0187 (   1) (       1) $0189 (   2) (     205) $018b (   1) (       1)
    $018e (   1) (      79) $018f (   1) (     202) $0190 (   1) (     203) $0191 (   1) (       1)
    $0193 (   1) (     205) $0194 (   1) (     207) $0196 (   1) (     211) $0197 (   1) (     209)
    $0198 (   1) (       1) $019c (   1) (     211) $019d (   1) (     213) $019f (   1) (     214)
    $01a0 (  -5) (       1) $01a6 (   1) (     218) $01a7 (   1) (       1) $01a9 (   1) (     218)
    $01ac (   1) (       1) $01ae (   1) (     218) $01af (   1) (       1) $01b1 (   2) (     217)
    $01b3 (  -3) (       1) $01b7 (   1) (     219) $01b8 (   1) (       1) $01bc (   1) (       1)
    $01c4 (   1) (       2) $01c7 (   1) (       2) $01ca (   1) (       2) $01cd ( -15) (       1)
    $01de ( -17) (       1) $01f1 (   1) (       2) $01f4 (   1) (       1) $01f6 (   1) (     -97)
    $01f7 (   1) (     -56) $01f8 ( -39) (       1) $0220 (   1) (    -130) $0222 ( -17) (       1)
    $0386 (   1) (      38) $0388 (   3) (      37) $038c (   1) (      64) $038e (   2) (      63)
    $0391 (  17) (      32) $03a3 (   9) (      32) $03d2 (   3) (UNIC_NCT) $03d8 ( -23) (       1)
    $03f4 (   1) (     -60) $03f7 (   1) (       1) $03f9 (   1) (      -7) $03fa (   1) (       1)
    $0400 (  16) (      80) $0410 (  32) (      32) $0460 ( -33) (       1) $048a ( -53) (       1)
    $04c0 (   1) (UNIC_NCT) $04c1 ( -13) (       1) $04d0 ( -37) (       1) $04f8 (   1) (       1)
    $0500 ( -15) (       1) $0531 (  38) (      48) $10a0 (  38) (UNIC_NCT) $1e00 (-149) (       1)
    $1ea0 ( -89) (       1) $1f08 (   8) (      -8) $1f18 (   6) (      -8) $1f28 (   8) (      -8)
    $1f38 (   8) (      -8) $1f48 (   6) (      -8) $1f59 (  -7) (      -8) $1f68 (   8) (      -8)
    $1fb8 (   2) (      -8) $1fba (   2) (     -74) $1fc8 (   4) (     -86) $1fd8 (   2) (      -8)
    $1fda (   2) (    -100) $1fe8 (   2) (      -8) $1fea (   2) (    -112) $1fec (   1) (      -7)
    $1ff8 (   2) (    -128) $1ffa (   2) (    -126) $2102 (   1) (UNIC_NCT) $2107 (   1) (UNIC_NCT)
    $210b (   3) (UNIC_NCT) $2110 (   3) (UNIC_NCT) $2115 (   1) (UNIC_NCT) $2119 (   5) (UNIC_NCT)
    $2124 (   1) (UNIC_NCT) $2126 (   1) (   -7517) $2128 (   1) (UNIC_NCT) $212a (   1) (   -8383)
    $212b (   1) (   -8262) $212c (   2) (UNIC_NCT) $2130 (   2) (UNIC_NCT) $2133 (   1) (UNIC_NCT)
    $213e (   2) (UNIC_NCT) $2145 (   1) (UNIC_NCT) $ff21 (  26) (      32) $0000
;

#ENDIF; ! Large_Unicode_Tables

[ CharIsOfCase c case
	i tab min max len par;
	if (c<'A') rfalse;
	if (case == 0) {
		if ((c >= 'a') && (c <= 'z')) rtrue;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) rtrue;
		tab = CharCasingChart1;
	}
	if (c<128) rfalse;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) rfalse;
		if (c < min+len) {
			if (par) { if ((c-min) % 2 == 0) rtrue; }
			else { rtrue; }
		}
	}
	rfalse;
];

[ CharToCase c case
	i tab min max len par del f;
	if (c<'A') return c;
	if (case == 1) {
		if ((c >= 'a') && (c <= 'z')) return c-32;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) return c+32;
		tab = CharCasingChart1;
	}
	if (c<128) return c;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		del = tab-->i; i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) return c;
		if (c < min+len) {
			f = false;
			if (par) { if ((c-min) % 2 == 0) f = true; }
			else { f = true; }
			if (f) {
				if (del == UNIC_NCT) return c;
				return c+del;
			}
		}
	}
	return c;
];

#IFDEF TARGET_ZCODE;
[ IT_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if ((ch >= 155) && (ch <= 157)) return ch+3; ! a, o, u umlaut in ZSCII
	if ((ch >= 158) && (ch <= 160)) return ch-3; ! A, O, U umlaut
	if ((ch >= 164) && (ch <= 165)) return ch+3; ! e, i umlaut
	if ((ch >= 167) && (ch <= 168)) return ch-3; ! E, I umlaut
	if ((ch >= 169) && (ch <= 174)) return ch+6; ! a, e, i, o, u, y acute
	if ((ch >= 175) && (ch <= 180)) return ch-6; ! A, E, I, O, U, Y acute
	if ((ch >= 181) && (ch <= 185)) return ch+5; ! a, e, i, o, u grave
	if ((ch >= 186) && (ch <= 190)) return ch-5; ! A, E, I, O, U grave
	if ((ch >= 191) && (ch <= 195)) return ch+5; ! a, e, i, o, u circumflex
	if ((ch >= 196) && (ch <= 200)) return ch-5; ! A, E, I, O, U circumflex
	if (ch == 201) return 202; ! a circle
	if (ch == 202) return 201; ! A circle
	if (ch == 203) return 204; ! o slash
	if (ch == 204) return 203; ! O slash
	if ((ch >= 205) && (ch <= 207)) return ch+3; ! a, n, o tilde
	if ((ch >= 208) && (ch <= 210)) return ch-3; ! A, N, O tilde
	if (ch == 211) return 212; ! ae ligature
	if (ch == 212) return 211; ! AE ligature
	if (ch == 213) return 214; ! c cedilla
	if (ch == 214) return 213; ! C cedilla
	if (ch == 215 or 216) return ch+2; ! thorn, eth
	if (ch == 217 or 218) return ch-2; ! Thorn, Eth
	if (ch == 220) return 221; ! oe ligature
	if (ch == 221) return 220; ! OE ligature
	return ch;
];
#IFNOT;
[ IT_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if (CharIsOfCase(ch, 0)) return CharToCase(ch, 1);
	if (CharIsOfCase(ch, 1)) return CharToCase(ch, 0);
	return ch;
];
#ENDIF;

[ CharTestCases case i j;
	for (i=32: i<$E0; i++) {
		if ((i>=127) && (i<155)) continue;
		print i, " - ", (char) i, " -";
		if (CharIsOfCase(i, 0)) print "  lower";
		if (CharIsOfCase(i, 1)) print "  upper";
		j = CharToCase(i, 0); if (j ~= i) print "  tolower: ", (char) j;
		j = CharToCase(i, 1); if (j ~= i) print "  toupper: ", (char) j;
		print "^";
	}
];


[ INDEXED_TEXT_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     return INDEXED_TEXT_TY_Create(arg1);
		CAST_KOVS:       return INDEXED_TEXT_TY_Cast(arg1, arg2, arg3);
		DESTROY_KOVS:    rfalse;
		PRECOPY_KOVS:    rfalse;
		COPY_KOVS:       rfalse;
		COMPARE_KOVS:    return INDEXED_TEXT_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  if (arg3 == -1) rtrue;
			             return INDEXED_TEXT_TY_ReadFile(arg1, arg2, arg3);
		WRITE_FILE_KOVS: return INDEXED_TEXT_TY_WriteFile(arg1);
		HASH_KOVS:       return INDEXED_TEXT_TY_Hash(arg1);
	}
];

[ INDEXED_TEXT_TY_Create opcast x;
	x =  BlkAllocate(32, INDEXED_TEXT_TY, IT_Storage_Flags);
	if (opcast) INDEXED_TEXT_TY_Cast(opcast, TEXT_TY, x);
	return x;
];

#ifndef IT_MemoryBufferSize;
Constant IT_MemoryBufferSize = 512;
#endif;

Constant IT_Memory_NoBuffers = 2;

#ifndef IT_Memory_NoBuffers;
Constant IT_Memory_NoBuffers = 1;
#endif;

#ifdef TARGET_ZCODE;
Array IT_MemoryBuffer -> IT_MemoryBufferSize*IT_Memory_NoBuffers; ! Where characters are bytes
#ifnot;
Array IT_MemoryBuffer --> (IT_MemoryBufferSize+2)*IT_Memory_NoBuffers; ! Where characters are words
#endif;

Global RawBufferAddress = IT_MemoryBuffer;
Global RawBufferSize = IT_MemoryBufferSize;

Global IT_cast_nesting;

[ INDEXED_TEXT_TY_Cast tx fromkov indt
	len i str oldstr offs realloc news buff buffx freebuff results;
	#ifdef TARGET_ZCODE;
	buffx = IT_MemoryBufferSize;
	#ifnot;
	buffx = (IT_MemoryBufferSize + 2)*WORDSIZE;
	#endif;
	
	buff = RawBufferAddress + IT_cast_nesting*buffx;
	IT_cast_nesting++;
	if (IT_cast_nesting > IT_Memory_NoBuffers) {
		buff = VM_AllocateMemory(buffx); freebuff = buff;
		if (buff == 0) {
			BlkAllocationError("ran out with too many simultaneous indexed text conversions");
			return;
		}
	}

	.RetryWithLargerBuffer;
	if (tx == 0) {
		#ifdef TARGET_ZCODE;
		buff-->0 = 1;
		buff->2 = 0;
		#ifnot;
		buff-->0 = 0;
		#endif;
		len = 1;
	} else {
		#ifdef TARGET_ZCODE;
		@output_stream 3 buff;
		#ifnot;
		if (unicode_gestalt_ok == false) { RunTimeProblem(RTP_NOGLULXUNICODE); jump Failed; }
		oldstr = glk_stream_get_current();
		str = glk_stream_open_memory_uni(buff, RawBufferSize, filemode_Write, 0);
		glk_stream_set_current(str);
		#endif;

		@push say__p; @push say__pc;
		ClearParagraphing();
		if (fromkov == SNIPPET_TY) print (PrintSnippet) tx;
		else {
			if (tx ofclass String) print (string) tx;
			if (tx ofclass Routine) (tx)();	
		}
		@pull say__pc; @pull say__p;

		#ifdef TARGET_ZCODE;

		@output_stream -3;
		len = buff-->0;
		if (len > RawBufferSize-1) len = RawBufferSize-1;
		offs = 2;
		buff->(len+2) = 0;

		#ifnot; ! i.e. GLULX
		
		results = buff + buffx - 2*WORDSIZE;
		glk_stream_close(str, results);
		if (oldstr) glk_stream_set_current(oldstr);
		len = results-->1;
		if (len > RawBufferSize-1) {
			! Glulx had to truncate text output because the buffer ran out:
			! len is the number of characters which it tried to print
			news = RawBufferSize;
			while (news < len) news=news*2;
			news = news*4; ! Bytes rather than words
			i = VM_AllocateMemory(news);
			if (i ~= 0) {
				if (freebuff) VM_FreeMemory(freebuff);
				freebuff = i;
				buff = i;
				RawBufferSize = news/4;
				jump RetryWithLargerBuffer;
			}
			! Memory allocation refused: all we can do is to truncate the text
			len = RawBufferSize-1;
		}
		offs = 0;
		buff-->(len) = 0;

		#endif;

		len++;
	}

	IT_cast_nesting--;

	if (indt == 0) {
		indt = BlkAllocate(len+1, INDEXED_TEXT_TY, IT_Storage_Flags);
		if (indt == 0) jump Failed;
	} else {
		if (BlkValueSetExtent(indt, len+1, 1) == false) { indt = 0; jump Failed; }
	}

	#ifdef TARGET_ZCODE;
	for (i=0:i<=len:i++) BlkValueWrite(indt, i, buff->(i+offs));
	#ifnot;
	for (i=0:i<=len:i++) BlkValueWrite(indt, i, buff-->(i+offs));
	#endif;

	.Failed;
	if (freebuff) VM_FreeMemory(freebuff);

	return indt;
];

[ INDEXED_TEXT_TY_Compare indtleft indtright pos ch1 ch2 dsizeleft dsizeright;
	dsizeleft = BlkValueExtent(indtleft);
	dsizeright = BlkValueExtent(indtright);
	for (pos=0:(pos<dsizeleft) && (pos<dsizeright):pos++) {
		ch1 = BlkValueRead(indtleft, pos);
		ch2 = BlkValueRead(indtright, pos);
		if (ch1 ~= ch2) return ch1-ch2;
		if (ch1 == 0) return 0;
	}
	if (pos == dsizeleft) return -1;
	return 1;
];

[ INDEXED_TEXT_TY_Distinguish indtleft indtright;
	if (INDEXED_TEXT_TY_Compare(indtleft, indtright) == 0) rfalse;
	rtrue;
];

[ INDEXED_TEXT_TY_Hash indt  rv len i;
	rv = 0;
	len = BlkValueExtent(indt);
	for (i=0: i<len: i++)
		rv = rv * 33 + BlkValueRead(indt, i);
	return rv;
];

[ INDEXED_TEXT_TY_Say indt  ch i dsize;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	dsize = BlkValueExtent(indt);
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(indt, i);
		if (ch == 0) break;
		#ifdef TARGET_ZCODE;
		print (char) ch;
		#ifnot; ! TARGET_ZCODE
		glk_put_char_uni(ch);
		#endif;
	}
];

[ INDEXED_TEXT_TY_WriteFile txb len pos ch;
	len = BlkValueExtent(txb);
	print "S";
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(txb, pos);
		if (ch == 0) {
			print "0;"; break;
		} else {
			print ch, ",";
		}
	}
];

[ INDEXED_TEXT_TY_ReadFile indt auxf ch i v dg pos tsize;
	tsize = BlkValueExtent(indt);
	while (ch ~= 32 or 9 or 10 or 13 or 0 or -1) {
		ch = FileIO_GetC(auxf);
		if (ch == ',' or ';') {
			if (pos+1 >= tsize) {
				if (BlkValueSetExtent(indt, 2*pos, 20) == false) break;
				tsize = BlkValueExtent(indt);
			}
			BlkValueWrite(indt, pos++, v);
			v = 0;
			if (ch == ';') break;
		} else {
			dg = ch - '0';
			v = v*10 + dg;
		}
	}
	BlkValueWrite(indt, pos, 0);
	return indt;
];

[ INDEXED_TEXT_TY_ROGPR indt
	pos len wa wl wpos bdm ch own;
	if (indt == 0) return GPR_FAIL;
	bdm = true; own = wn;
	len = BlkValueExtent(indt);
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(indt, pos);
		if (ch == 32 or 9 or 10 or 0) {
			if (bdm) continue;
			bdm = true;
			if (wpos ~= wl) return GPR_FAIL;
			if (ch == 0) break;
		} else {
			if (bdm) {
				bdm = false;
				if (NextWordStopped() == -1) return GPR_FAIL;
				wa = WordAddress(wn-1);
				wl = WordLength(wn-1);
				wpos = 0;
			}
			if (wa->wpos ~= ch or IT_RevCase(ch)) return GPR_FAIL;
			wpos++;
		}
	}
	if (wn == own) return GPR_FAIL; ! Progress must be made to avoid looping
	return GPR_PREPOSITION;
];

Constant CHR_BLOB = 1; ! Construe as an array of characters
Constant WORD_BLOB = 2; ! Of words
Constant PWORD_BLOB = 3; ! Of punctuated words
Constant UWORD_BLOB = 4; ! Of unpunctuated words
Constant PARA_BLOB = 5; ! Of paragraphs
Constant LINE_BLOB = 6; ! Of lines

Constant REGEXP_BLOB = 7; ! Not a blob type as such, but needed as a distinct value

Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;

[ IT_BlobAccess indt blobtype cindt wanted rindt
	brm oldbrm ch i dsize csize blobcount gp cl j;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return 0;
	if (blobtype == CHR_BLOB) return IT_CharacterLength(indt);
	dsize = BlkValueExtent(indt);
	if (cindt) csize = BlkValueExtent(cindt);
	else if (rindt) "*** rindt without cindt ***";
	brm = WS_BRM;
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(indt, i);
		if (ch == 0) break;
		oldbrm = brm;
		if (ch == 10 or 13 or 32 or 9) {
			if (oldbrm ~= WS_BRM) {
				gp = 0;
				for (j=i:j<dsize:j++) {
					ch = BlkValueRead(indt, j);
					if (ch == 0) { brm = WS_BRM; break; }
					if (ch == 10 or 13) { gp++; continue; }
					if (ch ~= 32 or 9) break;
				}
				ch = BlkValueRead(indt, i);
				if (j == dsize) brm = WS_BRM;
				switch (blobtype) {
					PARA_BLOB: if (gp >= 2) brm = WS_BRM;
					LINE_BLOB: if (gp >= 1) brm = WS_BRM;
					default: brm = WS_BRM;
				}
			}
		} else {
			gp = false;
			if ((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB) &&
				(ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}'))
				gp = true;
			switch (oldbrm) {
				WS_BRM:
					brm = ACCEPTED_BRM;
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				SKIPPED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
					}
				ACCEPTED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDP_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(indt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
				ACCEPTEDN_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDPN_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(indt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
			}
		}
		if (brm == ACCEPTED_BRM or ACCEPTEDP_BRM) {
			if (oldbrm ~= brm) blobcount++;
			if ((cindt) && (blobcount == wanted)) {
				if (rindt) {
					BlkValueWrite(cindt, cl, 0);
					IT_Concatenate(cindt, rindt, CHR_BLOB);
					csize = BlkValueExtent(cindt);
					cl = IT_CharacterLength(cindt);
					if (brm == ACCEPTED_BRM) brm = ACCEPTEDN_BRM;
					if (brm == ACCEPTEDP_BRM) brm = ACCEPTEDPN_BRM;
				} else {
					if (cl+1 >= csize) {
						if (BlkValueSetExtent(cindt, 2*cl, 2) == false) break;
						csize = BlkValueExtent(cindt);
					}
					BlkValueWrite(cindt, cl++, ch);
				}
			} else {
				if (rindt) {
					if (cl+1 >= csize) {
						if (BlkValueSetExtent(cindt, 2*cl, 3) == false) break;
						csize = BlkValueExtent(cindt);
					}
					BlkValueWrite(cindt, cl++, ch);
				}
			}
		} else {
			if ((rindt) && (brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)) {
				if (cl+1 >= csize) {
					if (BlkValueSetExtent(cindt, 2*cl, 4) == false) break;
					csize = BlkValueExtent(cindt);
				}
				BlkValueWrite(cindt, cl++, ch);
			}
		}
	}
	if (cindt) BlkValueWrite(cindt, cl++, 0);
	return blobcount;
];

[ IT_GetBlob cindt indt wanted blobtype;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	if (blobtype == CHR_BLOB) return IT_GetCharacter(cindt, indt, wanted);
	IT_BlobAccess(indt, blobtype, cindt, wanted);
	return cindt;
];

[ IT_ReplaceBlob blobtype indt wanted rindt cindt ilen rlen i;
	if (blobtype == CHR_BLOB) {
		ilen = IT_CharacterLength(indt);
		rlen = IT_CharacterLength(rindt);
		wanted--;
		if ((wanted >= 0) && (wanted<ilen)) {
			if (rlen == 1) {
				BlkValueWrite(indt, wanted, BlkValueRead(rindt, 0));
			} else {
				cindt = BlkValueCreate(INDEXED_TEXT_TY);
				if (BlkValueSetExtent(cindt, ilen+rlen+1, 5)) {
					for (i=0:i<wanted:i++)
						BlkValueWrite(cindt, i, BlkValueRead(indt, i));
					for (i=0:i<rlen:i++)
						BlkValueWrite(cindt, wanted+i, BlkValueRead(rindt, i));
					for (i=wanted+1:i<ilen:i++)
						BlkValueWrite(cindt, rlen+i-1, BlkValueRead(indt, i));
					BlkValueWrite(cindt, rlen+ilen, 0);
					BlkValueCopy(indt, cindt);
				}
				BlkFree(cindt);
			}
		}
	} else {
		cindt = BlkValueCreate(INDEXED_TEXT_TY);
		IT_BlobAccess(indt, blobtype, cindt, wanted, rindt);
		BlkValueCopy(indt, cindt);	
		BlkFree(cindt);
	}
];

[ IT_ReplaceText blobtype indt findt rindt
	cindt csize ilen flen i cl mpos ch chm whitespace punctuation;
	
	if (blobtype == REGEXP_BLOB or CHR_BLOB) 
		return IT_Replace_RE(blobtype, indt, findt, rindt);
	
	ilen = IT_CharacterLength(indt);
	flen = IT_CharacterLength(findt);
	cindt = BlkValueCreate(INDEXED_TEXT_TY);
	csize = BlkValueExtent(cindt);
	mpos = 0;

	whitespace = true; punctuation = false;
	for (i=0:i<=ilen:i++) {
		ch = BlkValueRead(indt, i);
		.MoreMatching;
		chm = BlkValueRead(findt, mpos++);
		if (mpos == 1) {
			switch (blobtype) {
				WORD_BLOB:
					if ((whitespace == false) && (punctuation == false)) chm = -1;
			}
		}
		whitespace = false;
		if (ch == 10 or 13 or 32 or 9) whitespace = true;
		punctuation = false;
		if (ch == '.' or ',' or '!' or '?'
			or '-' or '/' or '"' or ':' or ';'
			or '(' or ')' or '[' or ']' or '{' or '}') {
			if (blobtype == WORD_BLOB) chm = -1;
			punctuation = true;
		}
		if (ch == chm) {
			if (mpos == flen) {
				if (i == ilen) chm = 0;
				else chm = BlkValueRead(indt, i+1);
				if ((blobtype == CHR_BLOB) ||
					(chm == 0 or 10 or 13 or 32 or 9) ||
					(chm == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) {
					mpos = 0;
					cl = cl - (flen-1);
					BlkValueWrite(cindt, cl, 0);
					IT_Concatenate(cindt, rindt, CHR_BLOB);
					csize = BlkValueExtent(cindt);
					cl = IT_CharacterLength(cindt);
					continue;
				}
			}
		} else {
			mpos = 0;
		}
		if (cl+1 >= csize) {
			if (BlkValueSetExtent(cindt, 2*cl, 9) == false) break;
			csize = BlkValueExtent(cindt);
		}
		BlkValueWrite(cindt, cl++, ch);
	}
	BlkValueCopy(indt, cindt);	
	BlkFree(cindt);
];

[ IT_CharacterLength indt ch i dsize;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return 0;
	dsize = BlkValueExtent(indt);
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(indt, i);
		if (ch == 0) return i;
	}
	return dsize;
];

[ INDEXED_TEXT_TY_Empty indt;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) rfalse;
	if (IT_CharacterLength(indt) == 0) rtrue;
	rfalse;
];

[ IT_GetCharacter cindt indt i ch;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	if ((i<=0) || (i>IT_CharacterLength(indt))) ch = 0;
	else ch = BlkValueRead(indt, i-1);
	BlkValueWrite(cindt, 0, ch);
	BlkValueWrite(cindt, 1, 0);
	return cindt;
];

[ IT_CharactersOfCase indt case i ch len;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) rfalse;
	len = IT_CharacterLength(indt);
	for (i=0:i<len:i++) {
		ch = BlkValueRead(indt, i);
		if ((ch) && (CharIsOfCase(ch, case) == false)) rfalse;
	}
	rtrue;
];

[ IT_CharactersToCase cindt indt case i ch len bnd;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	len = IT_CharacterLength(indt);
	if (BlkValueSetExtent(cindt, len+1, 11) == false) return cindt;
	bnd = 1;
	for (i=0:i<len:i++) {
		ch = BlkValueRead(indt, i);
		if (case < 2) {
			BlkValueWrite(cindt, i, CharToCase(ch, case));
		} else {
			BlkValueWrite(cindt, i, CharToCase(ch, bnd));
			if (case == 2) {
				bnd = 0;
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') bnd = 1;
			}
			if (case == 3) {
				if (ch ~= 0 or 10 or 13 or 32 or 9) {
					if (bnd == 1) bnd = 0;
					else {
						if (ch == '.' or '!' or '?') bnd = 1;
					}
				}
			}
		}
	}
	BlkValueWrite(cindt, len, 0);
	return cindt;
];

[ IT_Concatenate indt_to indt_from blobtype indt_ref
	pos len ch i tosize x y case;
	if ((indt_to==0) || (BlkType(indt_to) ~= INDEXED_TEXT_TY)) rfalse;
	if ((indt_from==0) || (BlkType(indt_from) ~= INDEXED_TEXT_TY)) return indt_to;
	switch(blobtype) {
		CHR_BLOB, 0:
			pos = IT_CharacterLength(indt_to);
			len = IT_CharacterLength(indt_from);
			if (BlkValueSetExtent(indt_to, pos+len+1, 10) == false) return indt_to;
			for (i=0:i<len:i++) {
				ch = BlkValueRead(indt_from, i);
				BlkValueWrite(indt_to, i+pos, ch);
			}
			BlkValueWrite(indt_to, len+pos, 0);
			return indt_to;
		REGEXP_BLOB:
			return IT_RE_Concatenate(indt_to, indt_from, blobtype, indt_ref);
		default:
			print "*** IT_Concatenate used on impossible blob type ***^";
			rfalse;
	}
];

[ SetPlayersCommand indt_from i len at;
	len = IT_CharacterLength(indt_from);
	if (len > 118) len = 118;
	#ifdef TARGET_ZCODE;
	buffer->1 = len; at = 2;
	#ifnot;
	buffer-->0 = len; at = 4;
	#endif;
	for (i=0:i<len:i++) buffer->(i+at) = CharToCase(BlkValueRead(indt_from, i), 0);
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount(); ! The snippet variable ``player's command''
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ INDEXED_TEXT_TY_Support t a b c; rfalse; ];
[ INDEXED_TEXT_TY_Say indt; ];
[ SetPlayersCommand indt_from; ];
[ INDEXED_TEXT_TY_Create; ];
[ INDEXED_TEXT_TY_Cast a b c; ];
[ INDEXED_TEXT_TY_Empty t; rfalse; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of indexed texts

Global IT_RE_Trace = false; ! Change to true for (a lot of) debugging data in use
[ IT_RE_SetTrace F; IT_RE_Trace = F; ];

! Character classes

Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;

! Control structures

Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;

! Substring matchers

Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;

! Positional matchers

Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;

! Mode switches

Constant SENSITIVITY_RE_CC = -50;

Constant RE_MAX_PACKETS = 32;

Constant RE_PACKET_SIZE = 14; ! Words of memory used per packet
Constant RE_PACKET_SIZE_IN_BYTES = WORDSIZE*RE_PACKET_SIZE; ! Bytes used per packet

Array RE_PACKET_space --> RE_MAX_PACKETS*RE_PACKET_SIZE;

Constant RE_CCLASS = 0;      ! One of the class codes defined above
Constant RE_PAR1 = 1;        ! Three parameters whose meaning depends on class code
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;        ! Younger sibling in the compiled tree
Constant RE_PREVIOUS = 5;    ! Elder sibling
Constant RE_DOWN = 6;        ! Child
Constant RE_UP = 7;          ! Parent
Constant RE_DATA1 = 8;       ! Backtracking data
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;

[ IT_RE_Node n cc par1 par2 par3  offset;
	if ((n<0) || (n >= RE_MAX_PACKETS)) rfalse;
	offset = RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
	offset-->RE_CCLASS = cc;
	offset-->RE_PAR1 = par1;
	offset-->RE_PAR2 = par2;
	offset-->RE_PAR3 = par3;
	offset-->RE_NEXT = NULL;
	offset-->RE_PREVIOUS = NULL;
	offset-->RE_DOWN = NULL;
	offset-->RE_UP = NULL;
	offset-->RE_DATA1 = -1; ! Match start
	offset-->RE_DATA2 = -1; ! Match end
	offset-->RE_CONSTRAINT = -1; ! Rewind edge
	return offset;
];

[ IT_RE_NodeAddress n;
	if ((n<0) || (n >= RE_MAX_PACKETS)) return -1;
	return RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
];

Array RE_Subexpressions --> 11; ! Address of node for this subexpression
Array Allocated_Match_Vars --> 10; ! Indexed text to hold values of the variables

[ IT_RE_DebugMatchVars indt
	offset n i;
	print RE_Subexpressions-->10, " collecting subexps^";
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		print "Subexp ", offset-->RE_PAR1,
			" = [", offset-->RE_DATA1, ",", offset-->RE_DATA2, "] = ";
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++)
			print (char) BlkValueRead(indt, i);
		print "^";
	}
];

[ IT_RE_CreateMatchVars indt
	offset n i ch cindt cl csize;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		if (Allocated_Match_Vars-->n == 0)
			Allocated_Match_Vars-->n = INDEXED_TEXT_TY_Create(); ! Permanently
		cindt = Allocated_Match_Vars-->n;
		csize = BlkValueExtent(cindt);
		cl = 0;
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++) {
			ch = BlkValueRead(indt, i);
			if (cl+1 >= csize) {
				if (BlkValueSetExtent(cindt, 2*cl, 6) == false) break;
				csize = BlkValueExtent(cindt);
			}
			BlkValueWrite(cindt, cl++, ch);
		}
		BlkValueWrite(cindt, cl, 0);
	}
];

[ IT_RE_EmptyMatchVars indt
	n;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++)
		if (Allocated_Match_Vars-->n ~= 0)
			BlkValueWrite(Allocated_Match_Vars-->n, 0, 0);
];

[ IT_RE_GetMatchVar indt vn
	offset;
	if ((vn<0) || (vn>=10) || (vn >= RE_Subexpressions-->10)) jump Nope;
	offset = RE_Subexpressions-->vn;
	if (offset == 0) jump Nope;
	if (offset-->RE_DATA1 < 0) jump Nope;
	if (Allocated_Match_Vars-->vn == 0) {
		print "*** ", vn, " unallocated! ***^";
		jump Nope;
	}
	BlkValueCopy(indt, Allocated_Match_Vars-->vn);
	return indt;

	.Nope;
	BlkValueWrite(indt, 0, 0);
	return indt;
];

[ IT_MV_End n end
	offset;
	offset = RE_Subexpressions-->n;
	if (end==0) return offset-->RE_DATA1;
	return offset-->RE_DATA2;
];

[ IT_RE_Clear_Markers token;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) IT_RE_Clear_Markers(token-->RE_DOWN);
		token-->RE_DATA1 = -1;
		token-->RE_DATA2 = -1;
		token-->RE_CONSTRAINT = -1;
	}
];

[ IT_RE_DebugTree findt detail;
	print "Pattern: ", (INDEXED_TEXT_TY_Say) findt, "^";
	IT_RE_DebugSubtree(findt, 1, RE_PACKET_space, detail);
];

[ IT_RE_DebugSubtree findt depth offset detail
	cup;
	if (offset ~= NULL) {
		cup = offset-->RE_UP;
		if (offset-->RE_PREVIOUS ~= NULL) print "*** broken initial previous ***^";
	}
	while (offset ~= NULL) {
		if (offset-->RE_UP ~= cup) print "*** broken up matching ***^";
		spaces(depth*2);
		IT_RE_DebugNode(offset, findt, detail);
		if (offset-->RE_DOWN ~= NULL) {
			if ((offset-->RE_DOWN)-->RE_UP ~= offset)
				print "*** broken down/up ***^";
			IT_RE_DebugSubtree(findt, depth+1, offset-->RE_DOWN, detail);
		}
		if (offset-->RE_NEXT ~= NULL) {
			if ((offset-->RE_NEXT)-->RE_PREVIOUS ~= offset)
				print "*** broken next/previous ***^";
		}
		offset = offset-->RE_NEXT;
	}
];

[ IT_RE_DebugNode offset findt detail
	i par1 par2 par3;
	if (offset == NULL) "[NULL]";
	print "[", (offset-RE_PACKET_space)/(RE_PACKET_SIZE_IN_BYTES), "] ";
	! for (i=0:i<RE_PACKET_SIZE:i++) print offset-->i, " ";
	par1 = offset-->RE_PAR1;
	par2 = offset-->RE_PAR2;
	par3 = offset-->RE_PAR3;
	switch (offset-->RE_CCLASS) {
		DIGIT_RE_CC: print "DIGIT";
		NONDIGIT_RE_CC: print "NONDIGIT";
		UCASE_RE_CC: print "UCASE";
		NONUCASE_RE_CC: print "NONUCASE";
		LCASE_RE_CC: print "LCASE";
		NONLCASE_RE_CC: print "NONLCASE";
		WHITESPACE_RE_CC: print "WHITESPACE";
		NONWHITESPACE_RE_CC: print "NONWHITESPACE";
		PUNCTUATION_RE_CC: print "PUNCTUATION";
		NONPUNCTUATION_RE_CC: print "NONPUNCTUATION";
		WORD_RE_CC: print "WORD";
		NONWORD_RE_CC: print "NONWORD";
		ALWAYS_RE_CC: print "ALWAYS";
		NEVER_RE_CC: print "NEVER";
		START_RE_CC: print "START";
		END_RE_CC: print "END";
		BOUNDARY_RE_CC: print "BOUNDARY";
		NONBOUNDARY_RE_CC: print "NONBOUNDARY";
		ANYTHING_RE_CC: print "ANYTHING";
		NOTHING_RE_CC: print "NOTHING";
		RANGE_RE_CC: print "RANGE"; if (par3 == true) print " (negated)";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(findt, i);
		VARIABLE_RE_CC: print "VARIABLE ", par1;
		SUBEXP_RE_CC:
			if (par1 == 0) print "EXP";
			else print "SUBEXP ";
			if (par1 >= 0) print "= V", par1;
			if (par2 == 1) {
				if (par3 == 0) print " (?=...) lookahead";
				else print " (?<=...) lookbehind of width ", par3;
			}
			if (par2 == 2) {
				if (par3 == 0) print " (?!...) negated lookahead";
				else print " (?<!...) negated lookbehind of width ", par3;
			}
			if (par2 == 3) print " uncollecting";
			if (par2 == 0 or 3) {
				if (par3 == 1) print " forcing case sensitivity";
				if (par3 == 2) print " forcing case insensitivity";
			}
			if (par2 == 4) print " (?>...) possessive";
		NEWLINE_RE_CC: print "NEWLINE";
		TAB_RE_CC: print "TAB";
		QUANTIFIER_RE_CC: print "QUANTIFIER min=", par1, " max=", par2;
			if (par3) print " (lazy)"; else print " (greedy)";
		LITERAL_RE_CC: print "LITERAL";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(findt, i);
		DISJUNCTION_RE_CC: print "DISJUNCTION of ", par1, " choices";
		CHOICE_RE_CC: print "CHOICE no ", par1;
		SENSITIVITY_RE_CC: print "SENSITIVITY";
			if (par1) print " off"; else print " on";
		IF_RE_CC: print "IF"; if (par1 >= 1) print " = V", par1;
		CONDITION_RE_CC: print "CONDITION"; if (par1 >= 1) print " = V", par1;
		THEN_RE_CC: print "THEN";
		ELSE_RE_CC: print "ELSE";
	}
	if (detail)
		print ": ", offset-->RE_DATA1, ", ", offset-->RE_DATA2, ", ", offset-->RE_CONSTRAINT;
	print "^";
];

[ IT_CHR_CompileTree findt exactly
	root literal fto no_packets token attach_to;

	fto = IT_CharacterLength(findt);

	root = IT_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0);
	literal = IT_RE_Node(1, LITERAL_RE_CC, 0, fto, 0);
	
	root-->RE_DOWN = literal;
	literal-->RE_UP = root;

	if (exactly) {
		no_packets = 2;
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = IT_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = IT_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = IT_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = IT_RE_ExpandChoices(RE_PACKET_space, no_packets);
];

Array Subexp_Posns --> 20;
[ IT_RE_CompileTree findt exactly
	no_packets ffrom fto cc par1 par2 par3
	quantifiable token attach_to no_subs blevel bits;

	fto = IT_CharacterLength(findt);
	if (fto == 0) {
		IT_RE_Node(no_packets++, NEVER_RE_CC, 0, 0, 0); ! Empty regexp never matches
		return 1;
	}

	attach_to = IT_RE_Node(no_packets++, SUBEXP_RE_CC, 0, 0, 0);
	RE_Subexpressions-->0 = attach_to; RE_Subexpressions-->10 = 1; no_subs = 1;

	quantifiable = false; blevel = 0;
	
	for (ffrom = 0: ffrom < fto: ) {
		cc = BlkValueRead(findt, ffrom++); par1 = 0; par2 = 0; par3 = 0;
		if (cc == '\') {
			if (ffrom == fto) return "Search pattern not terminated";
			cc = BlkValueRead(findt, ffrom++);
			switch (cc) {
				'b': cc = BOUNDARY_RE_CC;
				'B': cc = NONBOUNDARY_RE_CC;
				'd': cc = DIGIT_RE_CC;
				'D': cc = NONDIGIT_RE_CC;
				'l': cc = LCASE_RE_CC;
				'L': cc = NONLCASE_RE_CC;
				'n': cc = NEWLINE_RE_CC;
				'p': cc = PUNCTUATION_RE_CC;
				'P': cc = NONPUNCTUATION_RE_CC;
				's': cc = WHITESPACE_RE_CC;
				'S': cc = NONWHITESPACE_RE_CC;
				't': cc = TAB_RE_CC;
				'u': cc = UCASE_RE_CC;
				'U': cc = NONUCASE_RE_CC;
				'w': cc = WORD_RE_CC;
				'W': cc = NONWORD_RE_CC;
				default:
					if ((cc >= '1') && (cc <= '9')) {
						par1 = cc-'0';
						cc = VARIABLE_RE_CC;
					} else {
						if (((cc >= 'a') && (cc <= 'z')) ||
							((cc >= 'A') && (cc <= 'Z'))) return "unknown escape";
						cc = LITERAL_RE_CC;
						par1 = ffrom-1; par2 = ffrom;
					}
			}
			quantifiable = true;
		} else {
			switch (cc) {
				'(': par2 = 0;
					!if (BlkValueRead(findt, ffrom) == ')') return "empty subexpression";
					if (BlkValueRead(findt, ffrom) == '?') {
						ffrom++;
						bits = true;
						if (BlkValueRead(findt, ffrom) == '-') { ffrom++; bits = false; }
						else if (BlkValueRead(findt, ffrom) == '<') { ffrom++; bits = false; }
						switch (cc = BlkValueRead(findt, ffrom++)) {
							'#': while (BlkValueRead(findt, ffrom++) ~= 0 or ')') ;
								if (BlkValueRead(findt, ffrom-1) == 0)
									return "comment never ends";
								continue;
							'(': cc = BlkValueRead(findt, ffrom);
								if ((cc == '1' or '2' or '3' or '4' or
									'5' or '6' or '7' or '8' or '9') &&
									(BlkValueRead(findt, ffrom+1) ==')')) {
									ffrom = ffrom + 2;
									par1 = cc - '0';
								} else ffrom--;
								cc = IF_RE_CC; ! (?(...)...) conditional
								quantifiable = false;
								if (blevel == 20) return "subexpressions too deep";
								Subexp_Posns-->(blevel++) = IT_RE_NodeAddress(no_packets);
								jump CClassKnown;
							'=': par2 = 1; ! (?=...) lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							'!': par2 = 2; ! (?!...) negated lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							':': par2 = 3; ! (?:...) uncollecting subexpression
							'>': par2 = 4; ! (?>...) possessive
							default:
								if (BlkValueRead(findt, ffrom) == ')') {
									if (cc == 'i') {
										cc = SENSITIVITY_RE_CC; par1 = bits; ffrom++;
										jump CClassKnown;
									}
								}
								if (BlkValueRead(findt, ffrom) == ':') {
									if (cc == 'i') {
										par1 = bits; par2 = 3; par3 = bits+1; ffrom++;
										jump AllowForm;
									}
								}
								return "unknown (?...) form";
						}
					}
					.AllowForm;
					if (par2 == 0) par1 = no_subs++; else par1 = -1;
					cc = SUBEXP_RE_CC; 
					quantifiable = false;
					if (blevel == 20) return "subexpressions too deep";
					Subexp_Posns-->(blevel++) = IT_RE_NodeAddress(no_packets);
				')': if (blevel == 0) return "subexpression bracket mismatch";
					blevel--;
					attach_to = Subexp_Posns-->blevel;
					if (attach_to-->RE_DOWN == NULL) {
						if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
						attach_to-->RE_DOWN =
							IT_RE_Node(no_packets++, ALWAYS_RE_CC, 0, 0, 0);
						(attach_to-->RE_DOWN)-->RE_UP = attach_to;
					}
					quantifiable = true;
					continue;
				'.': cc = ANYTHING_RE_CC; quantifiable = true;
				'|': cc = CHOICE_RE_CC; quantifiable = false;
				'^': cc = START_RE_CC; quantifiable = false;
				'$': cc = END_RE_CC; quantifiable = false;
				'{': if (quantifiable == false) return "quantifier misplaced";
					par1 = 0; par2 = -1; bits = 1;
					while ((cc=BlkValueRead(findt, ffrom++)) ~= 0 or '}') {
						if (cc == ',') {
							bits++;
							if (bits >= 3) return "too many colons in ?{...}";
							continue;
						}
						if ((cc >= '0') || (cc <= '9')) {
							if (bits == 1) {
								if (par1 < 0) par1 = 0;
								par1 = par1*10 + (cc-'0');
							} else {
								if (par2 < 0) par2 = 0;
								par2 = par2*10 + (cc-'0');
							}
						} else return "non-digit in ?{...}";
					}
					if (cc ~= '}') return "{x,y} quantifier never ends";
					cc = QUANTIFIER_RE_CC;
					if (par2 == -1) {
						if (bits == 2) par2 = 30000;
						else par2 = par1;
					}
					if (par1 > par2) return "{x,y} with x greater than y";
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'<', '[': par3 = false; if (cc == '<') bits = '>'; else bits = ']';
					if (BlkValueRead(findt, ffrom) == '^') { ffrom++; par3 = true; }
					par1 = ffrom;
					if (BlkValueRead(findt, ffrom) == bits) { ffrom++; }
					while (cc ~= bits or 0) {
						cc = BlkValueRead(findt, ffrom++);
						if (cc == '\') {
							cc = BlkValueRead(findt, ffrom++);
							if (cc ~= 0) cc = BlkValueRead(findt, ffrom++);
						}
					}
					if (cc == 0) return "Character range never ends";
					par2 = ffrom-1;
					if ((par2 > par1 + 1) &&
						(BlkValueRead(findt, par1) == ':') &&
						(BlkValueRead(findt, par2-1) == ':') &&
						(BlkValueRead(findt, par2-2) ~= '\'))
						return "POSIX named character classes unsupported";
					bits = IT_RE_RangeSyntaxCorrect(findt, par1, par2);
					if (bits) return bits;
					if (par1 < par2) cc = RANGE_RE_CC;
					else cc = NOTHING_RE_CC;
					quantifiable = true;
				'*': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 30000;
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'+': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 1; par2 = 30000;
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'?': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 1;
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
			}
		}
		
		.CClassKnown;
		
		if (cc >= 0) {
			quantifiable = true;
			if ((attach_to-->RE_CCLASS == LITERAL_RE_CC) &&
				(BlkValueRead(findt, ffrom) ~= '*' or '+' or '?' or '{')) {
				(attach_to-->RE_PAR2)++;
				if (IT_RE_Trace == 2) {
					print "Extending literal by ", cc, "=", (char) cc, "^";
				}
				continue;
			}
			cc = LITERAL_RE_CC; par1 = ffrom-1; par2 = ffrom;
		}
		
		if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";

		if (IT_RE_Trace == 2) {
			print "Attaching packet ", no_packets+1, " to ";
			IT_RE_DebugNode(attach_to, findt);
			IT_RE_DebugTree(findt);
		}

		token = IT_RE_Node(no_packets++, cc, par1, par2, par3);

		if ((token-->RE_CCLASS == SUBEXP_RE_CC) && (token-->RE_PAR2 == 0)) {
			RE_Subexpressions-->(token-->RE_PAR1) = token;
			(RE_Subexpressions-->10)++;
		}
		
		if ((attach_to-->RE_CCLASS == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC) &&
			(attach_to-->RE_DOWN == NULL)) {
			attach_to-->RE_DOWN = token; token-->RE_UP = attach_to;
		} else {
			if ((token-->RE_CCLASS == CHOICE_RE_CC) &&
				((attach_to-->RE_UP)-->RE_CCLASS == CHOICE_RE_CC)) {
				no_packets--; token = attach_to-->RE_UP;
			} else {
				if (token-->RE_CCLASS == CHOICE_RE_CC) {
					while (attach_to-->RE_PREVIOUS ~= NULL)
						attach_to = attach_to-->RE_PREVIOUS;
				}
				if (token-->RE_CCLASS == QUANTIFIER_RE_CC or CHOICE_RE_CC) {
					token-->RE_PREVIOUS = attach_to-->RE_PREVIOUS;
					token-->RE_UP = attach_to-->RE_UP;
					if ((attach_to-->RE_UP ~= NULL) && (attach_to-->RE_PREVIOUS == NULL))
						(attach_to-->RE_UP)-->RE_DOWN = token;
					token-->RE_DOWN = attach_to;
					bits = attach_to;
					while (bits ~= NULL) {
						bits-->RE_UP = token;
						bits = bits-->RE_NEXT;
					}
					attach_to-->RE_PREVIOUS = NULL;
					if (token-->RE_PREVIOUS ~= NULL)
						(token-->RE_PREVIOUS)-->RE_NEXT = token;
				} else {
					attach_to-->RE_NEXT = token; token-->RE_PREVIOUS = attach_to;
					token-->RE_UP = attach_to-->RE_UP;
				}
			}
		}
		
		if (token-->RE_CCLASS == CHOICE_RE_CC) {
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			token-->RE_NEXT = IT_RE_Node(no_packets++, CHOICE_RE_CC, 0, 0, 0);
			(token-->RE_NEXT)-->RE_PREVIOUS = token;
			(token-->RE_NEXT)-->RE_UP = token-->RE_UP;
			token = token-->RE_NEXT;
		}

		attach_to = token;

		if (IT_RE_Trace == 2) {
			print "Result:^";
			IT_RE_DebugTree(findt);
		}

	}
	
	if (blevel ~= 0) return "subexpression bracket mismatch";

	if (exactly) {
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = IT_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = IT_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = IT_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = IT_RE_ExpandChoices(RE_PACKET_space, no_packets);

	if (IT_RE_Trace) {
		print "Compiled pattern:^";
		IT_RE_DebugTree(findt);
	}
	
	bits = IT_RE_CheckTree(RE_PACKET_space, no_subs); if (bits) return bits;
	
	return no_packets;
];

[ IT_RE_RangeSyntaxCorrect findt rf rt
	i chm;
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(findt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(findt, ++i);
			if (((chm >= 'a') && (chm <= 'z')) ||
				((chm >= 'A') && (chm <= 'Z'))) {
				if (chm ~= 's' or 'S' or 'p' or 'P' or 'w' or 'W' or 'd'
					or 'D' or 'n' or 't' or 'l' or 'L' or 'u' or 'U')
					return "Invalid escape in {} range";
			}
		}
		if ((i+2<rt) && (BlkValueRead(findt, i+1) == '-')) {
			if (chm > BlkValueRead(findt, i+2)) return "Invalid {} range";
			i=i+2;
		}
	}
	rfalse;
];

[ IT_RE_ExpandChoices token no_packets
	rv prev nex holder new ct n cond_node then_node else_node;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == IF_RE_CC) {
			if ((token-->RE_DOWN)-->RE_CCLASS == CHOICE_RE_CC) {
				for (nex=token-->RE_DOWN, n=0: nex~=NULL: nex=nex-->RE_NEXT) n++;
				if (n~=2) return "conditional has too many clauses";
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = IT_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
				}
				then_node = token-->RE_DOWN;
				then_node-->RE_CCLASS = THEN_RE_CC;
				else_node = then_node-->RE_NEXT;
				else_node-->RE_CCLASS = ELSE_RE_CC;
				if (cond_node-->RE_PAR1 < 1) {
					cond_node-->RE_DOWN = then_node-->RE_DOWN;
					then_node-->RE_DOWN = (then_node-->RE_DOWN)-->RE_NEXT;
					if (then_node-->RE_DOWN ~= NULL)
						(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node; cond_node-->RE_UP = token;
				cond_node-->RE_NEXT = then_node; then_node-->RE_PREVIOUS = cond_node;
			} else {
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = IT_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				then_node = IT_RE_Node(no_packets++, THEN_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
					then_node-->RE_DOWN = token-->RE_DOWN;
				} else {
					cond_node-->RE_DOWN = token-->RE_DOWN;
					then_node-->RE_DOWN = (token-->RE_DOWN)-->RE_NEXT;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node;
				cond_node-->RE_UP = token; cond_node-->RE_NEXT = then_node;
				then_node-->RE_PREVIOUS = cond_node; then_node-->RE_UP = token;
				then_node-->RE_NEXT = NULL;
				if (then_node-->RE_DOWN ~= NULL)
					(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
				for (nex = then_node-->RE_DOWN: nex ~= NULL: nex = nex-->RE_NEXT) {
					nex-->RE_UP = then_node;
				}
			}
			
			if (cond_node-->RE_DOWN ~= NULL) {
				nex = cond_node-->RE_DOWN;
				if ((nex-->RE_CCLASS ~= SUBEXP_RE_CC) ||
					(nex-->RE_NEXT ~= NULL) ||
					(nex-->RE_PAR2 ~= 1 or 2)) {
					!IT_RE_DebugSubtree(0, 0, nex, true);
					return "condition not lookahead/behind";
				}
			}
		}
		if ((token-->RE_CCLASS == CHOICE_RE_CC) && (token-->RE_PAR1 < 1)) {
			prev = token-->RE_PREVIOUS;
			nex = token-->RE_NEXT;
			while ((nex ~= NULL) && (nex-->RE_CCLASS == CHOICE_RE_CC))
				nex = nex-->RE_NEXT;
			holder = token-->RE_UP; if (holder == NULL) return "bang";
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			new = IT_RE_Node(no_packets++, DISJUNCTION_RE_CC, 0, 0, 0);
			holder-->RE_DOWN = new; new-->RE_UP = holder;
			if (prev ~= NULL) {
				prev-->RE_NEXT = new; new-->RE_PREVIOUS = prev;
			}
			if (nex ~= NULL) {
				nex-->RE_PREVIOUS = new; new-->RE_NEXT = nex;
			}
			new-->RE_DOWN = token;
			token-->RE_PREVIOUS = NULL;
			ct = 1;
			while (token ~= NULL) {
				token-->RE_PAR1 = ct++;
				token-->RE_UP = new;
				if ((token-->RE_NEXT ~= NULL) &&
					((token-->RE_NEXT)-->RE_CCLASS ~= CHOICE_RE_CC))
					token-->RE_NEXT = NULL;
				token = token-->RE_NEXT;
			}
			new-->RE_PAR1 = ct-1;
			if (token ~= NULL) token-->RE_NEXT = NULL;
			token = new; continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			no_packets = IT_RE_ExpandChoices(token-->RE_DOWN, no_packets);
			if ((no_packets<0) || (no_packets >= RE_MAX_PACKETS)) break;
		}
		token = token-->RE_NEXT;
	}
	return no_packets;
];

[ IT_RE_CheckTree token no_subs
	rv;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == VARIABLE_RE_CC) {
			if (token-->RE_PAR1 >= no_subs) return "reference to nonexistent group";
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2) &&
			(token-->RE_PAR3 == -1)) {
			token-->RE_PAR3 = IT_RE_Width(token-->RE_DOWN);
			if (token-->RE_PAR3 == -1) return "variable length lookbehind not implemented";
		}
		if (token-->RE_DOWN ~= NULL) {
			rv = IT_RE_CheckTree(token-->RE_DOWN, no_subs);
			if (rv) return rv;
		}
		token = token-->RE_NEXT;
	}
	rfalse;
];

[ IT_RE_Width token downwards
	w rv aw choice;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC,
			PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC,
			ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC,
			UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
				w++;
			START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
				;
			LITERAL_RE_CC:
				w = w + token-->RE_PAR2 - token-->RE_PAR1;
			VARIABLE_RE_CC:
				return -1;
			IF_RE_CC:
				rv = IT_RE_Width((token-->RE_DOWN)-->RE_NEXT);
				if (rv == -1) return -1;
				if (rv ~= IT_RE_Width(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT))
					return -1;
				w = w + rv;
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) rv = 0;
				else {
					rv = IT_RE_Width(token-->RE_DOWN);
					if (rv == -1) return -1;
				}
				w = w + rv;
			QUANTIFIER_RE_CC:
				if (token-->RE_PAR1 ~= token-->RE_PAR2) return -1;
				rv = IT_RE_Width(token-->RE_DOWN);
				if (rv == -1) return -1;
				w = w + rv*(token-->RE_PAR1);				
			DISJUNCTION_RE_CC:
				aw = -1;
				for (choice = token-->RE_DOWN: choice ~= NULL: choice = choice-->RE_NEXT) {
					rv = IT_RE_Width(choice-->RE_DOWN);
					!print "Option found ", rv, "^";
					if (rv == -1) return -1;
					if ((aw >= 0) && (aw ~= rv)) return -1;
					aw = rv;
				}
				w = w + aw;
			SENSITIVITY_RE_CC:
				;
		}
		if (downwards) return w;
		if (token ~= NULL) token = token-->RE_NEXT;
	}
	return w;
];

Global IT_RE_RewindCount;
[ IT_RE_PrintNoRewinds; print IT_RE_RewindCount; ];

Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;

[ IT_RE_Parse findt indt ipos insens
	ilen rv root i initial_mode;

	ilen = IT_CharacterLength(indt);
	if ((ipos<0) || (ipos>ilen)) return -1;
	
	root = RE_PACKET_space;
	
	initial_mode = 0; if (insens) initial_mode = CIS_MFLAG;
	
	IT_RE_Clear_Markers(RE_PACKET_space);
	
	for (:ipos<=ilen:ipos++) {
		if ((RE_PACKET_space-->RE_DOWN ~= NULL) &&
			((RE_PACKET_space-->RE_DOWN)-->RE_CCLASS == START_RE_CC) &&
			(ipos>0)) { rv = -1; break; }
		if (ipos > 0) IT_RE_EraseConstraints(RE_PACKET_space, initial_mode);
		IT_RE_RewindCount = 0;
		rv = IT_RE_ParseAtPosition(findt, indt, ipos, ilen, RE_PACKET_space, initial_mode);
		if (rv >= 0) break;
	}

	if (rv == -1) {
		root-->RE_DATA1 = -1;
		root-->RE_DATA2 = -1;
	} else {
		root-->RE_DATA1 = ipos;
		root-->RE_DATA2 = ipos+rv;
	}
	return rv;
];

[ IT_RE_ParseAtPosition findt indt ifrom ito token mode_flags
	outcome ipos npos rv i ch edge rewind_this;

	if (ifrom > ito) return -1;

	ipos = ifrom;

	.Rewind;
	while (token ~= NULL) {
		outcome = false;
		if (IT_RE_Trace) {
			print "Matching at ", ipos, ": ";
			IT_RE_DebugNode(token, findt, true);
		}

		if (ipos<ito) ch = BlkValueRead(indt, ipos); else ch = 0;

		token-->RE_MODES = mode_flags; ! Save in case of backtrack

		switch (token-->RE_CCLASS) {
			
			! Should never happen
			
			CHOICE_RE_CC: return "internal error";
			
			! Mode switches
			
			SENSITIVITY_RE_CC:
				if (token-->RE_PAR1) mode_flags = mode_flags | CIS_MFLAG;
				else mode_flags = mode_flags & (~CIS_MFLAG);
				outcome = true;
		
			! Zero-length positional markers
			
			ALWAYS_RE_CC:
				outcome = true;
			NEVER_RE_CC:
			START_RE_CC:
				if (ipos == 0) outcome = true;
			END_RE_CC:
				if (BlkValueRead(indt, ipos) == 0) outcome = true;
			BOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(indt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(indt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv == 1) outcome = true;
			NONBOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(indt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(indt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv ~= 1) outcome = true;

			! Control constructs
		
			IF_RE_CC:
				i = token-->RE_PAR1; ch = false;
				if (IT_RE_Trace) {
					print "Trying conditional from ", ipos, ": ";
					IT_RE_DebugNode(token, findt, true);
				}
				if (i >= 1) {
					 if ((i<RE_Subexpressions-->10) &&
					 	((RE_Subexpressions-->i)-->RE_DATA1 >= 0)) ch = true;
				} else {					 	
					rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						(token-->RE_DOWN)-->RE_DOWN, mode_flags);
					if (rv >= 0) ch = true;
				}
				if (IT_RE_Trace) {
					print "Condition found to be ", ch, "^";
				}
				if (ch) {
					rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						((token-->RE_DOWN)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Then clause returned ", rv, "^";
				} else {
					if ((((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT) == NULL)
						rv = 0; ! The empty else clause matches
					else rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Else clause returned ", rv, "^";
				}
				if (rv >= 0) {
					outcome = true;
					ipos = ipos + rv;
				}
			DISJUNCTION_RE_CC:
				if (IT_RE_Trace) {
					print "Trying disjunction from ", ipos, ": ";
					IT_RE_DebugNode(token, findt, true);
				}
				for (ch = token-->RE_DOWN: ch ~= NULL: ch = ch-->RE_NEXT) {
					if (ch-->RE_PAR1 <= token-->RE_CONSTRAINT) continue;
					if (IT_RE_Trace) {
						print "Trying choice at ", ipos, ": ";
						IT_RE_DebugNode(ch, findt, true);
					}
					rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						ch-->RE_DOWN, mode_flags);
					if (rv >= 0) {
						token-->RE_DATA1 = ipos; ! Where match was made
						token-->RE_DATA2 = ch-->RE_PAR1; ! Option taken
						ipos = ipos + rv;
						outcome = true;
						if (IT_RE_Trace) {
							print "Choice worked with width ", rv, ": ";
							IT_RE_DebugNode(ch, findt, true);
						}
						break;
					} else {
						if (mode_flags & ACCUM_MFLAG == false)
							IT_RE_FailSubexpressions(ch-->RE_DOWN);
					}						
				}
				if (outcome == false) {
					if (IT_RE_Trace) {
						print "Failed disjunction from ", ipos, ": ";
						IT_RE_DebugNode(token, findt, true);
					}
					token-->RE_DATA1 = ipos; ! Where match was tried
					token-->RE_DATA2 = -1; ! No option was taken
				}
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) {
					npos = ipos - token-->RE_PAR3;
					if (npos<0) rv = -1; ! Lookbehind fails: nothing behind
					else rv = IT_RE_ParseAtPosition(findt, indt, npos, ito, token-->RE_DOWN,
						mode_flags);
				} else {
					switch (token-->RE_PAR3) {
						0: rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags);
						1: rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags & (~CIS_MFLAG));
						2: rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags | CIS_MFLAG);
					}
				}
				npos = ipos;
				if (rv >= 0) npos = ipos + rv;
				switch (token-->RE_PAR2) {
					1: if (rv >= 0) rv = 0;
					2: if (rv >= 0) rv = -1; else rv = 0;
				}
				if (rv >= 0) {
					token-->RE_DATA1 = ipos;
					ipos = ipos + rv;
					token-->RE_DATA2 = npos;
					outcome = true;
				} else {
					if (mode_flags & ACCUM_MFLAG == false) {
						token-->RE_DATA1 = -1;
						token-->RE_DATA2 = -1;
					}
				}
				if (token-->RE_PAR2 == 2) IT_RE_FailSubexpressions(token, true);
			QUANTIFIER_RE_CC:
				token-->RE_DATA1 = ipos;
				if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
					(token-->RE_DOWN)-->RE_CACHE1 = -1;
					(token-->RE_DOWN)-->RE_CACHE2 = -1;	
				}
				if (IT_RE_Trace) {
					print "Trying quantifier from ", ipos, ": ";
					IT_RE_DebugNode(token, findt, true);
				}
				if (token-->RE_PAR3 == false) { ! Greedy quantifier
					!edge = ito; if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					edge = token-->RE_PAR2;
					if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					rv = -1;
					for (i=0, npos=ipos: i<edge: i++) {
						if (IT_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							IT_RE_DebugNode(token, findt, true);
						}
						rv = IT_RE_ParseAtPosition(findt, indt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= token-->RE_PAR1) && (i <= token-->RE_PAR2))
						outcome = true;
				} else { ! Lazy quantifier
					edge = token-->RE_PAR1;
					if (token-->RE_CONSTRAINT > edge) edge = token-->RE_CONSTRAINT;
					for (i=0, npos=ipos: (npos<ito) && (i < token-->RE_PAR2): i++) {
						if (i >= edge) break;
						if (IT_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							IT_RE_DebugNode(token, findt, true);
						}
						rv = IT_RE_ParseAtPosition(findt, indt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= edge) && (i <= token-->RE_PAR2))
						outcome = true;
				}
				if (outcome) {
					if (token-->RE_PAR3 == false) { ! Greedy quantifier
						if (i > token-->RE_PAR1) { ! I.e., if we have been greedy
							token-->RE_DATA2 = i-1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					} else { ! Lazy quantifier
						if (i < token-->RE_PAR2) { ! I.e., if we have been lazy
							token-->RE_DATA2 = i+1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					}
					ipos = npos;
					if ((i == 0) && (mode_flags & ACCUM_MFLAG == false))
						IT_RE_FailSubexpressions(token-->RE_DOWN);
					if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
						(token-->RE_DOWN)-->RE_DATA1 = (token-->RE_DOWN)-->RE_CACHE1;
						(token-->RE_DOWN)-->RE_DATA2 = (token-->RE_DOWN)-->RE_CACHE2;	
					}
					if (IT_RE_Trace) {
						print "Successful quant reps ", i, ": ";
						IT_RE_DebugNode(token, findt, true);
					}
				} else {
					!token-->RE_DATA2 = -1;
					if (mode_flags & ACCUM_MFLAG == false)
						IT_RE_FailSubexpressions(token-->RE_DOWN);
					if (IT_RE_Trace) {
						print "Failed quant reps ", i, ": ";
						IT_RE_DebugNode(token, findt, true);
					}
				}
				
			! Character classes
				
			NOTHING_RE_CC: ;
			ANYTHING_RE_CC: if (ch) outcome = true; ipos++;
			WHITESPACE_RE_CC:
				if (ch == 10 or 13 or 32 or 9) { outcome = true; ipos++; }
			NONWHITESPACE_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9)) { outcome = true; ipos++; }
			PUNCTUATION_RE_CC:
				if (ch == '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			NONPUNCTUATION_RE_CC:
				if ((ch) && (ch ~= '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			WORD_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			NONWORD_RE_CC:
				if (ch == 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			DIGIT_RE_CC:
				if (ch == '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9') { outcome = true; ipos++; }
			NONDIGIT_RE_CC:
				if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9')) { outcome = true; ipos++; }
			LCASE_RE_CC:
				if (CharIsOfCase(ch, 0)) { outcome = true; ipos++; }
			NONLCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 0) == false)) { outcome = true; ipos++; }
			UCASE_RE_CC:
				if (CharIsOfCase(ch, 1)) { outcome = true; ipos++; }
			NONUCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 1) == false)) { outcome = true; ipos++; }
			NEWLINE_RE_CC: if (ch == 10) { outcome = true; ipos++; }
			TAB_RE_CC: if (ch == 9) { outcome = true; ipos++; }
			RANGE_RE_CC:
				if (IT_RE_Range(ch, findt,
					token-->RE_PAR1, token-->RE_PAR2, token-->RE_PAR3, mode_flags & CIS_MFLAG))
					{ outcome = true; ipos++; }
			
			! Substring matches
			
			LITERAL_RE_CC:
				rv = IT_RE_MatchSubstring(indt, ipos,
					findt, token-->RE_PAR1, token-->RE_PAR2, mode_flags & CIS_MFLAG);
				if (rv >= 0) { ipos = ipos + rv; outcome = true; }
			VARIABLE_RE_CC:
				i = token-->RE_PAR1;
				if ((RE_Subexpressions-->i)-->RE_DATA1 >= 0) {
					rv = IT_RE_MatchSubstring(indt, ipos,
						indt, (RE_Subexpressions-->i)-->RE_DATA1,
						(RE_Subexpressions-->i)-->RE_DATA2, mode_flags & CIS_MFLAG);
					if (rv >= 0) { ipos = ipos + rv; outcome = true; }
				}
				.NeverMatchIncompleteVar;
		}
		
		if (outcome == false) {
			if (IT_RE_RewindCount++ >= 10000) {
				if (IT_RE_RewindCount == 10001) {
					style bold; print "OVERFLOW^"; style roman;
				}
				return -1;
			}
			if (IT_RE_Trace) {
				print "Rewind sought from failure at pos ", ipos, " with: ";
					IT_RE_DebugNode(token, findt, true);
			}
			if ((token-->RE_CCLASS == QUANTIFIER_RE_CC) &&
				(IT_RE_SeekBacktrack(token-->RE_DOWN, findt, false, ito, false)))
				jump RewindFound;
			if (mode_flags & ACCUM_MFLAG == false) IT_RE_FailSubexpressions(token);
			token = token-->RE_PREVIOUS;
			while (token ~= NULL) {
				if (IT_RE_SeekBacktrack(token, findt, true, ito, false)) {
					.RewindFound;
					ipos = token-->RE_DATA1;
					mode_flags = token-->RE_MODES;
					if (mode_flags & ACCUM_MFLAG == false)
						IT_RE_FailSubexpressions(token, true);
					if (ipos == -1)
						IT_RE_DebugTree(findt, true);
					if (IT_RE_Trace) {
						print "^[", ifrom, ",", ito, "] rewinding to ", ipos, " at ";
						IT_RE_DebugNode(token, findt, true);
					}
					jump Rewind;
				}
				token = token-->RE_PREVIOUS;
			}
			if (IT_RE_Trace)
				print "^Rewind impossible^";
			return -1;
		}

		token = token-->RE_NEXT;
	}
	return ipos - ifrom;
];

[ IT_RE_SeekBacktrack token findt downwards ito report_only
	untried;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if ((IT_RE_Trace) && (report_only == false)) {
			print "Scan for rewind: ";
			IT_RE_DebugNode(token, findt, true);
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2 or 4)) {
			if (downwards) rfalse;
			continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			if ((IT_RE_Trace) && (report_only == false)) print "Descend^";
			if (IT_RE_SeekBacktrack(token-->RE_DOWN, findt, false, ito, report_only)) rtrue;
		}
		untried = false;
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC:
				if ((token-->RE_DATA2 >= 1) &&
					(token-->RE_DATA2 < token-->RE_PAR1) &&
					(token-->RE_CONSTRAINT < token-->RE_PAR1)) { ! Matched but earlier than last
					if (report_only) rtrue;
					if (token-->RE_CONSTRAINT == -1)
						token-->RE_CONSTRAINT = 1;
					else
						(token-->RE_CONSTRAINT)++;
					untried = true;
				}
			QUANTIFIER_RE_CC:
				if (token-->RE_CONSTRAINT ~= -2) {
					if ((IT_RE_Trace) && (report_only == false)) {
						print "Quant with cons not -2: ";
						IT_RE_DebugNode(token, findt, true);
					}
					if (token-->RE_DATA2 >= 0) {
						if (report_only) rtrue;
						token-->RE_CONSTRAINT = token-->RE_DATA2;
						untried = true;
					}
				}
		}
		if (untried) {
			if (IT_RE_Trace) {
				print "Grounds for rewind at: ";
				IT_RE_DebugNode(token, findt, true);
			}
			IT_RE_EraseConstraints(token-->RE_NEXT);
			IT_RE_EraseConstraints(token-->RE_DOWN);
			rtrue;
		}
		if (downwards) rfalse;
	}
	rfalse;
];

[ IT_RE_FailSubexpressions token downwards;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) IT_RE_FailSubexpressions(token-->RE_DOWN);
		if (token-->RE_CCLASS == SUBEXP_RE_CC) {
			token-->RE_DATA1 = -1;
			token-->RE_DATA2 = -1;
		}
		if (downwards) break;
	}
];

[ IT_RE_EraseConstraints token;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC: token-->RE_CONSTRAINT = -1;
			QUANTIFIER_RE_CC: token-->RE_CONSTRAINT = -1;
		}
		if (token-->RE_DOWN) IT_RE_EraseConstraints(token-->RE_DOWN);
		token = token-->RE_NEXT;
	}
];

[ IT_RE_MatchSubstring indt ipos mindt mfrom mto insens
	i ch;
	if (mfrom < 0) return 0;
	if (insens)
		for (i=mfrom:i<mto:i++) {
			ch = BlkValueRead(mindt, i);
			if (BlkValueRead(indt, ipos++) ~= ch or IT_RevCase(ch))
				return -1;
		}
	else
		for (i=mfrom:i<mto:i++)
			if (BlkValueRead(indt, ipos++) ~= BlkValueRead(mindt, i))
				return -1;
	return mto-mfrom;
];

[ IT_RE_Range ch findt rf rt negate insens
	i chm upper crev;
	if (ch == 0) rfalse;
	if (negate == true) {
		if (IT_RE_Range(ch, findt, rf, rt, false, insens)) rfalse;
		rtrue;
	}
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(findt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(findt, ++i);
			switch (chm) {
				's':
					if (ch == 10 or 13 or 32 or 9) rtrue;
				'S':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9)) rtrue;
				'p':
					if (ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'P':
					if ((ch) && (ch ~= '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'w':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'W':
					if (ch == 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'd':
					if (ch == '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9') rtrue;
				'D':
					if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9')) rtrue;
				'l': if (CharIsOfCase(ch, 0)) rtrue;
				'L': if (CharIsOfCase(ch, 0) == false) rtrue;
				'u': if (CharIsOfCase(ch, 1)) rtrue;
				'U': if (CharIsOfCase(ch, 1) == false) rtrue;
				'n': if (ch == 10) rtrue;
				't': if (ch == 9) rtrue;
			}
		}
		if ((i+2<rt) && (BlkValueRead(findt, i+1) == '-')) {
			upper = BlkValueRead(findt, i+2);
			if ((ch >= chm) && (ch <= upper)) rtrue;
			if (insens) {
				crev = IT_RevCase(ch);
				if ((crev >= chm) && (crev <= upper)) rtrue;
			}
			i=i+2;
		} else {
			if (chm == ch) rtrue;
			if ((insens) && (chm == IT_RevCase(ch))) rtrue;
		}
	}
	rfalse;
];

[ IT_Replace_RE findtype indt findt rindt insens exactly
	cindt csize ilen i cl mpos cpos ch chm;
	ilen = IT_CharacterLength(indt);

	IT_RE_Err = 0;
	switch (findtype) {
		REGEXP_BLOB: i = IT_RE_CompileTree(findt, exactly);
		CHR_BLOB: i = IT_CHR_CompileTree(findt, exactly);
		default: "*** bad findtype ***";
	}
	
	if ((i<0) || (i>RE_MAX_PACKETS)) {
		IT_RE_Err = i;
		print "*** Regular expression error: ", (string) IT_RE_Err, " ***^";
		RunTimeProblem(RTP_REGEXPSYNTAXERROR);
		return 0;
	}

	if (IT_RE_Trace) {
		IT_RE_DebugTree(findt);
		print "(compiled to ", i, " packets)^";
	}
	
	if (findtype == REGEXP_BLOB) IT_RE_EmptyMatchVars();

	mpos = 0; chm = 0; cpos = 0;
	while (IT_RE_Parse(findt, indt, mpos, insens) >= 0) {
		chm++;
		
		if (IT_RE_Trace) {
			print "^*** Match ", chm, " found (", RE_PACKET_space-->RE_DATA1, ",",
				RE_PACKET_space-->RE_DATA2, "): ";
			if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2) {
				print "<empty>";
			}
			for (i=RE_PACKET_space-->RE_DATA1:i<RE_PACKET_space-->RE_DATA2:i++) {
				print (char) BlkValueRead(indt, i);
			}
			print " ***^";
		}
		
		if (rindt == 0) break; ! Accept only one match, replace nothing
		
		if (rindt ~= 0 or 1) {
			if (chm == 1) {
				cindt = BlkValueCreate(INDEXED_TEXT_TY);
				csize = BlkValueExtent(cindt);
			}

			for (i=cpos:i<RE_PACKET_space-->RE_DATA1:i++) {
				ch = BlkValueRead(indt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetExtent(cindt, 2*cl, 7) == false) break;
					csize = BlkValueExtent(cindt);
				}
				BlkValueWrite(cindt, cl++, ch);
			}
			BlkValueWrite(cindt, cl, 0);
	
			IT_Concatenate(cindt, rindt, findtype, indt);
			csize = BlkValueExtent(cindt);
			cl = IT_CharacterLength(cindt);			
		}

		mpos = RE_PACKET_space-->RE_DATA2; cpos = mpos;
		if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2)
			mpos++;

		if (IT_RE_Trace) {
			if (chm == 100) { ! Purely to keep the output from being excessive
				print "(Stopping after 100 matches.)^"; break;
			}
		}
	}
	if (chm > 0) {
		if (rindt ~= 0 or 1) {
			for (i=cpos:i<ilen:i++) {
				ch = BlkValueRead(indt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetExtent(cindt, 2*cl, 8) == false) break;
					csize = BlkValueExtent(cindt);
				}
				BlkValueWrite(cindt, cl++, ch);
			}
		}
		
		if (findtype == REGEXP_BLOB) {
			IT_RE_CreateMatchVars(indt);
			if (IT_RE_Trace)
				IT_RE_DebugMatchVars(indt);
		}

		if (rindt ~= 0 or 1) {
			BlkValueWrite(cindt, cl, 0);
			BlkValueCopy(indt, cindt);	
			BlkFree(cindt);
		}
	}
	return chm;
];

[ IT_RE_Concatenate indt_to indt_from blobtype indt_ref
	pos len ch i tosize x y case;
	if ((indt_to==0) || (BlkType(indt_to) ~= INDEXED_TEXT_TY)) rfalse;
	if ((indt_from==0) || (BlkType(indt_from) ~= INDEXED_TEXT_TY)) return indt_to;
	pos = IT_CharacterLength(indt_to);
	tosize = BlkValueExtent(indt_to);
	len = IT_CharacterLength(indt_from);
	for (i=0:i<len:i++) {
		ch = BlkValueRead(indt_from, i);
		if ((ch == '\') && (i < len-1)) {
			ch = BlkValueRead(indt_from, ++i);
			if (ch == 'n') ch = 10;
			if (ch == 't') ch = 9;
			case = -1;
			if (ch == 'l') case = 0;
			if (ch == 'u') case = 1;
			if (case >= 0) ch = BlkValueRead(indt_from, ++i);
			if ((ch >= '0') && (ch <= '9')) {
				ch = ch - '0';
				if (ch < RE_Subexpressions-->10) {
					x = (RE_Subexpressions-->ch)-->RE_DATA1;
					y = (RE_Subexpressions-->ch)-->RE_DATA2;
					if (x >= 0) {
						for (:x<y:x++) {
							ch = BlkValueRead(indt_ref, x);
							if (pos+1 >= tosize) {
								if (BlkValueSetExtent(indt_to, 2*tosize, 11) == false) break;
								tosize = BlkValueExtent(indt_to);
							}
							if (case >= 0)
								BlkValueWrite(indt_to, pos++, CharToCase(ch, case));
							else
								BlkValueWrite(indt_to, pos++, ch);
						}
					}
				}
				continue;
			}
			
		}
		if (pos+1 >= tosize) {
			if (BlkValueSetExtent(indt_to, 2*tosize, 12) == false) break;
			tosize = BlkValueExtent(indt_to);
		}
		BlkValueWrite(indt_to, pos++, ch);
	}
	BlkValueWrite(indt_to, pos, 0);
	return indt_to;
];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of indexed texts

[ STORED_ACTION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     return STORED_ACTION_TY_Create();
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return STORED_ACTION_TY_Destroy(arg1);
		PRECOPY_KOVS:    rfalse;
		COPY_KOVS:       return STORED_ACTION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return STORED_ACTION_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return STORED_ACTION_TY_Hash(arg1);
	}
];

[ STORED_ACTION_TY_Create stora;
	stora = BlkAllocate(6*WORDSIZE, STORED_ACTION_TY, BLK_FLAG_WORD);
	BlkValueWrite(stora, 0, ##Wait); ! action
	BlkValueWrite(stora, 1, 0); ! noun
	BlkValueWrite(stora, 2, 0); ! second
	BlkValueWrite(stora, 3, player); ! actor
	BlkValueWrite(stora, 4, false); ! whether a request
	BlkValueWrite(stora, 5, 0); ! indexed text of command if necessary, 0 if not
	return stora;
];

[ STORED_ACTION_TY_New a n s ac req  stora;
	if (stora == 0) stora = STORED_ACTION_TY_Create();
	BlkValueWrite(stora, 0, a);
	BlkValueWrite(stora, 1, n);
	BlkValueWrite(stora, 2, s);
	BlkValueWrite(stora, 3, ac);
	BlkValueWrite(stora, 4, req);
	BlkValueWrite(stora, 5, 0);
	return stora;
];

[ STORED_ACTION_TY_Destroy stora toc;
	toc = BlkValueRead(stora, 5);
	if (toc) BlkFree(toc);
];

[ STORED_ACTION_TY_Copy storato storafrom tocfrom tocto;
	tocfrom = BlkValueRead(storafrom, 5);
	if (tocfrom == 0) return;
	tocto = INDEXED_TEXT_TY_Support(CREATE_KOVS);
	BlkValueCopy(tocto, tocfrom);
	BlkValueWrite(storato, 5, tocto);
];

[ STORED_ACTION_TY_Compare storaleft storaright delta itleft itright;
	delta = BlkValueRead(storaleft, 0) - BlkValueRead(storaright, 0);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 1) - BlkValueRead(storaright, 1);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 2) - BlkValueRead(storaright, 2);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 3) - BlkValueRead(storaright, 3);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 4) - BlkValueRead(storaright, 4);
	if (delta) return delta;
	itleft = BlkValueRead(storaleft, 5);
	itright = BlkValueRead(storaright, 5);
	if ((itleft ~= 0) && (itright ~= 0))
		return INDEXED_TEXT_TY_Support(COMPARE_KOVS, itleft, itright);
	return itleft - itright;
];

[ STORED_ACTION_TY_Distinguish stora1 stora2;
	if (STORED_ACTION_TY_Compare(stora1, stora2) == 0) rfalse;
	rtrue;
];

[ STORED_ACTION_TY_Hash stora  rv it;
	rv = BlkValueRead(stora, 0);
	rv = rv * 33 + BlkValueRead(stora, 1);
	rv = rv * 33 + BlkValueRead(stora, 2);
	rv = rv * 33 + BlkValueRead(stora, 3);
	rv = rv * 33 + BlkValueRead(stora, 4);
	it = BlkValueRead(stora, 5);
	if (it ~= 0)
		rv = rv * 33 + INDEXED_TEXT_TY_Support(HASH_KOVS, it);
	return rv;
];

[ STORED_ACTION_TY_Say stora text_of_command saved_command saved_pn saved_action K1 K2 at;
	if ((stora==0) || (BlkType(stora) ~= STORED_ACTION_TY)) return;
	text_of_command = BlkValueRead(stora, 5);
	if (text_of_command) {
		saved_command = INDEXED_TEXT_TY_Support(CREATE_KOVS);
		INDEXED_TEXT_TY_Support(CAST_KOVS, players_command, SNIPPET_TY, saved_command);
		SetPlayersCommand(text_of_command);
	}
	saved_pn = parsed_number; saved_action = action;
	action = BlkValueRead(stora, 0);
	at = FindAction(-1);
	K1 = ActionData-->(at+AD_NOUN_KOV);
	K2 = ActionData-->(at+AD_SECOND_KOV);
	if (K1 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, 1);
		if ((K1 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(players_command, SNIPPET_TY, saved_command);
			text_of_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(parsed_number, TEXT_TY, text_of_command);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
		}
	}
	if (K2 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, 2);
		if ((K2 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(players_command, SNIPPET_TY, saved_command);
			text_of_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(parsed_number, TEXT_TY, text_of_command);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
		}
	}	
	DB_Action(BlkValueRead(stora, 3), BlkValueRead(stora, 4), BlkValueRead(stora, 0),
		BlkValueRead(stora, 1), BlkValueRead(stora, 2), true);
	parsed_number = saved_pn; action = saved_action;
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkFree(saved_command);
	}
];

[ STORED_ACTION_TY_Involves stora item at;
	at = FindAction(BlkValueRead(stora, 0));
	if (at) {
		if ((ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, 1) == item)) rtrue;
		if ((ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, 2) == item)) rtrue;
	}
	if (BlkValueRead(stora, 3) == item) rtrue;
	rfalse;
];

[ STORED_ACTION_TY_Part stora ind at ado;
	if (ind == 1 or 2) {
		if (ind == 1) ado = AD_NOUN_KOV; else ado = AD_SECOND_KOV;
		at = FindAction(BlkValueRead(stora, 0));
		if ((at) && (ActionData-->(at+ado) == OBJECT_TY)) return BlkValueRead(stora, ind);
		return nothing;
	}
	return BlkValueRead(stora, ind);
];

Array SAT_Tmp-->7;
[ STORED_ACTION_TY_Adopt stora at;
	SAT_Tmp-->1 = action;
	SAT_Tmp-->2 = noun;
	SAT_Tmp-->3 = second;
	SAT_Tmp-->4 = actor;
	SAT_Tmp-->5 = act_requester;
	SAT_Tmp-->6 = parsed_number;
	action = BlkValueRead(stora, 0);
	at = FindAction(-1);
	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) noun = BlkValueRead(stora, 1);
	else { parsed_number = BlkValueRead(stora, 1); noun = nothing; }
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) second = BlkValueRead(stora, 2);
	else { parsed_number = BlkValueRead(stora, 2); second = nothing; }
	actor = BlkValueRead(stora, 3);
	if (BlkValueRead(stora, 4)) act_requester = player; else act_requester = nothing;
];

[ STORED_ACTION_TY_Unadopt;
	action = SAT_Tmp-->1;
	noun = SAT_Tmp-->2;
	second = SAT_Tmp-->3;	
	actor = SAT_Tmp-->4;	
	act_requester = SAT_Tmp-->5;
	parsed_number = SAT_Tmp-->6;
	return SAT_Tmp-->0;
];

[ STORED_ACTION_TY_Current stora at text_of_command;
	if ((stora==0) || (BlkType(stora) ~= STORED_ACTION_TY)) return 0;
	BlkValueWrite(stora, 0, action);
	at = FindAction(-1);
	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) BlkValueWrite(stora, 1, noun);
	else BlkValueWrite(stora, 1, parsed_number);
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) BlkValueWrite(stora, 2, second);
	else BlkValueWrite(stora, 2, parsed_number);
	BlkValueWrite(stora, 3, actor);
	if (act_requester) BlkValueWrite(stora, 4, true); else BlkValueWrite(stora, 4, false);
	if ((at) && ((ActionData-->(at+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(at+AD_SECOND_KOV) == UNDERSTANDING_TY))) {
		text_of_command = BlkValueRead(stora, 5);
		if (text_of_command == 0) {
			text_of_command = INDEXED_TEXT_TY_Support(CREATE_KOVS);
			BlkValueWrite(stora, 5, text_of_command);
		}
		INDEXED_TEXT_TY_Support(CAST_KOVS, players_command, SNIPPET_TY, text_of_command);
	} else BlkValueWrite(stora, 5, 0);
	return stora;
];

[ STORED_ACTION_TY_Try stora ks  text_of_command saved_command;
	if ((stora==0) || (BlkType(stora) ~= STORED_ACTION_TY)) return;
	if (ks) { @push keep_silent; keep_silent=1; }
	text_of_command = BlkValueRead(stora, 5);
	if (text_of_command) {
		saved_command = INDEXED_TEXT_TY_Support(CREATE_KOVS);
		INDEXED_TEXT_TY_Support(CAST_KOVS, players_command, SNIPPET_TY, saved_command);
		SetPlayersCommand(text_of_command);
	}
	TryAction(BlkValueRead(stora, 4), BlkValueRead(stora, 3),
		BlkValueRead(stora, 0), BlkValueRead(stora, 1), BlkValueRead(stora, 2));
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkFree(saved_command);
	}
	if (ks) { @pull keep_silent; }
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ STORED_ACTION_TY_Say stora; ];
[ STORED_ACTION_TY_New a n s ac req stora; return false; ];
[ STORED_ACTION_TY_Support t a b c; rfalse; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of heap

[ LIST_OF_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     arg3 = LIST_OF_TY_Create(arg2);
		                 if (arg1) LIST_OF_TY_CopyRawArray(arg3, arg1, 2);
		                 return arg3;
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return LIST_OF_TY_Destroy(arg1);
		PRECOPY_KOVS:    return LIST_OF_TY_PreCopy(arg1, arg2);
		COPY_KOVS:       return LIST_OF_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return LIST_OF_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return LIST_OF_TY_Hash(arg1);
	}
];

Constant LIST_ITEM_KOV_F = 0; ! Entry 0: the kind of the list
Constant LIST_LENGTH_F = 1; ! Entry 1: length, i.e., number of items
Constant LIST_ITEM_BASE = 2; ! List items begin at this entry

[ LIST_OF_TY_Create skov list;
	skov = KindBaseTerm(skov, 0);
	list = BlkAllocate(28*WORDSIZE, LIST_OF_TY, BLK_FLAG_MULTIPLE + BLK_FLAG_WORD);
	BlkValueWrite(list, LIST_ITEM_KOV_F, skov);
	BlkValueWrite(list, LIST_LENGTH_F, 0);
	return list;
];

[ LIST_OF_TY_CopyRawArray list arr rea len i ex bk v w;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	ex = BlkValueExtent(list);
	len = arr-->2;
	if ((len+LIST_ITEM_BASE > ex) &&
		(BlkValueSetExtent(list, len+LIST_ITEM_BASE) == false)) return 0;
	BlkValueWrite(list, LIST_LENGTH_F, len);
	if (rea == 2) bk = BlkValueRead(list, LIST_ITEM_KOV_F);
	else {
		bk = arr-->1;
		BlkValueWrite(list, LIST_ITEM_KOV_F, bk);
	}
	for (i=0:i<len:i++) {
		v = arr-->(i+3);
		if (KindAtomic(bk) == LIST_OF_TY) {
			w = LIST_OF_TY_Create(v-->1);
			LIST_OF_TY_CopyRawArray(w, v);
			BlkValueWrite(list, i+LIST_ITEM_BASE, w);
		} else {
			if (KOVIsBlockValue(bk)) v = BlkValueCreate(bk, v);
			BlkValueWrite(list, i+LIST_ITEM_BASE, v);
		}
	}
	#ifdef SHOW_ALLOCATIONS;
	print "Copied raw array to list: "; LIST_OF_TY_Say(list, 1); print "^";
	#endif;
	return list;
];

[ LIST_OF_TY_Destroy list no_items i;
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		no_items = BlkValueRead(list, LIST_LENGTH_F);
		for (i=0; i<no_items; i++) BlkFree(BlkValueRead(list, i+LIST_ITEM_BASE));
	}
	return list;
];

Global precopied_list_kov;

[ LIST_OF_TY_PreCopy lto lfrom list;
	precopied_list_kov = BlkValueRead(lto, LIST_ITEM_KOV_F);
];

[ LIST_OF_TY_Copy lto lfrom list no_items i nv bk val splk;
	no_items = BlkValueRead(lfrom, LIST_LENGTH_F);
	bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F);
	if (precopied_list_kov ~= 0 or 1) BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);
	else BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);
	if ((precopied_list_kov == INDEXED_TEXT_TY) && (bk == TEXT_TY)) {
		for (i=0; i<no_items; i++) {
			nv = BlkValueCreate(INDEXED_TEXT_TY);
			INDEXED_TEXT_TY_Cast(BlkValueRead(lfrom, i+LIST_ITEM_BASE), TEXT_TY, nv);
			BlkValueWrite(lto, i+LIST_ITEM_BASE, nv);
		}
	} else {
		if (KOVIsBlockValue(bk)) {
			for (i=0; i<no_items; i++) {
				val = BlkValueRead(lfrom, i+LIST_ITEM_BASE);
				nv = BlkValueCreate(BlkType(val));
				BlkValueCopy(nv, val);
				BlkValueWrite(lto, i+LIST_ITEM_BASE, nv);
			}
		}
	}
	precopied_list_kov = 0;
];

[ LIST_OF_TY_Compare listleft listright delta no_items i cf;
	delta = BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F);
	if (delta) return delta;
	delta = BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F);
	if (delta) return delta;
	no_items = BlkValueRead(listleft, LIST_LENGTH_F);
	cf = LIST_OF_TY_ComparisonFn(listleft);
	if (cf == 0 or UnsignedCompare) {
		for (i=0; i<no_items; i++) {
			delta = BlkValueRead(listleft, i+LIST_ITEM_BASE) -
				BlkValueRead(listright, i+LIST_ITEM_BASE);
			if (delta) return delta;
		}
	} else {
		for (i=0; i<no_items; i++) {
			delta = cf(BlkValueRead(listleft, i+LIST_ITEM_BASE),
				BlkValueRead(listright, i+LIST_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ LIST_OF_TY_ComparisonFn list;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));
];

[ LIST_OF_TY_Distinguish txb1 txb2;
	if (LIST_OF_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];

[ LIST_OF_TY_Hash list  len kov rv i;
	rv = 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	kov = BlkValueRead(list, LIST_ITEM_KOV_F);
	for (i=0: i<len: i++)
		rv = rv * 33 + KOVHashValue(kov, BlkValueRead(list, i+LIST_ITEM_BASE));
	return rv;
];

[ LIST_OF_TY_Say list format no_items v i bk;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F));
	! print "kov=", BlkValueRead(list, LIST_ITEM_KOV_F), ":";
	if (format == 1) print "{";
	for (i=0:i<no_items:i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		switch (format) {
			2: print (the) v;
			3: print (a) v;
			default:
				if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
				else if ((bk == TEXT_TY or INDEXED_TEXT_TY) && (format == 1)) {
					print "~"; PrintKindValuePair(bk, v); print "~";
				}
				else PrintKindValuePair(bk, v);
		}
		if (i<no_items-2) print ", ";
		if (i==no_items-2) {
			if (format == 1) print ", "; else {
				#ifdef SERIAL_COMMA; if (no_items ~= 2) print ","; #endif;
				print (string) LISTAND2__TX;
			}
		}
	}
	if (format == 1) print "}";
];

[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	ex = BlkValueExtent(list);
	len = desc(-3);
!	for (len=0, obj=desc(-2, nothing, len): obj: len++, obj=desc(-2, obj, len)) ;
!	len++;
	if (len+LIST_ITEM_BASE > ex) {
		if (BlkValueSetExtent(list, len+LIST_ITEM_BASE) == false)
			return 0;
	}
	if (kov) BlkValueWrite(list, LIST_ITEM_KOV_F, kov);
	else BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);
	BlkValueWrite(list, LIST_LENGTH_F, len);
	obj = 0;
	for (i=0: i<len: i++) {
		obj = desc(-2, obj, i);
		! print "i = ", i, " and obj = ", obj, "^";
		BlkValueWrite(list, i+LIST_ITEM_BASE, obj);
	}
	return list;
];

[ LIST_OF_TY_FindItem list v i no_items cf;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (cf == 0 or UnsignedCompare) {
		for (i=0; i<no_items; i++)
			if (v == BlkValueRead(list, i+LIST_ITEM_BASE)) rtrue;
	} else {
		for (i=0; i<no_items; i++)
			if (cf(v, BlkValueRead(list, i+LIST_ITEM_BASE)) == 0) rtrue;
	}
	rfalse;
];

[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	if (nodups && (LIST_OF_TY_FindItem(list, v))) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	ex = BlkValueExtent(list);
	if (no_items+LIST_ITEM_BASE+1 > ex) {
		if (BlkValueSetExtent(list, ex+16) == false) return 0;
	}
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
		BlkValueCopy(nv, v);
		v = nv;
	}
	if (posnflag) {
		posn--;
		for (i=no_items:i>posn:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-1+LIST_ITEM_BASE));			
		}
		BlkValueWrite(list, posn+LIST_ITEM_BASE, v);
	} else {
		BlkValueWrite(list, no_items+LIST_ITEM_BASE, v);
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+1);
	return list;
];

[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	if ((more==0) || (BlkType(more) ~= LIST_OF_TY)) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	msize = BlkValueRead(more, LIST_LENGTH_F);
	ex = BlkValueExtent(list);
	if (no_items+msize+LIST_ITEM_BASE > ex) {
		if (BlkValueSetExtent(list, no_items+msize+LIST_ITEM_BASE+8) == false)
			return 0;
	}
	if (posnflag) {
		posn--;
		for (i=no_items+msize:i>=posn+msize:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-msize+LIST_ITEM_BASE));			
		}
		! BlkValueWrite(list, posn, v);
		for (j=0: j<msize: j++) {
			v = BlkValueRead(more, j+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			BlkValueWrite(list, posn+j+LIST_ITEM_BASE, v);
		}
	} else {
		for (i=0, j=0: i<msize: i++) {
			v = BlkValueRead(more, i+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			if ((nodups == 0) || (LIST_OF_TY_FindItem(list, v) == false)) {
				BlkValueWrite(list, no_items+j+LIST_ITEM_BASE, v);
				j++;
			}
		}
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+j);
	return list;
];

[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	for (i=0; i<no_items; i++) {
		delendum = BlkValueRead(list, i+LIST_ITEM_BASE);
		if (cf == 0 or UnsignedCompare)
			f = (v == delendum);
		else
			f = (cf(v, delendum) == 0);
		if (f) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				BlkFree(delendum);
			for (j=i+1; j<no_items; j++)
				BlkValueWrite(list, j-1+LIST_ITEM_BASE,
					BlkValueRead(list, j+LIST_ITEM_BASE));
			no_items--; i--;
			BlkValueWrite(list, LIST_LENGTH_F, no_items);
		}
	}
	if (odsize ~= no_items) rfalse;
	if (forgive) rfalse;
	print "*** Couldn't remove: the value ";
	PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);
	print " was not present in the list ";
	LIST_OF_TY_Say(list, true);
	print " ***^";
	RunTimeProblem(RTP_LISTRANGEERROR);
];

[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((from > to) || (from <= 0) || (to > no_items)) {
		if (forgive) {
			if (from <= 0) from = 1;
			if (to >= no_items) to = no_items;
			if (from > to) return list;
		} else {
			print "*** Couldn't remove entries ", from, " to ", to, " from the list ";
			LIST_OF_TY_Say(list, true);
			print ", which has entries in the range 1 to ", no_items, " ***^";
			RunTimeProblem(RTP_LISTRANGEERROR);
			rfalse;
		}
	}
	to--; from--;
	d = to-from+1;
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
		for (i=0; i<d; i++)
			BlkFree(BlkValueRead(list, from+i+LIST_ITEM_BASE));
	for (i=from: i<no_items-d: i++)
		BlkValueWrite(list, i+LIST_ITEM_BASE,
			BlkValueRead(list, i+d+LIST_ITEM_BASE));
	BlkValueWrite(list, LIST_LENGTH_F, no_items-d);
	return list;
];

[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	rsize = BlkValueRead(rlist, LIST_LENGTH_F);
	cf = LIST_OF_TY_ComparisonFn(list);
	for (i=0: i<no_items: i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		for (k=0: k<rsize: k++) {
			w = BlkValueRead(rlist, k+LIST_ITEM_BASE);
			if (cf == 0 or UnsignedCompare)
				f = (v == w);
			else
				f = (cf(v, w) == 0);
			if (f) {
				if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
					BlkFree(v);
				for (j=i+1: j<no_items: j++)
					BlkValueWrite(list, j+LIST_ITEM_BASE-1, 
						BlkValueRead(list, j+LIST_ITEM_BASE));
				no_items--; i--;
				BlkValueWrite(list, LIST_LENGTH_F, no_items);
				break;
			}
		}
	}
	rfalse;
];

[ LIST_OF_TY_GetLength list;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	return BlkValueRead(list, LIST_LENGTH_F);
];

[ LIST_OF_TY_Empty list;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	if (BlkValueRead(list, LIST_LENGTH_F) == 0) rtrue;
	rfalse;
];

[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	if (newsize < 0) "*** Cannot resize a list to negative length ***";
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < newsize) {
		if (this_way_only == -1) return list;
		ex = BlkValueExtent(list);
		if (newsize+LIST_ITEM_BASE > ex) {
			if (BlkValueSetExtent(list, newsize+LIST_ITEM_BASE) == false)
				return 0;
		}
		dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F));
		for (i=no_items: i<newsize: i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i, dv);
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	if (no_items > newsize) {
		if (this_way_only == 1) return list;
		if (truncation_end == -1) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=0: i<no_items-newsize: i++)
					BlkFree(BlkValueRead(list, LIST_ITEM_BASE+i));
			for (i=0: i<newsize: i++)
				BlkValueWrite(list, LIST_ITEM_BASE+i,
					BlkValueRead(list, LIST_ITEM_BASE+no_items-newsize+i));
		} else {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=newsize: i<no_items: i++)
					BlkFree(BlkValueRead(list, LIST_ITEM_BASE+i));
		}
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	return list;
];

[ LIST_OF_TY_GetItem list i forgive no_items;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		if (forgive) return false;
		print "*** Couldn't read from entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		RunTimeProblem(RTP_LISTRANGEERROR);
		if (no_items >= 1) i = 1;
		else return false;
	}
	return BlkValueRead(list, LIST_ITEM_BASE+i-1);
];

[ WriteLIST_OF_TY_GetItem list i val no_items;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		print "*** Couldn't write to list entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		return RunTimeProblem(RTP_LISTRANGEERROR);
	}
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, val);
];

[ LIST_OF_TY_PutItem list i v  no_items nv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
		BlkValueCopy(nv, v);
		v = nv;
	}
	if ((i<=0) || (i>no_items)) return false;
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, v);
];

[ LIST_OF_TY_Mol list len i;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	len = multiple_object-->0;
	LIST_OF_TY_SetLength(list, len);
	for (i=1: i<=len: i++)
		LIST_OF_TY_PutItem(list, i, multiple_object-->i);
	return list;
];

[ LIST_OF_TY_Set_Mol list len i;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	if (len > 63) len = 63;
	multiple_object-->0 = len;
	for (i=1: i<=len: i++)
		multiple_object-->i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
];

[ LIST_OF_TY_Reverse list no_items i v;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	for (i=0;i*2<no_items;i++) {
		v = BlkValueRead(list, LIST_ITEM_BASE+i);
		BlkValueWrite(list, LIST_ITEM_BASE+i,
			BlkValueRead(list, LIST_ITEM_BASE+no_items-1-i));
		BlkValueWrite(list, LIST_ITEM_BASE+no_items-1-i, v);
	}
	return list;
];

[ LIST_OF_TY_Rotate list backwards  no_items i v;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	if (backwards) {
		v = BlkValueRead(list, LIST_ITEM_BASE);
		for (i=0:i<no_items-1:i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i+1));
		BlkValueWrite(list, no_items-1+LIST_ITEM_BASE, v);
	} else {
		v = BlkValueRead(list, no_items-1+LIST_ITEM_BASE);
		for (i=no_items-1:i>0:i--)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i-1));
		BlkValueWrite(list, LIST_ITEM_BASE, v);
	}
	return list;
];

Global LIST_OF_TY_Sort_cf;

[ LIST_OF_TY_Sort list dir prop cf  i j no_items v;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (dir == 2) {
		if (no_items < 2) return;
		for (i=1:i<no_items:i++) {
			j = random(i+1) - 1;
			v = BlkValueRead(list, LIST_ITEM_BASE+i);
			BlkValueWrite(list, LIST_ITEM_BASE+i, BlkValueRead(list, LIST_ITEM_BASE+j));
			BlkValueWrite(list, LIST_ITEM_BASE+j, v);
		}
		return;
	}
	SetSortDomain(ListSwapEntries, ListCompareEntries);
	if (cf) { LIST_OF_TY_Sort_cf = BlkValueCompare; ! dir = -dir;
	}
	else LIST_OF_TY_Sort_cf = 0;
	SortArray(list, prop, dir, no_items, false, 0);
];

[ ListSwapEntries list i j v;
	if (i==j) return;
	v = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, BlkValueRead(list, LIST_ITEM_BASE+j-1));
	BlkValueWrite(list, LIST_ITEM_BASE+j-1, v);
];

[ ListCompareEntries list col i j d cf;
	if (i==j) return 0;
	i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	j = BlkValueRead(list, LIST_ITEM_BASE+j-1);
	if (I7S_Col) {
		if (i provides I7S_Col) i=i.I7S_Col; else i=0;
		if (j provides I7S_Col) j=j.I7S_Col; else j=0;
		cf = LIST_OF_TY_Sort_cf;
	} else {
		cf = LIST_OF_TY_ComparisonFn(list);
	}
	if (cf == 0)
		return i - j;
	else
		return cf(i, j);
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ LIST_OF_TY_Support t a b c; rfalse; ];
[ LIST_OF_TY_Say list; ];
[ LIST_OF_TY_FindItem list v; rfalse; ];
[ LIST_OF_TY_Empty list; rfalse; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of heap

[ COMBINATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     arg3 = COMBINATION_TY_Create(arg2);
		                 if (arg1) COMBINATION_TY_CopyRawArray(arg3, arg1, 2);
		                 return arg3;
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return COMBINATION_TY_Destroy(arg1);
		PRECOPY_KOVS:    return COMBINATION_TY_PreCopy(arg1, arg2);
		COPY_KOVS:       return COMBINATION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return COMBINATION_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return COMBINATION_TY_Hash(arg1);
	}
];

Constant COMBINATION_KIND_F = 0; ! A pointer to a block indicating the kind
Constant COMBINATION_ITEM_BASE = 1; ! List items begin at this entry

[ COMBINATION_TY_Create kind comb N i bk v;
	N = KindBaseArity(kind);
	comb = BlkAllocate((COMBINATION_ITEM_BASE+N)*WORDSIZE, COMBINATION_TY, BLK_FLAG_WORD);
	BlkValueWrite(comb, COMBINATION_KIND_F, kind);
	for (i=0; i<N; i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk))
			v = BlkValueCreate(bk);
		else
			v = DefaultValueOfKOV(bk);
		BlkValueWrite(comb, COMBINATION_ITEM_BASE+i, v);
	}
	return comb;
];

[ COMBINATION_TY_CopyRawArray comb raw rea len i ex bk v w;
	if ((comb==0) || (BlkType(comb) ~= COMBINATION_TY)) return false;
	ex = BlkValueExtent(comb);
	len = raw-->2;
	if ((len+COMBINATION_ITEM_BASE > ex) &&
		(BlkValueSetExtent(comb, len+COMBINATION_ITEM_BASE) == false)) return 0;
	BlkValueWrite(comb, LIST_LENGTH_F, len);
	if (rea == 2) bk = BlkValueRead(comb, COMBINATION_KIND_F);
	else {
		bk = raw-->1;
		BlkValueWrite(comb, COMBINATION_KIND_F, bk);
	}
	for (i=0:i<len:i++) {
		v = raw-->(i+3);
		if (KOVIsBlockValue(bk)) v = BlkValueCreate(bk, v);
		BlkValueWrite(comb, i+COMBINATION_ITEM_BASE, v);
	}
	#ifdef SHOW_ALLOCATIONS;
	print "Copied raw array to comb: "; COMBINATION_TY_Say(comb, 1); print "^";
	#endif;
	return comb;
];

[ COMBINATION_TY_Destroy comb kind no_items i bk;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0; i<no_items; i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk))
			BlkFree(BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
	return comb;
];

Global precopied_comb_kov;

[ COMBINATION_TY_PreCopy lto lfrom comb no_items i nv bk;
	precopied_comb_kov = BlkValueRead(lto, COMBINATION_KIND_F);
];

[ COMBINATION_TY_Copy lto lfrom no_items i nv kind bk;
	kind = BlkValueRead(lto, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	BlkValueWrite(lto, COMBINATION_KIND_F, precopied_comb_kov);
	for (i=0; i<no_items; i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk)) {
			nv = BlkValueCreate(bk);
			BlkValueCopy(nv, BlkValueRead(lfrom, i+COMBINATION_ITEM_BASE));
			BlkValueWrite(lto, i+COMBINATION_ITEM_BASE, nv);
		}
	}
];

[ COMBINATION_TY_Compare listleft listright delta no_items i cf kind bk;
	kind = BlkValueRead(listleft, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0; i<no_items; i++) {
		bk = KindBaseTerm(kind, i);
		cf = KOVComparisonFunction(bk);
		if (cf == 0 or UnsignedCompare) {
			delta = BlkValueRead(listleft, i+COMBINATION_ITEM_BASE) -
				BlkValueRead(listright, i+COMBINATION_ITEM_BASE);
			if (delta) return delta;
		} else {
			delta = cf(BlkValueRead(listleft, i+COMBINATION_ITEM_BASE),
				BlkValueRead(listright, i+COMBINATION_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ COMBINATION_TY_Distinguish txb1 txb2;
	if (COMBINATION_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];

[ COMBINATION_TY_Hash comb  kind rv no_items i bk;
	rv = 0;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		rv = rv * 33 + KOVHashValue(bk, BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
	return rv;
];

[ COMBINATION_TY_Say comb format no_items v i kind bk;
	if ((comb==0) || (BlkType(comb) ~= COMBINATION_TY)) return;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	print "(";
	for (i=0; i<no_items; i++) {
		if (i>0) print ", ";
		bk = KindBaseTerm(kind, i);
		v = BlkValueRead(comb, i+COMBINATION_ITEM_BASE);
		if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
		else PrintKindValuePair(bk, v);
	}
	print ")";
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ COMBINATION_TY_Support t a b c; rfalse; ];
[ COMBINATION_TY_Say comb; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE


Constant RRV_NAME     		RR_NAME-4;
Constant RRV_PERMISSIONS	RR_PERMISSIONS-4;
Constant RRV_STORAGE		RR_STORAGE-4;
Constant RRV_KIND		RR_KIND-4;
Constant RRV_HANDLER		RR_HANDLER-4;
Constant RRV_DESCRIPTION	RR_DESCRIPTION-4;
Constant RRV_USED		6;
Constant RRV_FILLED		7;
Constant RRV_DATA_BASE		8;

! valencies
Constant RRVAL_V_TO_V		0;
Constant RRVAL_V_TO_O		RELS_Y_UNIQUE;
Constant RRVAL_O_TO_V		RELS_X_UNIQUE;
Constant RRVAL_O_TO_O		RELS_X_UNIQUE+RELS_Y_UNIQUE;
Constant RRVAL_EQUIV		RELS_EQUIVALENCE+RELS_SYMMETRIC;
Constant RRVAL_SYM_V_TO_V	RELS_SYMMETRIC;
Constant RRVAL_SYM_O_TO_O	RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;

! dictionary entry flags
Constant RRF_USED	$0001;	! entry contains a value
Constant RRF_DELETED	$0002;	! entry used to contain a value
Constant RRF_SINGLE	$0004;	! entry's Y is a value, not a list
Constant RRF_HASX	$0010;	! 2-in-1 entry contains a corresponding key
Constant RRF_HASY	$0020;	! 2-in-1 entry contains a corresponding value
Constant RRF_ENTKEYX	$0040;	! 2-in-1 entry key is left side KOV
Constant RRF_ENTKEYY	$0080;	! 2-in-1 entry key is right side KOV

! permission/task constants (those commented out here are generated by I7)
!Constant RELS_SYMMETRIC $8000;
!Constant RELS_EQUIVALENCE $4000;
!Constant RELS_X_UNIQUE $2000;
!Constant RELS_Y_UNIQUE $1000;
!Constant RELS_TEST $0800;
!Constant RELS_ASSERT_TRUE $0400;
!Constant RELS_ASSERT_FALSE $0200;
!Constant RELS_SHOW $0100;
!Constant RELS_ROUTE_FIND $0080;
!Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_COPY $0020;
Constant RELS_DESTROY $0010;
Constant RELS_LOOKUP_ANY $0008;
Constant RELS_LOOKUP_ALL_X $0004;
Constant RELS_LOOKUP_ALL_Y $0002;
Constant RELS_LIST $0001;

Constant RELS_EMPTY $0003;
Constant RELS_SET_VALENCY $0005;

! RELS_LOOKUP_ANY mode selection constants
Constant RLANY_GET_X 1;
Constant RLANY_GET_Y 2;
Constant RLANY_CAN_GET_X 3;
Constant RLANY_CAN_GET_Y 4;

! RELS_LIST mode selection constant
Constant RLIST_ALL_X 1;
Constant RLIST_ALL_Y 2;
Constant RLIST_ALL_PAIRS 3;


Constant RRP_MIN_SIZE      8;   ! minimum number of entries (DO NOT CHANGE)
Constant RRP_PERTURB_SHIFT 5;   ! affects the probe sequence
Constant RRP_RESIZE_SMALL  4;   ! resize factor for small tables
Constant RRP_RESIZE_LARGE  2;   ! resize factor for large tables
Constant RRP_LARGE_IS      256; ! how many entries make a table "large"?
Constant RRP_CROWDED_IS    2;   ! when filled entries outnumber unfilled by _ to 1


[ RelationTest relation task X Y  handler;
	handler = relation-->RR_HANDLER;
	return handler(relation, task, X, Y);
];


[ EmptyRelationHandler relation task X Y;
	if (task == RELS_EMPTY) rtrue;
	rfalse;
];


#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of heap


[ RELATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     arg3 = RELATION_TY_Create(arg2, arg1);
		                 return arg3;
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return RELATION_TY_Destroy(arg1);
		PRECOPY_KOVS:    rfalse;
		COPY_KOVS:       return RELATION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return RELATION_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return arg1;
	}
];


[ RELATION_TY_Create kov from rel i skov handler;
	rel = BlkAllocate((RRV_DATA_BASE + 3*RRP_MIN_SIZE)*WORDSIZE,
		RELATION_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
	if ((from == 0) && (kov ~= 0)) from = DefaultValueFinder(kov);
	if (from) {
		for (i=0: i<RRV_DATA_BASE: i++) BlkValueWrite(rel, i, BlkValueRead(from, i));
		if (BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler) {
			handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND));
			BlkValueWrite(rel, RRV_NAME, "anonymous relation");
			BlkValueWrite(rel, RRV_PERMISSIONS,
				RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW);
			BlkValueWrite(rel, RRV_HANDLER, handler);
			BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1);
			BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation");
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
		}
	} else {
		handler = ChooseRelationHandler(kov);
		BlkValueWrite(rel, RRV_NAME, "anonymous relation");
		BlkValueWrite(rel, RRV_PERMISSIONS,
			RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW);
		BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1);
		BlkValueWrite(rel, RRV_KIND, kov);
		BlkValueWrite(rel, RRV_HANDLER, handler);
		BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation");
		BlkValueWrite(rel, RRV_USED, 0);
		BlkValueWrite(rel, RRV_FILLED, 0);
	}
	return rel;
];


[ RELATION_TY_Destroy rel  handler;
	handler = BlkValueRead(rel, RRV_HANDLER);
	handler(rel, RELS_DESTROY);
	return rel;
];


[ RELATION_TY_Copy lto lfrom  handler;
	handler = BlkValueRead(lto, RRV_HANDLER);
	handler(lto, RELS_COPY);
];


[ RELATION_TY_Compare rleft rright ind1 ind2;
	ind1 = BlkValueRead(rleft, RRV_HANDLER);
	ind2 = BlkValueRead(rright, RRV_HANDLER);
	if (ind1 ~= ind2)
		return ind1 - ind2;
	return rleft - rright;
];

[ RELATION_TY_Distinguish rleft rright;
	if (RELATION_TY_Compare(rleft, rright) == 0) rfalse;
	rtrue;
];


[ RELATION_TY_Say rel;
	if (rel == 0) print "(null relation)"; ! shouldn't happen
	else print (string) rel-->RR_NAME;
];


[ RELATION_TY_Name rel txt;
	if (rel) {
		BlkValueWrite(rel, RRV_NAME, txt);
		BlkValueWrite(rel, RRV_DESCRIPTION, txt);
	}
];


[ ChooseRelationHandler kov sym;
	if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {
		if (sym) return SymHashListRelationHandler;
		return HashListRelationHandler;
	}
	if (sym) return SymDoubleHashSetRelationHandler;
	return DoubleHashSetRelationHandler;
];


[ RELATION_TY_SetValency rel val  kov filled cur handler ext;
	filled = BlkValueRead(rel, RRV_FILLED);
	if (filled) { print "*** Illegal valency change ***^"; rfalse; }
	kov = BlkValueRead(rel, RRV_KIND);
	if (val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O) {
		if (KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1)) {
			print "*** Relation cannot be made symmetric ***^";
			rfalse;
		}
	}
	cur = BlkValueRead(rel, RRV_HANDLER);
	switch (val) {
		RRVAL_V_TO_V:		handler = ChooseRelationHandler(kov, false);
		RRVAL_V_TO_O:		handler = HashTableRelationHandler;
		RRVAL_O_TO_V:		handler = ReversedHashTableRelationHandler;
		RRVAL_O_TO_O:		handler = TwoInOneHashTableRelationHandler;
		RRVAL_EQUIV:		handler = EquivHashTableRelationHandler;
		RRVAL_SYM_V_TO_V:	handler = ChooseRelationHandler(kov, true);
		RRVAL_SYM_O_TO_O:	handler = Sym2in1HashTableRelationHandler;
		default:		print "*** Illegal valency value ***^"; rfalse;
	}
	if (cur == handler) rtrue;
	! adjust size when going to or from 2-in-1
	if (cur == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetExtent(rel, RRV_DATA_BASE + 3*ext);
	} else if (handler == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetExtent(rel, RRV_DATA_BASE + 4*ext);
	}
	BlkValueWrite(rel, RRV_HANDLER, handler);
];

[ RELATION_TY_GetValency rel  handler;
	return BlkValueRead(rel, RRV_PERMISSIONS) & VALENCY_MASK;
];


[ DoubleHashSetRelationHandler rel task X Y sym  kov kx ky at tmp v;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		for (at = BlkValueRead(rel, RRV_STORAGE); at >= 0; at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (kx) BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky) BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (sym && (kov(X, Y) > 0)) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			DoubleHashSetRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
					v = BlkValueRead(rel, tmp + 2);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				} else {
					v = BlkValueRead(rel, tmp + 1);
					if (KOVIsBlockValue(kx)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_Y) rtrue;
					return BlkValueRead(rel, tmp + 2);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 2);
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 1);
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (X == 0 || BlkType(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X, RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						tmp++;
						if (Y == RLIST_ALL_Y) tmp++;
						v = BlkValueRead(rel, tmp);
						LIST_OF_TY_InsertItem(X, v, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, 0, kov);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						v = BlkValueRead(rel, tmp + 1);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);
						v = BlkValueRead(rel, tmp + 2);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, v);
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkFree(Y);
				return X;
		}
		rfalse;
	}
	at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
	switch(task) {
		RELS_TEST:
			if (at >= 0) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			if (at >= 0) rtrue;
			at = ~at;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
			if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
			if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
			DoubleHashSetCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			if (KOVIsBlockValue(ky))
				BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];

[ DoubleHashSetLookUp rel kx ky X Y  hashv i free mask perturb flags;
	! calculate a hash value for the pair
	hashv = KOVHashValue(kx, x) + KOVHashValue(ky, y);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) return ~i;
	if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) return i;
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
			if (free >= 0) return ~free;
			return ~i;
		}
		if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y))
			return i;
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ DoubleHashSetCheckResize rel  filled ext newext temp i at kov kx ky F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = BlkAllocate(ext * (3*WORDSIZE), INDEXED_TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i));
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetExtent(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1);
			Y = BlkValueRead(temp, 3*i + 2);
			at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		BlkFree(temp);
	}
];

[ DoubleHashSetEntryMatches rel at kx ky X Y  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	cy = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
	if (KOVIsBlockValue(ky)) {
		if (BlkValueCompare(cy, Y) ~= 0) rfalse;
	} else {
		if (cy ~= Y) rfalse;
	}
	rtrue;
];


[ HashListRelationHandler rel task X Y  sym kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);
];


[ HashTableRelationHandler rel task X Y  kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];


[ ReversedHashTableRelationHandler rel task X Y  kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	switch (task) {
		RELS_SET_VALENCY:
			return RELATION_TY_SetValency(rel, X);
		RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:
			return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);
		RELS_LOOKUP_ANY:
			switch (Y) {
				RLANY_GET_X: Y = RLANY_GET_Y;
				RLANY_GET_Y: Y = RLANY_GET_X;
				RLANY_CAN_GET_X: Y = RLANY_CAN_GET_Y;
				RLANY_CAN_GET_Y: Y = RLANY_CAN_GET_X;
			}
		RELS_LOOKUP_ALL_X:
			task = RELS_LOOKUP_ALL_Y;
		RELS_LOOKUP_ALL_Y:
			task = RELS_LOOKUP_ALL_X;
		RELS_SHOW:
		RELS_LIST:
			switch (Y) {
				RLIST_ALL_X: Y = RLIST_ALL_Y;
				RLIST_ALL_Y: Y = RLIST_ALL_X;
			}
	}
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];


[ SymDoubleHashSetRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		DoubleHashSetRelationHandler(rel, task, Y, X);
	return DoubleHashSetRelationHandler(rel, task, X, Y, 1);
];

[ SymHashListRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		HashListRelationHandler(rel, task, Y, X);
	return HashListRelationHandler(rel, task, X, Y);
];

[ Sym2in1HashTableRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		TwoInOneHashTableRelationHandler(rel, task, Y, X);
	return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);
];


[ HashCoreRelationHandler rel task kx ky X Y mult  sym rev at tmp fl;
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (kx) BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky || ~~(fl & RRF_SINGLE))
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y || ~~(fl & RRF_SINGLE)) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(BlkType(tmp)), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		! Z-machine doesn't have the room to let us pass sym/rev as parameters
		switch (RELATION_TY_GetValency(rel)) {
			RRVAL_SYM_V_TO_V:
				sym = 1;
				tmp = KOVComparisonFunction(kx);
				if (~~tmp) tmp = UnsignedCompare;
			RRVAL_O_TO_V:
				rev = 1;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (fl & RRF_SINGLE) {
					if (sym && tmp(X, Y) > 0) continue;
					print "  ";
					if (rev) PrintKindValuePair(ky, Y);
					else PrintKindValuePair(kx, X);
					if (sym) print " <=> "; else print " >=> ";
					if (rev) PrintKindValuePair(kx, X);
					else PrintKindValuePair(ky, Y);
					print "^";
				} else {
					for (mult=1: mult<=LIST_OF_TY_GetLength(Y): mult++) {
						fl = LIST_OF_TY_GetItem(Y, mult);
						if (sym && tmp(X, fl) > 0) continue;
						print "  ";
						if (rev) PrintKindValuePair(ky, fl);
						else PrintKindValuePair(kx, X);
						if (sym) print " <=> "; else print " >=> ";
						if (rev) PrintKindValuePair(kx, X);
						else PrintKindValuePair(ky, fl);
						print "^";
					}
				}
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			HashCoreRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		if (Y == RLANY_GET_Y or RLANY_CAN_GET_Y) {
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) {
				if (Y == RLANY_CAN_GET_Y) rtrue;
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				tmp = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) return tmp;
				return LIST_OF_TY_GetItem(tmp, 1);
			}
		} else {
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					sym = BlkValueRead(rel, tmp + 2);
					if (fl & RRF_SINGLE) {
						if (KOVIsBlockValue(ky)) {
							if (BlkValueCompare(X, sym) ~= 0) continue;
						} else {
							if (X ~= sym) continue;
						}
					} else {
						if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			if (fl & RRF_USED) {
				sym = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) {
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(X, sym) ~= 0) continue;
					} else {
						if (X ~= sym) continue;
					}
				} else {
					if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		at = HashCoreLookUp(rel, kx, X);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			tmp = BlkValueRead(rel, tmp + 2);
			if (fl & RRF_SINGLE)
				LIST_OF_TY_InsertItem(Y, tmp);
			else
				LIST_OF_TY_AppendList(Y, tmp);
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (BlkType(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1));
				}
				return X;
			RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE)
							LIST_OF_TY_InsertItem(X, tmp, false, 0, true);
						else
							LIST_OF_TY_AppendList(X, tmp, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				if (RELATION_TY_GetValency(rel) == RRVAL_O_TO_V) rev = 1;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, 0, tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + rev, BlkValueRead(rel, tmp + 1));
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE) {
							BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev, tmp);
							LIST_OF_TY_InsertItem(X, Y);
						} else {
							for (mult = LIST_OF_TY_GetLength(tmp): mult > 0: mult--) {
								BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev,
									LIST_OF_TY_GetItem(tmp, mult));
								LIST_OF_TY_InsertItem(X, Y);
							}
						}
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkFree(Y);
				return X;
		}
		rfalse;
	}
	at = HashCoreLookUp(rel, kx, X);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (fl & RRF_SINGLE) {
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				rfalse;
			} else {
				return LIST_OF_TY_FindItem(tmp, Y);
			}
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! no entry exists for this key, just add one
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				HashCoreCheckResize(rel);
				break;
			}
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if Y is the same as the stored key, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				! it's different: either replace it or expand into a list,
				! depending on the value of mult
				if (mult) {
					fl = LIST_OF_TY_Create(UNKNOWN_TY);	! new list
					BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);
					LIST_OF_TY_SetLength(fl, 2);
					BlkValueWrite(fl, LIST_ITEM_BASE, tmp);	! do not copy
					LIST_OF_TY_PutItem(fl, 2, Y);		! copy if needed
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, fl);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED);
				} else {
					if (KOVIsBlockValue(ky)) {
						BlkFree(tmp);
						Y = BlkValueCopy(BlkValueCreate(ky), Y);
					}
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				}
			} else {
				! if Y is present already, do nothing. otherwise add it.
				LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);
			}
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if the stored key isn't Y, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
				} else {
					if (tmp ~= Y) rtrue;
				}
				! delete the entry
				if (KOVIsBlockValue(ky))
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
				.DeleteEntryIgnoringY;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
				if (KOVIsBlockValue(kx))
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			} else {
				! remove Y from the list if present
				LIST_OF_TY_RemoveValue(tmp, Y, 1);
				! if the list is now empty, delete the whole entry
				if (LIST_OF_TY_GetLength(tmp) == 0) {
					BlkFree(tmp);
					jump DeleteEntryIgnoringY;
				}
			}
			rtrue;
	}
	rtrue;
];

[ HashCoreLookUp rel kx X  hashv i free mask perturb flags;
!print "[HCLU rel=", rel, " kx=", kx, " X=", X, ": ";
	! calculate a hash value for the key
	hashv = KOVHashValue(kx, x);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
		return i;
	}
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ HashCoreCheckResize rel  filled ext newext temp i at kov kx F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = BlkAllocate(ext * (3*WORDSIZE), INDEXED_TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i));
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetExtent(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1);
			Y = BlkValueRead(temp, 3*i + 2);
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		BlkFree(temp);
	}
];

[ HashCoreEntryMatches rel at kx X  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	rtrue;
];


[ EquivHashTableRelationHandler rel task X Y  kx at at2 tmp fl i ext;
	kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0);
	if (task == RELS_DESTROY) {
		! clear
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_COPY) {
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1);
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		ext = BlkValueRead(rel, RRV_STORAGE);
		! flag all items by negating their group numbers
		for (at=0, X=RRV_DATA_BASE: at<=ext: at++, X=X+3)
			if (BlkValueRead(rel, X) & RRF_USED)
				BlkValueWrite(rel, X + 2, -(BlkValueRead(rel, X + 2)));
		! display groups, unflagging them as we go
		for (at=0, X=RRV_DATA_BASE, fl=0: at<=ext: at++, X=X+3, fl=0) {
			if (BlkValueRead(rel, X) & RRF_USED) {
				fl = BlkValueRead(rel, X + 2);
				if (fl > 0) continue;		! already visited
				BlkValueWrite(rel, X + 2, -fl);	! unflag it
				! display the group starting with this member, but only
				! if there are more members in the group
				tmp = BlkValueRead(rel, X + 1);
				i = 0;
				for (at2=at+1, Y=RRV_DATA_BASE+3*at2: at2<=ext: at2++, Y=Y+3) {
					if (BlkValueRead(rel, Y) & RRF_USED) {
						if (BlkValueRead(rel, Y + 2) ~= fl) continue;
						BlkValueWrite(rel, Y + 2, -fl);
						if (~~i) {
							! print the saved first member
							print "  { ";
							PrintKindValuePair(kx, tmp);
							i = 1;
						}
						print ", ";
						PrintKindValuePair(kx, BlkValueRead(rel, Y + 1));
					}
				}
				if (i) print " }^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		! never empty since R(x,x) is always true
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		! kind of a cheat, but it's faster than searching for a better value to return
		if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
		return X;
	} else if (task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);
		at = HashCoreLookUp(rel, kx, X);
		if (at < 0) {
			LIST_OF_TY_InsertItem(Y, X);
		} else {
			X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					if (BlkValueRead(rel, tmp + 2) ~= X) continue;
					LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
				}
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		print "*** Domains of equivalence relations cannot be listed ***^";
		return X;
	}
	at = HashCoreLookUp(rel, kx, X);
	at2 = HashCoreLookUp(rel, kx, Y);
	switch(task) {
		RELS_TEST:
			if (at < 0) {
				! X is a loner, but could still be true if X == Y
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(X, Y) == 0) rtrue;
				} else {
					if (X == Y) rtrue;
				}
				rfalse;
			}
			if (at2 < 0) rfalse;
			if (at == at2) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) == tmp) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			! if X and Y are the same, we have nothing to do
			if (KOVIsBlockValue(kx)) {
				if (BlkValueCompare(X, Y) == 0) rtrue;
			} else {
				if (X == Y) rtrue;
			}
			if (at < 0) {
				if (at2 < 0) {
					! X and Y both missing: find a new group number and add both entries
					tmp = 0;		! candidate group number
					ext = BlkValueRead(rel, RRV_STORAGE);
					for (i=0: i<=ext: i++) {
						fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
						if (fl & RRF_USED) {
							fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i + 2);
							if (fl > tmp) tmp = fl;
						}
					}
					tmp++;			! new group number
					BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 2);
					! add X entry
					at = ~at;
					if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
					! add Y entry. at2 might change if X and Y have the same hash code.
					at2 = ~(HashCoreLookUp(rel, kx, Y));
					if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
					jump CheckResize;
				}
				! X missing, Y present: add a new X entry
				at = ~at;
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				jump CheckResize;
			}
			if (at2 < 0) {
				! X present, Y missing: add a new Y entry
				at2 = ~at2;
				if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
				jump CheckResize;
			}
			! X and Y both present: merge higher group into lower group
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! higher group
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);	! lower group
			if (tmp < fl) { i = tmp; tmp = fl; fl = i; }
			ext = BlkValueRead(rel, RRV_STORAGE);
			for (at=0: at<=ext: at++) {
				i = RRV_DATA_BASE + 3*at + 2;
				if (BlkValueRead(rel, i) == tmp)
					BlkValueWrite(rel, i, fl);
			}
			.CheckResize;
			HashCoreCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! if X and Y are already in different groups, we have nothing to do
			if (at < 0 || at2 < 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) ~= tmp) rtrue;
			! delete the entry for X
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];


[ TwoInOneHashTableRelationHandler rel task X Y sym  kov kx ky at at2 tmp fl;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED)
				if ((kx && (fl & RRF_ENTKEYX)) || (ky && (fl & RRF_ENTKEYY))) {
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
				}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED) {
				if ((X && (fl & RRF_ENTKEYX)) || (Y && (fl & RRF_ENTKEYY))) {
					! copy the entry key
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
					if (fl & RRF_ENTKEYX)
						tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					else
						tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, tmp);
					! update references in X/Y fields pointing here
					if (fl & RRF_HASX) {
						at2 = TwoInOneLookUp(rel, kx,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 2),
							RRF_ENTKEYX);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 3, tmp);
					}
					if (fl & RRF_HASY) {
						at2 = TwoInOneLookUp(rel, ky,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3),
							RRF_ENTKEYY);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, tmp);
					}
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
				(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
				if (sym && kov(X, Y) > 0) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 4*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
				BlkValueWrite(rel, tmp + 3, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		switch (Y) {
			RLANY_GET_X, RLANY_CAN_GET_X:
				at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASX) {
						if (Y == RLANY_CAN_GET_X) rtrue;
						return BlkValueRead(rel, tmp + 2);
					}
				}
			RLANY_GET_Y, RLANY_CAN_GET_Y:
				at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASY) {
						if (Y == RLANY_CAN_GET_Y) rtrue;
						return BlkValueRead(rel, tmp + 3);
					}
				}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASX)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASY)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 3));
		}
		return Y;
	} else if (task == RELS_LIST) {
		switch (Y) {
			RLIST_ALL_X:
				fl = RRF_USED+RRF_ENTKEYX+RRF_HASY;
				jump ListEntryKeys;
			RLIST_ALL_Y:
				fl = RRF_USED+RRF_ENTKEYY+RRF_HASX;
				.ListEntryKeys;
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					if ((BlkValueRead(rel, tmp) & fl) == fl)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1), false, 0, true);
				}
			RLIST_ALL_PAIRS:
				tmp = BlkValueRead(X, LIST_ITEM_KOV_F);
				if (KindAtomic(tmp) ~= COMBINATION_TY) rfalse;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, 0, tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					fl = BlkValueRead(rel, tmp);
					if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
						(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, tmp + 1));
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, BlkValueRead(rel, tmp + 3));
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkFree(Y);
				return X;
		}
		return X;
	}
	at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (~~(fl & RRF_HASY)) rfalse;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) == 0) rtrue;
			} else {
				if (tmp == Y) rtrue;
			}
			rfalse;
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! create a new forward entry
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				fl = RRF_USED+RRF_HASY+RRF_ENTKEYX;
				if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
					fl = fl + RRF_ENTKEYY;
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
			} else {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl & RRF_HASY) {
					! if the Y we're inserting is already there, we're done
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(tmp, Y) == 0) rtrue;
					} else {
						if (tmp == Y) rtrue;
					}
					! it's different, so delete the reverse entry
					at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY);
					if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				} else {
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl + RRF_HASY);
				}
				! use the existing copy of X
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
			}
			! use the existing copy of Y if there is one
			at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY);
			if (KOVIsBlockValue(ky)) {
				if (at2 >= 0)
					Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at2 + 1);
				else
					Y = BlkValueCopy(BlkValueCreate(ky), Y);
			}
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
			if (at2 >= 0) {
				! delete existing reverse entry (and its own forward entry)
				TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);
			} else {
				at2 = ~at2;
			}
			! create reverse entry
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at2);
			if (fl == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			fl = fl | (RRF_USED+RRF_HASX+RRF_ENTKEYY);
			if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
				fl = fl | RRF_ENTKEYX;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2, fl);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 1, Y);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, X);
			TwoInOneCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! we only have work to do if the entry exists and has a Y which
			! matches the Y we're deleting
			if (at < 0) rtrue;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & RRF_HASY) == 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
			} else {
				if (tmp ~= Y) rtrue;
			}
			TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);
			rtrue;
	}
];

[ TwoInOneDelete rel at kx ky ekflag both  fl at2 E i;
!print "[2in1DEL at=", at, " (E=", BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1), ") ekflag=", ekflag, " both=", both, "]^";
	fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
	if (ekflag == RRF_ENTKEYX) {
		if (fl & RRF_HASY) {
			i = RRV_DATA_BASE + 4*at + 3;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching Y<-X entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
				if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			}
			fl = fl & ~RRF_HASY;
		}
	} else {
		if (fl & RRF_HASX) {
			i = RRV_DATA_BASE + 4*at + 2;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching X->Y entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
				if (at2 >= 0) {
					TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);
					if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				}
			}
			fl = fl & ~RRF_HASX;
		}
	}
	if ((fl & (RRF_HASX+RRF_HASY)) == 0) {
		! entry is now empty, mark it deleted
		if (((fl & RRF_ENTKEYX) && KOVIsBlockValue(kx)) ||
		    ((ky ~= kx) && (fl & RRF_ENTKEYY) && KOVIsBlockValue(ky))) {
			BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
		}
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, RRF_DELETED);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, 0);
		BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
	} else {
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
	}
];

[ TwoInOneLookUp rel ke E ekflag  hashv i free mask perturb flags;
!print "[2in1LU rel=", rel, " ke=", ke, " E=", E, " ekf=", ekflag, ": ";
	! calculate a hash value for the key
	hashv = KOVHashValue(ke, E);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
		return i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ TwoInOneCheckResize rel  filled ext newext temp i at kov kx ky F E X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = BlkAllocate(ext * (4*WORDSIZE), INDEXED_TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*4: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i));
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetExtent(rel, RRV_DATA_BASE + newext*4);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*4: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 4*i);
			if (F == 0 || (F & RRF_DELETED)) continue;
			E = BlkValueRead(temp, 4*i + 1);
			X = BlkValueRead(temp, 4*i + 2);
			Y = BlkValueRead(temp, 4*i + 3);
			if (F & RRF_ENTKEYX) at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
			else at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, E);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
		}
		! done with temporary space
		BlkFree(temp);
	}
];

[ TwoInOneEntryMatches rel at ke E  ce;
	ce = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
	if (KOVIsBlockValue(ke)) {
		if (BlkValueCompare(ce, E) ~= 0) rfalse;
	} else {
		if (ce ~= E) rfalse;
	}
	rtrue;
];


#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ RELATION_TY_Support t a b c; rfalse; ];
[ RELATION_TY_Say comb; ];
[ RELATION_TY_Name rel txt; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE


[ RELATION_TY_Empty rel set  handler;
	handler = rel-->RR_HANDLER;
	return handler(rel, RELS_EMPTY, set);
];


Array ResourceIDsOfFigures --> 0 1  0;

Array ResourceIDsOfSounds --> 0  0;


[ CreateBlockConstants;
];



! End of automatically generated I6 source
! --------------------------------------------------------------------------
